---
layout: post
titile: "How Boom configures core modules"
categories: risc-v, boom
---

What is the tile in the risc-v core design? 
Tile is a baisc unit of core design that embraces multiple components of the core design.
As shown in the below code,
each boom-core requires data cache, frontend/icache, ROCC components.

**common/tilte.scala**
```scala
 69 class BoomTile(
 70   val boomParams: BoomTileParams,
 71   crossing: ClockCrossingType,
 72   lookup: LookupByHartIdImpl,
 73   q: Parameters,
 74   logicalTreeNode: LogicalTreeNode)
 75   extends BaseTile(boomParams, crossing, lookup, q)
 76   with SinksExternalInterrupts
 77   with SourcesExternalNotifications
 78 {
 79
 80   // Private constructor ensures altered LazyModule.p is used implicitly
 81   def this(params: BoomTileParams, crossing: RocketCrossingParams, lookup: LookupByHartIdImpl, logicalTreeNode: LogicalTreeNode)
 82     (implicit p: Parameters) = this(params, crossing.crossingType, lookup, p, logicalTreeNode)

...

180   override lazy val module = new BoomTileModuleImp(this)
181
182   // DCache
183   lazy val dcache: BoomNonBlockingDCache = LazyModule(new BoomNonBlockingDCache(hartId))
184   val dCacheTap = TLIdentityNode()
185   tlMasterXbar.node := dCacheTap := dcache.node
186
187
188   // Frontend/ICache
189   val frontend = LazyModule(new BoomFrontend(tileParams.icache.get, hartId))
190   tlMasterXbar.node := frontend.masterNode
191
192   private val deviceOpt = None
193   val iCacheLogicalTreeNode = new ICacheLogicalTreeNode(deviceOpt, tileParams.icache.get)
194
195
196   // ROCC
197   val roccs = p(BuildRoCC).map(_(p))
198   roccs.map(_.atlNode).foreach { atl => tlMasterXbar.node :=* atl }
199   roccs.map(_.tlNode).foreach { tl => tlOtherMastersNode :=* tl }
200
201 }
```
line 180 instantiate BoomTileModuleImp class instance with 
the BoomTile instance itself as argument.
Passing **this** enables the BoomTileModuleImp instance to access
the outer BoomTile instance's member field.

```scala
208 class BoomTileModuleImp(outer: BoomTile) extends BaseTileModuleImp(outer){
209
210   Annotated.params(this, outer.boomParams)
211
212   val core = Module(new BoomCore()(outer.p))
213   val lsu  = Module(new LSU()(outer.p, outer.dcache.module.edge))
214
215
216   var nPTWPorts        = 3
217   val ptwPorts         = ListBuffer(lsu.io.ptw, outer.frontend.module.io.ptw, core.io.ptw_tlb)
218
219   var nHellaCachePorts = 0
220   val hellaCachePorts  = ListBuffer[HellaCacheIO]()
221
222   outer.reportWFI(None) // TODO: actually report this?
223
224   outer.decodeCoreInterrupts(core.io.interrupts) // Decode the interrupt vector
225
226   outer.bus_error_unit.foreach { beu =>
227     core.io.interrupts.buserror.get := beu.module.io.interrupt
228     beu.module.io.errors.dcache := outer.dcache.module.io.errors
229     beu.module.io.errors.icache := outer.frontend.module.io.errors
230   }
231
232   // Pass through various external constants and reports
233   outer.traceSourceNode.bundle <> core.io.trace
234   outer.bpwatchSourceNode.bundle <> DontCare // core.io.bpwatch
235   core.io.hartid := constants.hartid
236   outer.dcache.module.io.hartid := constants.hartid
237   outer.frontend.module.io.hartid := constants.hartid
238   outer.frontend.module.io.reset_vector := constants.reset_vector
239
240   // Connect the core pipeline to other intra-tile modules
241   outer.frontend.module.io.cpu <> core.io.ifu
242   core.io.lsu <> lsu.io.core
243
244   //fpuOpt foreach { fpu => core.io.fpu <> fpu.io } RocketFpu - not needed in boom
245   core.io.rocc := DontCare
246   core.io.reset_vector := DontCare
```

BoomTileModuleImp contains BoomCore instance and LSU instance.
Also, this class takes BoomTile instance as its argument, 
it can make use of the frontend on the BoomTile. 

Front-end
The Fetch and Branch Prediction portions of the pipeline that fetch instructions from the i-cache.

**ifu/frontend.scala**
```scala
131 class BoomFrontend(val icacheParams: ICacheParams, hartid: Int)(implicit p: Parameters) extends LazyModule
132 {
133   lazy val module = new BoomFrontendModule(this)
134   val icache = LazyModule(new boom.ifu.ICache(icacheParams, hartid))
135   val masterNode = icache.masterNode
136   val slaveNode = icache.slaveNode
137 }
138

144 class BoomFrontendBundle(val outer: BoomFrontend) extends CoreBundle()(outer.p)
145   with HasExternallyDrivenTileConstants
146 {
147   val cpu = Flipped(new BoomFrontendIO())
148   val ptw = new TLBPTWIO()
149   val errors = new ICacheErrors
150 }

152 /**
153  * Main Frontend module that connects the icache, TLB, fetch controller,
154  * and branch prediction pipeline together.
155  *
156  * @param outer top level Frontend class
157  */
158 class BoomFrontendModule(outer: BoomFrontend) extends LazyModuleImp(outer)
159   with HasCoreParameters
160   with HasL1ICacheParameters
161   with HasL1ICacheBankedParameters
162 {
163   val io = IO(new BoomFrontendBundle(outer))
164   implicit val edge = outer.masterNode.edges.out(0)
165   require(fetchWidth*coreInstBytes == outer.icacheParams.fetchBytes)
166
167   val icache = outer.icache.module
168   val tlb = Module(new TLB(true, log2Ceil(fetchBytes), TLBConfig(nTLBEntries)))
169   val fetch_controller = Module(new FetchControlUnit)
170   val bpdpipeline = Module(new BranchPredictionStage(bankBytes))

284   //-------------------------------------------------------------
285   // **** Branch Prediction ****
286   //-------------------------------------------------------------
287
288   bpdpipeline.io.s0_req.valid := s0_valid
289   bpdpipeline.io.s0_req.bits.addr := s0_pc
290
291   bpdpipeline.io.f2_replay := s2_replay
292   bpdpipeline.io.f2_stall := !fetch_controller.io.imem_resp.ready
293   bpdpipeline.io.f3_stall := fetch_controller.io.f3_stall
294   bpdpipeline.io.f3_is_br := fetch_controller.io.f3_is_br
295   bpdpipeline.io.debug_imemresp_pc := fetch_controller.io.imem_resp.bits.pc
296
297   bpdpipeline.io.br_unit_resp := io.cpu.br_unit
298   bpdpipeline.io.ftq_restore := fetch_controller.io.ftq_restore_history
299   bpdpipeline.io.redirect := fetch_controller.io.imem_req.valid
300
301   bpdpipeline.io.flush := io.cpu.flush
302
303   bpdpipeline.io.f2_valid := fetch_controller.io.imem_resp.valid
304   bpdpipeline.io.f2_redirect := fetch_controller.io.f2_redirect
305   bpdpipeline.io.f3_will_redirect := fetch_controller.io.f3_will_redirect
306   bpdpipeline.io.f4_redirect := fetch_controller.io.f4_redirect
307   bpdpipeline.io.f4_taken := fetch_controller.io.f4_taken
308   bpdpipeline.io.fe_clear := fetch_controller.io.clear_fetchbuffer
309
310   bpdpipeline.io.f2_aligned_pc := alignToFetchBoundary(s2_pc)
311   bpdpipeline.io.f3_ras_update := fetch_controller.io.f3_ras_update
312   bpdpipeline.io.f3_btb_update := fetch_controller.io.f3_btb_update
313   bpdpipeline.io.bim_update    := fetch_controller.io.bim_update
314   bpdpipeline.io.bpd_update    := fetch_controller.io.bpd_update
315
316   bpdpipeline.io.status_prv    := io.cpu.status_prv
317   bpdpipeline.io.status_debug  := io.cpu.status_debug
```

**exu/core.scala**
```scala
 70 class BoomCore(implicit p: Parameters) extends BoomModule
 71    with HasBoomCoreIO
 72 {
 73   //**********************************
 74   // construct all of the modules
 75
 76   // Only holds integer-registerfile execution units.
 77   val exe_units = new boom.exu.ExecutionUnits(fpu=false)

...

 165   // Branch Unit
 166   val br_unit = Wire(new BranchUnitResp())
 167   val brunit_idx = exe_units.br_unit_idx
 168   br_unit <> exe_units.br_unit_io
 169
 170   val flush_ifu = br_unit.brinfo.mispredict || // In practice, means flushing everything prior to dispatch.
 171                          rob.io.flush.valid || // i.e. 'flush in-order part of the pipeline'
 172                          io.ifu.sfence_take_pc
 173
 174   assert (!(br_unit.brinfo.mispredict && rob.io.commit.rollback), "Can't have a mispredict during rollback.")
 175
 176   for (eu <- exe_units) {
 177     eu.io.brinfo := br_unit.brinfo
 178   }
```

**exu/execution-units/execution-units.scala**
```scala
28 class ExecutionUnits(val fpu: Boolean)(implicit val p: Parameters) extends HasBoomCoreParameters
 29 {
 30   val totalIssueWidth = issueParams.map(_.issueWidth).sum
 31
 32   //*******************************
 33   // Instantiate the ExecutionUnits
 34
 35   private val exe_units = ArrayBuffer[ExecutionUnit]()
 36
 37   //*******************************
 38   // Act like a collection
 39
 40   def length = exe_units.length
 41
 42   def apply(n: Int) = exe_units(n)
 43
 44   def map[T](f: ExecutionUnit => T) = {
 45     exe_units.map(f)
 46   }
 47
 48   def withFilter(f: ExecutionUnit => Boolean) = {
 49     exe_units.withFilter(f)
 50   }
 51
 52   def foreach[U](f: ExecutionUnit => U) = {
 53     exe_units.foreach(f)
 54   }
 55
 56   def zipWithIndex = {
 57     exe_units.zipWithIndex
 58   }
 59
 60   def indexWhere(f: ExecutionUnit => Boolean) = {
 61     exe_units.indexWhere(f)
 62   }
 63
 64   def count(f: ExecutionUnit => Boolean) = {
 65     exe_units.count(f)
 66   }
 67
 68   lazy val memory_units = {
 69     exe_units.filter(_.hasMem)
 70   }
 71
 72   lazy val br_unit = {
 73     require (exe_units.count(_.hasBrUnit) == 1)
 74     exe_units.find(_.hasBrUnit).get
 75   }

...

109   if (!fpu) {
110     val int_width = issueParams.find(_.iqType == IQT_INT.litValue).get.issueWidth
111
112     for (w <- 0 until memWidth) {
113       val memExeUnit = Module(new ALUExeUnit(
114         hasAlu = false,
115         hasMem = true))
116
117       memExeUnit.io.ll_iresp.ready := DontCare
118
119       exe_units += memExeUnit
120     }
121
122     for (w <- 0 until int_width) {
123       def is_nth(n: Int): Boolean = w == ((n) % int_width)
124       val alu_exe_unit = Module(new ALUExeUnit(
125         hasBrUnit      = is_nth(0),
126         hasCSR         = is_nth(1),
127         hasRocc        = is_nth(1) && usingRoCC,
128         hasMul         = is_nth(2),
129         hasDiv         = is_nth(3),
130         hasIfpu        = is_nth(4) && usingFPU))
131       exe_units += alu_exe_unit
132     }
133   } else {
134     val fp_width = issueParams.find(_.iqType == IQT_FP.litValue).get.issueWidth
135     for (w <- 0 until fp_width) {
136       val fpu_exe_unit = Module(new FPUExeUnit(hasFpu = true,
137                                              hasFdiv = usingFDivSqrt && (w==0),
138                                              hasFpiu = (w==0)))
139       exe_units += fpu_exe_unit
140     }
141   }
```

**exu/execution-units/execution-unit.scala**
```scala
204 class ALUExeUnit(
205   hasBrUnit      : Boolean = false,
206   hasCSR         : Boolean = false,
207   hasAlu         : Boolean = true,
208   hasMul         : Boolean = false,
209   hasDiv         : Boolean = false,
210   hasIfpu        : Boolean = false,
211   hasMem         : Boolean = false,
212   hasRocc        : Boolean = false)
213   (implicit p: Parameters)
214   extends ExecutionUnit(
215     readsIrf         = true,
216     writesIrf        = hasAlu || hasMul || hasDiv,
217     writesLlIrf      = hasMem || hasRocc,
218     writesLlFrf      = (hasIfpu || hasMem) && p(tile.TileKey).core.fpu != None,
219     numBypassStages  =
220       if (hasAlu && hasMul) 3 //TODO XXX p(tile.TileKey).core.imulLatency
221       else if (hasAlu) 1 else 0,
222     dataWidth        = p(tile.XLen) + 1,
223     bypassable       = hasAlu,
224     alwaysBypassable = hasAlu && !(hasMem || hasBrUnit || hasMul || hasDiv || hasCSR || hasIfpu || hasRocc),
225     hasCSR           = hasCSR,
226     hasBrUnit        = hasBrUnit,
227     hasAlu           = hasAlu,
228     hasMul           = hasMul,
229     hasDiv           = hasDiv,
230     hasIfpu          = hasIfpu,
231     hasMem           = hasMem,
232     hasRocc          = hasRocc)
233   with freechips.rocketchip.rocket.constants.MemoryOpConstants

...

269   // ALU Unit -------------------------------
270   var alu: ALUUnit = null
271   if (hasAlu) {
272     alu = Module(new ALUUnit(isBranchUnit = hasBrUnit,
273                              numStages = numBypassStages,
274                              dataWidth = xLen))
275     alu.io.req.valid := (
276       io.req.valid &&
277       (io.req.bits.uop.fu_code === FU_ALU ||
278        io.req.bits.uop.fu_code === FU_BRU ||
279       (io.req.bits.uop.fu_code === FU_CSR && io.req.bits.uop.uopc =/= uopROCC)))
280     //ROCC Rocc Commands are taken by the RoCC unit
281
282     alu.io.req.bits.uop      := io.req.bits.uop
283     alu.io.req.bits.kill     := io.req.bits.kill
284     alu.io.req.bits.rs1_data := io.req.bits.rs1_data
285     alu.io.req.bits.rs2_data := io.req.bits.rs2_data
286     alu.io.req.bits.rs3_data := DontCare
287     alu.io.resp.ready := DontCare
288     alu.io.brinfo <> io.brinfo
289
290     iresp_fu_units += alu
291
292     // Bypassing only applies to ALU
293     io.bypass <> alu.io.bypass
294
295     // branch unit is embedded inside the ALU
296     if (hasBrUnit) {
297       io.br_unit <> alu.io.br_unit
298       alu.io.get_ftq_pc <> io.get_ftq_pc
299       alu.io.status <> io.status
300     }
301   }
```

Class ALUExeUnit makes use of ALUUnit class to instantiate execution pipeline. 
Here, ALUUnit isnstance introduces a branch unit 
that can resolve branch instruction (taken/not-taken) and 
calculate the target address if the branch instruction is taken.
%
To resolve the branch instruction,
there are several information that should be passed to the branch unit.
The rs1_data and rs2_data are required to calculate the target address.
Also, the predicted result is passed to the alu as brinfo.

```scala
 64 class ExecutionUnitIO(
 65   val writesIrf      : Boolean,
 66   val writesLlIrf    : Boolean,
 67   val writesFrf      : Boolean,
 68   val writesLlFrf    : Boolean,
 69   val hasRocc        : Boolean,
 70   val hasBrUnit      : Boolean,
 71   val hasFcsr        : Boolean,
 72   val hasMem         : Boolean,
 73   val numBypassPorts : Int,
 74   val dataWidth      : Int
 75   )(implicit p: Parameters) extends BoomBundle
 76 {
 77   // describe which functional units we support (used by the issue window)
 78   val fu_types = Output(Bits(FUC_SZ.W))
 79
 80   val req      = Flipped(new DecoupledIO(new FuncUnitReq(dataWidth)))
 81
 82   val iresp    = if (writesIrf)   new DecoupledIO(new ExeUnitResp(dataWidth)) else null
 83   val fresp    = if (writesFrf)   new DecoupledIO(new ExeUnitResp(dataWidth)) else null
 84   val ll_iresp = if (writesLlIrf) new DecoupledIO(new ExeUnitResp(dataWidth)) else null
 85   val ll_fresp = if (writesLlFrf) new DecoupledIO(new ExeUnitResp(dataWidth)) else null
 86
 87
 88   val bypass   = Output(new BypassData(numBypassPorts, dataWidth))
 89   val brinfo   = Input(new BrResolutionInfo())

...

136 abstract class ExecutionUnit(
137   val readsIrf         : Boolean       = false,
138   val writesIrf        : Boolean       = false,
139   val readsFrf         : Boolean       = false,
140   val writesFrf        : Boolean       = false,
141   val writesLlIrf      : Boolean       = false,
142   val writesLlFrf      : Boolean       = false,
143   val numBypassStages  : Int,
144   val dataWidth        : Int,
145   val bypassable       : Boolean       = false, // TODO make override def for code clarity
146   val alwaysBypassable : Boolean       = false,
147   val hasMem           : Boolean       = false,
148   val hasCSR           : Boolean       = false,
149   val hasBrUnit        : Boolean       = false,
150   val hasAlu           : Boolean       = false,
151   val hasFpu           : Boolean       = false,
152   val hasMul           : Boolean       = false,
153   val hasDiv           : Boolean       = false,
154   val hasFdiv          : Boolean       = false,
155   val hasIfpu          : Boolean       = false,
156   val hasFpiu          : Boolean       = false,
157   val hasRocc          : Boolean       = false
158   )(implicit p: Parameters) extends BoomModule
159 {
160   val io = IO(new ExecutionUnitIO(writesIrf, writesLlIrf, writesFrf, writesLlFrf,
161     hasRocc, hasBrUnit, hasFpu || hasIfpu || hasFdiv, hasMem,
162     numBypassStages, dataWidth))
```







