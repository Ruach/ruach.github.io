##decode isa and automatically generated decoder
*gem5/src/arch/x86/isa/decoder/decoder.isa*
```cpp
decode LEGACY_LOCK default Unknown::unknown()
{
    //No lock prefix
    0x0: decode OPCODE_TYPE default Unknown::unknown()
    {
        ##include "one_byte_opcodes.isa"
        ##include "two_byte_opcodes.isa"
        ##include "three_byte_0f38_opcodes.isa"
        ##include "three_byte_0f3a_opcodes.isa"
    }
    //Lock prefix
    ##include "locked_opcodes.isa"
}
```

*gem5/build/X86/arch/x86/generated/decode-method.cc.inc*
```cpp
    6 StaticInstPtr
    7 X86ISA::Decoder::decodeInst(X86ISA::ExtMachInst machInst)
    8 {
    9     using namespace X86ISAInst;
   10   switch (LEGACY_LOCK) {
   11
   12     case 0x0:
   13       switch (OPCODE_TYPE) {
   14
   15         case X86ISA::OneByteOpcode:
   16           switch (OPCODE_OP_TOP5) {
```


##Deep dive into decode block parsing
*gem5/src/arch/isa_parser*
```python
2209     def p_top_level_decode_block(self, t):
2210         'top_level_decode_block : decode_block'
2211         codeObj = t[1]
2212         codeObj.wrap_decode_block('''
2213 StaticInstPtr
2214 %(isa_name)s::Decoder::decodeInst(%(isa_name)s::ExtMachInst machInst)
2215 {
2216     using namespace %(namespace)s;
2217 ''' % self, '}')
2218
2219         codeObj.emit()
```

This function generates decode-method.cc.inc file
We have to follow decode_block to see 
how the transition happens from macroop decode DSP to CPP.

```python
2221     def p_decode_block(self, t):
2222         'decode_block : DECODE ID opt_default LBRACE decode_stmt_list RBRACE'
2223         default_defaults = self.defaultStack.pop()
2224         codeObj = t[5]
2225         # use the "default defaults" only if there was no explicit
2226         # default statement in decode_stmt_list
2227         if not codeObj.has_decode_default:
2228             codeObj += default_defaults
2229         codeObj.wrap_decode_block('switch (%s) {\n' % t[2], '}\n')
2230         t[0] = codeObj
```
decode_block is one chunk of block 
starting with decode keyword 
and following ID and { }.

```cpp
 43 'X86ISA::OneByteOpcode': decode OPCODE_OP_TOP5 {
 44     format Inst {
 45         0x00: decode OPCODE_OP_BOTTOM3 {
 46             0x6: decode MODE_SUBMODE {
 47                 0x0: UD2();
 48                 default: WarnUnimpl::push_ES();
 49             }
 50             0x7: decode MODE_SUBMODE {
 51                 0x0: UD2();
 52                 default: WarnUnimpl::pop_ES();
 53             }
 54             default: MultiInst::ADD(OPCODE_OP_BOTTOM3,
 55                                     [Eb,Gb], [Ev,Gv],
 56                                     [Gb,Eb], [Gv,Ev],
 57                                     [rAb,Ib], [rAv,Iz]);
 58         }
```
A statement on line 43 starting with decode keyword can be one example of decode block.
This block includes another decode block decode OPCODE_OP_BOTTOM3
and can be parsed from *decode_stmt_list* token.


```python
2253     def p_decode_stmt_list_0(self, t):
2254         'decode_stmt_list : decode_stmt'
2255         t[0] = t[1]
2256
2257     def p_decode_stmt_list_1(self, t):
2258         'decode_stmt_list : decode_stmt decode_stmt_list'
2259         if (t[1].has_decode_default and t[2].has_decode_default):
2260             error(t.lineno(1), 'Two default cases in decode block')
2261         t[0] = t[1] + t[2]
```

###Four different types of decode_stmt
decode_stmt_list consists of decode_stmt or 
decode_stmt followed by another decode_stmt_list.
Let's take a look at decode_stmt rule.

```python
2263     #
2264     # Decode statement rules
2265     #
2266     # There are four types of statements allowed in a decode block:
2267     # 1. Format blocks 'format <foo> { ... }'
2268     # 2. Nested decode blocks
2269     # 3. Instruction definitions.
2270     # 4. C preprocessor directives.
2271
2272
2273     # Preprocessor directives found in a decode statement list are
2274     # passed through to the output, replicated to all of the output
2275     # code streams.  This works well for ifdefs, so we can ifdef out
2276     # both the declarations and the decode cases generated by an
2277     # instruction definition.  Handling them as part of the grammar
2278     # makes it easy to keep them in the right place with respect to
2279     # the code generated by the other statements.
2280     def p_decode_stmt_cpp(self, t):
2281         'decode_stmt : CPPDIRECTIVE'
2282         t[0] = GenCode(self, t[1], t[1], t[1], t[1])
2283
2284     # A format block 'format <foo> { ... }' sets the default
2285     # instruction format used to handle instruction definitions inside
2286     # the block.  This format can be overridden by using an explicit
2287     # format on the instruction definition or with a nested format
2288     # block.
2289     def p_decode_stmt_format(self, t):
2290         'decode_stmt : FORMAT push_format_id LBRACE decode_stmt_list RBRACE'
2291         # The format will be pushed on the stack when 'push_format_id'
2292         # is processed (see below).  Once the parser has recognized
2293         # the full production (though the right brace), we're done
2294         # with the format, so now we can pop it.
2295         self.formatStack.pop()
2296         t[0] = t[4]

2309     # Nested decode block: if the value of the current field matches
2310     # the specified constant(s), do a nested decode on some other field.
2311     def p_decode_stmt_decode(self, t):
2312         'decode_stmt : case_list COLON decode_block'
2313         case_list = t[1]
2314         codeObj = t[3]
2315         # just wrap the decoding code from the block as a case in the
2316         # outer switch statement.
2317         codeObj.wrap_decode_block('\n%s\n' % ''.join(case_list),
2318                                   'M5_UNREACHABLE;\n')
2319         codeObj.has_decode_default = (case_list == ['default:'])
2320         t[0] = codeObj
2321
2322     # Instruction definition (finally!).
2323     def p_decode_stmt_inst(self, t):
2324         'decode_stmt : case_list COLON inst SEMI'
2325         case_list = t[1]
2326         codeObj = t[3]
2327         codeObj.wrap_decode_block('\n%s' % ''.join(case_list), 'break;\n')
2328         codeObj.has_decode_default = (case_list == ['default:'])
2329         t[0] = codeObj
```
As specified in the above comment,
there are four grammar rules for parsing decode_stmt:
*p_decode_stmt_inst, p_decode_stmt_decode
p_decode_stmt_format, p_decode_stmt_cpp*.
Because we have interest in parsing macroop instruction,
*p_decode_stmt_inst* rule is important.

Let's take a look at inst::PREFETCH(Mb) in two_byte_opcodes
as an example of decode_stmt.
```cpp
 260         0x01: decode OPCODE_OP_BOTTOM3 {
 261             0x0: invd();
 262             0x1: wbinvd();
 263             0x2: Inst::UD2();
 264             0x3: Inst::UD2();
 265             0x4: Inst::PREFETCH_EN(Mb);
 266             0x5: Inst::PREFETCH(Mb);
 267             0x6: FailUnimpl::femms();
```
here case_list indicates index of switch statement such as 0x5 for PREFETCH.
COLON and SEMI are terminals, so it doesn't give us any useful information.
What we have to look at is *inst* non-terminal symbol.

```python
2366     # Define an instruction using the current instruction format
2367     # (specified by an enclosing format block).
2368     # "<mnemonic>(<args>)"
2369     def p_inst_0(self, t):
2370         'inst : ID LPAREN arg_list RPAREN'
2371         # Pass the ID and arg list to the current format class to deal with.
2372         currentFormat = self.formatStack.top()
2373         codeObj = currentFormat.defineInst(self, t[1], t[3], t.lexer.lineno)
2374         args = ','.join(map(str, t[3]))
2375         args = re.sub('(?m)^', '//', args)
2376         args = re.sub('^//', '', args)
2377         comment = '\n// %s::%s(%s)\n' % (currentFormat.id, t[1], args)
2378         codeObj.prepend_all(comment)
2379         t[0] = codeObj
2380
2381     # Define an instruction using an explicitly specified format:
2382     # "<fmt>::<mnemonic>(<args>)"
2383     def p_inst_1(self, t):
2384         'inst : ID DBLCOLON ID LPAREN arg_list RPAREN'
2385         try:
2386             format = self.formatMap[t[1]]
2387         except KeyError:
2388             error(t.lineno(1), 'instruction format "%s" not defined.' % t[1])
2389
2390         codeObj = format.defineInst(self, t[3], t[5], t.lexer.lineno)
2391         comment = '\n// %s::%s(%s)\n' % (t[1], t[3], t[5])
2392         codeObj.prepend_all(comment)
2393         t[0] = codeObj
2394
```
There are two grammar rules for resolving *inst* symbol.
The grammar rule p_inst_1 matches with 
explicitly defined macroop instructions, 
which have double colons on its invocation
(e.g., Inst::PREFETCH(mb)).

Because this is the rule definining terminal symbol inst,
it returns generated codeObj as a t[0].
As rules are reduced, 
generated codeObj is returned to the top rule.

Then how the codeObj is generated for inst statement? 
We can find that *p_inst_1* function
makes use of *defineInst* function
defined for each format.
Here the retrieved format is associated with t[1] and 
it could be *Inst* for Inst::PREFETCH(mb).

By the whay, what is the Foramt?
To understand it,
*gem5/src/arch/isa_parser.py*
we have to look at *formatMap* dictionary
which returns Format data structure
associated with format id of macroop instruction.

###formatMap
*gem5/src/arch/isa_parser.py*
```python
1564         # This dictionary maps format name strings to Format objects.
1565         self.formatMap = {}
```
Because formatMap has been initialized as empty list,
it should be filled in as a result of parsing.
And defFormat function pushes entry to the formatMap.

```python
2496     def defFormat(self, id, params, code, lineno):
2497         '''Define a new format'''
2498
2499         # make sure we haven't already defined this one
2500         if id in self.formatMap:
2501             error(lineno, 'format %s redefined.' % id)
2502
2503         # create new object and store in global map
2504         self.formatMap[id] = Format(id, params, code)
```
defFormat adds *Format* instance 
when there is no existing format name indicated by id parameter.
Therefore, we can know that 
*id* parameter is important to add new Format to the formatMap.
And we could infer id can be string such as *Inst*
from the Inst::PREFETCH statement.

To find out what is id parameter exactly,
we have to find the place 
where the defFormat function is called,
we can easily find a grammar rule named *p_def_format*.

```python
2133     # An instruction format definition looks like
2134     # "def format <fmt>(<params>) {{...}};"
2135     def p_def_format(self, t):
2136         'def_format : DEF FORMAT ID LPAREN param_list RPAREN CODELIT SEMI'
2137         (id, params, code) = (t[3], t[5], t[7])
2138         self.defFormat(id, params, code, t.lexer.lineno)
```

This rule matches any block
starting with *def format* keyword, and 
third keyword of this block is ID.
This keywords is passed to the defFormat's first parameter, id. 

When you search keyword with def format,
you can find multiple files in
isa/formats directory which define all formats of x86 macroops.

*gem5/src/arch/x86/isa/formats/multi.isa*
```python
def format Inst(*opTypeSet) {{
    blocks = specializeInst(Name, list(opTypeSet), EmulEnv())
    (header_output, decoder_output,
     decode_block, exec_output) = blocks.makeList()
}};
```

Because all the format isa files should be parsed by the isa_parser,
as it meets *def format* block
such as *def format Inst*,
defFormat method is invoked 
by p_def_format parsing rule.

Because isa_parser starts to parse macroop after parsing def format,
when p_inst_1 grammar rule is invoked,
it can retrieve format associated with macroop
and invokes defineInst function thorugh the Format.

Also note that defFormat receives 
code and parameters of the parsed def format block.

###defineInst needs two dynamically compiled functions
We can now understand what is the Format and
how and when the generated Format is pushed into the formatMap.
Then what happens when *defineInst* is invoked 
through the Format? 

*gem5/src/arch/isa_parser.py*
```python
 223 ################
 224 # Format object.
 225 #
 226 # A format object encapsulates an instruction format.  It must provide
 227 # a defineInst() method that generates the code for an instruction
 228 # definition.
 229
 230 class Format(object):
 231     def __init__(self, id, params, code):
 232         self.id = id
 233         self.params = params
 234         label = 'def format ' + id
 235         self.user_code = compile(fixPythonIndentation(code), label, 'exec')
 236         param_list = string.join(params, ", ")
 237         f = '''def defInst(_code, _context, %s):
 238                 my_locals = vars().copy()
 239                 exec _code in _context, my_locals
 240                 return my_locals\n''' % param_list
 241         c = compile(f, label + ' wrapper', 'exec')
 242         exec c
 243         self.func = defInst
 244
 245     def defineInst(self, parser, name, args, lineno):
 246         parser.updateExportContext()
 247         context = parser.exportContext.copy()
 248         if len(name):
 249             Name = name[0].upper()
 250             if len(name) > 1:
 251                 Name += name[1:]
 252         context.update({ 'name' : name, 'Name' : Name })
 253         try:
 254             vars = self.func(self.user_code, context, *args[0], **args[1])
 255         except Exception, exc:
 256             if debug:
 257                 raise
 258             error(lineno, 'error defining "%s": %s.' % (name, exc))
 259         for k in vars.keys():
 260             if k not in ('header_output', 'decoder_output',
 261                          'exec_output', 'decode_block'):
 262                 del vars[k]
 263         return GenCode(parser, **vars)
```

To understand *defineInst* function,
we need to carefully look at constructor of Format class.
When the Format instance is initiated,
it compiles two functions.
Pyton compile function generates code object 
compiled from input string or file.

Rember that def format grammar passes 
code block of def format to the defFormat function,
and it makes use of that code block to compile first function. 
The generated code object is stored to *self.user_code*.

And second compile invocation 
generates function named *defInst*.

```python
def defInst(_code, _context, *opTypeSet):
                my_locals = vars().copy()
                exec _code in _context, my_locals
                return my_locals
```

The generated defInst function pointer is stored 
to the *self.func* member field of Format instance.

###Finally defineInst is invoked!
After two functions are compiled, 
it can finally invokes *defineInst* function.
To understand what kind of operands are needed by defineInst,
let's go back to p_inst_1 function that invokes defineInst.

2383     def p_inst_1(self, t):
2384         'inst : ID DBLCOLON ID LPAREN arg_list RPAREN'
2385         try:
2386             format = self.formatMap[t[1]]
2387         except KeyError:
2388             error(t.lineno(1), 'instruction format "%s" not defined.' % t[1])
2389
2390         codeObj = format.defineInst(self, t[3], t[5], t.lexer.lineno)
2391         comment = '\n// %s::%s(%s)\n' % (t[1], t[3], t[5])
2392         codeObj.prepend_all(comment)
2393         t[0] = codeObj

First it passes self which is parser instance as parser,
t[3]:Macroop mnemonic as name,
t[5]:argument list passed to macroop invocation in decoder as args.

The most important part of the defineInst is invoking 
pre-compiled functions.
As shown in line 254 of defineInst function,
it invokes secondly compiled function *defInst*
with firstly compiled function, 
context of parser and its operands .

```python
def defInst(_code, _context, *opTypeSet):
                my_locals = vars().copy()
                exec _code in _context, my_locals
                return my_locals
```

When we look at the second auto-generated function, defInst,
we can find that exec executes the first auto-generated function 
with context of parser as global variable and 
macroop arguments as local variable. 

#First auto-generated function: codes in the def format block
*gem5/src/arch/x86/isa/formats/multi.isa*
```python
def format Inst(*opTypeSet) {{
    blocks = specializeInst(Name, list(opTypeSet), EmulEnv())
    (header_output, decoder_output,
     decode_block, exec_output) = blocks.makeList()
}};

Remeber that the first auto-generated code object consists of 
code statements excerpted from def format block by the isa_parser.
Because we are investigating on Inst format block,
we are going to look at the code block of Inst.

As shown on the above code block,
it invokes specializeInst function and generate blocks.
Note that the generated blocks are used to 
set several code blocks of macroop (header, decoder, exec). 

From the output of blocks, 
we can infer that blocks 
returned from specializeInst function 
generates actual code of macroop.
Therefore, let's dive into the specializeInst function.

##specializeInst: determines operand types of macroop and generate codes
specializeInst function has 
two very important roles in parsing macroops:
translating general macroop invocation to 
specific macroop implementation depending on its argument,
and macroop related code generation.

When we look at the decoder code, 
for invocation of one macroop named X,
there exist multiple definitions associated with the X
such as X_M and X_P.

Even though specific method name has not been used,
different variant of X should be invoked properly.
Then who manages this transformation?
The specializeInst member function
parses the macroop argument, and 
generates code that invokes proper variants of macroop.

*gem5/src/arch/x86/isa/specialize.isa*
```python
108     class OpType(object):
109         parser = re.compile(r"(?P<tag>[A-Z]+)(?P<size>[a-z]*)|(r(?P<reg>[A-Z0-9]+)(?P<rsize>[a-z]*))")
110         def __init__(self, opTypeString):
111             match = OpType.parser.search(opTypeString)
112             if match == None:
113                 raise Exception, "Problem parsing operand type %s" % opTypeString
114             self.reg = match.group("reg")
115             self.tag = match.group("tag")
116             self.size = match.group("size")
117             if not self.size:
118                 self.size = match.group("rsize")
119
120     ModRMRegIndex = "(MODRM_REG | (REX_R << 3))"
121     ModRMRMIndex = "(MODRM_RM | (REX_B << 3))"
122     InstRegIndex = "(OPCODE_OP_BOTTOM3 | (REX_B << 3))"
123
124     # This function specializes the given piece of code to use a particular
125     # set of argument types described by "opTypes".
126     def specializeInst(Name, opTypes, env):
127         # print "Specializing %s with opTypes %s" % (Name, opTypes)
128         while len(opTypes):
129             # Parse the operand type string we're working with
130             opType = OpType(opTypes[0])
131             opTypes.pop(0)
132
133             if opType.tag not in ("I", "J", "P", "PR", "Q", "V", "VR", "W"):
134                 if opType.size:
135                     env.setSize(opType.size)
136
137             if opType.reg:
138                 #Figure out what to do with fixed register operands
139                 #This is the index to use, so we should stick it some place.
140                 if opType.reg in ("A", "B", "C", "D"):
141                     regString = "INTREG_R%sX" % opType.reg
142                 else:
143                     regString = "INTREG_R%s" % opType.reg
144                 env.addReg(regString)
145                 env.addToDisassembly(
146                     "printReg(out, InstRegIndex(%s), regSize);\n" %
147                                                                      regString)
148
149                 Name += "_R"
150
151             elif opType.tag == "B":
152                 # This refers to registers whose index is encoded as part of the opcode
153                 env.addToDisassembly(
154                         "printReg(out, InstRegIndex(%s), regSize);\n" %
155                                                                   InstRegIndex)
156
157                 Name += "_R"
158
159                 env.addReg(InstRegIndex)
160             elif opType.tag == "M":
161                 # This refers to memory. The macroop constructor sets up modrm
162                 # addressing. Non memory modrm settings should cause an error.
163                 env.doModRM = True
164                 return doSplitDecode("MODRM_MOD",
165                         {"3" : (doBadInstDecode,) },
166                         (doRipRelativeDecode, Name, opTypes, env))
167             elif opType.tag == None or opType.size == None:
168                 raise Exception, "Problem parsing operand tag: %s" % opType.tag
169             elif opType.tag == "C":
170                 # A control register indexed by the "reg" field
171                 env.addReg(ModRMRegIndex)
172                 env.addToDisassembly(
173                         "ccprintf(out, \"CR%%d\", %s);\n" % ModRMRegIndex)
174                 Name += "_C"
175             elif opType.tag == "D":
176                 # A debug register indexed by the "reg" field
177                 env.addReg(ModRMRegIndex)
178                 env.addToDisassembly(
179                         "ccprintf(out, \"DR%%d\", %s);\n" % ModRMRegIndex)
180                 Name += "_D"
181             elif opType.tag == "S":
182                 # A segment selector register indexed by the "reg" field
183                 env.addReg(ModRMRegIndex)
184                 env.addToDisassembly(
185                         "printSegment(out, %s);\n" % ModRMRegIndex)
186                 Name += "_S"
187             elif opType.tag in ("G", "P", "T", "V"):
188                 # Use the "reg" field of the ModRM byte to select the register
189                 env.addReg(ModRMRegIndex)
190                 env.addToDisassembly(
191                         "printReg(out, InstRegIndex(%s), regSize);\n" %
192                                                                  ModRMRegIndex)
193
194                 if opType.tag == "P":
195
196                     Name += "_MMX"
197                 elif opType.tag == "V":
198                     Name += "_XMM"
199                 else:
200                     Name += "_R"
201             elif opType.tag in ("E", "Q", "W"):
202                 # This might refer to memory or to a register. We need to
203                 # divide it up farther.
204                 regEnv = copy.copy(env)
205                 regEnv.addReg(ModRMRMIndex)
206                 regEnv.addToDisassembly(
207                         "printReg(out, InstRegIndex(%s), regSize);\n" %
208                                                                   ModRMRMIndex)
209
210                 # This refers to memory. The macroop constructor should set up
211
212                 # modrm addressing.
213                 memEnv = copy.copy(env)
214                 memEnv.doModRM = True
215                 regSuffix = "_R"
216                 if opType.tag == "Q":
217                     regSuffix = "_MMX"
218                 elif opType.tag == "W":
219                     regSuffix = "_XMM"
220                 return doSplitDecode("MODRM_MOD",
221                     {"3" : (specializeInst, Name + regSuffix,
222                             copy.copy(opTypes), regEnv)},
223                            (doRipRelativeDecode, Name,
224                             copy.copy(opTypes), memEnv))
225             elif opType.tag in ("I", "J"):
226                 # Immediates
227                 env.addToDisassembly(
228                         "ccprintf(out, \"%#x\", machInst.immediate);\n")
229                 Name += "_I"
230             elif opType.tag == "O":
231                 # Immediate containing a memory offset
232                 Name += "_MI"
233             elif opType.tag in ("PR", "R", "VR"):
234                 # Non register modrm settings should cause an error
235                 env.addReg(ModRMRMIndex)
236                 env.addToDisassembly(
237                         "printReg(out, InstRegIndex(%s), regSize);\n" %
238                                                                   ModRMRMIndex)
239
240                 if opType.tag == "PR":
241
242                     Name += "_MMX"
243                 elif opType.tag == "VR":
244                     Name += "_XMM"
245                 else:
246                     Name += "_R"
247             elif opType.tag in ("X", "Y"):
248                 # This type of memory addressing is for string instructions.
249                 # They'll use the right index and segment internally.
250                 if opType.tag == "X":
251                     env.addToDisassembly(
252                             '''printMem(out, env.seg,
253                                 1, X86ISA::ZeroReg, X86ISA::INTREG_RSI, 0,
254                                 env.addressSize, false);''')
255                 else:
256                     env.addToDisassembly(
257                             '''printMem(out, SEGMENT_REG_ES,
258                                 1, X86ISA::ZeroReg, X86ISA::INTREG_RDI, 0,
259                                 env.addressSize, false);''')
260                 Name += "_M"
261             else:
262                 raise Exception, "Unrecognized tag %s." % opType.tag
263
264         # Generate code to return a macroop of the given name which will
265         # operate in the "emulation environment" env
266         return genMacroop(Name, env)
```


As you can see on the above code,
depending on operand type of a macroop
and its tag field,
different function name is generated 
by adding a character representing type of macroop.

This is because, for one macroop mnemonic 
such as mov macroop, 
different usages of macroop can exist.
In other words, 
depending on its operand type 
such as memory, registers,
it can be interpreted as different macroop invocation.

In Gem5, 
those different macroop invocations are 
reprenseted as different functions 
having same mnemonic but different suffix with underbar.

Because tag field of macroop indicates 
operands of macroop used in its invocation
in decoder, which means operands of macroop,
different macroop method name is generated 
by the specializeInst function.

One interesting example is 
when macroop contains M type operands.
when first opType of the operand is M,
instead of adding string directly,
it invokes *doSplitDecode* function 
to call proper macroop function
depending on the ModRM value of the macroop.

```python
160             elif opType.tag == "M":
161                 # This refers to memory. The macroop constructor sets up modrm
162                 # addressing. Non memory modrm settings should cause an error.
163                 env.doModRM = True
164                 return doSplitDecode("MODRM_MOD",
165                         {"3" : (doBadInstDecode,) },
166                         (doRipRelativeDecode, Name, opTypes, env))
```

doSplitDecode requires three parameters:
switchVal required for choosing one among multiple cases,
val required for building implementation of each switch statement,
and default variable containing function
executed when switch doesn't meet any satisfiable condition.

```python
 47     # This code builds up a decode block which decodes based on switchval.
 48     # vals is a dict which matches case values with what should be decoded to.
 49     # Each element of the dict is a list containing a function and then the
 50     # arguments to pass to it.
 51     def doSplitDecode(switchVal, vals, default = None):
 52         blocks = OutputBlocks()
 53         blocks.decode_block = 'switch(%s) {\n' % switchVal
 54         for (val, todo) in vals.items():
 55             new_blocks = todo[0](*todo[1:])
 56             new_blocks.decode_block = \
 57                 '\tcase %s: %s\n' % (val, new_blocks.decode_block)
 58             blocks.append(new_blocks)
 59         if default:
 60             new_blocks = default[0](*default[1:])
 61             new_blocks.decode_block = \
 62                 '\tdefault: %s\n' % new_blocks.decode_block
 63             blocks.append(new_blocks)
 64         blocks.decode_block += '}\n'
 65         return blocks
```

When M flag has been set for the macroop operand,
it passes one condition and associated function to doSplitDecode function,
which maps doBadInstDecode to condition 3.
And one important default block and function,
*doRipRelativeDecode*.

```python
 69     def doRipRelativeDecode(Name, opTypes, env):
 70         # print "RIPing %s with opTypes %s" % (Name, opTypes)
 71         env.memoryInst = True
 72         normEnv = copy.copy(env)
 73         normEnv.addToDisassembly(
 74                 '''printMem(out, env.seg, env.scale, env.index, env.base,
 75                     machInst.displacement, env.addressSize, false);''')
 76         normBlocks = specializeInst(Name + "_M", copy.copy(opTypes), normEnv)
 77         ripEnv = copy.copy(env)
 78         ripEnv.addToDisassembly(
 79                 '''printMem(out, env.seg, 1, 0, 0,
 80                     machInst.displacement, env.addressSize, true);''')
 81         ripBlocks = specializeInst(Name + "_P", copy.copy(opTypes), ripEnv)
 82
 83         blocks = OutputBlocks()
 84         blocks.append(normBlocks)
 85         blocks.append(ripBlocks)                                                                                                                                                                                                                                                     86
 87         blocks.decode_block = '''
 88         if(machInst.modRM.mod == 0 &&
 89           machInst.modRM.rm == 5 &&
 90           machInst.mode.submode == SixtyFourBitMode)
 91         { %s }
 92         else
 93         { %s }''' % \
 94          (ripBlocks.decode_block, normBlocks.decode_block)
 95         return blocks
```

This function generates codeblock 
when switch condition doesn't satisfy and falls thorugh to the default.
As shown in the above code,
two specializeInst function are called 
to generate code which can invoke *X_M and X_P*
macroop functions.






*gem5/build/X86/arch/x86/generated/decode-method.cc*
```cpp
10228                 case 0x5:
10229                   // Inst::PREFETCH((['Mb'], {}))
10230                   switch(MODRM_MOD) {
10231                         case 3:
10232                           return new Unknown(machInst);
10233
10234                         default:
10235                           if(machInst.modRM.mod == 0 &&
10236                             machInst.modRM.rm == 5 &&
10237                             machInst.mode.submode == SixtyFourBitMode)
10238                           { return new X86Macroop::PREFETCH_P(machInst, EmulEnv(0,
10239                                                 0,
10240                                                 1,
10241                                                 ADDRSIZE,
10242                                                 STACKSIZE));
10243                    }
10244                           else
10245                           { return new X86Macroop::PREFETCH_M(machInst, EmulEnv(0,
10246                                                 0,
10247                                                 1,
10248                                                 ADDRSIZE,
10249                                                 STACKSIZE));
10250                    }
10251                   }
10252                   break;
```





