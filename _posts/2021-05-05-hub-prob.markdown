---
layout: post
titile: "Linux usb core driver interface
categories: linux, embedded-linux
---

```c
static struct usb_driver hub_driver = {
        .name =         "hub",
        .probe =        hub_probe,
        .disconnect =   hub_disconnect,
        .suspend =      hub_suspend,
        .resume =       hub_resume,
        .reset_resume = hub_reset_resume,
        .pre_reset =    hub_pre_reset,
        .post_reset =   hub_post_reset,
        .unlocked_ioctl = hub_ioctl,
        .id_table =     hub_id_table,
        .supports_autosuspend = 1,
};                             
        
int usb_hub_init(void)
{
        if (usb_register(&hub_driver) < 0) {
                printk(KERN_ERR "%s: can't register hub driver\n",
                        usbcore_name);
                return -1;
        }
 
        /*
         * The workqueue needs to be freezable to avoid interfering with
         * USB-PERSIST port handover. Otherwise it might see that a full-speed
         * device was gone before the EHCI controller had handed its port
         * over to the companion full-speed controller.
         */
        hub_wq = alloc_workqueue("usb_hub_wq", WQ_FREEZABLE, 0);
        if (hub_wq)
                return 0;

        /* Fall through if kernel_thread failed */
        usb_deregister(&hub_driver);
        pr_err("%s: can't allocate workqueue for usb hub\n", usbcore_name);

        return -1;
}    
```
Because hub_driver has been registered as usb_register function
which register the driver as usb interface driver,
when the hub_driver is bound,
usb_probe_interface function is invoked first place
and then invokes its real probe function registered in the hub_driver object. 


```c
/* called from driver core with dev locked */
static int usb_probe_interface(struct device *dev)
{
        struct usb_driver *driver = to_usb_driver(dev->driver);
        struct usb_interface *intf = to_usb_interface(dev);
        struct usb_device *udev = interface_to_usbdev(intf);
        const struct usb_device_id *id;
        int error = -ENODEV;
        int lpm_disable_error = -ENODEV;

        dev_dbg(dev, "%s\n", __func__);

        intf->needs_binding = 0;

        if (usb_device_is_owned(udev))
                return error;

        if (udev->authorized == 0) {
                dev_err(&intf->dev, "Device is not authorized for usage\n");
                return error;
        } else if (intf->authorized == 0) {
                dev_err(&intf->dev, "Interface %d is not authorized for usage\n",
                                intf->altsetting->desc.bInterfaceNumber);
                return error;
        }

        id = usb_match_dynamic_id(intf, driver);
        if (!id)
                id = usb_match_id(intf, driver->id_table);
        if (!id)
                return error;

        dev_dbg(dev, "%s - got id\n", __func__);

        error = usb_autoresume_device(udev);
        if (error)
                return error;

        intf->condition = USB_INTERFACE_BINDING;

        /* Probed interfaces are initially active.  They are
         * runtime-PM-enabled only if the driver has autosuspend support.
         * They are sensitive to their children's power states.
         */
        pm_runtime_set_active(dev);
        pm_suspend_ignore_children(dev, false);
        if (driver->supports_autosuspend)
                pm_runtime_enable(dev);

        /* If the new driver doesn't allow hub-initiated LPM, and we can't
         * disable hub-initiated LPM, then fail the probe.
         *
         * Otherwise, leaving LPM enabled should be harmless, because the
         * endpoint intervals should remain the same, and the U1/U2 timeouts
         * should remain the same.
         *
         * If we need to install alt setting 0 before probe, or another alt
         * setting during probe, that should also be fine.  usb_set_interface()
         * will attempt to disable LPM, and fail if it can't disable it.
         */
        if (driver->disable_hub_initiated_lpm) {
                lpm_disable_error = usb_unlocked_disable_lpm(udev);
                if (lpm_disable_error) {
                        dev_err(&intf->dev, "%s Failed to disable LPM for driver %s\n",
                                __func__, driver->name);
                        error = lpm_disable_error;
                        goto err;
                }
        }

        /* Carry out a deferred switch to altsetting 0 */
        if (intf->needs_altsetting0) {
                error = usb_set_interface(udev, intf->altsetting[0].
                                desc.bInterfaceNumber, 0);
                if (error < 0)
                        goto err;
                intf->needs_altsetting0 = 0;
        }

        error = driver->probe(intf, id);
        if (error)
                goto err;

        intf->condition = USB_INTERFACE_BOUND;

        /* If the LPM disable succeeded, balance the ref counts. */
        if (!lpm_disable_error)
                usb_unlocked_enable_lpm(udev);

        usb_autosuspend_device(udev);
        return error;

 err:
        usb_set_intfdata(intf, NULL);
        intf->needs_remote_wakeup = 0;
        intf->condition = USB_INTERFACE_UNBOUND;

        /* If the LPM disable succeeded, balance the ref counts. */
        if (!lpm_disable_error)
                usb_unlocked_enable_lpm(udev);

        /* Unbound interfaces are always runtime-PM-disabled and -suspended */
        if (driver->supports_autosuspend)
                pm_runtime_disable(dev);
        pm_runtime_set_suspended(dev);

        usb_autosuspend_device(udev);
        return error;
}
```

```c
static int hub_probe(struct usb_interface *intf, const struct usb_device_id *id)
{
        struct usb_host_interface *desc;
        struct usb_device *hdev;
        struct usb_hub *hub;

        desc = intf->cur_altsetting;
        hdev = interface_to_usbdev(intf);

        /*
         * Set default autosuspend delay as 0 to speedup bus suspend,
         * based on the below considerations:
         *
         * - Unlike other drivers, the hub driver does not rely on the
         *   autosuspend delay to provide enough time to handle a wakeup
         *   event, and the submitted status URB is just to check future
         *   change on hub downstream ports, so it is safe to do it.
         *
         * - The patch might cause one or more auto supend/resume for
         *   below very rare devices when they are plugged into hub
         *   first time:
         *
         *      devices having trouble initializing, and disconnect
         *      themselves from the bus and then reconnect a second
         *      or so later
         *
         *      devices just for downloading firmware, and disconnects
         *      themselves after completing it
         *
         *   For these quite rare devices, their drivers may change the
         *   autosuspend delay of their parent hub in the probe() to one
         *   appropriate value to avoid the subtle problem if someone
         *   does care it.
         *
         * - The patch may cause one or more auto suspend/resume on
         *   hub during running 'lsusb', but it is probably too
         *   infrequent to worry about.
         *
         * - Change autosuspend delay of hub can avoid unnecessary auto
         *   suspend timer for hub, also may decrease power consumption
         *   of USB bus.
         *
         * - If user has indicated to prevent autosuspend by passing
         *   usbcore.autosuspend = -1 then keep autosuspend disabled.
         */
#ifdef CONFIG_PM
        if (hdev->dev.power.autosuspend_delay >= 0)
                pm_runtime_set_autosuspend_delay(&hdev->dev, 0);
#endif

        /*
         * Hubs have proper suspend/resume support, except for root hubs
         * where the controller driver doesn't have bus_suspend and
         * bus_resume methods.
         */
        if (hdev->parent) {             /* normal device */
                usb_enable_autosuspend(hdev);
        } else {                        /* root hub */
                const struct hc_driver *drv = bus_to_hcd(hdev->bus)->driver;

                if (drv->bus_suspend && drv->bus_resume)
                        usb_enable_autosuspend(hdev);
        }

        if (hdev->level == MAX_TOPO_LEVEL) {
                dev_err(&intf->dev,
                        "Unsupported bus topology: hub nested too deep\n");
                return -E2BIG;
        }

#ifdef  CONFIG_USB_OTG_DISABLE_EXTERNAL_HUB
        if (hdev->parent) {
                dev_warn(&intf->dev, "ignoring external hub\n");
                return -ENODEV;
        }
#endif

        if (!hub_descriptor_is_sane(desc)) {
                dev_err(&intf->dev, "bad descriptor, ignoring hub\n");
                return -EIO;
        }

        /* We found a hub */
        dev_info(&intf->dev, "USB hub found\n");

        hub = kzalloc(sizeof(*hub), GFP_KERNEL);
        if (!hub)
                return -ENOMEM;

        kref_init(&hub->kref);
        hub->intfdev = &intf->dev;
        hub->hdev = hdev;
        INIT_DELAYED_WORK(&hub->leds, led_work);
        INIT_DELAYED_WORK(&hub->init_work, NULL);
        INIT_WORK(&hub->events, hub_event);
        spin_lock_init(&hub->irq_urb_lock);
        timer_setup(&hub->irq_urb_retry, hub_retry_irq_urb, 0);
        usb_get_intf(intf);
        usb_get_dev(hdev);

        usb_set_intfdata(intf, hub);
        intf->needs_remote_wakeup = 1;
        pm_suspend_ignore_children(&intf->dev, true);

        if (hdev->speed == USB_SPEED_HIGH)
                highspeed_hubs++;

        if (id->driver_info & HUB_QUIRK_CHECK_PORT_AUTOSUSPEND)
                hub->quirk_check_port_auto_suspend = 1;

        if (id->driver_info & HUB_QUIRK_DISABLE_AUTOSUSPEND) {
                hub->quirk_disable_autosuspend = 1;
                usb_autopm_get_interface_no_resume(intf);
        }

        if (hub_configure(hub, &desc->endpoint[0].desc) >= 0)
                return 0;

        hub_disconnect(intf);
        return -ENODEV;
}
```



```c
static int hub_configure(struct usb_hub *hub,
        struct usb_endpoint_descriptor *endpoint)
{
        struct usb_hcd *hcd;
        struct usb_device *hdev = hub->hdev;
        struct device *hub_dev = hub->intfdev;
        u16 hubstatus, hubchange;
        u16 wHubCharacteristics;
        unsigned int pipe;
        int maxp, ret, i;
        char *message = "out of memory";
        unsigned unit_load;
        unsigned full_load;
        unsigned maxchild;

	...

        usb_hub_adjust_deviceremovable(hdev, hub->descriptor);

        hub_activate(hub, HUB_INIT);
        return 0;

fail:
        dev_err(hub_dev, "config failed, %s (err %d)\n",
                        message, ret);
        /* hub_disconnect() frees urb and descriptor */
        return ret;
}
```




























```c
/*
 * The table of devices
 */
#define UNUSUAL_DEV(id_vendor, id_product, bcdDeviceMin, bcdDeviceMax, \
                    vendorName, productName, useProtocol, useTransport, \
                    initFunction, flags) \
{ USB_DEVICE_VER(id_vendor, id_product, bcdDeviceMin, bcdDeviceMax), \
  .driver_info = (flags) }

#define COMPLIANT_DEV   UNUSUAL_DEV

#define USUAL_DEV(useProto, useTrans) \
{ USB_INTERFACE_INFO(USB_CLASS_MASS_STORAGE, useProto, useTrans) }

/* Define the device is matched with Vendor ID and interface descriptors */
#define UNUSUAL_VENDOR_INTF(id_vendor, cl, sc, pr, \
                        vendorName, productName, useProtocol, useTransport, \
                        initFunction, flags) \
{ \
        .match_flags = USB_DEVICE_ID_MATCH_INT_INFO \
                                | USB_DEVICE_ID_MATCH_VENDOR, \
        .idVendor    = (id_vendor), \
        .bInterfaceClass = (cl), \
        .bInterfaceSubClass = (sc), \
        .bInterfaceProtocol = (pr), \
        .driver_info = (flags) \
}

const struct usb_device_id usb_storage_usb_ids[] = {
#       include "unusual_devs.h"
        { }             /* Terminating entry */
};      

```

**unusual_devs.h**
```c
/* patch submitted by Vivian Bregier <Vivian.Bregier@imag.fr> */
UNUSUAL_DEV(  0x03eb, 0x2002, 0x0100, 0x0100,
                "ATMEL",
                "SND1 Storage",
                USB_SC_DEVICE, USB_PR_DEVICE, NULL,
                US_FL_IGNORE_RESIDUE),

/* Control/Bulk transport for all SubClass values */
USUAL_DEV(USB_SC_RBC, USB_PR_CB),
USUAL_DEV(USB_SC_8020, USB_PR_CB),
USUAL_DEV(USB_SC_QIC, USB_PR_CB),
USUAL_DEV(USB_SC_UFI, USB_PR_CB),
USUAL_DEV(USB_SC_8070, USB_PR_CB),
USUAL_DEV(USB_SC_SCSI, USB_PR_CB),
```


```c
/**
 * struct usb_device_id - identifies USB devices for probing and hotplugging
 * @match_flags: Bit mask controlling which of the other fields are used to
 *      match against new devices. Any field except for driver_info may be
 *      used, although some only make sense in conjunction with other fields.
 *      This is usually set by a USB_DEVICE_*() macro, which sets all
 *      other fields in this structure except for driver_info.
 * @idVendor: USB vendor ID for a device; numbers are assigned
 *      by the USB forum to its members.
 * @idProduct: Vendor-assigned product ID.
 * @bcdDevice_lo: Low end of range of vendor-assigned product version numbers.
 *      This is also used to identify individual product versions, for
 *      a range consisting of a single device.
 * @bcdDevice_hi: High end of version number range.  The range of product
 *      versions is inclusive.
 * @bDeviceClass: Class of device; numbers are assigned
 *      by the USB forum.  Products may choose to implement classes,
 *      or be vendor-specific.  Device classes specify behavior of all
 *      the interfaces on a device.
 * @bDeviceSubClass: Subclass of device; associated with bDeviceClass.
 * @bDeviceProtocol: Protocol of device; associated with bDeviceClass.
 * @bInterfaceClass: Class of interface; numbers are assigned
 *      by the USB forum.  Products may choose to implement classes,
 *      or be vendor-specific.  Interface classes specify behavior only
 *      of a given interface; other interfaces may support other classes.
 * @bInterfaceSubClass: Subclass of interface; associated with bInterfaceClass.
 * @bInterfaceProtocol: Protocol of interface; associated with bInterfaceClass.
 * @bInterfaceNumber: Number of interface; composite devices may use
 *      fixed interface numbers to differentiate between vendor-specific
 *      interfaces.
 * @driver_info: Holds information used by the driver.  Usually it holds
 *      a pointer to a descriptor understood by the driver, or perhaps
 *      device flags.
 *
 * In most cases, drivers will create a table of device IDs by using
 * USB_DEVICE(), or similar macros designed for that purpose.
 * They will then export it to userspace using MODULE_DEVICE_TABLE(),
 * and provide it to the USB core through their usb_driver structure.
 *
 * See the usb_match_id() function for information about how matches are
 * performed.  Briefly, you will normally use one of several macros to help
 * construct these entries.  Each entry you provide will either identify
 * one or more specific products, or will identify a class of products
 * which have agreed to behave the same.  You should put the more specific
 * matches towards the beginning of your table, so that driver_info can
 * record quirks of specific products.
 */
struct usb_device_id {
        /* which fields to match against? */
        __u16           match_flags;

        /* Used for product specific matches; range is inclusive */
        __u16           idVendor;
        __u16           idProduct;
        __u16           bcdDevice_lo;
        __u16           bcdDevice_hi;

        /* Used for device class matches */
        __u8            bDeviceClass;
        __u8            bDeviceSubClass;
        __u8            bDeviceProtocol;

        /* Used for interface class matches */
        __u8            bInterfaceClass;
        __u8            bInterfaceSubClass;
        __u8            bInterfaceProtocol;

        /* Used for vendor-specific interface matches */
        __u8            bInterfaceNumber;

        /* not matched against */
        kernel_ulong_t  driver_info
                __attribute__((aligned(sizeof(kernel_ulong_t))));
};

```





