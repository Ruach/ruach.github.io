---
layout: post
titile: "Linux usb core driver interface
categories: linux, embedded-linux
---

```c
/* called from driver core with dev locked */
static int usb_probe_interface(struct device *dev)
{
        struct usb_driver *driver = to_usb_driver(dev->driver);
        struct usb_interface *intf = to_usb_interface(dev);
        struct usb_device *udev = interface_to_usbdev(intf);
        const struct usb_device_id *id;
        int error = -ENODEV;
        int lpm_disable_error = -ENODEV;

        dev_dbg(dev, "%s\n", __func__);

        intf->needs_binding = 0;

        if (usb_device_is_owned(udev))
                return error;

        if (udev->authorized == 0) {
                dev_err(&intf->dev, "Device is not authorized for usage\n");
                return error;
        } else if (intf->authorized == 0) {
                dev_err(&intf->dev, "Interface %d is not authorized for usage\n",
                                intf->altsetting->desc.bInterfaceNumber);
                return error;
        }

        id = usb_match_dynamic_id(intf, driver);
        if (!id)
                id = usb_match_id(intf, driver->id_table);
        if (!id)
                return error;

        dev_dbg(dev, "%s - got id\n", __func__);

        error = usb_autoresume_device(udev);
        if (error)
                return error;

        intf->condition = USB_INTERFACE_BINDING;

        /* Probed interfaces are initially active.  They are
         * runtime-PM-enabled only if the driver has autosuspend support.
         * They are sensitive to their children's power states.
         */
        pm_runtime_set_active(dev);
        pm_suspend_ignore_children(dev, false);
        if (driver->supports_autosuspend)
                pm_runtime_enable(dev);

        /* If the new driver doesn't allow hub-initiated LPM, and we can't
         * disable hub-initiated LPM, then fail the probe.
         *
         * Otherwise, leaving LPM enabled should be harmless, because the
         * endpoint intervals should remain the same, and the U1/U2 timeouts
         * should remain the same.
         *
         * If we need to install alt setting 0 before probe, or another alt
         * setting during probe, that should also be fine.  usb_set_interface()
         * will attempt to disable LPM, and fail if it can't disable it.
         */
        if (driver->disable_hub_initiated_lpm) {
                lpm_disable_error = usb_unlocked_disable_lpm(udev);
                if (lpm_disable_error) {
                        dev_err(&intf->dev, "%s Failed to disable LPM for driver %s\n",
                                __func__, driver->name);
                        error = lpm_disable_error;
                        goto err;
                }
        }

        /* Carry out a deferred switch to altsetting 0 */
        if (intf->needs_altsetting0) {
                error = usb_set_interface(udev, intf->altsetting[0].
                                desc.bInterfaceNumber, 0);
                if (error < 0)
                        goto err;
                intf->needs_altsetting0 = 0;
        }

        error = driver->probe(intf, id);
        if (error)
                goto err;

        intf->condition = USB_INTERFACE_BOUND;

        /* If the LPM disable succeeded, balance the ref counts. */
        if (!lpm_disable_error)
                usb_unlocked_enable_lpm(udev);

        usb_autosuspend_device(udev);
        return error;

 err:
        usb_set_intfdata(intf, NULL);
        intf->needs_remote_wakeup = 0;
        intf->condition = USB_INTERFACE_UNBOUND;

        /* If the LPM disable succeeded, balance the ref counts. */
        if (!lpm_disable_error)
                usb_unlocked_enable_lpm(udev);

        /* Unbound interfaces are always runtime-PM-disabled and -suspended */
        if (driver->supports_autosuspend)
                pm_runtime_disable(dev);
        pm_runtime_set_suspended(dev);

        usb_autosuspend_device(udev);
        return error;
}


```




```c

/**     
 * usb_find_interface - find usb_interface pointer for driver and device
 * @drv: the driver whose current configuration is considered
 * @minor: the minor number of the desired device
 *
 * This walks the bus device list and returns a pointer to the interface
 * with the matching minor and driver.  Note, this only works for devices
 * that share the USB major number.
 *      
 * Return: A pointer to the interface with the matching major and @minor.
 */
struct usb_interface *usb_find_interface(struct usb_driver *drv, int minor)
{                            
        struct find_interface_arg argb;
        struct device *dev;
                        
        argb.minor = minor;
        argb.drv = &drv->drvwrap.driver;

        dev = bus_find_device(&usb_bus_type, NULL, &argb, __find_interface);
 
        /* Drop reference count from bus_find_device */
        put_device(dev);
 
        return dev ? to_usb_interface(dev) : NULL;
}
EXPORT_SYMBOL_GPL(usb_find_interface)

/**
 * bus_find_device - device iterator for locating a particular device.
 * @bus: bus type
 * @start: Device to begin with
 * @data: Data to pass to match function
 * @match: Callback function to check device
 *              
 * This is similar to the bus_for_each_dev() function above, but it
 * returns a reference to a device that is 'found' for later use, as
 * determined by the @match callback.
 *      
 * The callback should return 0 if the device doesn't match and non-zero
 * if it does.  If the callback returns non-zero, this function will
 * return to the caller and not iterate over any more devices.
 */     
struct device *bus_find_device(struct bus_type *bus,
                               struct device *start, const void *data,
                               int (*match)(struct device *dev, const void *data))
{
        struct klist_iter i; 
        struct device *dev;
 
        if (!bus || !bus->p)
                return NULL;
 
        klist_iter_init_node(&bus->p->klist_devices, &i,
                             (start ? &start->p->knode_bus : NULL));
        while ((dev = next_device(&i)))
                if (match(dev, data) && get_device(dev))
                        break;
        klist_iter_exit(&i);
        return dev;
}
EXPORT_SYMBOL_GPL(bus_find_device);

static int __find_interface(struct device *dev, const void *data)
{
        const struct find_interface_arg *arg = data;
        struct usb_interface *intf;
 
        if (!is_usb_interface(dev))
                return 0;
 
        if (dev->driver != arg->drv)
                return 0;
        intf = to_usb_interface(dev);
        return intf->minor == arg->minor;
}


```



static struct usb_driver hub_driver = {
        .name =         "hub",
        .probe =        hub_probe,
        .disconnect =   hub_disconnect,
        .suspend =      hub_suspend,
        .resume =       hub_resume,
        .reset_resume = hub_reset_resume,
        .pre_reset =    hub_pre_reset,
        .post_reset =   hub_post_reset,
        .unlocked_ioctl = hub_ioctl,
        .id_table =     hub_id_table,
        .supports_autosuspend = 1,
};

int usb_hub_init(void)
{
        if (usb_register(&hub_driver) < 0) {
                printk(KERN_ERR "%s: can't register hub driver\n",
                        usbcore_name);
                return -1;
        }

        /*
         * The workqueue needs to be freezable to avoid interfering with
         * USB-PERSIST port handover. Otherwise it might see that a full-speed
         * device was gone before the EHCI controller had handed its port
         * over to the companion full-speed controller.
         */
        hub_wq = alloc_workqueue("usb_hub_wq", WQ_FREEZABLE, 0);
        if (hub_wq)
                return 0;

        /* Fall through if kernel_thread failed */
        usb_deregister(&hub_driver);
        pr_err("%s: can't allocate workqueue for usb hub\n", usbcore_name);

        return -1;
}


