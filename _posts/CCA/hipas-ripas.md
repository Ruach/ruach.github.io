## Four different types of S2TTE in RMM
RIPAS and HIPAS is additional concept only applicable for realms. Also, it is 
implemented utilizing the reserved bits of the descriptor. Therefore, basic
understanding of how stage 2 page table descriptors are interpreted is necessary.
MMU determines the type of the descriptor by looking at Desc[1:0] bits. 

```cpp
#define S2TTE_L012_TABLE                0x3UL
#define S2TTE_L012_BLOCK                0x1UL
#define S2TTE_L3_PAGE                   0x3UL
#define S2TTE_Lx_INVALID                0x0UL
```
RTT utilize four basic stage 2 table descriptor types. Then why it is important
in terms of HIPAS and RIPAS?

### Which bits are used for HIPAS / RIPAS? 
RMM utilize the Desc[5:2] as HIPAS and Desc[6] as RIPAS. Also note that the 
concept of RIPAS and HIPAS is invented for invalid stage 2 descriptor. Since 
the lower attributes of the invalid descriptor is ignored by the MMU, RMM can 
utilize these bits to convey additional non-architectural information. 

However, when it comes to valid descriptor including PAGE and BLOCK, bits 
assigned for HIPAS and RIPAS will be interpreted as architectural information by
the MMU. For example, the bits used by the HIPAS completely overlaps with the 
MemAttr which determines memory attribute and cache behavior of that page. Also, 
Desc[6] is interpreted as S2AP[0] which determines the access permission of the
memory page. 

There could be two design decision to utilize HIPAS and RIPAS to avoid problem 
due to overlapping region of RIPAS/ HIPAS. 

1. Apply HIPAS and RIPAS to **invalid** stage 2 page descriptor only and make 
RMM to check whether the page is valid or not. 
2. Define semantic of HIPAS and RIPAS to considering possible interpretation of 
those fields as lower memory attributes for valid descriptor.


### Valid Trusted IPA page
Let's see how the page descriptor for valid Trusted IPA will be generated by the
RMM. When it comes to valid descriptor, whether it is page or block, to allow 
accesses to the pages mapped by the descriptor, it sets up lower and upper 
attribute of the descriptor properly. 

```cpp
#define S2TTE_ATTRS     (S2TTE_MEMATTR_FWB_NORMAL_WB | S2TTE_AP_RW | \
                        S2TTE_SH_IS | S2TTE_AF)
#define S2TTE_BLOCK     (S2TTE_ATTRS | S2TTE_L012_BLOCK)
#define S2TTE_PAGE      (S2TTE_ATTRS | S2TTE_L3_PAGE)

unsigned long s2tte_create_valid(unsigned long pa, long level)
{               
        assert(level >= RTT_MIN_BLOCK_LEVEL);
        assert(addr_is_level_aligned(pa, level));
        if (level == RTT_PAGE_LEVEL) {
                return (pa | S2TTE_PAGE);
        }
        return (pa | S2TTE_BLOCK);
}
```

RMM provides API called s2tte_create_valid to generate valid descriptor for page
or block. Note that it appends pre-determined attribute for valid page to HPA. 
Let's see which attributes should be set to support valid block and page mapping
for trusted IPA page. 

Let's assume that the target page is PAGE_LEVEL. S2TTE_PAGE is a combination of 
descriptor type and lower/upper attributes required for trusted IPA page. 
S2TTE_L3_PAGE is a descriptor type and S2TTE_ATTRS is lower and upper attributes.

### Memory attributes (Desc[5:2])
```cpp
#define S2TTE_MEMATTR_FWB_NORMAL_WB     ((1UL << 4) | (2UL << 2)) 
```

If the descriptor is valid, Desc[5:2] is used to set-up memattr filed of the 
descriptor. Because FWB should be set for the realm, Desc[5] is reserved, and 
Desc[4] determines interpretation of Desc[3:2]. When Desc[4] is zero, the two 
bits in the Desc[3:2] determines memory attributes for the device. Because 
trusted IPA will not be used as device memory, it should not be zero. That is 
the reason of (1UL LSL 4) to set Desc[4]. When Desc[4] == 1, the last two bits 
of the MemAttr, which is Desc[3:2] determines its memory attribute. To make it 
normal write-back, it should be set as 0x2 presented as (2UL LSL 2) in the above.
However, when we interpret this value ias HIPAS directly, it is not the value we 
expect, which is 0x6. Therefore, we can conclude that the HIPAS does not have 
meaning when the descriptor is valid. 

However, when we think about which page can be updated as valid S2TTE for 
protected IPA, its HIPAS and RIPAS should be ASSIGNED and RAM, respectively. 
Therefore, we can know that the HIPAS and RIPAS is only valid before the S2TTE
is updated to valid page. After the S2TTE is changed to valid descriptor, then
the HIPAS and RIPAS value does not mean anything because the bits used for them
will be overwritten by the RMM to enforce some security guarantees. However, 
still we can think of RIPAS and HIPAS for the valid page logically. 


### S2AP data access perimission flag Desc[7:6]
To allow read write access to the page, the S2AP flag should be properly set as 
0x3, which indicates Read Write access perimission.

```cpp
#define S2TTE_AP_SHIFT                  6
#define S2TTE_AP_MASK                   (3UL << S2TTE_AP_SHIFT)
#define S2TTE_AP_RW                     (3UL << S2TTE_AP_SHIFT)
```

Note that RIPAS partially overlaps with the S2AP. Note that Desc[6] is RIPAS and
S2AP[0] at the same time. As RMM overwrites S2AP for valid descriptor as 
(3UL LSL 6), the RIPAS value of the valid page will be 0, which means EPMTY. 
The value of the RIPAS after the descriptor becomes valid is meaningless. 

The early conclusion of the RIPAS and HIPAS is this concept is only valid for 
invalid stage 2 descriptor. This concept is necessary to enforce specific page 
satisfying the condition of RIPAS and HIPAS can become valid descriptor, but 
after the change, these conditions have no meaning. Also, the RMM checks if the
descriptor is valid or not first if it needs to check HIPAS and RIPAS.


## RTT creation focusing on HIPAS and RIPAS
To understand how the RIPAS and HIPAS are utilized by the RMM, I will go through
several RMI relevant to updating RIPAS/HIPAS and descriptor type of the S2TTE.
The first function is generating new S2TTE entry, RMI_RTT_CREATE. 
```cpp
unsigned long smc_rtt_create(unsigned long rtt_addr, //host provided address that can be used as rtt table!
                             unsigned long rd_addr,
                             unsigned long map_addr, //IPA address of guest that should be mapped in RTT
                             unsigned long ulevel)
{       
	......
        rtt_walk_lock_unlock(g_table_root, sl, ipa_bits,
                                map_addr, level - 1L, &wi);
        if (wi.last_level != level - 1L) {
                INFO("UPPER level RTT should be generated\n");
                //check why it works with 3level at first :*
                ret = pack_return_code(RMI_ERROR_RTT, wi.last_level);
                goto out_unlock_llt;
        }
        
        parent_s2tt = granule_map(wi.g_llt, SLOT_RTT);
        parent_s2tte = s2tte_read(&parent_s2tt[wi.index]);
        s2tt = granule_map(g_tbl, SLOT_DELEGATED); //new s2tt that needs to be added under parent_s2tt
```

Let's assume that the we only have the root pointer of the stage 2 page table 
and want to initialize the subsequent descriptors. In my settings, start_level
which is the level of the root rtt table is 2. As we already have RTT page for 
the root level which was generated during the REC creation, we can reasonably 
assume that ulevel of the smc_rtt_create will be 3. 

To generate new S2TT descriptor at level N, we need its parent descriptor at 
level (N-1). Because we already have root page table at level 2, we need another 
descriptor at level 3. To abstract the process traversing the S2TT, RMM provides
API function rtt_walk_lock_unlock. See [[]] for details. Through the information
returned from this function, we can retrieve parent descriptor.

Since the root page was initialized as zero, because all delegated pages are 
initialized as zero, all next level descriptors that can be indexed from the 
root pages should be presented as invalid descriptor. Remind that condition
(Desc[1:0] == 0x0) means invalid descriptor (S2TTE_Lx_INVALID). Also, naturally, 
HIPAS and RIPAS of all root entries will be zero indicating unassigned and EMPTY.


```cpp
unsigned long smc_rtt_create(unsigned long rtt_addr, //host provided address that can be used as rtt table!
                             unsigned long rd_addr,
                             unsigned long map_addr, //IPA address of guest that should be mapped in RTT
                             unsigned long ulevel)
{
	......
        if (s2tte_is_unassigned(parent_s2tte)) {
                INFO("s2tte_is_unassigned\n");
                /*
                 * Note that if map_addr is an Unprotected IPA, the RIPAS field
                 * is guaranteed to be zero, in both parent and child s2ttes.
                 */
                enum ripas ripas = s2tte_get_ripas(parent_s2tte);

                s2tt_init_unassigned(s2tt, ripas);

                /*
                 * Increase the refcount of the parent, the granule was
                 * locked while table walking and hand-over-hand locking.
                 * Atomicity and acquire/release semantics not required because
                 * the table is accessed always locked.
                 */
                __granule_get(wi.g_llt);

/*                                              
 * Returns true if @s2tte has HIPAS=UNASSIGNED or HIPAS=INVALID_NS.
 */
bool s2tte_is_unassigned(unsigned long s2tte)
{        
        return s2tte_has_hipas(s2tte, S2TTE_INVALID_HIPAS_UNASSIGNED);
}        

static bool s2tte_has_hipas(unsigned long s2tte, unsigned long hipas)
{               
        unsigned long desc_type = s2tte & DESC_TYPE_MASK;
        unsigned long invalid_desc_hipas = s2tte & S2TTE_INVALID_HIPAS_MASK;
        
        if ((desc_type != S2TTE_Lx_INVALID) || (invalid_desc_hipas != hipas)) {
                return false;
        }
        return true;
}               
                        
```

Why this information HIPAS, RIPAS and descriptor types are important in creation
of new page descriptors? Because smc_rtt_create initialize new descriptor page
based on its parent descriptor information. You can easily follow the above code
and confirm that the parent_s2tte will be considered as unassigned descriptor. 


```cpp
/*
 * Populates @s2tt with s2ttes which have HIPAS=UNASSIGNED and RIPAS=@ripas.
 *              
 * The granule is populated before it is made a table,
 * hence, don't use s2tte_write for access.
 */
void s2tt_init_unassigned(unsigned long *s2tt, enum ripas ripas)
{        
        for (unsigned int i = 0U; i < S2TTES_PER_S2TT; i++) {
                s2tt[i] = s2tte_create_unassigned(ripas);
        }

        dsb(ish);
}

/*
 * Creates a value which can be OR'd with an s2tte to set RIPAS=@ripas.
 */
unsigned long s2tte_create_ripas(enum ripas ripas)
{       
        if (ripas == RIPAS_EMPTY) {
                return S2TTE_INVALID_RIPAS_EMPTY;
        }
        return S2TTE_INVALID_RIPAS_RAM;
}

/*
 * Creates an invalid s2tte with HIPAS=UNASSIGNED and RIPAS=@ripas.
 */
unsigned long s2tte_create_unassigned(enum ripas ripas)
{       
        return S2TTE_INVALID_HIPAS_UNASSIGNED | s2tte_create_ripas(ripas);
}
```

As the parent_s2tte's RIPAS is RIPAS_EMPTY, the level 3 RTT entries will be all
initialized as unassigned and EMPTY for HIPAS and RIPAS, respectively. This 
process will be repeated until it reaches the end-level. Because we initialized 
newly added s2tt page's entries as unassigned empty, the next level page table 
for RTT will be added in the same way. 

```cpp
unsigned long smc_rtt_create(unsigned long rtt_addr, //host provided address that can be used as rtt table!
                             unsigned long rd_addr,
                             unsigned long map_addr, //IPA address of guest that should be mapped in RTT
                             unsigned long ulevel)
{
	......
        parent_s2tte = s2tte_create_table(rtt_addr, level - 1L);
        s2tte_write(&parent_s2tt[wi.index], parent_s2tte);
```

Since the parent_s2tte now points the generated new table, its descriptor type
should be changed accordingly to S2TTE_TABLE from S2TTE_Lx_INVALID.

```cpp
#define S2TTE_L012_TABLE                0x3UL
#define S2TTE_TABLE     S2TTE_L012_TABLE
unsigned long s2tte_create_table(unsigned long pa, long level)
{        
        assert(level < RTT_PAGE_LEVEL);
        assert(GRANULE_ALIGNED(pa));
        
        return (pa | S2TTE_TABLE);
}          
```

Creating the table is not really changing anything related with the address or 
HIPAS and RIPAS, but it changes the s2tt descriptor type as S2TTE_TABLE. Note 
that RIPAS and HIPAS are effective because the table ignores the bits used by
them.


## HIPAS and RIPAS changed in the leaf entries
We've seen how the page descriptor is created through the RMI. If there were no
RMIs or RSI, during the S2TT creation, then RIPAS and HIPAS of all S2TTE entries
should be  EMPTY and UNASSIGNED. However, the RIPAS nad HIPAS should be RAM and 
ASSIGNED if one memory pages needs to be used for Trusted IPA. We will see which
RMIs will change those values 

### Change RIPAS from EMPTY to RAM before realm start
Before the realm has started, the RIPAS of invalid descriptor can be initialized
as RAM through RTT_INIT_RIPAS. As the RIPAS and HIPAS are necessary to make the 
mapping for memory page through the stage 2 descriptor, it is only meaningful 
to change HIPAS and RIPAS of a descriptor that can be utilized as BLOCK or PAGE
descriptor. 

```cpp
unsigned long smc_rtt_init_ripas(unsigned long rd_addr,
                                 unsigned long map_addr,
                                 unsigned long ulevel)
{       
	......
        /* Allowed only for HIPAS=UNASSIGNED */
        if (s2tte_is_table(s2tte, level) || !s2tte_is_unassigned(s2tte)) {
                ret = pack_return_code(RMI_ERROR_RTT, (unsigned int)level);
                goto out_unmap_llt;
        }

	s2tte |= s2tte_create_ripas(RIPAS_RAM);
                
        s2tte_write(&s2tt[wi.index], s2tte);
        s2tte = s2tte_read(&s2tt[wi.index]);

	ripas_granule_measure(rd, map_addr, level);

        ret = RMI_SUCCESS;

out_unmap_llt:
        buffer_unmap(s2tt);
out_unlock_llt:
        buffer_unmap(rd);
        granule_unlock(wi.g_llt);
        return ret;
}
```

Note that when the s2tte is table, it returns from the RMI with error message. 
Also, the s2tte should be unassigned. In summary, the descriptor type of S2TTE
should be S2TTE_Lx_INVALID and its RIPAS should be unassigned. 

```cpp
                
unsigned long smc_rtt_init_ripas(unsigned long rd_addr,
                                 unsigned long map_addr,
                                 unsigned long ulevel)
 {  
 	......
        s2tte |= s2tte_create_ripas(RIPAS_RAM);
        s2tte_write(&s2tt[wi.index], s2tte);
        s2tte = s2tte_read(&s2tt[wi.index]);
                
        ripas_granule_measure(rd, map_addr, level);

        ret = RMI_SUCCESS;
	......
}

unsigned long s2tte_create_ripas(enum ripas ripas)
{        
        if (ripas == RIPAS_EMPTY) {
                return S2TTE_INVALID_RIPAS_EMPTY;
        }
        return S2TTE_INVALID_RIPAS_RAM;
}   
```

If the conditions are met, then it sets RIPAS of the S2TTE as RAM and update
the RTT.


### UNASSIGNED page to ASSIGNED page (HIPAS change)
The most important role of the RMI_DATA_CREATE is generating a valid descriptor,
if all conditions met. As a side, it can change the HIPAS from UNASSIGNED to
ASSIGNED. 

```cpp
static unsigned long data_create(unsigned long data_addr,                       
                                 unsigned long rd_addr,                         
                                 unsigned long map_addr,                        
                                 struct granule *g_src,                         
                                 unsigned long flags)                           
{                                                      
	......
        s2tt = granule_map(wi.g_llt, SLOT_RTT);
        s2tte = s2tte_read(&s2tt[wi.index]);
        if (!s2tte_is_unassigned(s2tte)) {
                ret = pack_return_code(RMI_ERROR_RTT, RTT_PAGE_LEVEL);
                goto out_unmap_ll_table;
        }

        ripas = s2tte_get_ripas(s2tte);
	......

	new_data_state = GRANULE_STATE_DATA;

        s2tte = (ripas == RIPAS_EMPTY) ?
                s2tte_create_assigned_empty(data_addr, RTT_PAGE_LEVEL) :
                s2tte_create_valid(data_addr, RTT_PAGE_LEVEL);

        s2tte_write(&s2tt[wi.index], s2tte);
        s2tte = s2tte_read(&s2tt[wi.index]);
        INFO(" -> s2tte:%lx\n", s2tte);

        __granule_get(wi.g_llt);

        ret = RMI_SUCCESS;
```

To generate the mapping, first, HIPAS of S2TTE should be UNASSIGNE verified by 
s2tte_is_unassigned. As HIPAS of leaf page table descriptors were set as 
UNASSIGNED during S2TTE creation, this condition will meet. If the S2TTE's RIPAS
is UNASSIGNED, based on the RIPAS of S2TTE, it would generate the mapping or not. 
Therefore, when the RIPAS and HIPAS of the leaf S2TTE are RAM and UNASSIGNED, 
respectively, then s2tte_create_valid function returns valid leaf descriptor.
As the S2TTE becomes valid descriptor, the HIPAS and RIPAS doesn't have any 
meaning. See [[]].


```cpp
unsigned long s2tte_create_assigned_empty(unsigned long pa, long level)
{       
        assert(level >= RTT_MIN_BLOCK_LEVEL);
        assert(addr_is_level_aligned(pa, level)); 
        return (pa | S2TTE_INVALID_HIPAS_ASSIGNED | S2TTE_INVALID_RIPAS_EMPTY);
}  
```

However, if they are EMPTY and UNASSIGNED, it just changes the HIPAS of S2TTE as
ASSIGNED. Because it is not a valid mapping. Since it is not a valid mapping, if
realm tries to access the IPA supposed to be mapped by this descriptor, it will
raise the fault and exit to the RMM. If the fault happens due to ASSIGNED but 
EMPTY S2TTE, then RMM injects the fault to the realm. Seems that current 
implementation of REALM linux just make the kernel crash without handling it.











```cpp
static bool update_ripas(unsigned long *s2tte, unsigned long level,
                         enum ripas ripas)
{
        if (s2tte_is_table(*s2tte, level)) {
                return false;
        }

        if (s2tte_is_valid(*s2tte, level)) {
                if (ripas == RIPAS_EMPTY) {
                        unsigned long pa = s2tte_pa(*s2tte, level);
                        *s2tte = s2tte_create_assigned_empty(pa, level);
                }
                return true;
        }
        
        if (s2tte_is_unassigned(*s2tte) || s2tte_is_assigned(*s2tte, level)) {
                *s2tte |= s2tte_create_ripas(ripas);
                return true;
        }

        return false;
}
```
There are two main cases I will cover for the RIPAS update.


```cpp
unsigned long s2tte_create_assigned_empty(unsigned long pa, long level)
{               
        assert(level >= RTT_MIN_BLOCK_LEVEL);
        assert(addr_is_level_aligned(pa, level));
        return (pa | S2TTE_INVALID_HIPAS_ASSIGNED | S2TTE_INVALID_RIPAS_EMPTY);
}  
```

When it needs to change RIPAS from the RAM to EMPTY, it should reset all other 
attributes together with the RIPAS, so it generate new S2TTE with the HPA. As 
shown in the code, it doesn't set any attributes for the assigned and empty 
page. What about the opposite case? Before thinking about this, we have to know
that smc_rtt_set_ripas is only allowed to be invoked when the realm explicitly
requested the changes. Therefore, I think there would not be the case where 
the realm accesses the assigned but empty page and ask ripas change to the host.
Not sure, I need to check!





