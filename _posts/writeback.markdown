# writeback
The wrietback packet is generated only when the cache block is evicted 
from the cache. It cannot be generated by the processor, 
but part of the cache. 
Therefore, the lowest cache should not see the writeback packet.

```cpp
 899 PacketPtr
 900 Cache::evictBlock(CacheBlk *blk)
 901 {
 902     PacketPtr pkt = (blk->isSet(CacheBlk::DirtyBit) || writebackClean) ?
 903         writebackBlk(blk) : cleanEvictBlk(blk);
 904 
 905     invalidateBlock(blk);
 906 
 907     return pkt;
 908 }
```

The only location where the writeback packet is generated 
in the GEM5 is the evictBlock function. 
Based on the status of the evicted cache block, 
two different packets can be generated and 
forwarded to the next level cache. 
If the evicted block is set as dirty,
which means the cached block has been modified while 
it stays in the cache, 
it should be a writeback packet to notify 
that the cache should be written back to the memory at the end of the operation. 

```cpp
 668     /** 
 669      * Determine if clean lines should be written back or not. In
 670      * cases where a downstream cache is mostly inclusive we likely
 671      * want it to act as a victim cache also for lines that have not
 672      * been modified. Hence, we cannot simply drop the line (or send a
 673      * clean evict), but rather need to send the actual data.
 674      */
 675     const bool writebackClean;
```
Also, when the writebackClean flag is set,
it should also generate the writeback packet
even though the cache block is not dirty.
Let's take a look at the writeback packet first
and then move to the cleanEvict packet. 

## writeback packet
```cpp
1615 PacketPtr
1616 BaseCache::writebackBlk(CacheBlk *blk)
1617 {
1618     chatty_assert(!isReadOnly || writebackClean,
1619                   "Writeback from read-only cache");
1620     assert(blk && blk->isValid() &&
1621         (blk->isSet(CacheBlk::DirtyBit) || writebackClean));
1622 
1623     stats.writebacks[Request::wbRequestorId]++;
1624 
1625     RequestPtr req = std::make_shared<Request>(
1626         regenerateBlkAddr(blk), blkSize, 0, Request::wbRequestorId);
1627 
1628     if (blk->isSecure())
1629         req->setFlags(Request::SECURE);
1630 
1631     req->taskId(blk->getTaskId());
1632 
1633     PacketPtr pkt =
1634         new Packet(req, blk->isSet(CacheBlk::DirtyBit) ?
1635                    MemCmd::WritebackDirty : MemCmd::WritebackClean);
1636 
1637     DPRINTF(Cache, "Create Writeback %s writable: %d, dirty: %d\n",
1638         pkt->print(), blk->isSet(CacheBlk::WritableBit),
1639         blk->isSet(CacheBlk::DirtyBit));
1640 
1641     if (blk->isSet(CacheBlk::WritableBit)) {
1642         // not asserting shared means we pass the block in modified
1643         // state, mark our own block non-writeable
1644         blk->clearCoherenceBits(CacheBlk::WritableBit);
1645     } else {
1646         // we are in the Owned state, tell the receiver
1647         pkt->setHasSharers();
1648     }
1649 
1650     // make sure the block is not marked dirty
1651     blk->clearCoherenceBits(CacheBlk::DirtyBit);
1652 
1653     pkt->allocate();
1654     pkt->setDataFromBlock(blk->data, blkSize);
1655 
1656     // When a block is compressed, it must first be decompressed before being
1657     // sent for writeback.
1658     if (compressor) {
1659         pkt->payloadDelay = compressor->getDecompressionLatency(blk);
1660     }
1661 
1662     return pkt;
1663 }
```

It first generates request based on the cache block address. 
Also, it generates actual writeback packet.
It sets its command as either WritebackClean or WritebackDirty 
based on the DirtyBit of the evicted cache block. 
If the evicted block sets WritableBit, 
it means that the evicted block is in (M)odified or (E)xclusive state.
However, note that it is writebackBlk function which 
writebacks the dirty cache block. 
Therefore, it should be modified state not the exclusive state
cause exclusive state means that it exclusively owns the cache block but 
globally same data. 
\XXX{Why it clears Writablebit when the evicted block has WritableBit?}

Also, when it doesn't set the WritableBit, 
it means that the block is dirty but not writable. 
The owned state is the only case satisfying those conditions. 
In that case it set the current block to indicate that 
there are more cache entries in somewhere in the cache hierarchies 
sharing the entry mapped to current request address. 
Also, because the packet has no space for storing data by default,
it invokes allocate function to allocate space for new data.
Ans setDataFromBlock copies the data from the block to the packet. 



## cleanEvict packet 
```cpp
 910 PacketPtr
 911 Cache::cleanEvictBlk(CacheBlk *blk)
 912 {
 913     assert(!writebackClean);
 914     assert(blk && blk->isValid() && !blk->isSet(CacheBlk::DirtyBit));
 915 
 916     // Creating a zero sized write, a message to the snoop filter
 917     RequestPtr req = std::make_shared<Request>(
 918         regenerateBlkAddr(blk), blkSize, 0, Request::wbRequestorId);
 919 
 920     if (blk->isSecure())
 921         req->setFlags(Request::SECURE);
 922 
 923     req->taskId(blk->getTaskId());
 924 
 925     PacketPtr pkt = new Packet(req, MemCmd::CleanEvict);
 926     pkt->allocate();
 927     DPRINTF(Cache, "Create CleanEvict %s\n", pkt->print());
 928 
 929     return pkt;
 930 }

```

## invalidateBlock
```cpp
1586 void
1587 BaseCache::invalidateBlock(CacheBlk *blk)
1588 {
1589     // If block is still marked as prefetched, then it hasn't been used
1590     if (blk->wasPrefetched()) {
1591         prefetcher->prefetchUnused();
1592     }
1593 
1594     // Notify that the data contents for this address are no longer present
1595     updateBlockData(blk, nullptr, blk->isValid());
1596 
1597     // If handling a block present in the Tags, let it do its invalidation
1598     // process, which will update stats and invalidate the block itself
1599     if (blk != tempBlock) {
1600         tags->invalidate(blk);
1601     } else {
1602         tempBlock->invalidate();
1603     }
1604 }
```

*gem5/src/mem/cache/tags/base.cc*
```cpp
249     /**
250      * This function updates the tags when a block is invalidated
251      *
252      * @param blk A valid block to invalidate.
253      */
254     virtual void invalidate(CacheBlk *blk)
255     {
256         assert(blk);
257         assert(blk->isValid());
258
259         stats.occupancies[blk->getSrcRequestorId()]--;
260         stats.totalRefs += blk->getRefCount();
261         stats.sampledRefs++;
262
263         blk->invalidate();
264     }
```

*gem5/src/mem/cache_blk.hh*
```cpp
 70 class CacheBlk : public TaggedEntry
 71 {
 72   public:
......
197     /**
198      * Invalidate the block and clear all state.
199      */
200     virtual void invalidate() override
201     {
202         TaggedEntry::invalidate();
203
204         clearPrefetched();
205         clearCoherenceBits(AllBits);
206
207         setTaskId(context_switch_task_id::Unknown);
208         setWhenReady(MaxTick);
209         setRefCount(0);
210         setSrcRequestorId(Request::invldRequestorId);
211         lockList.clear();
212     }
```


*gem5/src/mem/tags/tagged_entry*
```cpp
 46 class TaggedEntry : public ReplaceableEntry
 47 {
......
102     /** Invalidate the block. Its contents are no longer valid. */
103     virtual void invalidate()
104     {
105         _valid = false;
106         setTag(MaxAddr);
107         clearSecure();
108     }
```

