<!doctype html>














<!-- `site.alt_lang` can specify a language different from the UI -->
<html lang="en" data-mode="light">
  <!-- The Head -->

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta
    name="viewport"
    content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover"
  >

  

  

  
    <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v4.3.2" />
<meta property="og:title" content="O3 Cpu Fetch" />
<meta property="og:locale" content="en" />
<meta name="description" content="Fetch 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 895 template &lt;class Impl&gt; 896 void 897 DefaultFetch&lt;Impl&gt;::tick() 898 { 899 list&lt;ThreadID&gt;::iterator threads = activeThreads-&gt;begin(); 900 list&lt;ThreadID&gt;::iterator end = activeThreads-&gt;end(); 901 bool status_change = false; 902 903 wroteToTimeBuffer = false; 904 905 for (ThreadID i = 0; i &lt; numThreads; ++i) { 906 issuePipelinedIfetch[i] = false; 907 } 908 909 while (threads != end) { 910 ThreadID tid = *threads++; 911 912 // Check the signals for each thread to determine the proper status 913 // for each thread. 914 bool updated_status = checkSignalsAndUpdate(tid); 915 status_change = status_change || updated_status; 916 } 917 918 DPRINTF(Fetch, &quot;Running stage.\n&quot;); 919 920 if (FullSystem) { 921 if (fromCommit-&gt;commitInfo[0].interruptPending) { 922 interruptPending = true; 923 } 924 925 if (fromCommit-&gt;commitInfo[0].clearInterrupt) { 926 interruptPending = false; 927 } 928 } 929 930 for (threadFetched = 0; threadFetched &lt; numFetchingThreads; 931 threadFetched++) { 932 // Fetch each of the actively fetching threads. 933 fetch(status_change); 934 } 935 936 // Record number of instructions fetched this cycle for distribution. 937 fetchNisnDist.sample(numInst); 938 939 if (status_change) { 940 // Change the fetch stage status if there was a status change. 941 _status = updateFetchStatus(); 942 } 943 944 // Issue the next I-cache request if possible. 945 for (ThreadID i = 0; i &lt; numThreads; ++i) { 946 if (issuePipelinedIfetch[i]) { 947 pipelineIcacheAccesses(i); 948 } 949 } 950 951 // Send instructions enqueued into the fetch queue to decode. 952 // Limit rate by fetchWidth. Stall if decode is stalled. 953 unsigned insts_to_decode = 0; 954 unsigned available_insts = 0; 955 956 for (auto tid : *activeThreads) { 957 if (!stalls[tid].decode) { 958 available_insts += fetchQueue[tid].size(); 959 } 960 } 961 962 // Pick a random thread to start trying to grab instructions from 963 auto tid_itr = activeThreads-&gt;begin(); 964 std::advance(tid_itr, random_mt.random&lt;uint8_t&gt;(0, activeThreads-&gt;size() - 1)); 965 966 while (available_insts != 0 &amp;&amp; insts_to_decode &lt; decodeWidth) { 967 ThreadID tid = *tid_itr; 968 if (!stalls[tid].decode &amp;&amp; !fetchQueue[tid].empty()) { 969 const auto&amp; inst = fetchQueue[tid].front(); 970 toDecode-&gt;insts[toDecode-&gt;size++] = inst; 971 DPRINTF(Fetch, &quot;[tid:%i] [sn:%llu] Sending instruction to decode &quot; 972 &quot;from fetch queue. Fetch queue size: %i.\n&quot;, 973 tid, inst-&gt;seqNum, fetchQueue[tid].size()); 974 975 wroteToTimeBuffer = true; 976 fetchQueue[tid].pop_front(); 977 insts_to_decode++; 978 available_insts--; 979 } 980 981 tid_itr++; 982 // Wrap around if at end of active threads list 983 if (tid_itr == activeThreads-&gt;end()) 984 tid_itr = activeThreads-&gt;begin(); 985 } 986 987 // If there was activity this cycle, inform the CPU of it. 988 if (wroteToTimeBuffer) { 989 DPRINTF(Activity, &quot;Activity this cycle.\n&quot;); 990 cpu-&gt;activityThisCycle(); 991 } 992 993 // Reset the number of the instruction we&#39;ve fetched. 994 numInst = 0; 995 }" />
<meta property="og:description" content="Fetch 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 895 template &lt;class Impl&gt; 896 void 897 DefaultFetch&lt;Impl&gt;::tick() 898 { 899 list&lt;ThreadID&gt;::iterator threads = activeThreads-&gt;begin(); 900 list&lt;ThreadID&gt;::iterator end = activeThreads-&gt;end(); 901 bool status_change = false; 902 903 wroteToTimeBuffer = false; 904 905 for (ThreadID i = 0; i &lt; numThreads; ++i) { 906 issuePipelinedIfetch[i] = false; 907 } 908 909 while (threads != end) { 910 ThreadID tid = *threads++; 911 912 // Check the signals for each thread to determine the proper status 913 // for each thread. 914 bool updated_status = checkSignalsAndUpdate(tid); 915 status_change = status_change || updated_status; 916 } 917 918 DPRINTF(Fetch, &quot;Running stage.\n&quot;); 919 920 if (FullSystem) { 921 if (fromCommit-&gt;commitInfo[0].interruptPending) { 922 interruptPending = true; 923 } 924 925 if (fromCommit-&gt;commitInfo[0].clearInterrupt) { 926 interruptPending = false; 927 } 928 } 929 930 for (threadFetched = 0; threadFetched &lt; numFetchingThreads; 931 threadFetched++) { 932 // Fetch each of the actively fetching threads. 933 fetch(status_change); 934 } 935 936 // Record number of instructions fetched this cycle for distribution. 937 fetchNisnDist.sample(numInst); 938 939 if (status_change) { 940 // Change the fetch stage status if there was a status change. 941 _status = updateFetchStatus(); 942 } 943 944 // Issue the next I-cache request if possible. 945 for (ThreadID i = 0; i &lt; numThreads; ++i) { 946 if (issuePipelinedIfetch[i]) { 947 pipelineIcacheAccesses(i); 948 } 949 } 950 951 // Send instructions enqueued into the fetch queue to decode. 952 // Limit rate by fetchWidth. Stall if decode is stalled. 953 unsigned insts_to_decode = 0; 954 unsigned available_insts = 0; 955 956 for (auto tid : *activeThreads) { 957 if (!stalls[tid].decode) { 958 available_insts += fetchQueue[tid].size(); 959 } 960 } 961 962 // Pick a random thread to start trying to grab instructions from 963 auto tid_itr = activeThreads-&gt;begin(); 964 std::advance(tid_itr, random_mt.random&lt;uint8_t&gt;(0, activeThreads-&gt;size() - 1)); 965 966 while (available_insts != 0 &amp;&amp; insts_to_decode &lt; decodeWidth) { 967 ThreadID tid = *tid_itr; 968 if (!stalls[tid].decode &amp;&amp; !fetchQueue[tid].empty()) { 969 const auto&amp; inst = fetchQueue[tid].front(); 970 toDecode-&gt;insts[toDecode-&gt;size++] = inst; 971 DPRINTF(Fetch, &quot;[tid:%i] [sn:%llu] Sending instruction to decode &quot; 972 &quot;from fetch queue. Fetch queue size: %i.\n&quot;, 973 tid, inst-&gt;seqNum, fetchQueue[tid].size()); 974 975 wroteToTimeBuffer = true; 976 fetchQueue[tid].pop_front(); 977 insts_to_decode++; 978 available_insts--; 979 } 980 981 tid_itr++; 982 // Wrap around if at end of active threads list 983 if (tid_itr == activeThreads-&gt;end()) 984 tid_itr = activeThreads-&gt;begin(); 985 } 986 987 // If there was activity this cycle, inform the CPU of it. 988 if (wroteToTimeBuffer) { 989 DPRINTF(Activity, &quot;Activity this cycle.\n&quot;); 990 cpu-&gt;activityThisCycle(); 991 } 992 993 // Reset the number of the instruction we&#39;ve fetched. 994 numInst = 0; 995 }" />
<link rel="canonical" href="https://ruach.github.io/posts/O3-CPU-Fetch/" />
<meta property="og:url" content="https://ruach.github.io/posts/O3-CPU-Fetch/" />
<meta property="og:site_name" content="Ruach" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-05-27T00:00:00-04:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="O3 Cpu Fetch" />
<meta name="twitter:site" content="@ruach_lee" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2021-05-27T00:00:00-04:00","datePublished":"2021-05-27T00:00:00-04:00","description":"Fetch 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 895 template &lt;class Impl&gt; 896 void 897 DefaultFetch&lt;Impl&gt;::tick() 898 { 899 list&lt;ThreadID&gt;::iterator threads = activeThreads-&gt;begin(); 900 list&lt;ThreadID&gt;::iterator end = activeThreads-&gt;end(); 901 bool status_change = false; 902 903 wroteToTimeBuffer = false; 904 905 for (ThreadID i = 0; i &lt; numThreads; ++i) { 906 issuePipelinedIfetch[i] = false; 907 } 908 909 while (threads != end) { 910 ThreadID tid = *threads++; 911 912 // Check the signals for each thread to determine the proper status 913 // for each thread. 914 bool updated_status = checkSignalsAndUpdate(tid); 915 status_change = status_change || updated_status; 916 } 917 918 DPRINTF(Fetch, &quot;Running stage.\\n&quot;); 919 920 if (FullSystem) { 921 if (fromCommit-&gt;commitInfo[0].interruptPending) { 922 interruptPending = true; 923 } 924 925 if (fromCommit-&gt;commitInfo[0].clearInterrupt) { 926 interruptPending = false; 927 } 928 } 929 930 for (threadFetched = 0; threadFetched &lt; numFetchingThreads; 931 threadFetched++) { 932 // Fetch each of the actively fetching threads. 933 fetch(status_change); 934 } 935 936 // Record number of instructions fetched this cycle for distribution. 937 fetchNisnDist.sample(numInst); 938 939 if (status_change) { 940 // Change the fetch stage status if there was a status change. 941 _status = updateFetchStatus(); 942 } 943 944 // Issue the next I-cache request if possible. 945 for (ThreadID i = 0; i &lt; numThreads; ++i) { 946 if (issuePipelinedIfetch[i]) { 947 pipelineIcacheAccesses(i); 948 } 949 } 950 951 // Send instructions enqueued into the fetch queue to decode. 952 // Limit rate by fetchWidth. Stall if decode is stalled. 953 unsigned insts_to_decode = 0; 954 unsigned available_insts = 0; 955 956 for (auto tid : *activeThreads) { 957 if (!stalls[tid].decode) { 958 available_insts += fetchQueue[tid].size(); 959 } 960 } 961 962 // Pick a random thread to start trying to grab instructions from 963 auto tid_itr = activeThreads-&gt;begin(); 964 std::advance(tid_itr, random_mt.random&lt;uint8_t&gt;(0, activeThreads-&gt;size() - 1)); 965 966 while (available_insts != 0 &amp;&amp; insts_to_decode &lt; decodeWidth) { 967 ThreadID tid = *tid_itr; 968 if (!stalls[tid].decode &amp;&amp; !fetchQueue[tid].empty()) { 969 const auto&amp; inst = fetchQueue[tid].front(); 970 toDecode-&gt;insts[toDecode-&gt;size++] = inst; 971 DPRINTF(Fetch, &quot;[tid:%i] [sn:%llu] Sending instruction to decode &quot; 972 &quot;from fetch queue. Fetch queue size: %i.\\n&quot;, 973 tid, inst-&gt;seqNum, fetchQueue[tid].size()); 974 975 wroteToTimeBuffer = true; 976 fetchQueue[tid].pop_front(); 977 insts_to_decode++; 978 available_insts--; 979 } 980 981 tid_itr++; 982 // Wrap around if at end of active threads list 983 if (tid_itr == activeThreads-&gt;end()) 984 tid_itr = activeThreads-&gt;begin(); 985 } 986 987 // If there was activity this cycle, inform the CPU of it. 988 if (wroteToTimeBuffer) { 989 DPRINTF(Activity, &quot;Activity this cycle.\\n&quot;); 990 cpu-&gt;activityThisCycle(); 991 } 992 993 // Reset the number of the instruction we&#39;ve fetched. 994 numInst = 0; 995 }","headline":"O3 Cpu Fetch","mainEntityOfPage":{"@type":"WebPage","@id":"https://ruach.github.io/posts/O3-CPU-Fetch/"},"url":"https://ruach.github.io/posts/O3-CPU-Fetch/"}</script>
<!-- End Jekyll SEO tag -->

  

  <title>O3 Cpu Fetch | Ruach
  </title>

  <!--
  The Favicons for Web, Android, Microsoft, and iOS (iPhone and iPad) Apps
  Generated by: https://realfavicongenerator.net/
-->



<link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png">
<link rel="manifest" href="/assets/img/favicons/site.webmanifest">
<link rel="shortcut icon" href="/assets/img/favicons/favicon.ico">
<meta name="apple-mobile-web-app-title" content="Ruach">
<meta name="application-name" content="Ruach">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml">
<meta name="theme-color" content="#ffffff">


  
    
      <link rel="preconnect" href="https://fonts.googleapis.com" >
      <link rel="dns-prefetch" href="https://fonts.googleapis.com" >
    
      <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
      <link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin>
    
      <link rel="preconnect" href="https://fonts.googleapis.com" >
      <link rel="dns-prefetch" href="https://fonts.googleapis.com" >
    
      <link rel="preconnect" href="https://cdn.jsdelivr.net" >
      <link rel="dns-prefetch" href="https://cdn.jsdelivr.net" >
    

    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap">
  

  <!-- GA -->
  

  <!-- Bootstrap -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css">

  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.2/css/all.min.css">

  <link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css">

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.21.2/dist/tocbot.min.css">
  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css">
  

  
    <!-- Manific Popup -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css">
  

  <!-- JavaScript -->

  

  <!-- A placeholder to allow defining custom metadata -->

</head>


  <body>
    <!-- The Side Bar -->

<aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end">
  <header class="profile-wrapper">
    <a href="/" id="avatar" class="rounded-circle">
      
        
        <img src="/assets/img/jaehyuk.png" width="112" height="112" alt="avatar" onerror="this.style.display='none'">
      
    </a>

    <h1 class="site-title">
      <a href="/">Ruach</a>
    </h1>
    <p class="site-subtitle fst-italic mb-0">Security Researcher at Gatech</p>
  </header>
  <!-- .profile-wrapper -->

  <nav class="flex-column flex-grow-1 w-100 ps-0">
    <ul class="nav">
      <!-- home -->
      <li class="nav-item">
        <a href="/" class="nav-link">
          <i class="fa-fw fas fa-home"></i>
          <span>HOME</span>
        </a>
      </li>
      <!-- the real tabs -->
      
        <li class="nav-item">
          <a href="/categories/" class="nav-link">
            <i class="fa-fw fas fa-stream"></i>
            

            <span>CATEGORIES</span>
          </a>
        </li>
        <!-- .nav-item -->
      
        <li class="nav-item">
          <a href="/tags/" class="nav-link">
            <i class="fa-fw fas fa-tags"></i>
            

            <span>TAGS</span>
          </a>
        </li>
        <!-- .nav-item -->
      
        <li class="nav-item">
          <a href="/archives/" class="nav-link">
            <i class="fa-fw fas fa-archive"></i>
            

            <span>ARCHIVES</span>
          </a>
        </li>
        <!-- .nav-item -->
      
        <li class="nav-item">
          <a href="/about/" class="nav-link">
            <i class="fa-fw fas fa-info-circle"></i>
            

            <span>ABOUT</span>
          </a>
        </li>
        <!-- .nav-item -->
      
    </ul>
  </nav>

  <div class="sidebar-bottom d-flex flex-wrap  align-items-center w-100">
    

    
      

      
        <a
          href="javascript:location.href = 'mailto:' + ['jaehyuk','gatech.edu'].join('@')"
          aria-label="email"
          

          

          

          
        >
          <i class="fas fa-envelope"></i>
        </a>
      
    
      

      
        <a
          href="https://www.linkedin.com/in/jaehyuk-lee-29b33b121/"
          aria-label="linkedin"
          

          
            target="_blank"
            
          

          

          
            rel="noopener noreferrer"
          
        >
          <i class="fab fa-linkedin"></i>
        </a>
      
    
      

      
        <a
          href="https://github.com/Ruach"
          aria-label="github"
          

          
            target="_blank"
            
          

          

          
            rel="noopener noreferrer"
          
        >
          <i class="fab fa-github"></i>
        </a>
      
    
      

      
        <a
          href="https://stackoverflow.com/users/4460514/ruach?tab=profile"
          aria-label="stack-overflow"
          

          
            target="_blank"
            
          

          

          
            rel="noopener noreferrer"
          
        >
          <i class="fab fa-stack-overflow"></i>
        </a>
      
    
  </div>
  <!-- .sidebar-bottom -->
</aside>
<!-- #sidebar -->


    <div id="main-wrapper" class="d-flex justify-content-center">
      <div class="container d-flex flex-column px-xxl-5">
        <!-- The Top Bar -->

<header id="topbar-wrapper" aria-label="Top Bar">
  <div
    id="topbar"
    class="d-flex align-items-center justify-content-between px-lg-3 h-100"
  >
    <nav id="breadcrumb" aria-label="Breadcrumb">
      

      
        
          
            <span>
              <a href="/">
                Home
              </a>
            </span>

          
        
          
        
          
            
              <span>O3 Cpu Fetch</span>
            

          
        
      
    </nav>
    <!-- endof #breadcrumb -->

    <button type="button" id="sidebar-trigger" class="btn btn-link">
      <i class="fas fa-bars fa-fw"></i>
    </button>

    <div id="topbar-title">
      Post
    </div>

    <button type="button" id="search-trigger" class="btn btn-link">
      <i class="fas fa-search fa-fw"></i>
    </button>

    <search class="align-items-center ms-3 ms-lg-0">
      <i class="fas fa-search fa-fw"></i>
      <input
        class="form-control"
        id="search-input"
        type="search"
        aria-label="search"
        autocomplete="off"
        placeholder="Search..."
      >
    </search>
    <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button>
  </div>
</header>


        <div class="row flex-grow-1">
          <main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4">
            
              <!-- Refactor the HTML structure -->



<!--
  In order to allow a wide table to scroll horizontally,
  we suround the markdown table with `<div class="table-wrapper">` and `</div>`
-->



<!--
  Fixed kramdown code highlight rendering:
  https://github.com/penibelst/jekyll-compress-html/issues/101
  https://github.com/penibelst/jekyll-compress-html/issues/71#issuecomment-188144901
-->



<!-- Change the icon of checkbox -->



<!-- Handle images -->





<!-- Add header for code snippets -->



<!-- Create heading anchors -->





  
  

  
    
    

    
      
        
        
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    

    
  

  
  

  
    
    

    
      
        
        
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    

    
  

  
  

  

  
  

  




<!-- return -->




<article class="px-1">
  <header>
    <h1 data-toc-skip>O3 Cpu Fetch</h1>

    <div class="post-meta text-muted">
      <!-- published date -->
      <span>
        Posted
        <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->




<time
  
  data-ts="1622088000"
  data-df="ll"
  
    data-bs-toggle="tooltip" data-bs-placement="bottom"
  
>
  May 27, 2021
</time>

      </span>

      <!-- lastmod date -->
      

      

      <div class="d-flex justify-content-between">
        <!-- author(s) -->
        <span>
          

          By

          <em>
            
              <a href="https://ruach.github.io">Jaehyuk Lee</a>
            
          </em>
        </span>

        <!-- read time -->
        <!-- Calculate the post's reading time, and display the word count in tooltip -->



<!-- words per minute -->










<!-- return element -->
<span
  class="readtime"
  data-bs-toggle="tooltip"
  data-bs-placement="bottom"
  title="12019 words"
>
  <em>66 min</em> read</span>

      </div>
      <!-- .d-flex -->
    </div>
    <!-- .post-meta -->
  </header>

  <div class="content">
    <h3 id="fetch"><span class="me-2">Fetch</span><a href="#fetch" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
</pre></td><td class="rouge-code"><pre> <span class="mi">895</span> <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Impl</span><span class="p">&gt;</span>
 <span class="mi">896</span> <span class="kt">void</span>
 <span class="mi">897</span> <span class="n">DefaultFetch</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;::</span><span class="n">tick</span><span class="p">()</span>
 <span class="mi">898</span> <span class="p">{</span>
 <span class="mi">899</span>     <span class="n">list</span><span class="o">&lt;</span><span class="n">ThreadID</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">threads</span> <span class="o">=</span> <span class="n">activeThreads</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">();</span>
 <span class="mi">900</span>     <span class="n">list</span><span class="o">&lt;</span><span class="n">ThreadID</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">end</span> <span class="o">=</span> <span class="n">activeThreads</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">();</span>
 <span class="mi">901</span>     <span class="kt">bool</span> <span class="n">status_change</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
 <span class="mi">902</span> 
 <span class="mi">903</span>     <span class="n">wroteToTimeBuffer</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
 <span class="mi">904</span> 
 <span class="mi">905</span>     <span class="k">for</span> <span class="p">(</span><span class="n">ThreadID</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numThreads</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">906</span>         <span class="n">issuePipelinedIfetch</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
 <span class="mi">907</span>     <span class="p">}</span>
 <span class="mi">908</span> 
 <span class="mi">909</span>     <span class="nf">while</span> <span class="p">(</span><span class="n">threads</span> <span class="o">!=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">910</span>         <span class="n">ThreadID</span> <span class="n">tid</span> <span class="o">=</span> <span class="o">*</span><span class="n">threads</span><span class="o">++</span><span class="p">;</span>
 <span class="mi">911</span> 
 <span class="mi">912</span>         <span class="c1">// Check the signals for each thread to determine the proper status</span>
 <span class="mi">913</span>         <span class="c1">// for each thread.</span>
 <span class="mi">914</span>         <span class="kt">bool</span> <span class="n">updated_status</span> <span class="o">=</span> <span class="n">checkSignalsAndUpdate</span><span class="p">(</span><span class="n">tid</span><span class="p">);</span>
 <span class="mi">915</span>         <span class="n">status_change</span> <span class="o">=</span>  <span class="n">status_change</span> <span class="o">||</span> <span class="n">updated_status</span><span class="p">;</span>
 <span class="mi">916</span>     <span class="p">}</span>
 <span class="mi">917</span> 
 <span class="mi">918</span>     <span class="nf">DPRINTF</span><span class="p">(</span><span class="n">Fetch</span><span class="p">,</span> <span class="s">"Running stage.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
 <span class="mi">919</span> 
 <span class="mi">920</span>     <span class="nf">if</span> <span class="p">(</span><span class="n">FullSystem</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">921</span>         <span class="k">if</span> <span class="p">(</span><span class="n">fromCommit</span><span class="o">-&gt;</span><span class="n">commitInfo</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">interruptPending</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">922</span>             <span class="n">interruptPending</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
 <span class="mi">923</span>         <span class="p">}</span>
 <span class="mi">924</span> 
 <span class="mi">925</span>         <span class="nf">if</span> <span class="p">(</span><span class="n">fromCommit</span><span class="o">-&gt;</span><span class="n">commitInfo</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">clearInterrupt</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">926</span>             <span class="n">interruptPending</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
 <span class="mi">927</span>         <span class="p">}</span>
 <span class="mi">928</span>     <span class="p">}</span>
 <span class="mi">929</span> 
 <span class="mi">930</span>     <span class="k">for</span> <span class="p">(</span><span class="n">threadFetched</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">threadFetched</span> <span class="o">&lt;</span> <span class="n">numFetchingThreads</span><span class="p">;</span>
 <span class="mi">931</span>          <span class="n">threadFetched</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">932</span>         <span class="c1">// Fetch each of the actively fetching threads.</span>
 <span class="mi">933</span>         <span class="n">fetch</span><span class="p">(</span><span class="n">status_change</span><span class="p">);</span>
 <span class="mi">934</span>     <span class="p">}</span>
 <span class="mi">935</span> 
 <span class="mi">936</span>     <span class="c1">// Record number of instructions fetched this cycle for distribution.</span>
 <span class="mi">937</span>     <span class="n">fetchNisnDist</span><span class="p">.</span><span class="n">sample</span><span class="p">(</span><span class="n">numInst</span><span class="p">);</span>
 <span class="mi">938</span> 
 <span class="mi">939</span>     <span class="nf">if</span> <span class="p">(</span><span class="n">status_change</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">940</span>         <span class="c1">// Change the fetch stage status if there was a status change.</span>
 <span class="mi">941</span>         <span class="n">_status</span> <span class="o">=</span> <span class="n">updateFetchStatus</span><span class="p">();</span>
 <span class="mi">942</span>     <span class="p">}</span>
 <span class="mi">943</span> 
 <span class="mi">944</span>     <span class="c1">// Issue the next I-cache request if possible.</span>
 <span class="mi">945</span>     <span class="k">for</span> <span class="p">(</span><span class="n">ThreadID</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numThreads</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">946</span>         <span class="k">if</span> <span class="p">(</span><span class="n">issuePipelinedIfetch</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
 <span class="mi">947</span>             <span class="n">pipelineIcacheAccesses</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
 <span class="mi">948</span>         <span class="p">}</span>
 <span class="mi">949</span>     <span class="p">}</span>
 <span class="mi">950</span> 
 <span class="mi">951</span>     <span class="c1">// Send instructions enqueued into the fetch queue to decode.</span>
 <span class="mi">952</span>     <span class="c1">// Limit rate by fetchWidth.  Stall if decode is stalled.</span>
 <span class="mi">953</span>     <span class="kt">unsigned</span> <span class="n">insts_to_decode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="mi">954</span>     <span class="kt">unsigned</span> <span class="n">available_insts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="mi">955</span> 
 <span class="mi">956</span>     <span class="nf">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">tid</span> <span class="o">:</span> <span class="o">*</span><span class="n">activeThreads</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">957</span>         <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stalls</span><span class="p">[</span><span class="n">tid</span><span class="p">].</span><span class="n">decode</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">958</span>             <span class="n">available_insts</span> <span class="o">+=</span> <span class="n">fetchQueue</span><span class="p">[</span><span class="n">tid</span><span class="p">].</span><span class="n">size</span><span class="p">();</span>
 <span class="mi">959</span>         <span class="p">}</span>
 <span class="mi">960</span>     <span class="p">}</span>
 <span class="mi">961</span> 
 <span class="mi">962</span>     <span class="c1">// Pick a random thread to start trying to grab instructions from</span>
 <span class="mi">963</span>     <span class="k">auto</span> <span class="n">tid_itr</span> <span class="o">=</span> <span class="n">activeThreads</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">();</span>
 <span class="mi">964</span>     <span class="n">std</span><span class="o">::</span><span class="n">advance</span><span class="p">(</span><span class="n">tid_itr</span><span class="p">,</span> <span class="n">random_mt</span><span class="p">.</span><span class="n">random</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">activeThreads</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
 <span class="mi">965</span> 
 <span class="mi">966</span>     <span class="nf">while</span> <span class="p">(</span><span class="n">available_insts</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">insts_to_decode</span> <span class="o">&lt;</span> <span class="n">decodeWidth</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">967</span>         <span class="n">ThreadID</span> <span class="n">tid</span> <span class="o">=</span> <span class="o">*</span><span class="n">tid_itr</span><span class="p">;</span>
 <span class="mi">968</span>         <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stalls</span><span class="p">[</span><span class="n">tid</span><span class="p">].</span><span class="n">decode</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">fetchQueue</span><span class="p">[</span><span class="n">tid</span><span class="p">].</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
 <span class="mi">969</span>             <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">inst</span> <span class="o">=</span> <span class="n">fetchQueue</span><span class="p">[</span><span class="n">tid</span><span class="p">].</span><span class="n">front</span><span class="p">();</span>
 <span class="mi">970</span>             <span class="n">toDecode</span><span class="o">-&gt;</span><span class="n">insts</span><span class="p">[</span><span class="n">toDecode</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">inst</span><span class="p">;</span>
 <span class="mi">971</span>             <span class="n">DPRINTF</span><span class="p">(</span><span class="n">Fetch</span><span class="p">,</span> <span class="s">"[tid:%i] [sn:%llu] Sending instruction to decode "</span>
 <span class="mi">972</span>                     <span class="s">"from fetch queue. Fetch queue size: %i.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
 <span class="mi">973</span>                     <span class="n">tid</span><span class="p">,</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">seqNum</span><span class="p">,</span> <span class="n">fetchQueue</span><span class="p">[</span><span class="n">tid</span><span class="p">].</span><span class="n">size</span><span class="p">());</span>
 <span class="mi">974</span> 
 <span class="mi">975</span>             <span class="n">wroteToTimeBuffer</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
 <span class="mi">976</span>             <span class="n">fetchQueue</span><span class="p">[</span><span class="n">tid</span><span class="p">].</span><span class="n">pop_front</span><span class="p">();</span>
 <span class="mi">977</span>             <span class="n">insts_to_decode</span><span class="o">++</span><span class="p">;</span>
 <span class="mi">978</span>             <span class="n">available_insts</span><span class="o">--</span><span class="p">;</span>
 <span class="mi">979</span>         <span class="p">}</span>
 <span class="mi">980</span> 
 <span class="mi">981</span>         <span class="n">tid_itr</span><span class="o">++</span><span class="p">;</span>
 <span class="mi">982</span>         <span class="c1">// Wrap around if at end of active threads list</span>
 <span class="mi">983</span>         <span class="nf">if</span> <span class="p">(</span><span class="n">tid_itr</span> <span class="o">==</span> <span class="n">activeThreads</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">())</span>
 <span class="mi">984</span>             <span class="n">tid_itr</span> <span class="o">=</span> <span class="n">activeThreads</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">();</span>
 <span class="mi">985</span>     <span class="p">}</span>
 <span class="mi">986</span> 
 <span class="mi">987</span>     <span class="c1">// If there was activity this cycle, inform the CPU of it.</span>
 <span class="mi">988</span>     <span class="nf">if</span> <span class="p">(</span><span class="n">wroteToTimeBuffer</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">989</span>         <span class="n">DPRINTF</span><span class="p">(</span><span class="n">Activity</span><span class="p">,</span> <span class="s">"Activity this cycle.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
 <span class="mi">990</span>         <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">activityThisCycle</span><span class="p">();</span>
 <span class="mi">991</span>     <span class="p">}</span>
 <span class="mi">992</span> 
 <span class="mi">993</span>     <span class="c1">// Reset the number of the instruction we've fetched.</span>
 <span class="mi">994</span>     <span class="n">numInst</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="mi">995</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<h2 id="fetch-resolving-tlb-and-cache-accesses-to-actually-fetches-instructions"><span class="me-2">fetch: resolving TLB and cache accesses to actually fetches instructions</span><a href="#fetch-resolving-tlb-and-cache-accesses-to-actually-fetches-instructions" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
</pre></td><td class="rouge-code"><pre><span class="mi">1157</span> <span class="kt">void</span>
<span class="mi">1158</span> <span class="n">DefaultFetch</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;::</span><span class="n">fetch</span><span class="p">(</span><span class="kt">bool</span> <span class="o">&amp;</span><span class="n">status_change</span><span class="p">)</span>
<span class="mi">1159</span> <span class="p">{</span>
<span class="mi">1160</span>     <span class="c1">//////////////////////////////////////////</span>
<span class="mi">1161</span>     <span class="c1">// Start actual fetch</span>
<span class="mi">1162</span>     <span class="c1">//////////////////////////////////////////</span>
<span class="mi">1163</span>     <span class="n">ThreadID</span> <span class="n">tid</span> <span class="o">=</span> <span class="n">getFetchingThread</span><span class="p">();</span>
<span class="mi">1164</span> 
<span class="mi">1165</span>     <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">switchedOut</span><span class="p">());</span>
<span class="mi">1166</span> 
<span class="mi">1167</span>     <span class="k">if</span> <span class="p">(</span><span class="n">tid</span> <span class="o">==</span> <span class="n">InvalidThreadID</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1168</span>         <span class="c1">// Breaks looping condition in tick()</span>
<span class="mi">1169</span>         <span class="n">threadFetched</span> <span class="o">=</span> <span class="n">numFetchingThreads</span><span class="p">;</span>
<span class="mi">1170</span> 
<span class="mi">1171</span>         <span class="k">if</span> <span class="p">(</span><span class="n">numThreads</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// @todo Per-thread stats</span>
<span class="mi">1172</span>             <span class="n">profileStall</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="mi">1173</span>         <span class="p">}</span>
<span class="mi">1174</span> 
<span class="mi">1175</span>         <span class="k">return</span><span class="p">;</span>
<span class="mi">1176</span>     <span class="p">}</span>
<span class="mi">1177</span> 
<span class="mi">1178</span>     <span class="nf">DPRINTF</span><span class="p">(</span><span class="n">Fetch</span><span class="p">,</span> <span class="s">"Attempting to fetch from [tid:%i]</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">tid</span><span class="p">);</span>
<span class="mi">1179</span> 
<span class="mi">1180</span>     <span class="c1">// The current PC.</span>
<span class="mi">1181</span>     <span class="n">TheISA</span><span class="o">::</span><span class="n">PCState</span> <span class="n">thisPC</span> <span class="o">=</span> <span class="n">pc</span><span class="p">[</span><span class="n">tid</span><span class="p">];</span>
<span class="mi">1182</span> 
<span class="mi">1183</span>     <span class="n">Addr</span> <span class="n">pcOffset</span> <span class="o">=</span> <span class="n">fetchOffset</span><span class="p">[</span><span class="n">tid</span><span class="p">];</span>
<span class="mi">1184</span>     <span class="n">Addr</span> <span class="n">fetchAddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">thisPC</span><span class="p">.</span><span class="n">instAddr</span><span class="p">()</span> <span class="o">+</span> <span class="n">pcOffset</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">BaseCPU</span><span class="o">::</span><span class="n">PCMask</span><span class="p">;</span>
<span class="mi">1185</span> 
<span class="mi">1186</span>     <span class="kt">bool</span> <span class="n">inRom</span> <span class="o">=</span> <span class="n">isRomMicroPC</span><span class="p">(</span><span class="n">thisPC</span><span class="p">.</span><span class="n">microPC</span><span class="p">());</span>
<span class="mi">1187</span> 
<span class="mi">1188</span>     <span class="c1">// If returning from the delay of a cache miss, then update the status</span>
<span class="mi">1189</span>     <span class="c1">// to running, otherwise do the cache access.  Possibly move this up</span>
<span class="mi">1190</span>     <span class="c1">// to tick() function.</span>
<span class="mi">1191</span>     <span class="nf">if</span> <span class="p">(</span><span class="n">fetchStatus</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">==</span> <span class="n">IcacheAccessComplete</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1192</span>         <span class="n">DPRINTF</span><span class="p">(</span><span class="n">Fetch</span><span class="p">,</span> <span class="s">"[tid:%i] Icache miss is complete.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">tid</span><span class="p">);</span>
<span class="mi">1193</span> 
<span class="mi">1194</span>         <span class="n">fetchStatus</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">=</span> <span class="n">Running</span><span class="p">;</span>
<span class="mi">1195</span>         <span class="n">status_change</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="mi">1196</span>     <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">fetchStatus</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">==</span> <span class="n">Running</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1197</span>         <span class="c1">// Align the fetch PC so its at the start of a fetch buffer segment.</span>
<span class="mi">1198</span>         <span class="n">Addr</span> <span class="n">fetchBufferBlockPC</span> <span class="o">=</span> <span class="n">fetchBufferAlignPC</span><span class="p">(</span><span class="n">fetchAddr</span><span class="p">);</span>
<span class="mi">1199</span> 
<span class="mi">1200</span>         <span class="c1">// If buffer is no longer valid or fetchAddr has moved to point</span>
<span class="mi">1201</span>         <span class="c1">// to the next cache block, AND we have no remaining ucode</span>
<span class="mi">1202</span>         <span class="c1">// from a macro-op, then start fetch from icache.</span>
<span class="mi">1203</span>         <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">fetchBufferValid</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">fetchBufferBlockPC</span> <span class="o">==</span> <span class="n">fetchBufferPC</span><span class="p">[</span><span class="n">tid</span><span class="p">])</span>
<span class="mi">1204</span>             <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">inRom</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">macroop</span><span class="p">[</span><span class="n">tid</span><span class="p">])</span> <span class="p">{</span>
<span class="mi">1205</span>             <span class="n">DPRINTF</span><span class="p">(</span><span class="n">Fetch</span><span class="p">,</span> <span class="s">"[tid:%i] Attempting to translate and read "</span>
<span class="mi">1206</span>                     <span class="s">"instruction, starting at PC %s.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">tid</span><span class="p">,</span> <span class="n">thisPC</span><span class="p">);</span>
<span class="mi">1207</span> 
<span class="mi">1208</span>             <span class="n">fetchCacheLine</span><span class="p">(</span><span class="n">fetchAddr</span><span class="p">,</span> <span class="n">tid</span><span class="p">,</span> <span class="n">thisPC</span><span class="p">.</span><span class="n">instAddr</span><span class="p">());</span>
<span class="mi">1209</span> 
<span class="mi">1210</span>             <span class="k">if</span> <span class="p">(</span><span class="n">fetchStatus</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">==</span> <span class="n">IcacheWaitResponse</span><span class="p">)</span>
<span class="mi">1211</span>                 <span class="o">++</span><span class="n">icacheStallCycles</span><span class="p">;</span>
<span class="mi">1212</span>             <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">fetchStatus</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">==</span> <span class="n">ItlbWait</span><span class="p">)</span>
<span class="mi">1213</span>                 <span class="o">++</span><span class="n">fetchTlbCycles</span><span class="p">;</span>
<span class="mi">1214</span>             <span class="k">else</span>
<span class="mi">1215</span>                 <span class="o">++</span><span class="n">fetchMiscStallCycles</span><span class="p">;</span>
<span class="mi">1216</span>             <span class="k">return</span><span class="p">;</span>
<span class="mi">1217</span>         <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">((</span><span class="n">checkInterrupt</span><span class="p">(</span><span class="n">thisPC</span><span class="p">.</span><span class="n">instAddr</span><span class="p">())</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">delayedCommit</span><span class="p">[</span><span class="n">tid</span><span class="p">]))</span> <span class="p">{</span>
<span class="mi">1218</span>             <span class="c1">// Stall CPU if an interrupt is posted and we're not issuing</span>
<span class="mi">1219</span>             <span class="c1">// an delayed commit micro-op currently (delayed commit instructions</span>
<span class="mi">1220</span>             <span class="c1">// are not interruptable by interrupts, only faults)</span>
<span class="mi">1221</span>             <span class="o">++</span><span class="n">fetchMiscStallCycles</span><span class="p">;</span>
<span class="mi">1222</span>             <span class="n">DPRINTF</span><span class="p">(</span><span class="n">Fetch</span><span class="p">,</span> <span class="s">"[tid:%i] Fetch is stalled!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">tid</span><span class="p">);</span>
<span class="mi">1223</span>             <span class="k">return</span><span class="p">;</span>
<span class="mi">1224</span>         <span class="p">}</span>
<span class="mi">1225</span>     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="mi">1226</span>         <span class="k">if</span> <span class="p">(</span><span class="n">fetchStatus</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">==</span> <span class="n">Idle</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1227</span>             <span class="o">++</span><span class="n">fetchIdleCycles</span><span class="p">;</span>
<span class="mi">1228</span>             <span class="n">DPRINTF</span><span class="p">(</span><span class="n">Fetch</span><span class="p">,</span> <span class="s">"[tid:%i] Fetch is idle!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">tid</span><span class="p">);</span>
<span class="mi">1229</span>         <span class="p">}</span>
<span class="mi">1230</span> 
<span class="mi">1231</span>         <span class="c1">// Status is Idle, so fetch should do nothing.</span>
<span class="mi">1232</span>         <span class="k">return</span><span class="p">;</span>
<span class="mi">1233</span>     <span class="p">}</span>
<span class="p">......</span>
<span class="mi">1417</span> <span class="p">}</span>

</pre></td></tr></tbody></table></code></div></div>
<p>The fetch function is pretty complex and long function to analyze at once. 
Therefore, we will divide the fetch function in two main parts to understand
entire logic of the O3CPU’s fetch stage. The first main part will explain 
how the fetch stage generate request to ITLB and ICache to resolve virtual to 
physical address translation and access the cache using the translated address. 
After the fetch stage receive the instructions from the ICache, the remaining part
will prepare the data structure that will be passed to the next stage, decode. 
Let’s take a look at how the fetch function retrieve the instructions first.</p>

<h2 id="first-part-of-the-fetch-itlb-to-icache-access"><span class="me-2">First part of the fetch: ITLB to ICache access.</span><a href="#first-part-of-the-fetch-itlb-to-icache-access" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<h3 id="getfetchingthread-selecting-thread-to-let-it-fetch"><span class="me-2">getFetchingThread: selecting thread to let it fetch</span><a href="#getfetchingthread-selecting-thread-to-let-it-fetch" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<p>If there are multiple threads need to fetch next instructions, 
the processor should select one among them to continue fetching. 
Based on the policy adopted by the processor, it can return 
different thread based on the current status of threads.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre></td><td class="rouge-code"><pre><span class="mi">1445</span> <span class="c1">///////////////////////////////////////</span>
<span class="mi">1446</span> <span class="c1">//                                   //</span>
<span class="mi">1447</span> <span class="c1">//  SMT FETCH POLICY MAINTAINED HERE //</span>
<span class="mi">1448</span> <span class="c1">//                                   //</span>
<span class="mi">1449</span> <span class="c1">///////////////////////////////////////</span>
<span class="mi">1450</span> <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Impl</span><span class="p">&gt;</span>
<span class="mi">1451</span> <span class="n">ThreadID</span>
<span class="mi">1452</span> <span class="n">DefaultFetch</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;::</span><span class="n">getFetchingThread</span><span class="p">()</span>
<span class="mi">1453</span> <span class="p">{</span>
<span class="mi">1454</span>     <span class="k">if</span> <span class="p">(</span><span class="n">numThreads</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1455</span>         <span class="k">switch</span> <span class="p">(</span><span class="n">fetchPolicy</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1456</span>           <span class="k">case</span> <span class="n">FetchPolicy</span><span class="o">::</span><span class="n">RoundRobin</span><span class="p">:</span>
<span class="mi">1457</span>             <span class="k">return</span> <span class="n">roundRobin</span><span class="p">();</span>
<span class="mi">1458</span>           <span class="k">case</span> <span class="n">FetchPolicy</span><span class="o">::</span><span class="n">IQCount</span><span class="p">:</span>
<span class="mi">1459</span>             <span class="k">return</span> <span class="n">iqCount</span><span class="p">();</span>
<span class="mi">1460</span>           <span class="k">case</span> <span class="n">FetchPolicy</span><span class="o">::</span><span class="n">LSQCount</span><span class="p">:</span>
<span class="mi">1461</span>             <span class="k">return</span> <span class="n">lsqCount</span><span class="p">();</span>
<span class="mi">1462</span>           <span class="k">case</span> <span class="n">FetchPolicy</span><span class="o">::</span><span class="n">Branch</span><span class="p">:</span>
<span class="mi">1463</span>             <span class="k">return</span> <span class="n">branchCount</span><span class="p">();</span>
<span class="mi">1464</span>           <span class="k">default</span><span class="o">:</span>
<span class="mi">1465</span>             <span class="k">return</span> <span class="n">InvalidThreadID</span><span class="p">;</span>
<span class="mi">1466</span>         <span class="p">}</span>
<span class="mi">1467</span>     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="mi">1468</span>         <span class="n">list</span><span class="o">&lt;</span><span class="n">ThreadID</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="kr">thread</span> <span class="o">=</span> <span class="n">activeThreads</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">();</span>
<span class="mi">1469</span>         <span class="k">if</span> <span class="p">(</span><span class="kr">thread</span> <span class="o">==</span> <span class="n">activeThreads</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
<span class="mi">1470</span>             <span class="k">return</span> <span class="n">InvalidThreadID</span><span class="p">;</span>
<span class="mi">1471</span>         <span class="p">}</span>
<span class="mi">1472</span> 
<span class="mi">1473</span>         <span class="n">ThreadID</span> <span class="n">tid</span> <span class="o">=</span> <span class="o">*</span><span class="kr">thread</span><span class="p">;</span>
<span class="mi">1474</span> 
<span class="mi">1475</span>         <span class="nf">if</span> <span class="p">(</span><span class="n">fetchStatus</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">==</span> <span class="n">Running</span> <span class="o">||</span>
<span class="mi">1476</span>             <span class="n">fetchStatus</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">==</span> <span class="n">IcacheAccessComplete</span> <span class="o">||</span>
<span class="mi">1477</span>             <span class="n">fetchStatus</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">==</span> <span class="n">Idle</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1478</span>             <span class="k">return</span> <span class="n">tid</span><span class="p">;</span>
<span class="mi">1479</span>         <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="mi">1480</span>             <span class="k">return</span> <span class="n">InvalidThreadID</span><span class="p">;</span>
<span class="mi">1481</span>         <span class="p">}</span>
<span class="mi">1482</span>     <span class="p">}</span>
<span class="mi">1483</span> <span class="p">}</span>

</pre></td></tr></tbody></table></code></div></div>

<h3 id="translating-virtual-to-physical-address-using-i-tlb"><span class="me-2">Translating virtual to physical address using I-TLB</span><a href="#translating-virtual-to-physical-address-using-i-tlb" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
</pre></td><td class="rouge-code"><pre> <span class="mi">602</span> <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Impl</span><span class="p">&gt;</span>
 <span class="mi">603</span> <span class="kt">bool</span>
 <span class="mi">604</span> <span class="n">DefaultFetch</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;::</span><span class="n">fetchCacheLine</span><span class="p">(</span><span class="n">Addr</span> <span class="n">vaddr</span><span class="p">,</span> <span class="n">ThreadID</span> <span class="n">tid</span><span class="p">,</span> <span class="n">Addr</span> <span class="n">pc</span><span class="p">)</span>
 <span class="mi">605</span> <span class="p">{</span>   
 <span class="mi">606</span>     <span class="n">Fault</span> <span class="n">fault</span> <span class="o">=</span> <span class="n">NoFault</span><span class="p">;</span>
 <span class="mi">607</span>     
 <span class="mi">608</span>     <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">switchedOut</span><span class="p">());</span>
 <span class="mi">609</span>     
 <span class="mi">610</span>     <span class="c1">// @todo: not sure if these should block translation.</span>
 <span class="mi">611</span>     <span class="c1">//AlphaDep</span>
 <span class="mi">612</span>     <span class="k">if</span> <span class="p">(</span><span class="n">cacheBlocked</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">613</span>         <span class="n">DPRINTF</span><span class="p">(</span><span class="n">Fetch</span><span class="p">,</span> <span class="s">"[tid:%i] Can't fetch cache line, cache blocked</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
 <span class="mi">614</span>                 <span class="n">tid</span><span class="p">);</span>
 <span class="mi">615</span>         <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
 <span class="mi">616</span>     <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">checkInterrupt</span><span class="p">(</span><span class="n">pc</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">delayedCommit</span><span class="p">[</span><span class="n">tid</span><span class="p">])</span> <span class="p">{</span>
 <span class="mi">617</span>         <span class="c1">// Hold off fetch from getting new instructions when:</span>
 <span class="mi">618</span>         <span class="c1">// Cache is blocked, or</span>
 <span class="mi">619</span>         <span class="c1">// while an interrupt is pending and we're not in PAL mode, or</span>
 <span class="mi">620</span>         <span class="c1">// fetch is switched out.</span>
 <span class="mi">621</span>         <span class="n">DPRINTF</span><span class="p">(</span><span class="n">Fetch</span><span class="p">,</span> <span class="s">"[tid:%i] Can't fetch cache line, interrupt pending</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
 <span class="mi">622</span>                 <span class="n">tid</span><span class="p">);</span>
 <span class="mi">623</span>         <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
 <span class="mi">624</span>     <span class="p">}</span>
 <span class="mi">625</span>     
 <span class="mi">626</span>     <span class="c1">// Align the fetch address to the start of a fetch buffer segment.</span>
 <span class="mi">627</span>     <span class="n">Addr</span> <span class="n">fetchBufferBlockPC</span> <span class="o">=</span> <span class="n">fetchBufferAlignPC</span><span class="p">(</span><span class="n">vaddr</span><span class="p">);</span>
 <span class="mi">628</span>     
 <span class="mi">629</span>     <span class="nf">DPRINTF</span><span class="p">(</span><span class="n">Fetch</span><span class="p">,</span> <span class="s">"[tid:%i] Fetching cache line %#x for addr %#x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
 <span class="mi">630</span>             <span class="n">tid</span><span class="p">,</span> <span class="n">fetchBufferBlockPC</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">);</span>
 <span class="mi">631</span>     
 <span class="mi">632</span>     <span class="c1">// Setup the memReq to do a read of the first instruction's address.</span>
 <span class="mi">633</span>     <span class="c1">// Set the appropriate read size and flags as well.</span>
 <span class="mi">634</span>     <span class="c1">// Build request here.</span>
 <span class="mi">635</span>     <span class="n">RequestPtr</span> <span class="n">mem_req</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Request</span><span class="o">&gt;</span><span class="p">(</span>
 <span class="mi">636</span>         <span class="n">tid</span><span class="p">,</span> <span class="n">fetchBufferBlockPC</span><span class="p">,</span> <span class="n">fetchBufferSize</span><span class="p">,</span> 
 <span class="mi">637</span>         <span class="n">Request</span><span class="o">::</span><span class="n">INST_FETCH</span><span class="p">,</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">instMasterId</span><span class="p">(),</span> <span class="n">pc</span><span class="p">,</span>
 <span class="mi">638</span>         <span class="n">cpu</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">contextId</span><span class="p">());</span>
 <span class="mi">639</span>     
 <span class="mi">640</span>     <span class="n">mem_req</span><span class="o">-&gt;</span><span class="n">taskId</span><span class="p">(</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">taskId</span><span class="p">());</span>
 <span class="mi">641</span>     
 <span class="mi">642</span>     <span class="n">memReq</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">=</span> <span class="n">mem_req</span><span class="p">;</span>
 <span class="mi">643</span>     
 <span class="mi">644</span>     <span class="c1">// Initiate translation of the icache block</span>
 <span class="mi">645</span>     <span class="n">fetchStatus</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">=</span> <span class="n">ItlbWait</span><span class="p">;</span>
 <span class="mi">646</span>     <span class="n">FetchTranslation</span> <span class="o">*</span><span class="n">trans</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">FetchTranslation</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
 <span class="mi">647</span>     <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">itb</span><span class="o">-&gt;</span><span class="n">translateTiming</span><span class="p">(</span><span class="n">mem_req</span><span class="p">,</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">getTC</span><span class="p">(),</span>
 <span class="mi">648</span>                               <span class="n">trans</span><span class="p">,</span> <span class="n">BaseTLB</span><span class="o">::</span><span class="n">Execute</span><span class="p">);</span>
 <span class="mi">649</span>     <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
 <span class="mi">650</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>One can ask how the fetch stage can understand when the translation is finished.
Note that <strong>FetchTranslation</strong> object is instantiated and sent to the 
Instruction TLB (itb) which conveys functions that should be invoked 
after the Translation is resolved. Therefore, when the instruction TLB finishes
the translation, it invokes the function provided by the passed FetchTranslation object and 
let the fetch stage to process next step, initiating the cache access. 
Anyway, let’s take a look at which function is provided to the TLB.</p>

<p><em>gem5/src/cpu/o3/fetch.hh</em></p>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="rouge-code"><pre><span class="mi">115</span>     <span class="k">class</span> <span class="nc">FetchTranslation</span> <span class="o">:</span> <span class="k">public</span> <span class="n">BaseTLB</span><span class="o">::</span><span class="n">Translation</span>
<span class="mi">116</span>     <span class="p">{</span>
<span class="mi">117</span>       <span class="k">protected</span><span class="o">:</span>
<span class="mi">118</span>         <span class="n">DefaultFetch</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">fetch</span><span class="p">;</span>
<span class="mi">119</span> 
<span class="mi">120</span>       <span class="k">public</span><span class="o">:</span>
<span class="mi">121</span>         <span class="n">FetchTranslation</span><span class="p">(</span><span class="n">DefaultFetch</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">_fetch</span><span class="p">)</span>
<span class="mi">122</span>             <span class="o">:</span> <span class="n">fetch</span><span class="p">(</span><span class="n">_fetch</span><span class="p">)</span>
<span class="mi">123</span>         <span class="p">{}</span>
<span class="mi">124</span> 
<span class="mi">125</span>         <span class="kt">void</span>
<span class="mi">126</span>         <span class="nf">markDelayed</span><span class="p">()</span>
<span class="mi">127</span>         <span class="p">{}</span>
<span class="mi">128</span> 
<span class="mi">129</span>         <span class="kt">void</span>
<span class="mi">130</span>         <span class="n">finish</span><span class="p">(</span><span class="k">const</span> <span class="n">Fault</span> <span class="o">&amp;</span><span class="n">fault</span><span class="p">,</span> <span class="k">const</span> <span class="n">RequestPtr</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">,</span> <span class="n">ThreadContext</span> <span class="o">*</span><span class="n">tc</span><span class="p">,</span>
<span class="mi">131</span>                <span class="n">BaseTLB</span><span class="o">::</span><span class="n">Mode</span> <span class="n">mode</span><span class="p">)</span>
<span class="mi">132</span>         <span class="p">{</span>
<span class="mi">133</span>             <span class="n">assert</span><span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">BaseTLB</span><span class="o">::</span><span class="n">Execute</span><span class="p">);</span>
<span class="mi">134</span>             <span class="n">fetch</span><span class="o">-&gt;</span><span class="n">finishTranslation</span><span class="p">(</span><span class="n">fault</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
<span class="mi">135</span>             <span class="k">delete</span> <span class="k">this</span><span class="p">;</span>
<span class="mi">136</span>         <span class="p">}</span>
<span class="mi">137</span>     <span class="p">};</span>
</pre></td></tr></tbody></table></code></div></div>

<p>You might remember that the TLB invokes the <strong>finish</strong> function at the end of the translation
Yes the FetchTranslation object provide the finish function. When the TLB finishes translation,
by invoking finish function, it can let the processor know the translation is resolved. 
The finish function further invokes the <strong>finishTranslation</strong> function defined in the 
DefaultFetch class.</p>

<h3 id="finishtranslation-finishing-tlb-access-and-generate-cache-access"><span class="me-2">finishTranslation: finishing TLB access and generate cache access</span><a href="#finishtranslation-finishing-tlb-access-and-generate-cache-access" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<p>After the request to the TLB has been resolved, the remaining job is accessing the cache 
to read the instruction to fetch. Let’s take a look at how the fetch stage of the O3 CPU 
access the instruction cache.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="rouge-code"><pre> <span class="mi">652</span> <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Impl</span><span class="p">&gt;</span>
 <span class="mi">653</span> <span class="kt">void</span>
 <span class="mi">654</span> <span class="n">DefaultFetch</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;::</span><span class="n">finishTranslation</span><span class="p">(</span><span class="k">const</span> <span class="n">Fault</span> <span class="o">&amp;</span><span class="n">fault</span><span class="p">,</span>
 <span class="mi">655</span>                                       <span class="k">const</span> <span class="n">RequestPtr</span> <span class="o">&amp;</span><span class="n">mem_req</span><span class="p">)</span>
 <span class="mi">656</span> <span class="p">{</span>
 <span class="mi">657</span>     <span class="n">ThreadID</span> <span class="n">tid</span> <span class="o">=</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">contextToThread</span><span class="p">(</span><span class="n">mem_req</span><span class="o">-&gt;</span><span class="n">contextId</span><span class="p">());</span>
 <span class="mi">658</span>     <span class="n">Addr</span> <span class="n">fetchBufferBlockPC</span> <span class="o">=</span> <span class="n">mem_req</span><span class="o">-&gt;</span><span class="n">getVaddr</span><span class="p">();</span>
 <span class="mi">659</span> 
 <span class="mi">660</span>     <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">switchedOut</span><span class="p">());</span>
 <span class="mi">661</span> 
 <span class="mi">662</span>     <span class="c1">// Wake up CPU if it was idle</span>
 <span class="mi">663</span>     <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">wakeCPU</span><span class="p">();</span>
 <span class="mi">664</span> 
 <span class="mi">665</span>     <span class="k">if</span> <span class="p">(</span><span class="n">fetchStatus</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ItlbWait</span> <span class="o">||</span> <span class="n">mem_req</span> <span class="o">!=</span> <span class="n">memReq</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">||</span>
 <span class="mi">666</span>         <span class="n">mem_req</span><span class="o">-&gt;</span><span class="n">getVaddr</span><span class="p">()</span> <span class="o">!=</span> <span class="n">memReq</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">getVaddr</span><span class="p">())</span> <span class="p">{</span>
 <span class="mi">667</span>         <span class="n">DPRINTF</span><span class="p">(</span><span class="n">Fetch</span><span class="p">,</span> <span class="s">"[tid:%i] Ignoring itlb completed after squash... fetchStatus:%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
 <span class="mi">668</span>                 <span class="n">tid</span><span class="p">,</span><span class="n">fetchStatus</span><span class="p">[</span><span class="n">tid</span><span class="p">]);</span>
 <span class="mi">669</span>         <span class="o">++</span><span class="n">fetchTlbSquashes</span><span class="p">;</span>
 <span class="mi">670</span>         <span class="k">return</span><span class="p">;</span>
 <span class="mi">671</span>     <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>Compared to simple processor which doesn’t provide speculative execution, 
O3 processor utilize the branch prediction and out-of-order execution. 
Therefore, if the current TLB completion is notified to the O3CPU because of a
misspeculation, it should drop the TLB response and stop accessing the cache.
Note that the speculation can turn out to be false while it waits TLB response.
Line 665-670 checks the misspeculation.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre></td><td class="rouge-code"><pre> <span class="mi">674</span>     <span class="c1">// If translation was successful, attempt to read the icache block.</span>
 <span class="mi">675</span>     <span class="nf">if</span> <span class="p">(</span><span class="n">fault</span> <span class="o">==</span> <span class="n">NoFault</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">676</span>         <span class="c1">// Check that we're not going off into random memory</span>
 <span class="mi">677</span>         <span class="c1">// If we have, just wait around for commit to squash something and put</span>
 <span class="mi">678</span>         <span class="c1">// us on the right track</span>
 <span class="mi">679</span>         <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">system</span><span class="o">-&gt;</span><span class="n">isMemAddr</span><span class="p">(</span><span class="n">mem_req</span><span class="o">-&gt;</span><span class="n">getPaddr</span><span class="p">()))</span> <span class="p">{</span>
 <span class="mi">680</span>             <span class="n">warn</span><span class="p">(</span><span class="s">"Address %#x is outside of physical memory, stopping fetch</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
 <span class="mi">681</span>                     <span class="n">mem_req</span><span class="o">-&gt;</span><span class="n">getPaddr</span><span class="p">());</span>
 <span class="mi">682</span>             <span class="n">fetchStatus</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">=</span> <span class="n">NoGoodAddr</span><span class="p">;</span>
 <span class="mi">683</span>             <span class="n">memReq</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
 <span class="mi">684</span>             <span class="k">return</span><span class="p">;</span>
 <span class="mi">685</span>         <span class="p">}</span>
 <span class="mi">686</span> 
 <span class="mi">687</span>         <span class="c1">// Build packet here to access the Icache.</span>
 <span class="mi">688</span>         <span class="n">PacketPtr</span> <span class="n">data_pkt</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Packet</span><span class="p">(</span><span class="n">mem_req</span><span class="p">,</span> <span class="n">MemCmd</span><span class="o">::</span><span class="n">ReadReq</span><span class="p">);</span>
 <span class="mi">689</span>         <span class="n">data_pkt</span><span class="o">-&gt;</span><span class="n">dataDynamic</span><span class="p">(</span><span class="k">new</span> <span class="kt">uint8_t</span><span class="p">[</span><span class="n">fetchBufferSize</span><span class="p">]);</span>
 <span class="mi">690</span> 
 <span class="mi">691</span>         <span class="n">fetchBufferPC</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">=</span> <span class="n">fetchBufferBlockPC</span><span class="p">;</span>
 <span class="mi">692</span>         <span class="n">fetchBufferValid</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
 <span class="mi">693</span>         <span class="nf">DPRINTF</span><span class="p">(</span><span class="n">Fetch</span><span class="p">,</span> <span class="s">"Fetch: Doing instruction read.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
 <span class="mi">694</span> 
 <span class="mi">695</span>         <span class="n">fetchedCacheLines</span><span class="o">++</span><span class="p">;</span>
 <span class="mi">696</span>
 <span class="mi">697</span>         <span class="c1">// Access the cache.</span>
 <span class="mi">698</span>         <span class="nf">if</span> <span class="p">(</span><span class="o">!</span><span class="n">icachePort</span><span class="p">.</span><span class="n">sendTimingReq</span><span class="p">(</span><span class="n">data_pkt</span><span class="p">))</span> <span class="p">{</span>
 <span class="mi">699</span>             <span class="n">assert</span><span class="p">(</span><span class="n">retryPkt</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
 <span class="mi">700</span>             <span class="n">assert</span><span class="p">(</span><span class="n">retryTid</span> <span class="o">==</span> <span class="n">InvalidThreadID</span><span class="p">);</span>
 <span class="mi">701</span>             <span class="n">DPRINTF</span><span class="p">(</span><span class="n">Fetch</span><span class="p">,</span> <span class="s">"[tid:%i] Out of MSHRs!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">tid</span><span class="p">);</span>
 <span class="mi">702</span> 
 <span class="mi">703</span>             <span class="n">fetchStatus</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">=</span> <span class="n">IcacheWaitRetry</span><span class="p">;</span>
 <span class="mi">704</span>             <span class="n">retryPkt</span> <span class="o">=</span> <span class="n">data_pkt</span><span class="p">;</span>
 <span class="mi">705</span>             <span class="n">retryTid</span> <span class="o">=</span> <span class="n">tid</span><span class="p">;</span>
 <span class="mi">706</span>             <span class="n">cacheBlocked</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
 <span class="mi">707</span>         <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
 <span class="mi">708</span>             <span class="n">DPRINTF</span><span class="p">(</span><span class="n">Fetch</span><span class="p">,</span> <span class="s">"[tid:%i] Doing Icache access.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">tid</span><span class="p">);</span>
 <span class="mi">709</span>             <span class="n">DPRINTF</span><span class="p">(</span><span class="n">Activity</span><span class="p">,</span> <span class="s">"[tid:%i] Activity: Waiting on I-cache "</span>
 <span class="mi">710</span>                     <span class="s">"response.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">tid</span><span class="p">);</span>
 <span class="mi">711</span>             <span class="n">lastIcacheStall</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">=</span> <span class="n">curTick</span><span class="p">();</span>
 <span class="mi">712</span>             <span class="n">fetchStatus</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">=</span> <span class="n">IcacheWaitResponse</span><span class="p">;</span>
 <span class="mi">713</span>             <span class="c1">// Notify Fetch Request probe when a packet containing a fetch</span>
 <span class="mi">714</span>             <span class="c1">// request is successfully sent</span>
 <span class="mi">715</span>             <span class="n">ppFetchRequestSent</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">(</span><span class="n">mem_req</span><span class="p">);</span>
 <span class="mi">716</span>         <span class="p">}</span>
 <span class="mi">717</span>     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</pre></td></tr></tbody></table></code></div></div>

<p>If the current TLB resolution response is valid and speculated successfully, 
it should generate read request packet and send it to the Instruction Cache. 
Line 687-695 builds the packet and send buffer to be used for containing 
instructions read from the cache. 
When the cache access request cannot be sent to the instruction cache (line 698-707)
because of the cache is busy for handling previous requests,
it should retry when the Instruction cache is available later. 
Based on the line 701, we can guess that the cache supports multiple cache accesses simultaneously,
but the request can exceed the capacity of its simultaneous processing.
We will see whether the GEM5 supports blocking cache access or non-blocking cache accesses in another posting.
Anyway when the retry is required, it memorizes the request packet and tid. 
Also it changes current status as <strong>IcacheWaitRetry</strong>.
When the Instruction cache is available to process the request (line 708-716), 
it sets current status as  <strong>IcacheWaitResponse</strong> and waits 
until the Instruction cache resolves the request and send the actual instructions.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre></td><td class="rouge-code"><pre> <span class="mi">717</span>     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
 <span class="mi">718</span>         <span class="c1">// Don't send an instruction to decode if we can't handle it.</span>
 <span class="mi">719</span>         <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">numInst</span> <span class="o">&lt;</span> <span class="n">fetchWidth</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">fetchQueue</span><span class="p">[</span><span class="n">tid</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">fetchQueueSize</span><span class="p">))</span> <span class="p">{</span>
 <span class="mi">720</span>             <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">finishTranslationEvent</span><span class="p">.</span><span class="n">scheduled</span><span class="p">());</span>
 <span class="mi">721</span>             <span class="n">finishTranslationEvent</span><span class="p">.</span><span class="n">setFault</span><span class="p">(</span><span class="n">fault</span><span class="p">);</span>
 <span class="mi">722</span>             <span class="n">finishTranslationEvent</span><span class="p">.</span><span class="n">setReq</span><span class="p">(</span><span class="n">mem_req</span><span class="p">);</span>
 <span class="mi">723</span>             <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">schedule</span><span class="p">(</span><span class="n">finishTranslationEvent</span><span class="p">,</span>
 <span class="mi">724</span>                           <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">clockEdge</span><span class="p">(</span><span class="n">Cycles</span><span class="p">(</span><span class="mi">1</span><span class="p">)));</span>
 <span class="mi">725</span>             <span class="k">return</span><span class="p">;</span>
 <span class="mi">726</span>         <span class="p">}</span>
 <span class="mi">727</span>         <span class="nf">DPRINTF</span><span class="p">(</span><span class="n">Fetch</span><span class="p">,</span> <span class="s">"[tid:%i] Got back req with addr %#x but expected %#x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
 <span class="mi">728</span>                 <span class="n">tid</span><span class="p">,</span> <span class="n">mem_req</span><span class="o">-&gt;</span><span class="n">getVaddr</span><span class="p">(),</span> <span class="n">memReq</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">getVaddr</span><span class="p">());</span>
 <span class="mi">729</span>         <span class="c1">// Translation faulted, icache request won't be sent.</span>
 <span class="mi">730</span>         <span class="n">memReq</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
 <span class="mi">731</span> 
 <span class="mi">732</span>         <span class="c1">// Send the fault to commit.  This thread will not do anything</span>
 <span class="mi">733</span>         <span class="c1">// until commit handles the fault.  The only other way it can</span>
 <span class="mi">734</span>         <span class="c1">// wake up is if a squash comes along and changes the PC.</span>
 <span class="mi">735</span>         <span class="n">TheISA</span><span class="o">::</span><span class="n">PCState</span> <span class="n">fetchPC</span> <span class="o">=</span> <span class="n">pc</span><span class="p">[</span><span class="n">tid</span><span class="p">];</span>
 <span class="mi">736</span> 
 <span class="mi">737</span>         <span class="nf">DPRINTF</span><span class="p">(</span><span class="n">Fetch</span><span class="p">,</span> <span class="s">"[tid:%i] Translation faulted, building noop.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">tid</span><span class="p">);</span>
 <span class="mi">738</span>         <span class="c1">// We will use a nop in ordier to carry the fault.</span>
 <span class="mi">739</span>         <span class="n">DynInstPtr</span> <span class="n">instruction</span> <span class="o">=</span> <span class="n">buildInst</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">StaticInst</span><span class="o">::</span><span class="n">nopStaticInstPtr</span><span class="p">,</span>
 <span class="mi">740</span>                                            <span class="nb">NULL</span><span class="p">,</span> <span class="n">fetchPC</span><span class="p">,</span> <span class="n">fetchPC</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
 <span class="mi">741</span>         <span class="n">instruction</span><span class="o">-&gt;</span><span class="n">setNotAnInst</span><span class="p">();</span>
 <span class="mi">742</span> 
 <span class="mi">743</span>         <span class="n">instruction</span><span class="o">-&gt;</span><span class="n">setPredTarg</span><span class="p">(</span><span class="n">fetchPC</span><span class="p">);</span>
 <span class="mi">744</span>         <span class="n">instruction</span><span class="o">-&gt;</span><span class="n">fault</span> <span class="o">=</span> <span class="n">fault</span><span class="p">;</span>
 <span class="mi">745</span>         <span class="n">wroteToTimeBuffer</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
 <span class="mi">746</span> 
 <span class="mi">747</span>         <span class="nf">DPRINTF</span><span class="p">(</span><span class="n">Activity</span><span class="p">,</span> <span class="s">"Activity this cycle.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
 <span class="mi">748</span>         <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">activityThisCycle</span><span class="p">();</span>
 <span class="mi">749</span> 
 <span class="mi">750</span>         <span class="n">fetchStatus</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">=</span> <span class="n">TrapPending</span><span class="p">;</span>
 <span class="mi">751</span> 
 <span class="mi">752</span>         <span class="nf">DPRINTF</span><span class="p">(</span><span class="n">Fetch</span><span class="p">,</span> <span class="s">"[tid:%i] Blocked, need to handle the trap.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">tid</span><span class="p">);</span>
 <span class="mi">753</span>         <span class="nf">DPRINTF</span><span class="p">(</span><span class="n">Fetch</span><span class="p">,</span> <span class="s">"[tid:%i] fault (%s) detected @ PC %s.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
 <span class="mi">754</span>                 <span class="n">tid</span><span class="p">,</span> <span class="n">fault</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">(),</span> <span class="n">pc</span><span class="p">[</span><span class="n">tid</span><span class="p">]);</span>
 <span class="mi">755</span>     <span class="p">}</span>
 <span class="mi">756</span>     <span class="n">_status</span> <span class="o">=</span> <span class="n">updateFetchStatus</span><span class="p">();</span>
 <span class="mi">757</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>When the TLB translation emits fault instead of successful translation, 
it should be handled based on the reason of the fault. 
When the fetchQeueue is already full or XXX (line 719-726),
instead of issuing cache access, it postpone the operation to later 
by scheduling the finishTranslationEvent. 
Note that the request packet received from the ITLB and fault structure 
is also included in the finishTranslationEvent to process it later.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="rouge-code"><pre><span class="mi">140</span>     <span class="cm">/* Event to delay delivery of a fetch translation result in case of
141      * a fault and the nop to carry the fault cannot be generated
142      * immediately */</span>
<span class="mi">143</span>     <span class="k">class</span> <span class="nc">FinishTranslationEvent</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Event</span>
<span class="mi">144</span>     <span class="p">{</span> 
<span class="mi">145</span>       <span class="k">private</span><span class="o">:</span>
<span class="mi">146</span>         <span class="n">DefaultFetch</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">fetch</span><span class="p">;</span>
<span class="mi">147</span>         <span class="n">Fault</span> <span class="n">fault</span><span class="p">;</span>
<span class="mi">148</span>         <span class="n">RequestPtr</span> <span class="n">req</span><span class="p">;</span>
<span class="mi">149</span>       
<span class="mi">150</span>       <span class="k">public</span><span class="o">:</span>
<span class="mi">151</span>         <span class="n">FinishTranslationEvent</span><span class="p">(</span><span class="n">DefaultFetch</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">_fetch</span><span class="p">)</span>
<span class="mi">152</span>             <span class="o">:</span> <span class="n">fetch</span><span class="p">(</span><span class="n">_fetch</span><span class="p">),</span> <span class="n">req</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span>
<span class="mi">153</span>         <span class="p">{}</span>
<span class="mi">154</span>         
<span class="mi">155</span>         <span class="kt">void</span> <span class="n">setFault</span><span class="p">(</span><span class="n">Fault</span> <span class="n">_fault</span><span class="p">)</span>
<span class="mi">156</span>         <span class="p">{</span>   
<span class="mi">157</span>             <span class="n">fault</span> <span class="o">=</span> <span class="n">_fault</span><span class="p">;</span>
<span class="mi">158</span>         <span class="p">}</span>
<span class="mi">159</span>         
<span class="mi">160</span>         <span class="kt">void</span> <span class="n">setReq</span><span class="p">(</span><span class="k">const</span> <span class="n">RequestPtr</span> <span class="o">&amp;</span><span class="n">_req</span><span class="p">)</span>
<span class="mi">161</span>         <span class="p">{</span>   
<span class="mi">162</span>             <span class="n">req</span> <span class="o">=</span> <span class="n">_req</span><span class="p">;</span>
<span class="mi">163</span>         <span class="p">}</span>
<span class="mi">164</span>         
<span class="mi">165</span>         <span class="cm">/** Process the delayed finish translation */</span>
<span class="mi">166</span>         <span class="kt">void</span> <span class="nf">process</span><span class="p">()</span>
<span class="mi">167</span>         <span class="p">{</span>   
<span class="mi">168</span>             <span class="n">assert</span><span class="p">(</span><span class="n">fetch</span><span class="o">-&gt;</span><span class="n">numInst</span> <span class="o">&lt;</span> <span class="n">fetch</span><span class="o">-&gt;</span><span class="n">fetchWidth</span><span class="p">);</span>
<span class="mi">169</span>             <span class="n">fetch</span><span class="o">-&gt;</span><span class="n">finishTranslation</span><span class="p">(</span><span class="n">fault</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
<span class="mi">170</span>         <span class="p">}</span>
<span class="mi">171</span>         
<span class="mi">172</span>         <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">description</span><span class="p">()</span> <span class="k">const</span>
<span class="mi">173</span>         <span class="p">{</span>   
<span class="mi">174</span>             <span class="k">return</span> <span class="s">"FullO3CPU FetchFinishTranslation"</span><span class="p">;</span>
<span class="mi">175</span>         <span class="p">}</span>   
<span class="mi">176</span>       <span class="p">};</span>
</pre></td></tr></tbody></table></code></div></div>
<p>In detail, when the FinishTranslationEvent happens after the designated cycles passed,
it invokes the process function defined in the class. As shown in the above code line 166-170,
it calls finishTranslation with the passed fault and request again.</p>

<p>For the other reason of faults, 
\TODO{explanation required for the rest of the faulting code}.
After the fetch stage handles the response from the ITLB, 
it should update the current status of the fetch stage by invoking the updateFetchStatus function.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="rouge-code"><pre> <span class="mi">841</span> <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Impl</span><span class="p">&gt;</span>
 <span class="mi">842</span> <span class="k">typename</span> <span class="n">DefaultFetch</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;::</span><span class="n">FetchStatus</span>
 <span class="mi">843</span> <span class="n">DefaultFetch</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;::</span><span class="n">updateFetchStatus</span><span class="p">()</span>
 <span class="mi">844</span> <span class="p">{</span>
 <span class="mi">845</span>     <span class="c1">//Check Running</span>
 <span class="mi">846</span>     <span class="n">list</span><span class="o">&lt;</span><span class="n">ThreadID</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">threads</span> <span class="o">=</span> <span class="n">activeThreads</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">();</span>
 <span class="mi">847</span>     <span class="n">list</span><span class="o">&lt;</span><span class="n">ThreadID</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">end</span> <span class="o">=</span> <span class="n">activeThreads</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">();</span>
 <span class="mi">848</span> 
 <span class="mi">849</span>     <span class="k">while</span> <span class="p">(</span><span class="n">threads</span> <span class="o">!=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">850</span>         <span class="n">ThreadID</span> <span class="n">tid</span> <span class="o">=</span> <span class="o">*</span><span class="n">threads</span><span class="o">++</span><span class="p">;</span>
 <span class="mi">851</span> 
 <span class="mi">852</span>         <span class="k">if</span> <span class="p">(</span><span class="n">fetchStatus</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">==</span> <span class="n">Running</span> <span class="o">||</span>
 <span class="mi">853</span>             <span class="n">fetchStatus</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">==</span> <span class="n">Squashing</span> <span class="o">||</span>
 <span class="mi">854</span>             <span class="n">fetchStatus</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">==</span> <span class="n">IcacheAccessComplete</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">855</span> 
 <span class="mi">856</span>             <span class="k">if</span> <span class="p">(</span><span class="n">_status</span> <span class="o">==</span> <span class="n">Inactive</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">857</span>                 <span class="n">DPRINTF</span><span class="p">(</span><span class="n">Activity</span><span class="p">,</span> <span class="s">"[tid:%i] Activating stage.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">tid</span><span class="p">);</span>
 <span class="mi">858</span> 
 <span class="mi">859</span>                 <span class="k">if</span> <span class="p">(</span><span class="n">fetchStatus</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">==</span> <span class="n">IcacheAccessComplete</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">860</span>                     <span class="n">DPRINTF</span><span class="p">(</span><span class="n">Activity</span><span class="p">,</span> <span class="s">"[tid:%i] Activating fetch due to cache"</span>
 <span class="mi">861</span>                             <span class="s">"completion</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">tid</span><span class="p">);</span>
 <span class="mi">862</span>                 <span class="p">}</span>
 <span class="mi">863</span> 
 <span class="mi">864</span>                 <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">activateStage</span><span class="p">(</span><span class="n">O3CPU</span><span class="o">::</span><span class="n">FetchIdx</span><span class="p">);</span>
 <span class="mi">865</span>             <span class="p">}</span>
 <span class="mi">866</span> 
 <span class="mi">867</span>             <span class="k">return</span> <span class="n">Active</span><span class="p">;</span>
 <span class="mi">868</span>         <span class="p">}</span>
 <span class="mi">869</span>     <span class="p">}</span>
 <span class="mi">870</span> 
 <span class="mi">871</span>     <span class="c1">// Stage is switching from active to inactive, notify CPU of it.</span>
 <span class="mi">872</span>     <span class="nf">if</span> <span class="p">(</span><span class="n">_status</span> <span class="o">==</span> <span class="n">Active</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">873</span>         <span class="n">DPRINTF</span><span class="p">(</span><span class="n">Activity</span><span class="p">,</span> <span class="s">"Deactivating stage.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
 <span class="mi">874</span> 
 <span class="mi">875</span>         <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">deactivateStage</span><span class="p">(</span><span class="n">O3CPU</span><span class="o">::</span><span class="n">FetchIdx</span><span class="p">);</span>
 <span class="mi">876</span>     <span class="p">}</span>
 <span class="mi">877</span> 
 <span class="mi">878</span>     <span class="k">return</span> <span class="n">Inactive</span><span class="p">;</span>
 <span class="mi">879</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<h3 id="processcachecompletion-completing-icache-access"><span class="me-2">processCacheCompletion: completing ICache access</span><a href="#processcachecompletion-completing-icache-access" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<p>When the sendTimingReq is invoked through the icachePort, which means 
cache access request sent to the Instruction cache successfully, 
after few cycles elapsed, the O3CPU will be notified that the cache read completes.
The cache access completion is handled by the recvTimingResp of the IcachePort 
allocated for the O3CPU.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre><span class="mi">1676</span> <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Impl</span><span class="p">&gt;</span>
<span class="mi">1677</span> <span class="kt">bool</span>
<span class="mi">1678</span> <span class="n">DefaultFetch</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;::</span><span class="n">IcachePort</span><span class="o">::</span><span class="n">recvTimingResp</span><span class="p">(</span><span class="n">PacketPtr</span> <span class="n">pkt</span><span class="p">)</span>
<span class="mi">1679</span> <span class="p">{</span>
<span class="mi">1680</span>     <span class="n">DPRINTF</span><span class="p">(</span><span class="n">O3CPU</span><span class="p">,</span> <span class="s">"Fetch unit received timing</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="mi">1681</span>     <span class="c1">// We shouldn't ever get a cacheable block in Modified state</span>
<span class="mi">1682</span>     <span class="n">assert</span><span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">isUncacheable</span><span class="p">()</span> <span class="o">||</span>
<span class="mi">1683</span>            <span class="o">!</span><span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">cacheResponding</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">hasSharers</span><span class="p">()));</span>
<span class="mi">1684</span>     <span class="n">fetch</span><span class="o">-&gt;</span><span class="n">processCacheCompletion</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>
<span class="mi">1685</span> 
<span class="mi">1686</span>     <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="mi">1687</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>When it receives the instructions from the cache, it invokes the 
processCacheCompletion function and ask this function to handle the 
response arrived from the cache.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre></td><td class="rouge-code"><pre> <span class="mi">389</span> <span class="n">DefaultFetch</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;::</span><span class="n">processCacheCompletion</span><span class="p">(</span><span class="n">PacketPtr</span> <span class="n">pkt</span><span class="p">)</span>
 <span class="mi">390</span> <span class="p">{</span>
 <span class="mi">391</span>     <span class="n">ThreadID</span> <span class="n">tid</span> <span class="o">=</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">contextToThread</span><span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">contextId</span><span class="p">());</span>
 <span class="mi">392</span> 
 <span class="mi">393</span>     <span class="n">DPRINTF</span><span class="p">(</span><span class="n">Fetch</span><span class="p">,</span> <span class="s">"[tid:%i] Waking up from cache miss.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">tid</span><span class="p">);</span>
 <span class="mi">394</span>     <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">switchedOut</span><span class="p">());</span>
 <span class="mi">395</span> 
 <span class="mi">396</span>     <span class="c1">// Only change the status if it's still waiting on the icache access</span>
 <span class="mi">397</span>     <span class="c1">// to return.</span>
 <span class="mi">398</span>     <span class="k">if</span> <span class="p">(</span><span class="n">fetchStatus</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">!=</span> <span class="n">IcacheWaitResponse</span> <span class="o">||</span>
 <span class="mi">399</span>         <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">req</span> <span class="o">!=</span> <span class="n">memReq</span><span class="p">[</span><span class="n">tid</span><span class="p">])</span> <span class="p">{</span>
 <span class="mi">400</span>         <span class="o">++</span><span class="n">fetchIcacheSquashes</span><span class="p">;</span>
 <span class="mi">401</span>         <span class="k">delete</span> <span class="n">pkt</span><span class="p">;</span>
 <span class="mi">402</span>         <span class="k">return</span><span class="p">;</span>
 <span class="mi">403</span>     <span class="p">}</span>
 <span class="mi">404</span> 
 <span class="mi">405</span>     <span class="nf">memcpy</span><span class="p">(</span><span class="n">fetchBuffer</span><span class="p">[</span><span class="n">tid</span><span class="p">],</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">getConstPtr</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">fetchBufferSize</span><span class="p">);</span>
 <span class="mi">406</span>     <span class="n">fetchBufferValid</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
 <span class="mi">407</span> 
 <span class="mi">408</span>     <span class="c1">// Wake up the CPU (if it went to sleep and was waiting on</span>
 <span class="mi">409</span>     <span class="c1">// this completion event).</span>
 <span class="mi">410</span>     <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">wakeCPU</span><span class="p">();</span>
 <span class="mi">411</span> 
 <span class="mi">412</span>     <span class="nf">DPRINTF</span><span class="p">(</span><span class="n">Activity</span><span class="p">,</span> <span class="s">"[tid:%i] Activating fetch due to cache completion</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
 <span class="mi">413</span>             <span class="n">tid</span><span class="p">);</span>
 <span class="mi">414</span> 
 <span class="mi">415</span>     <span class="nf">switchToActive</span><span class="p">();</span>
 <span class="mi">416</span> 
 <span class="mi">417</span>     <span class="c1">// Only switch to IcacheAccessComplete if we're not stalled as well.</span>
 <span class="mi">418</span>     <span class="nf">if</span> <span class="p">(</span><span class="n">checkStall</span><span class="p">(</span><span class="n">tid</span><span class="p">))</span> <span class="p">{</span>
 <span class="mi">419</span>         <span class="n">fetchStatus</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">=</span> <span class="n">Blocked</span><span class="p">;</span>
 <span class="mi">420</span>     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
 <span class="mi">421</span>         <span class="n">fetchStatus</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">=</span> <span class="n">IcacheAccessComplete</span><span class="p">;</span>
 <span class="mi">422</span>     <span class="p">}</span>
 <span class="mi">423</span> 
 <span class="mi">424</span>     <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">setAccessLatency</span><span class="p">();</span>
 <span class="mi">425</span>     <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">ppInstAccessComplete</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>
 <span class="mi">426</span>     <span class="c1">// Reset the mem req to NULL.</span>
 <span class="mi">427</span>     <span class="k">delete</span> <span class="n">pkt</span><span class="p">;</span>
 <span class="mi">428</span>     <span class="n">memReq</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
 <span class="mi">429</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>When the instructions from the cache arrives, it could be the case where 
the misspeculation had initiated the cache access. 
In that case, it should drop the cache access by deleting the response packet.
In other cases, the read instructions should be copied from the packet to the 
<strong>fetchBuffer</strong> containing the fetched instructions (line 405-406). 
When the current tid is stalled because of some events (we will cover which condition
makes the thread to be stalled), it should be blocked until the stall is resolved.
If there is no stall, then the fetchStatus can be changed to <strong>IcacheAccessComplete</strong>,
which means the thread can finish the fetch stage.
Now let’s go back to the fetch function again!</p>

<h2 id="revisiting-fetch-stage-to-handle-the-instructions-fetched-from-the-cache"><span class="me-2">Revisiting fetch stage to handle the instructions fetched from the cache</span><a href="#revisiting-fetch-stage-to-handle-the-instructions-fetched-from-the-cache" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<h3 id="fetch-tick-happens-every-processor-tick"><span class="me-2">Fetch tick happens every processor tick</span><a href="#fetch-tick-happens-every-processor-tick" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<p>One important thing to note is that Fetch stage is always executed at every clock cycle.
However, based on the current status of the processor and other components such as 
TLB and cache, fetch stage cannot produce meaningful progress and should wait 
until the other component finish their operations. Although modern processors 
have multiple cores to execute, but if the all cores are waiting the cache accesses, 
no other hardware thread cannot execute the fetch stage. The <strong>getFetchingThread</strong>
function checks the status of the all hardware threads and returns thread if there is one
that can execute the fetch stage.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="rouge-code"><pre><span class="mi">1156</span> <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Impl</span><span class="p">&gt;</span>
<span class="mi">1157</span> <span class="kt">void</span>
<span class="mi">1158</span> <span class="n">DefaultFetch</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;::</span><span class="n">fetch</span><span class="p">(</span><span class="kt">bool</span> <span class="o">&amp;</span><span class="n">status_change</span><span class="p">)</span>
<span class="mi">1159</span> <span class="p">{</span>
<span class="mi">1160</span>     <span class="c1">//////////////////////////////////////////</span>
<span class="mi">1161</span>     <span class="c1">// Start actual fetch</span>
<span class="mi">1162</span>     <span class="c1">//////////////////////////////////////////</span>
<span class="mi">1163</span>     <span class="n">ThreadID</span> <span class="n">tid</span> <span class="o">=</span> <span class="n">getFetchingThread</span><span class="p">();</span>
<span class="mi">1164</span> 
<span class="mi">1165</span>     <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">switchedOut</span><span class="p">());</span>
<span class="mi">1166</span> 
<span class="mi">1167</span>     <span class="k">if</span> <span class="p">(</span><span class="n">tid</span> <span class="o">==</span> <span class="n">InvalidThreadID</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1168</span>         <span class="c1">// Breaks looping condition in tick()</span>
<span class="mi">1169</span>         <span class="n">threadFetched</span> <span class="o">=</span> <span class="n">numFetchingThreads</span><span class="p">;</span>
<span class="mi">1170</span> 
<span class="mi">1171</span>         <span class="k">if</span> <span class="p">(</span><span class="n">numThreads</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// @todo Per-thread stats</span>
<span class="mi">1172</span>             <span class="n">profileStall</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="mi">1173</span>         <span class="p">}</span>
<span class="mi">1174</span> 
<span class="mi">1175</span>         <span class="k">return</span><span class="p">;</span>
<span class="mi">1176</span>     <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>As shown in the above code, when there is no available hardware thread to execute fetch stage,
getFetchingThread returns InvalidThreadID, and no thread can produce progress at that clock cycle.
Only the case where the getFetchingThread returns an available thread is the thread is in 
one of the three fetchStatus: Running, IcacheAccessComplete, or Idle.</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="rouge-code"><pre>   1000: system.cpu.fetch: Running stage.
   1000: system.cpu.fetch: Attempting to fetch from [tid:0]
   1000: system.cpu.fetch: [tid:0] Attempting to translate and read instruction, starting at PC (0x7ffff8000090=&gt;0x7ffff8000098).(0=&gt;1).
   1000: system.cpu.fetch: [tid:0] Fetching cache line 0x7ffff8000080 for addr 0x7ffff8000090
   1000: system.cpu.fetch: Fetch: Doing instruction read.
   1000: system.cpu.fetch: [tid:0] Doing Icache access.
   1500: system.cpu.fetch: Running stage.
   1500: system.cpu.fetch: There are no more threads available to fetch from.
   1500: system.cpu.fetch: [tid:0] Fetch is waiting cache response!
   2000: system.cpu.fetch: Running stage.
   2000: system.cpu.fetch: There are no more threads available to fetch from.
   2000: system.cpu.fetch: [tid:0] Fetch is waiting cache response!
   2500: system.cpu.fetch: Running stage.
   2500: system.cpu.fetch: There are no more threads available to fetch from.
   2500: system.cpu.fetch: [tid:0] Fetch is waiting cache response!
   3000: system.cpu.fetch: Running stage.
   3000: system.cpu.fetch: There are no more threads available to fetch from.
   3000: system.cpu.fetch: [tid:0] Fetch is waiting cache response!
   3500: system.cpu.fetch: Running stage.
   3500: system.cpu.fetch: There are no more threads available to fetch from.
   3500: system.cpu.fetch: [tid:0] Fetch is waiting cache response!
   4000: system.cpu.fetch: Running stage.
   4000: system.cpu.fetch: There are no more threads available to fetch from.
   4000: system.cpu.fetch: [tid:0] Fetch is waiting cache response!
   4500: system.cpu.fetch: Running stage.
   4500: system.cpu.fetch: There are no more threads available to fetch from.
   4500: system.cpu.fetch: [tid:0] Fetch is waiting cache response!
   5000: system.cpu.fetch: Running stage.
   5000: system.cpu.fetch: There are no more threads available to fetch from.
   5000: system.cpu.fetch: [tid:0] Fetch is waiting cache response!
   5500: system.cpu.fetch: Running stage.
   5500: system.cpu.fetch: There are no more threads available to fetch from.
   5500: system.cpu.fetch: [tid:0] Fetch is waiting cache response!
  78000: system.cpu.fetch: [tid:0] Waking up from cache miss.
  78001: system.cpu.fetch: [tid:0] Waking up from cache miss.
  78500: system.cpu.fetch: Running stage.
  78500: system.cpu.fetch: Attempting to fetch from [tid:0]
  78500: system.cpu.fetch: [tid:0] Icache miss is complete.
</pre></td></tr></tbody></table></code></div></div>

<p>In our current system, because we only have one hardware thread, 
while it waits for the ICache miss to be resolved, it cannot execute fetch stage
to produce further progress. The described behavior of the fetch stage is described 
in the above log. After the thread first fetches the instructions at cycle 1000,
it cannot produce any progress until the ICache miss is resolved at cycle 78000. 
After the ICache miss is resolved (after 78500 cycle), it can finally produce progress from the fetch stage.
Remember that when a missed ICache is resolved by the processCacheCompletion function, 
it changes the fetchStatus of the thread from IcacheWaitResponse to <strong>IcacheAccessComplete</strong>.
Therefore, when the fetch stage is executed once again, the undiscovered path will be executed.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="mi">1188</span>     <span class="c1">// If returning from the delay of a cache miss, then update the status</span>
<span class="mi">1189</span>     <span class="c1">// to running, otherwise do the cache access.  Possibly move this up</span>
<span class="mi">1190</span>     <span class="c1">// to tick() function.</span>
<span class="mi">1191</span>     <span class="nf">if</span> <span class="p">(</span><span class="n">fetchStatus</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">==</span> <span class="n">IcacheAccessComplete</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1192</span>         <span class="n">DPRINTF</span><span class="p">(</span><span class="n">Fetch</span><span class="p">,</span> <span class="s">"[tid:%i] Icache miss is complete.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">tid</span><span class="p">);</span>
<span class="mi">1193</span> 
<span class="mi">1194</span>         <span class="n">fetchStatus</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">=</span> <span class="n">Running</span><span class="p">;</span>
<span class="mi">1195</span>         <span class="n">status_change</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="mi">1196</span>     <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">fetchStatus</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">==</span> <span class="n">Running</span><span class="p">)</span> <span class="p">{</span>
</pre></td></tr></tbody></table></code></div></div>

<p>Compared to the initial fetch execution that initiated the ITLB and ICache accesses, 
because the fetchStatus has been changed to IcacheAccessComplete,
the fetch stage can execute the rest of the fetch function at this moment. 
Let’s take a look at the rest of the fetch function in detail.</p>

<h3 id="fetchbuffer-contains-actual-instructions-for-a-particular-hardware-thread"><span class="me-2">fetchBuffer contains actual instructions for a particular hardware thread</span><a href="#fetchbuffer-contains-actual-instructions-for-a-particular-hardware-thread" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="rouge-code"><pre><span class="mi">1235</span>     <span class="c1">//when a requested instruction cache block is arrived(IcacheAccessComplete)</span>
<span class="mi">1236</span>     <span class="o">++</span><span class="n">fetchCycles</span><span class="p">;</span>
<span class="mi">1237</span> 
<span class="mi">1238</span>     <span class="n">TheISA</span><span class="o">::</span><span class="n">PCState</span> <span class="n">nextPC</span> <span class="o">=</span> <span class="n">thisPC</span><span class="p">;</span>
<span class="mi">1239</span> 
<span class="mi">1240</span>     <span class="n">StaticInstPtr</span> <span class="n">staticInst</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="mi">1241</span>     <span class="n">StaticInstPtr</span> <span class="n">curMacroop</span> <span class="o">=</span> <span class="n">macroop</span><span class="p">[</span><span class="n">tid</span><span class="p">];</span>
<span class="mi">1242</span> 
<span class="mi">1243</span>     <span class="c1">// If the read of the first instruction was successful, then grab the</span>
<span class="mi">1244</span>     <span class="c1">// instructions from the rest of the cache line and put them into the</span>
<span class="mi">1245</span>     <span class="c1">// queue heading to decode.</span>
<span class="mi">1246</span> 
<span class="mi">1247</span>     <span class="nf">DPRINTF</span><span class="p">(</span><span class="n">Fetch</span><span class="p">,</span> <span class="s">"[tid:%i] Adding instructions to queue to "</span>
<span class="mi">1248</span>             <span class="s">"decode.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">tid</span><span class="p">);</span>
<span class="mi">1249</span> 
<span class="mi">1250</span>     <span class="c1">// Need to keep track of whether or not a predicted branch</span>
<span class="mi">1251</span>     <span class="c1">// ended this fetch block.</span>
<span class="mi">1252</span>     <span class="kt">bool</span> <span class="n">predictedBranch</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="mi">1253</span> 
<span class="mi">1254</span>     <span class="c1">// Need to halt fetch if quiesce instruction detected</span>
<span class="mi">1255</span>     <span class="kt">bool</span> <span class="n">quiesce</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="mi">1256</span> 
<span class="mi">1257</span>     <span class="n">TheISA</span><span class="o">::</span><span class="n">MachInst</span> <span class="o">*</span><span class="n">cacheInsts</span> <span class="o">=</span>
<span class="mi">1258</span>         <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">TheISA</span><span class="o">::</span><span class="n">MachInst</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">fetchBuffer</span><span class="p">[</span><span class="n">tid</span><span class="p">]);</span>
<span class="mi">1259</span>
<span class="mi">1260</span>     <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">numInsts</span> <span class="o">=</span> <span class="n">fetchBufferSize</span> <span class="o">/</span> <span class="n">instSize</span><span class="p">;</span>
<span class="mi">1261</span>     <span class="kt">unsigned</span> <span class="n">blkOffset</span> <span class="o">=</span> <span class="p">(</span><span class="n">fetchAddr</span> <span class="o">-</span> <span class="n">fetchBufferPC</span><span class="p">[</span><span class="n">tid</span><span class="p">])</span> <span class="o">/</span> <span class="n">instSize</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></div></div>

<p>Remember that the fetchBuffer[tid] contains the actual instructions read from
the ICache. Note that cacheInsts variable which is the TheISA::MachInst * type 
references the instruction buffer, fetchBuffer[tid].
This variable is passed to the decoder to pass the instruction stream read from the ICache. 
Also, the TheISA::MachInst is a uint64_t in the x86 architecture (TheISA will be changed to the X86 namespace). 
Because X86 architecture adopts variable instruction length, it approximately 
set the instruction length as 8bytes and calculate the number of instructions 
in the instruction stream fetched from the ICache. 
Note that the numInsts is approximated as fetchBufferSize / instSize.</p>

<h2 id="the-main-fetchloop-processing-instructions"><span class="me-2">The main fetchloop processing instructions</span><a href="#the-main-fetchloop-processing-instructions" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre><span class="mi">1263</span>     <span class="c1">// Loop through instruction memory from the cache.</span>
<span class="mi">1264</span>     <span class="c1">// Keep issuing while fetchWidth is available and branch is not</span>
<span class="mi">1265</span>     <span class="c1">// predicted taken</span>
<span class="mi">1266</span>     <span class="nf">while</span> <span class="p">(</span><span class="n">numInst</span> <span class="o">&lt;</span> <span class="n">fetchWidth</span> <span class="o">&amp;&amp;</span> <span class="n">fetchQueue</span><span class="p">[</span><span class="n">tid</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">fetchQueueSize</span>
<span class="mi">1267</span>            <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">predictedBranch</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">quiesce</span><span class="p">)</span> <span class="p">{</span>
<span class="p">......</span>
<span class="mi">1382</span>         <span class="c1">// Re-evaluate whether the next instruction to fetch is in micro-op ROM</span>
<span class="mi">1383</span>         <span class="c1">// or not.</span>
<span class="mi">1384</span>         <span class="n">inRom</span> <span class="o">=</span> <span class="n">isRomMicroPC</span><span class="p">(</span><span class="n">thisPC</span><span class="p">.</span><span class="n">microPC</span><span class="p">());</span>
<span class="mi">1385</span>     <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>The while loop (line 1266-1267) is the main body of processing instructions 
stored in the fetchBuffer. Be careful not to confuse numInst with numInsts.
numInst means the number of instructions fetched at this cycle, and numInsts means 
the number of instructions that can possibly reside in the fetchBuffer. 
Also, fetchQueue is the CPP standard deque managing DynInstPtr which is the pointer 
of one macroop instruction. Therefore, the loop checks first whether the number of 
fetched instructions at this cycle exceed the deisgnated fetchWidth and examine 
whether the fetchQueue is overflowed, which means too many instructions have been fetched 
from the instruction cache. Because the instruction length can vary but the capacity 
of fetchQueue is limited, sometimes depending on which instructions actually reside
in the fetched instruction cache, it cannot process all instructions at that cycle. 
Based on the fact that it checks if the fetchQueue is overflowed at every iteration, 
we can assume that the loop insert instruction to the fetchQueue. We will take a look at 
the details soon!
Also it checks the type of the previous instruction handled by the loop, 
whether it is predictedBranch or quiesce. If the previous instruction turns out to 
one of these type of instruction, then the loop should not process the instruction
in the fetchBuffer further and stop.</p>

<h3 id="decoder"><span class="me-2">Decoder</span><a href="#decoder" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="rouge-code"><pre><span class="mi">1268</span>         <span class="c1">// We need to process more memory if we aren't going to get a</span>
<span class="mi">1269</span>         <span class="c1">// StaticInst from the rom, the current macroop, or what's already</span>
<span class="mi">1270</span>         <span class="c1">// in the decoder.</span>
<span class="mi">1271</span>         <span class="kt">bool</span> <span class="n">needMem</span> <span class="o">=</span> <span class="o">!</span><span class="n">inRom</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">curMacroop</span> <span class="o">&amp;&amp;</span>
<span class="mi">1272</span>             <span class="o">!</span><span class="n">decoder</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">instReady</span><span class="p">();</span>
<span class="mi">1273</span>         <span class="n">fetchAddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">thisPC</span><span class="p">.</span><span class="n">instAddr</span><span class="p">()</span> <span class="o">+</span> <span class="n">pcOffset</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">BaseCPU</span><span class="o">::</span><span class="n">PCMask</span><span class="p">;</span>
<span class="mi">1274</span>         <span class="n">Addr</span> <span class="n">fetchBufferBlockPC</span> <span class="o">=</span> <span class="n">fetchBufferAlignPC</span><span class="p">(</span><span class="n">fetchAddr</span><span class="p">);</span>
<span class="mi">1275</span> 
<span class="mi">1276</span>         <span class="nf">if</span> <span class="p">(</span><span class="n">needMem</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1277</span>             <span class="c1">// If buffer is no longer valid or fetchAddr has moved to point</span>
<span class="mi">1278</span>             <span class="c1">// to the next cache block then start fetch from icache.</span>
<span class="mi">1279</span>             <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fetchBufferValid</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">||</span>
<span class="mi">1280</span>                 <span class="n">fetchBufferBlockPC</span> <span class="o">!=</span> <span class="n">fetchBufferPC</span><span class="p">[</span><span class="n">tid</span><span class="p">])</span>
<span class="mi">1281</span>                 <span class="k">break</span><span class="p">;</span>
<span class="mi">1282</span> 
<span class="mi">1283</span>             <span class="k">if</span> <span class="p">(</span><span class="n">blkOffset</span> <span class="o">&gt;=</span> <span class="n">numInsts</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1284</span>                 <span class="c1">// We need to process more memory, but we've run out of the</span>
<span class="mi">1285</span>                 <span class="c1">// current block.</span>
<span class="mi">1286</span>                 <span class="k">break</span><span class="p">;</span>
<span class="mi">1287</span>             <span class="p">}</span>
<span class="mi">1288</span> 
<span class="mi">1289</span>             <span class="n">decoder</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">moreBytes</span><span class="p">(</span><span class="n">thisPC</span><span class="p">,</span> <span class="n">fetchAddr</span><span class="p">,</span> <span class="n">cacheInsts</span><span class="p">[</span><span class="n">blkOffset</span><span class="p">]);</span>
<span class="mi">1290</span> 
<span class="mi">1291</span>             <span class="nf">if</span> <span class="p">(</span><span class="n">decoder</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">needMoreBytes</span><span class="p">())</span> <span class="p">{</span>
<span class="mi">1292</span>                 <span class="n">blkOffset</span><span class="o">++</span><span class="p">;</span>
<span class="mi">1293</span>                 <span class="n">fetchAddr</span> <span class="o">+=</span> <span class="n">instSize</span><span class="p">;</span>
<span class="mi">1294</span>                 <span class="n">pcOffset</span> <span class="o">+=</span> <span class="n">instSize</span><span class="p">;</span>
<span class="mi">1295</span>             <span class="p">}</span>
<span class="mi">1296</span>         <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>After the all conditions are met, each iteration of the loop processes the instruction 
one by one. For the first execution of the fetch stage, the inRom and curMacroop are set 
as false and NULL respectively. Also, when the decoder object embedded in the fetch stage 
is initialized, the instDone variable of the decoder is set as false, which will be returned 
as the result of instReady function of the decoder. 
Therefore, the needMem should be set for the initial execution. 
When the needMem flag is set, which means \TODO{XXX},
it invokes moreBytes function of the decoder to decode the instruction.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre><span class="mi">306</span>     <span class="c1">//Use this to give data to the decoder. This should be used</span>
<span class="mi">307</span>     <span class="c1">//when there is control flow.</span>
<span class="mi">308</span>     <span class="kt">void</span> <span class="nf">moreBytes</span><span class="p">(</span><span class="k">const</span> <span class="n">PCState</span> <span class="o">&amp;</span><span class="n">pc</span><span class="p">,</span> <span class="n">Addr</span> <span class="n">fetchPC</span><span class="p">,</span> <span class="n">MachInst</span> <span class="n">data</span><span class="p">)</span>
<span class="mi">309</span>     <span class="p">{</span>
<span class="mi">310</span>         <span class="n">DPRINTF</span><span class="p">(</span><span class="n">Decoder</span><span class="p">,</span> <span class="s">"Getting more bytes.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="mi">311</span>         <span class="n">basePC</span> <span class="o">=</span> <span class="n">fetchPC</span><span class="p">;</span>
<span class="mi">312</span>         <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">fetchPC</span> <span class="o">&gt;=</span> <span class="n">pc</span><span class="p">.</span><span class="n">instAddr</span><span class="p">())</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">pc</span><span class="p">.</span><span class="n">instAddr</span><span class="p">()</span> <span class="o">-</span> <span class="n">fetchPC</span><span class="p">;</span>
<span class="mi">313</span>         <span class="n">fetchChunk</span> <span class="o">=</span> <span class="n">letoh</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="mi">314</span>         <span class="n">outOfBytes</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="mi">315</span>         <span class="nf">process</span><span class="p">();</span>
<span class="mi">316</span>     <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
</pre></td><td class="rouge-code"><pre> <span class="mi">74</span> <span class="n">Decoder</span><span class="o">::</span><span class="n">process</span><span class="p">()</span>
 <span class="mi">75</span> <span class="p">{</span>
 <span class="mi">76</span>     <span class="c1">//This function drives the decoder state machine.</span>
 <span class="mi">77</span> 
 <span class="mi">78</span>     <span class="c1">//Some sanity checks. You shouldn't try to process more bytes if</span>
 <span class="mi">79</span>     <span class="c1">//there aren't any, and you shouldn't overwrite an already</span>
 <span class="mi">80</span>     <span class="c1">//decoder ExtMachInst.</span>
 <span class="mi">81</span>     <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">outOfBytes</span><span class="p">);</span>
 <span class="mi">82</span>     <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">instDone</span><span class="p">);</span>
 <span class="mi">83</span> 
 <span class="mi">84</span>     <span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">ResetState</span><span class="p">)</span>
 <span class="mi">85</span>         <span class="n">state</span> <span class="o">=</span> <span class="n">doResetState</span><span class="p">();</span>
 <span class="mi">86</span>     <span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">FromCacheState</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">87</span>         <span class="n">state</span> <span class="o">=</span> <span class="n">doFromCacheState</span><span class="p">();</span>
 <span class="mi">88</span>     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
 <span class="mi">89</span>         <span class="n">instBytes</span><span class="o">-&gt;</span><span class="n">chunks</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">fetchChunk</span><span class="p">);</span>
 <span class="mi">90</span>     <span class="p">}</span>
 <span class="mi">91</span> 
 <span class="mi">92</span>     <span class="c1">//While there's still something to do...</span>
 <span class="mi">93</span>     <span class="nf">while</span> <span class="p">(</span><span class="o">!</span><span class="n">instDone</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">outOfBytes</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">94</span>         <span class="kt">uint8_t</span> <span class="n">nextByte</span> <span class="o">=</span> <span class="n">getNextByte</span><span class="p">();</span>
 <span class="mi">95</span>         <span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">96</span>           <span class="k">case</span> <span class="n">PrefixState</span><span class="p">:</span>
 <span class="mi">97</span>             <span class="n">state</span> <span class="o">=</span> <span class="n">doPrefixState</span><span class="p">(</span><span class="n">nextByte</span><span class="p">);</span>
 <span class="mi">98</span>             <span class="k">break</span><span class="p">;</span>
 <span class="mi">99</span>           <span class="k">case</span> <span class="n">Vex2Of2State</span><span class="p">:</span>
<span class="mi">100</span>             <span class="n">state</span> <span class="o">=</span> <span class="n">doVex2Of2State</span><span class="p">(</span><span class="n">nextByte</span><span class="p">);</span>
<span class="mi">101</span>             <span class="k">break</span><span class="p">;</span>
<span class="mi">102</span>           <span class="k">case</span> <span class="n">Vex2Of3State</span><span class="p">:</span>
<span class="mi">103</span>             <span class="n">state</span> <span class="o">=</span> <span class="n">doVex2Of3State</span><span class="p">(</span><span class="n">nextByte</span><span class="p">);</span>
<span class="mi">104</span>             <span class="k">break</span><span class="p">;</span>
<span class="mi">105</span>           <span class="k">case</span> <span class="n">Vex3Of3State</span><span class="p">:</span>
<span class="mi">106</span>             <span class="n">state</span> <span class="o">=</span> <span class="n">doVex3Of3State</span><span class="p">(</span><span class="n">nextByte</span><span class="p">);</span>
<span class="mi">107</span>             <span class="k">break</span><span class="p">;</span>
<span class="mi">108</span>           <span class="k">case</span> <span class="n">VexOpcodeState</span><span class="p">:</span>
<span class="mi">109</span>             <span class="n">state</span> <span class="o">=</span> <span class="n">doVexOpcodeState</span><span class="p">(</span><span class="n">nextByte</span><span class="p">);</span>
<span class="mi">110</span>             <span class="k">break</span><span class="p">;</span>
<span class="mi">111</span>           <span class="k">case</span> <span class="n">OneByteOpcodeState</span><span class="p">:</span>
<span class="mi">112</span>             <span class="n">state</span> <span class="o">=</span> <span class="n">doOneByteOpcodeState</span><span class="p">(</span><span class="n">nextByte</span><span class="p">);</span>
<span class="mi">113</span>             <span class="k">break</span><span class="p">;</span>
<span class="mi">114</span>           <span class="k">case</span> <span class="n">TwoByteOpcodeState</span><span class="p">:</span>
<span class="mi">115</span>             <span class="n">state</span> <span class="o">=</span> <span class="n">doTwoByteOpcodeState</span><span class="p">(</span><span class="n">nextByte</span><span class="p">);</span>
<span class="mi">116</span>             <span class="k">break</span><span class="p">;</span>
<span class="mi">117</span>           <span class="k">case</span> <span class="n">ThreeByte0F38OpcodeState</span><span class="p">:</span>
<span class="mi">118</span>             <span class="n">state</span> <span class="o">=</span> <span class="n">doThreeByte0F38OpcodeState</span><span class="p">(</span><span class="n">nextByte</span><span class="p">);</span>
<span class="mi">119</span>             <span class="k">break</span><span class="p">;</span>
<span class="mi">120</span>           <span class="k">case</span> <span class="n">ThreeByte0F3AOpcodeState</span><span class="p">:</span>
<span class="mi">121</span>             <span class="n">state</span> <span class="o">=</span> <span class="n">doThreeByte0F3AOpcodeState</span><span class="p">(</span><span class="n">nextByte</span><span class="p">);</span>
<span class="mi">122</span>             <span class="k">break</span><span class="p">;</span>
<span class="mi">123</span>           <span class="k">case</span> <span class="n">ModRMState</span><span class="p">:</span>
<span class="mi">124</span>             <span class="n">state</span> <span class="o">=</span> <span class="n">doModRMState</span><span class="p">(</span><span class="n">nextByte</span><span class="p">);</span>
<span class="mi">125</span>             <span class="k">break</span><span class="p">;</span>
<span class="mi">126</span>           <span class="k">case</span> <span class="n">SIBState</span><span class="p">:</span>
<span class="mi">127</span>             <span class="n">state</span> <span class="o">=</span> <span class="n">doSIBState</span><span class="p">(</span><span class="n">nextByte</span><span class="p">);</span>
<span class="mi">128</span>             <span class="k">break</span><span class="p">;</span>
<span class="mi">129</span>           <span class="k">case</span> <span class="n">DisplacementState</span><span class="p">:</span>
<span class="mi">130</span>             <span class="n">state</span> <span class="o">=</span> <span class="n">doDisplacementState</span><span class="p">();</span>
<span class="mi">131</span>             <span class="k">break</span><span class="p">;</span>
<span class="mi">132</span>           <span class="k">case</span> <span class="n">ImmediateState</span><span class="p">:</span>
<span class="mi">133</span>             <span class="n">state</span> <span class="o">=</span> <span class="n">doImmediateState</span><span class="p">();</span>
<span class="mi">134</span>             <span class="k">break</span><span class="p">;</span>
<span class="mi">135</span>           <span class="k">case</span> <span class="n">ErrorState</span><span class="p">:</span>
<span class="mi">136</span>             <span class="n">panic</span><span class="p">(</span><span class="s">"Went to the error state in the decoder.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="mi">137</span>           <span class="k">default</span><span class="o">:</span>
<span class="mi">138</span>             <span class="n">panic</span><span class="p">(</span><span class="s">"Unrecognized state! %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
<span class="mi">139</span>         <span class="p">}</span>
<span class="mi">140</span>     <span class="p">}</span>
<span class="mi">141</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>Based on the instruction format, 
different doXXX function will be invoked 
to parse the macroop instruction. 
First of all, it invokes doResetState for every macroop 
to initialize the variables representing the parsed instruction. 
Also it sets the origPC field as the PC address of the macroop instruction.
After the initialization, based on the instruction format, 
it will invoke different parsing code. 
Based on the n-1 byte(s) of the instruction,
next n(+1) bytes of the instruction’s format will be determined. 
Therefore, by parsing each byte one by one,
different format of the instruction can be fully decoded 
by the above process function.
During the parsing, it invokes consumeByte(s) function 
when a particular part of the instruction could be successfully decoded. 
The consumeByte function increases the offset variable of the decoder 
to present the length of the currently being parsed macroop. 
After the moreBytes finish the early decoding of the macroop instruction,
it sets the instDone as true. 
However, note that moreBytes and process function just parses 
the macroop instruction to excerpt some bytes 
dedicated for each part of the instruction 
such as Rex and modRM in x86 architecture. 
Therefore, we still need to decode the parsed instruction 
to understand what is this instruction!</p>

<h2 id="the-second-loop-to-process-each-instruction"><span class="me-2">The second loop to process each instruction</span><a href="#the-second-loop-to-process-each-instruction" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>
<p>After the decoder finishing early-decode of the macroop instruction, 
it encounters another loop that translate the macroop instruction 
into multiple microops if possible. 
Note that the processor pipeline 
executes the microops not the macroop instructions. 
Therefore, instead of the macroop, 
the microops should be inserted into the fetch queue.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="mi">1298</span>         <span class="c1">// Extract as many instructions and/or microops as we can from</span>
<span class="mi">1299</span>         <span class="c1">// the memory we've processed so far.</span>
<span class="mi">1300</span>         <span class="k">do</span> <span class="p">{</span>
<span class="p">......</span>
<span class="mi">1378</span>         <span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">curMacroop</span> <span class="o">||</span> <span class="n">decoder</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">instReady</span><span class="p">())</span> <span class="o">&amp;&amp;</span>
<span class="mi">1379</span>                  <span class="n">numInst</span> <span class="o">&lt;</span> <span class="n">fetchWidth</span> <span class="o">&amp;&amp;</span>
<span class="mi">1380</span>                  <span class="n">fetchQueue</span><span class="p">[</span><span class="n">tid</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">fetchQueueSize</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></div></div>

<p>As shown in the above code, the second loop continues 
until the curMacroop is not a NULL
or until the translation from the current macroop to the microops is fished 
and the fetchQueue is available to contain translated microops. 
Let’s take a look at the details of the second loop.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="rouge-code"><pre><span class="mi">1298</span>         <span class="c1">// Extract as many instructions and/or microops as we can from</span>
<span class="mi">1299</span>         <span class="c1">// the memory we've processed so far.</span>
<span class="mi">1300</span>         <span class="k">do</span> <span class="p">{</span>
<span class="mi">1301</span>             <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">curMacroop</span> <span class="o">||</span> <span class="n">inRom</span><span class="p">))</span> <span class="p">{</span>
<span class="mi">1302</span>                 <span class="k">if</span> <span class="p">(</span><span class="n">decoder</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">instReady</span><span class="p">())</span> <span class="p">{</span>
<span class="mi">1303</span>                     <span class="n">staticInst</span> <span class="o">=</span> <span class="n">decoder</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">decode</span><span class="p">(</span><span class="n">thisPC</span><span class="p">);</span>
<span class="mi">1304</span> 
<span class="mi">1305</span>                     <span class="c1">// Increment stat of fetched instructions.</span>
<span class="mi">1306</span>                     <span class="o">++</span><span class="n">fetchedInsts</span><span class="p">;</span>
<span class="mi">1307</span> 
<span class="mi">1308</span>                     <span class="k">if</span> <span class="p">(</span><span class="n">staticInst</span><span class="o">-&gt;</span><span class="n">isMacroop</span><span class="p">())</span> <span class="p">{</span>
<span class="mi">1309</span>                         <span class="n">curMacroop</span> <span class="o">=</span> <span class="n">staticInst</span><span class="p">;</span>
<span class="mi">1310</span>                     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="mi">1311</span>                         <span class="n">pcOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="mi">1312</span>                     <span class="p">}</span>
<span class="mi">1313</span>                 <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="mi">1314</span>                     <span class="c1">// We need more bytes for this instruction so blkOffset and</span>
<span class="mi">1315</span>                     <span class="c1">// pcOffset will be updated</span>
<span class="mi">1316</span>                     <span class="k">break</span><span class="p">;</span>
<span class="mi">1317</span>                 <span class="p">}</span>
<span class="mi">1318</span>             <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>Note that we haven’t assigned anything to curMacroop and executed the ROM code.
Also, decoder[tid]-&gt;instReady is true 
because the moreBytes function successfully pre-decoded the macroop instruction. 
Therefore, it will invoke the decode function to understand which instruction actually it is.
The decode function of the decoder generates the <strong>StaticInstPtr</strong> which has information
about the current instruction located at thisPC. 
In our case, because we are firstly executing the macroop instruction,
it should return the reference of the macroop instruction.
Let’s briefly take a look at the decode function.</p>

<p><em>gem5/src/arch/x86/decode.cc</em></p>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre></td><td class="rouge-code"><pre><span class="mi">693</span> <span class="n">StaticInstPtr</span>
<span class="mi">694</span> <span class="n">Decoder</span><span class="o">::</span><span class="n">decode</span><span class="p">(</span><span class="n">PCState</span> <span class="o">&amp;</span><span class="n">nextPC</span><span class="p">)</span>
<span class="mi">695</span> <span class="p">{</span>
<span class="mi">696</span>     <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">instDone</span><span class="p">)</span>
<span class="mi">697</span>         <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="mi">698</span>     <span class="n">instDone</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="mi">699</span>     <span class="n">updateNPC</span><span class="p">(</span><span class="n">nextPC</span><span class="p">);</span>
<span class="mi">700</span> 
<span class="mi">701</span>     <span class="n">StaticInstPtr</span> <span class="o">&amp;</span><span class="n">si</span> <span class="o">=</span> <span class="n">instBytes</span><span class="o">-&gt;</span><span class="n">si</span><span class="p">;</span>
<span class="mi">702</span>     <span class="k">if</span> <span class="p">(</span><span class="n">si</span><span class="p">)</span>
<span class="mi">703</span>         <span class="k">return</span> <span class="n">si</span><span class="p">;</span>
<span class="mi">704</span> 
<span class="mi">705</span>     <span class="c1">// We didn't match in the AddrMap, but we still populated an entry. Fix</span>
<span class="mi">706</span>     <span class="c1">// up its byte masks.</span>
<span class="mi">707</span>     <span class="k">const</span> <span class="kt">int</span> <span class="n">chunkSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">MachInst</span><span class="p">);</span>
<span class="mi">708</span> 
<span class="mi">709</span>     <span class="n">instBytes</span><span class="o">-&gt;</span><span class="n">lastOffset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
<span class="mi">710</span> 
<span class="mi">711</span>     <span class="n">Addr</span> <span class="n">firstBasePC</span> <span class="o">=</span> <span class="n">basePC</span> <span class="o">-</span> <span class="p">(</span><span class="n">instBytes</span><span class="o">-&gt;</span><span class="n">chunks</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">chunkSize</span><span class="p">;</span>
<span class="mi">712</span>     <span class="n">Addr</span> <span class="n">firstOffset</span> <span class="o">=</span> <span class="n">origPC</span> <span class="o">-</span> <span class="n">firstBasePC</span><span class="p">;</span>
<span class="mi">713</span>     <span class="n">Addr</span> <span class="n">totalSize</span> <span class="o">=</span> <span class="n">instBytes</span><span class="o">-&gt;</span><span class="n">lastOffset</span> <span class="o">-</span> <span class="n">firstOffset</span> <span class="o">+</span>
<span class="mi">714</span>         <span class="p">(</span><span class="n">instBytes</span><span class="o">-&gt;</span><span class="n">chunks</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">chunkSize</span><span class="p">;</span>
<span class="mi">715</span>     <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">firstOffset</span><span class="p">;</span>
<span class="mi">716</span>     <span class="n">instBytes</span><span class="o">-&gt;</span><span class="n">masks</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<span class="mi">717</span> 
<span class="mi">718</span>     <span class="k">while</span> <span class="p">(</span><span class="n">totalSize</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">719</span>         <span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">totalSize</span><span class="p">;</span>
<span class="mi">720</span>         <span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="n">chunkSize</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="o">?</span> <span class="n">chunkSize</span> <span class="o">:</span> <span class="n">end</span><span class="p">;</span>
<span class="mi">721</span>         <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
<span class="mi">722</span>         <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">instBytes</span><span class="o">-&gt;</span><span class="n">masks</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="mi">723</span> 
<span class="mi">724</span>         <span class="n">MachInst</span> <span class="n">maskVal</span> <span class="o">=</span> <span class="n">mask</span><span class="p">(</span><span class="n">size</span> <span class="o">*</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">start</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>
<span class="mi">725</span>         <span class="n">assert</span><span class="p">(</span><span class="n">maskVal</span><span class="p">);</span>
<span class="mi">726</span> 
<span class="mi">727</span>         <span class="n">instBytes</span><span class="o">-&gt;</span><span class="n">masks</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">maskVal</span><span class="p">);</span>
<span class="mi">728</span>         <span class="n">instBytes</span><span class="o">-&gt;</span><span class="n">chunks</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="n">instBytes</span><span class="o">-&gt;</span><span class="n">masks</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
<span class="mi">729</span>         <span class="n">totalSize</span> <span class="o">-=</span> <span class="n">size</span><span class="p">;</span>
<span class="mi">730</span>         <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="mi">731</span>     <span class="p">}</span>
<span class="mi">732</span> 
<span class="mi">733</span>     <span class="n">si</span> <span class="o">=</span> <span class="n">decode</span><span class="p">(</span><span class="n">emi</span><span class="p">,</span> <span class="n">origPC</span><span class="p">);</span>
<span class="mi">734</span>     <span class="k">return</span> <span class="n">si</span><span class="p">;</span>
<span class="mi">735</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>There are two important things to be done by the decode function. 
First, it invokes updateNPC to update the next pc 
based on the current instruction.
Also remember that the basePC has been set as fetchAddr 
when the moreBytes has been invoked.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre><span class="mi">328</span>     <span class="kt">void</span>
<span class="mi">329</span>     <span class="nf">updateNPC</span><span class="p">(</span><span class="n">X86ISA</span><span class="o">::</span><span class="n">PCState</span> <span class="o">&amp;</span><span class="n">nextPC</span><span class="p">)</span>
<span class="mi">330</span>     <span class="p">{</span>
<span class="mi">331</span>         <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nextPC</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
<span class="mi">332</span>             <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">basePC</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">-</span> <span class="n">origPC</span><span class="p">;</span>
<span class="mi">333</span>             <span class="n">DPRINTF</span><span class="p">(</span><span class="n">Decoder</span><span class="p">,</span>
<span class="mi">334</span>                     <span class="s">"Calculating the instruction size: "</span>
<span class="mi">335</span>                     <span class="s">"basePC: %#x offset: %#x origPC: %#x size: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
<span class="mi">336</span>                     <span class="n">basePC</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">origPC</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="mi">337</span>             <span class="n">nextPC</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
<span class="mi">338</span>             <span class="n">nextPC</span><span class="p">.</span><span class="n">npc</span><span class="p">(</span><span class="n">nextPC</span><span class="p">.</span><span class="n">pc</span><span class="p">()</span> <span class="o">+</span> <span class="n">size</span><span class="p">);</span>
<span class="mi">339</span>         <span class="p">}</span>
<span class="mi">340</span>     <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>Because decoder already knows the length of the instruction,
it can calculate the size of the instruction
and set the nextPC value as current PC + sizeof(instruction).
The npc function updates the _npc field of the nextPC, and 
it will be used to update the _pc member field of the PCState object later. 
Note that the nextPC is actually the thisPC variable
declared in the fetch function. 
It could be confusing because 
the fetch function also declares the nextPC variable, but 
updateNPC updates the npc of the thisPC not the nextPC variable of the fetch.
After updating the npc, 
the decode function invokes actual decode function.
Also it is important that the updateNPC function is only invoked 
when the curMacroop is set as NULL. 
While the microops of the macroop is fetched,
the npc will not be updated.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre><span class="mi">681</span> <span class="n">StaticInstPtr</span>
<span class="mi">682</span> <span class="n">Decoder</span><span class="o">::</span><span class="n">decode</span><span class="p">(</span><span class="n">ExtMachInst</span> <span class="n">mach_inst</span><span class="p">,</span> <span class="n">Addr</span> <span class="n">addr</span><span class="p">)</span>
<span class="mi">683</span> <span class="p">{</span>
<span class="mi">684</span>     <span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">instMap</span><span class="o">-&gt;</span><span class="n">find</span><span class="p">(</span><span class="n">mach_inst</span><span class="p">);</span>
<span class="mi">685</span>     <span class="k">if</span> <span class="p">(</span><span class="n">iter</span> <span class="o">!=</span> <span class="n">instMap</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">())</span>
<span class="mi">686</span>         <span class="k">return</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
<span class="mi">687</span> 
<span class="mi">688</span>     <span class="n">StaticInstPtr</span> <span class="n">si</span> <span class="o">=</span> <span class="n">decodeInst</span><span class="p">(</span><span class="n">mach_inst</span><span class="p">);</span>
<span class="mi">689</span>     <span class="p">(</span><span class="o">*</span><span class="n">instMap</span><span class="p">)[</span><span class="n">mach_inst</span><span class="p">]</span> <span class="o">=</span> <span class="n">si</span><span class="p">;</span>
<span class="mi">690</span>     <span class="k">return</span> <span class="n">si</span><span class="p">;</span>
<span class="mi">691</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>It traverses decode cache instMap 
to find the instruction object 
cached if the same instruction has been decoded earlier.
If not, it invokes decodeInst function 
automatically generated based on the python parser on the GEM5. 
We will not cover the details of the decodeInst function in this posting.
Let’s go back to the second loop again!
After the decode function execution, 
we can finally have the object 
associated with the decoded instruction. 
If the decoded instruction is the macroop, 
it sets the curMacroop as the returned staticInst.</p>

<h3 id="fetchmicroop-fetching-microops-from-the-macroop-or-rom"><span class="me-2">fetchMicroop: Fetching microops from the macroop or ROM</span><a href="#fetchmicroop-fetching-microops-from-the-macroop-or-rom" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre><span class="mi">1319</span>             <span class="c1">// Whether we're moving to a new macroop because we're at the</span>
<span class="mi">1320</span>             <span class="c1">// end of the current one, or the branch predictor incorrectly</span>
<span class="mi">1321</span>             <span class="c1">// thinks we are...</span>
<span class="mi">1322</span>             <span class="kt">bool</span> <span class="n">newMacro</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="mi">1323</span>             <span class="nf">if</span> <span class="p">(</span><span class="n">curMacroop</span> <span class="o">||</span> <span class="n">inRom</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1324</span>                 <span class="k">if</span> <span class="p">(</span><span class="n">inRom</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1325</span>                     <span class="n">staticInst</span> <span class="o">=</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">microcodeRom</span><span class="p">.</span><span class="n">fetchMicroop</span><span class="p">(</span>
<span class="mi">1326</span>                             <span class="n">thisPC</span><span class="p">.</span><span class="n">microPC</span><span class="p">(),</span> <span class="n">curMacroop</span><span class="p">);</span>
<span class="mi">1327</span>                 <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="mi">1328</span>                     <span class="n">staticInst</span> <span class="o">=</span> <span class="n">curMacroop</span><span class="o">-&gt;</span><span class="n">fetchMicroop</span><span class="p">(</span><span class="n">thisPC</span><span class="p">.</span><span class="n">microPC</span><span class="p">());</span>
<span class="mi">1329</span>                 <span class="p">}</span>
<span class="mi">1330</span>                 <span class="n">newMacro</span> <span class="o">|=</span> <span class="n">staticInst</span><span class="o">-&gt;</span><span class="n">isLastMicroop</span><span class="p">();</span>
<span class="mi">1331</span>             <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>The curMacroop is set as the macroop instruction pointed to by the PC.
However, to execute the instruction on the pipeline,
we should have access on the microops consisting of the current Macroop.
You might remember that the macroop consists of multiple microops). 
Also, it might remind you of the ROM code. 
Yeah, there are two places where the microops are used. 
Therefore, based on the current status of the processor, 
whether it executes the macroop or ROM code, 
it needs to fetch the microops 
from the relevant places. 
Regardless of its location,
GEM5 utilize the interface called <strong>fetchMicroop</strong>.
When the processor is in the midst of execution of ROM code, 
it invokes the fetchMicroop function from the microcodeRom.</p>

<p><em>gem5/src/arch/x86/microcode_rom.hh</em></p>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre> <span class="mi">60</span>         <span class="n">StaticInstPtr</span>
 <span class="mi">61</span>         <span class="nf">fetchMicroop</span><span class="p">(</span><span class="n">MicroPC</span> <span class="n">microPC</span><span class="p">,</span> <span class="n">StaticInstPtr</span> <span class="n">curMacroop</span><span class="p">)</span>
 <span class="mi">62</span>         <span class="p">{</span>
 <span class="mi">63</span>             <span class="n">microPC</span> <span class="o">=</span> <span class="n">normalMicroPC</span><span class="p">(</span><span class="n">microPC</span><span class="p">);</span>
 <span class="mi">64</span>             <span class="k">if</span> <span class="p">(</span><span class="n">microPC</span> <span class="o">&gt;=</span> <span class="n">numMicroops</span><span class="p">)</span>
 <span class="mi">65</span>                 <span class="k">return</span> <span class="n">X86ISA</span><span class="o">::</span><span class="n">badMicroop</span><span class="p">;</span>
 <span class="mi">66</span>             <span class="k">else</span>
 <span class="mi">67</span>                 <span class="k">return</span> <span class="n">genFuncs</span><span class="p">[</span><span class="n">microPC</span><span class="p">](</span><span class="n">curMacroop</span><span class="p">);</span>
 <span class="mi">68</span>         <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>Also when the processor is in the middle of executing the macroop,
it should ask the macroop to return microops consisting of it.</p>

<p><em>gem5/src/arch/x86/insts/macroop.hh</em></p>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre> <span class="mi">77</span>     <span class="n">StaticInstPtr</span>
 <span class="mi">78</span>     <span class="n">fetchMicroop</span><span class="p">(</span><span class="n">MicroPC</span> <span class="n">microPC</span><span class="p">)</span> <span class="k">const</span>
 <span class="mi">79</span>     <span class="p">{</span>
 <span class="mi">80</span>         <span class="k">if</span> <span class="p">(</span><span class="n">microPC</span> <span class="o">&gt;=</span> <span class="n">numMicroops</span><span class="p">)</span>
 <span class="mi">81</span>             <span class="k">return</span> <span class="n">badMicroop</span><span class="p">;</span>
 <span class="mi">82</span>         <span class="k">else</span>
 <span class="mi">83</span>             <span class="k">return</span> <span class="n">microops</span><span class="p">[</span><span class="n">microPC</span><span class="p">];</span>
 <span class="mi">84</span>     <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p><em>gem5/src/cpu/fetch_impl.hh</em></p>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="mi">1239</span>     <span class="n">StaticInstPtr</span> <span class="n">staticInst</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></div></div>
<p>The return value of the fetchMicroop function 
will be stored to the staticInst, which is the StaticInstPtr.
Therefore, it can points to any instructions.
Previously, the decoded macroops are pointed to by this staticInst variable. 
It provides a method to discern whether it is 
Macroop or Microop.</p>

<h3 id="populating-dynamic-instruction-object"><span class="me-2">Populating dynamic instruction object</span><a href="#populating-dynamic-instruction-object" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre><span class="mi">1332</span> 
<span class="mi">1333</span>             <span class="n">DynInstPtr</span> <span class="n">instruction</span> <span class="o">=</span>
<span class="mi">1334</span>                 <span class="nf">buildInst</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">staticInst</span><span class="p">,</span> <span class="n">curMacroop</span><span class="p">,</span>
<span class="mi">1335</span>                           <span class="n">thisPC</span><span class="p">,</span> <span class="n">nextPC</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="mi">1336</span> 
<span class="mi">1337</span>             <span class="n">ppFetch</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">(</span><span class="n">instruction</span><span class="p">);</span>
<span class="mi">1338</span>             <span class="n">numInst</span><span class="o">++</span><span class="p">;</span>
<span class="mi">1339</span> 
<span class="mi">1340</span> <span class="err">#</span><span class="k">if</span> <span class="n">TRACING_ON</span>
<span class="mi">1341</span>             <span class="nf">if</span> <span class="p">(</span><span class="n">DTRACE</span><span class="p">(</span><span class="n">O3PipeView</span><span class="p">))</span> <span class="p">{</span>
<span class="mi">1342</span>                 <span class="n">instruction</span><span class="o">-&gt;</span><span class="n">fetchTick</span> <span class="o">=</span> <span class="n">curTick</span><span class="p">();</span>
<span class="mi">1343</span>             <span class="p">}</span>
<span class="mi">1344</span> <span class="err">#</span><span class="n">endif</span>
</pre></td></tr></tbody></table></code></div></div>
<p>Now we have a <strong>macroop pointed to by curMacroop</strong> variable and 
its associated <strong>microop pointed to by staticInst</strong>. 
Using this information, the <strong>buildInst</strong> function 
populates the dynamic object representing one instruction
that can be really executed on the pipeline. 
One might ask why we need another object for instruction.
However, note that these objects are static instruction object, but
we need a dynamic instruction object 
that conveys all information required for executing the instruction
through the pipeline.
The dynamic instruction objects are populated for 
passing information of the instruction in between different pipeline stages. 
Therefore, the buildInst function generates the dynamic instruction 
and enqueues the instruction into the fetch queue 
to pass the instruction information to the next pipeline stages.
Let’s take a look at how the buildInst generates the dynamic instruction.</p>

<h2 id="buildinst-populating-microops-from-the-macroop"><span class="me-2">buildInst: populating microops from the macroop</span><a href="#buildinst-populating-microops-from-the-macroop" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="rouge-code"><pre><span class="mi">1102</span> <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Impl</span><span class="p">&gt;</span>
<span class="mi">1103</span> <span class="k">typename</span> <span class="n">Impl</span><span class="o">::</span><span class="n">DynInstPtr</span>
<span class="mi">1104</span> <span class="n">DefaultFetch</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;::</span><span class="n">buildInst</span><span class="p">(</span><span class="n">ThreadID</span> <span class="n">tid</span><span class="p">,</span> <span class="n">StaticInstPtr</span> <span class="n">staticInst</span><span class="p">,</span>
<span class="mi">1105</span>                               <span class="n">StaticInstPtr</span> <span class="n">curMacroop</span><span class="p">,</span> <span class="n">TheISA</span><span class="o">::</span><span class="n">PCState</span> <span class="n">thisPC</span><span class="p">,</span>
<span class="mi">1106</span>                               <span class="n">TheISA</span><span class="o">::</span><span class="n">PCState</span> <span class="n">nextPC</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">trace</span><span class="p">)</span>
<span class="mi">1107</span> <span class="p">{</span>
<span class="mi">1108</span>     <span class="c1">// Get a sequence number.</span>
<span class="mi">1109</span>     <span class="n">InstSeqNum</span> <span class="n">seq</span> <span class="o">=</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">getAndIncrementInstSeq</span><span class="p">();</span>
<span class="mi">1110</span> 
<span class="mi">1111</span>     <span class="c1">// Create a new DynInst from the instruction fetched.</span>
<span class="mi">1112</span>     <span class="n">DynInstPtr</span> <span class="n">instruction</span> <span class="o">=</span>
<span class="mi">1113</span>         <span class="k">new</span> <span class="n">DynInst</span><span class="p">(</span><span class="n">staticInst</span><span class="p">,</span> <span class="n">curMacroop</span><span class="p">,</span> <span class="n">thisPC</span><span class="p">,</span> <span class="n">nextPC</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
<span class="mi">1114</span>     <span class="n">instruction</span><span class="o">-&gt;</span><span class="n">setTid</span><span class="p">(</span><span class="n">tid</span><span class="p">);</span>
<span class="mi">1115</span> 
<span class="mi">1116</span>     <span class="n">instruction</span><span class="o">-&gt;</span><span class="n">setASID</span><span class="p">(</span><span class="n">tid</span><span class="p">);</span>
<span class="mi">1117</span> 
<span class="mi">1118</span>     <span class="n">instruction</span><span class="o">-&gt;</span><span class="n">setThreadState</span><span class="p">(</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">[</span><span class="n">tid</span><span class="p">]);</span>
<span class="mi">1119</span> 
<span class="mi">1120</span>     <span class="n">DPRINTF</span><span class="p">(</span><span class="n">Fetch</span><span class="p">,</span> <span class="s">"[tid:%i] Instruction PC %#x (%d) created "</span>
<span class="mi">1121</span>             <span class="s">"[sn:%lli].</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">tid</span><span class="p">,</span> <span class="n">thisPC</span><span class="p">.</span><span class="n">instAddr</span><span class="p">(),</span>
<span class="mi">1122</span>             <span class="n">thisPC</span><span class="p">.</span><span class="n">microPC</span><span class="p">(),</span> <span class="n">seq</span><span class="p">);</span>
<span class="mi">1123</span> 
<span class="mi">1124</span>     <span class="n">DPRINTF</span><span class="p">(</span><span class="n">Fetch</span><span class="p">,</span> <span class="s">"[tid:%i] Instruction is: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">tid</span><span class="p">,</span>
<span class="mi">1125</span>             <span class="n">instruction</span><span class="o">-&gt;</span><span class="n">staticInst</span><span class="o">-&gt;</span>
<span class="mi">1126</span>             <span class="n">disassemble</span><span class="p">(</span><span class="n">thisPC</span><span class="p">.</span><span class="n">instAddr</span><span class="p">()));</span>
</pre></td></tr></tbody></table></code></div></div>
<p>You can think of the DynInst as the meta data conveying all information
to execute one instruction.
After the instruction generation, 
it sets the thread specific information of the instruction (tid, ASID). 
Those information is required later in the execution stage
to understand which instruction has been issued by which thread.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre> <span class="mi">53</span> <span class="k">struct</span> <span class="nc">O3CPUImpl</span>
 <span class="mi">54</span> <span class="p">{</span>
 <span class="mi">55</span>     <span class="cm">/** The type of MachInst. */</span>
 <span class="mi">56</span>     <span class="k">typedef</span> <span class="n">TheISA</span><span class="o">::</span><span class="n">MachInst</span> <span class="n">MachInst</span><span class="p">;</span>
 <span class="mi">57</span>
 <span class="mi">58</span>     <span class="cm">/** The CPU policy to be used, which defines all of the CPU stages. */</span>
 <span class="mi">59</span>     <span class="k">typedef</span> <span class="n">SimpleCPUPolicy</span><span class="o">&lt;</span><span class="n">O3CPUImpl</span><span class="o">&gt;</span> <span class="n">CPUPol</span><span class="p">;</span>
 <span class="mi">60</span>
 <span class="mi">61</span>     <span class="cm">/** The DynInst type to be used. */</span>
 <span class="mi">62</span>     <span class="k">typedef</span> <span class="n">BaseO3DynInst</span><span class="o">&lt;</span><span class="n">O3CPUImpl</span><span class="o">&gt;</span> <span class="n">DynInst</span><span class="p">;</span>
 <span class="mi">63</span>
 <span class="mi">64</span>     <span class="cm">/** The refcounted DynInst pointer to be used.  In most cases this is
 65      *  what should be used, and not DynInst *.
 66      */</span>
 <span class="mi">67</span>     <span class="k">typedef</span> <span class="n">RefCountingPtr</span><span class="o">&lt;</span><span class="n">DynInst</span><span class="o">&gt;</span> <span class="n">DynInstPtr</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></div></div>

<p>The constructor call of the DynInst invokes 
the constructor of the BaseO3DynInst class 
and initialize its member field 
as described in the following constructor.</p>

<p><em>gem5/src/cpu/o3/dyn_inst_impl.hh</em></p>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre> <span class="mi">50</span> <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Impl</span><span class="p">&gt;</span>
 <span class="mi">51</span> <span class="n">BaseO3DynInst</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;::</span><span class="n">BaseO3DynInst</span><span class="p">(</span><span class="k">const</span> <span class="n">StaticInstPtr</span> <span class="o">&amp;</span><span class="n">staticInst</span><span class="p">,</span>
 <span class="mi">52</span>                                    <span class="k">const</span> <span class="n">StaticInstPtr</span> <span class="o">&amp;</span><span class="n">macroop</span><span class="p">,</span>
 <span class="mi">53</span>                                    <span class="n">TheISA</span><span class="o">::</span><span class="n">PCState</span> <span class="n">pc</span><span class="p">,</span> <span class="n">TheISA</span><span class="o">::</span><span class="n">PCState</span> <span class="n">predPC</span><span class="p">,</span>
 <span class="mi">54</span>                                    <span class="n">InstSeqNum</span> <span class="n">seq_num</span><span class="p">,</span> <span class="n">O3CPU</span> <span class="o">*</span><span class="n">cpu</span><span class="p">)</span>
 <span class="mi">55</span>     <span class="o">:</span> <span class="n">BaseDynInst</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;</span><span class="p">(</span><span class="n">staticInst</span><span class="p">,</span> <span class="n">macroop</span><span class="p">,</span> <span class="n">pc</span><span class="p">,</span> <span class="n">predPC</span><span class="p">,</span> <span class="n">seq_num</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span>
 <span class="mi">56</span> <span class="p">{</span>
 <span class="mi">57</span>     <span class="n">initVars</span><span class="p">();</span>
 <span class="mi">58</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>Let’s take a look at who derives the DynInstPtr then.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre> <span class="mi">97</span> <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Impl</span><span class="p">&gt;</span>
 <span class="mi">98</span> <span class="k">class</span> <span class="nc">FullO3CPU</span> <span class="o">:</span> <span class="k">public</span> <span class="n">BaseO3CPU</span>
 <span class="mi">99</span> <span class="p">{</span>
<span class="mi">100</span>   <span class="k">public</span><span class="o">:</span>
<span class="mi">101</span>     <span class="c1">// Typedefs from the Impl here.</span>
<span class="mi">102</span>     <span class="k">typedef</span> <span class="k">typename</span> <span class="n">Impl</span><span class="o">::</span><span class="n">CPUPol</span> <span class="n">CPUPolicy</span><span class="p">;</span>
<span class="mi">103</span>     <span class="k">typedef</span> <span class="k">typename</span> <span class="n">Impl</span><span class="o">::</span><span class="n">DynInstPtr</span> <span class="n">DynInstPtr</span><span class="p">;</span>
<span class="mi">104</span>     <span class="k">typedef</span> <span class="k">typename</span> <span class="n">Impl</span><span class="o">::</span><span class="n">O3CPU</span> <span class="n">O3CPU</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></div></div>
<p>As shown in the above code, 
the DynInstPtr is the Impl::DynInstPtr, 
which is the RefCountingPtr<DynInst> defined in the O3CPUImpl. 
The RefCountingPtr is the CPP template class defining all operations
such as equal sign that can assign new object of the template type and 
member field reference operator -&gt; to access the assigned object.
The only additional work done by this class is 
counting the reference for this object, 
and it can be utilized as the template typed object. 
Therefore, without knowing the details, 
the instruction variable can be utilized 
as a pointer referencing DynInst objects.</DynInst></p>

<h3 id="inserting-generated-dynamic-instructions-into-the-fetchqueue"><span class="me-2">Inserting generated dynamic instructions into the fetchQueue</span><a href="#inserting-generated-dynamic-instructions-into-the-fetchqueue" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="rouge-code"><pre><span class="mi">1127</span> 
<span class="mi">1128</span> <span class="err">#</span><span class="k">if</span> <span class="n">TRACING_ON</span>
<span class="mi">1129</span>     <span class="nf">if</span> <span class="p">(</span><span class="n">trace</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1130</span>         <span class="n">instruction</span><span class="o">-&gt;</span><span class="n">traceData</span> <span class="o">=</span>
<span class="mi">1131</span>             <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">getTracer</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getInstRecord</span><span class="p">(</span><span class="n">curTick</span><span class="p">(),</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">tcBase</span><span class="p">(</span><span class="n">tid</span><span class="p">),</span>
<span class="mi">1132</span>                     <span class="n">instruction</span><span class="o">-&gt;</span><span class="n">staticInst</span><span class="p">,</span> <span class="n">thisPC</span><span class="p">,</span> <span class="n">curMacroop</span><span class="p">);</span>
<span class="mi">1133</span>     <span class="p">}</span>
<span class="mi">1134</span> <span class="err">#</span><span class="k">else</span>
<span class="mi">1135</span>     <span class="n">instruction</span><span class="o">-&gt;</span><span class="n">traceData</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="mi">1136</span> <span class="err">#</span><span class="n">endif</span>
<span class="mi">1137</span> 
<span class="mi">1138</span>     <span class="c1">// Add instruction to the CPU's list of instructions.</span>
<span class="mi">1139</span>     <span class="n">instruction</span><span class="o">-&gt;</span><span class="n">setInstListIt</span><span class="p">(</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">addInst</span><span class="p">(</span><span class="n">instruction</span><span class="p">));</span>
<span class="mi">1140</span> 
<span class="mi">1141</span>     <span class="c1">// Write the instruction to the first slot in the queue</span>
<span class="mi">1142</span>     <span class="c1">// that heads to decode.</span>
<span class="mi">1143</span>     <span class="nf">assert</span><span class="p">(</span><span class="n">numInst</span> <span class="o">&lt;</span> <span class="n">fetchWidth</span><span class="p">);</span>
<span class="mi">1144</span>     <span class="n">fetchQueue</span><span class="p">[</span><span class="n">tid</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">instruction</span><span class="p">);</span>
<span class="mi">1145</span>     <span class="nf">assert</span><span class="p">(</span><span class="n">fetchQueue</span><span class="p">[</span><span class="n">tid</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">fetchQueueSize</span><span class="p">);</span>
<span class="mi">1146</span>     <span class="nf">DPRINTF</span><span class="p">(</span><span class="n">Fetch</span><span class="p">,</span> <span class="s">"[tid:%i] Fetch queue entry created (%i/%i).</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
<span class="mi">1147</span>             <span class="n">tid</span><span class="p">,</span> <span class="n">fetchQueue</span><span class="p">[</span><span class="n">tid</span><span class="p">].</span><span class="n">size</span><span class="p">(),</span> <span class="n">fetchQueueSize</span><span class="p">);</span>
<span class="mi">1148</span>     <span class="c1">//toDecode-&gt;insts[toDecode-&gt;size++] = instruction;</span>
<span class="mi">1149</span> 
<span class="mi">1150</span>     <span class="c1">// Keep track of if we can take an interrupt at this boundary</span>
<span class="mi">1151</span>     <span class="n">delayedCommit</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">=</span> <span class="n">instruction</span><span class="o">-&gt;</span><span class="n">isDelayedCommit</span><span class="p">();</span>
<span class="mi">1152</span> 
<span class="mi">1153</span>     <span class="k">return</span> <span class="n">instruction</span><span class="p">;</span>
<span class="mi">1154</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>After the dynamic instruction is populated, 
it should be inserted into the fetchQueue 
to pass the generated instructions to the next stage. 
Now let’s go back to the second loop of the fetch function</p>

<h2 id="updating-nextpc-and-handling-branch-instruction"><span class="me-2">Updating nextPC and handling branch instruction</span><a href="#updating-nextpc-and-handling-branch-instruction" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre><span class="mi">1346</span>             <span class="n">nextPC</span> <span class="o">=</span> <span class="n">thisPC</span><span class="p">;</span>
<span class="mi">1347</span> 
<span class="mi">1348</span>             <span class="c1">// If we're branching after this instruction, quit fetching</span>
<span class="mi">1349</span>             <span class="c1">// from the same block.</span>
<span class="mi">1350</span>             <span class="n">predictedBranch</span> <span class="o">|=</span> <span class="n">thisPC</span><span class="p">.</span><span class="n">branching</span><span class="p">();</span>
<span class="mi">1351</span>             <span class="n">predictedBranch</span> <span class="o">|=</span>
<span class="mi">1352</span>                 <span class="nf">lookupAndUpdateNextPC</span><span class="p">(</span><span class="n">instruction</span><span class="p">,</span> <span class="n">nextPC</span><span class="p">);</span>
<span class="mi">1353</span>             <span class="nf">if</span> <span class="p">(</span><span class="n">predictedBranch</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1354</span>                 <span class="n">DPRINTF</span><span class="p">(</span><span class="n">Fetch</span><span class="p">,</span> <span class="s">"Branch detected with PC = %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">thisPC</span><span class="p">);</span>
<span class="mi">1355</span>             <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>Until now, we have populated the microops and 
enqueued the generated instructions into the fetchQueue. 
To repeat this sequence of operations and fill the fetchQueue, 
the second loop should determine the nextPC to lookup. 
First of all, if the current instruction is one of the branching instructions,
the nextPC should be determined based on the execution result of 
branch prediction speculatively.</p>

<h3 id="lookupandupdatenextpc-determine-the-nextpc-based-on-control-flow-instruction"><span class="me-2">lookupAndUpdateNextPC: determine the nextPC based on control flow instruction</span><a href="#lookupandupdatenextpc-determine-the-nextpc-based-on-control-flow-instruction" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<p>The <strong>lookupAndUpdateNextPC</strong> determines the nextPC by checking 
whether the current instruction is the control flow instruction. 
Also, because O3 processor adopts branch predictor,
the lookupAndUpdateNextPC asks branch predictor 
whether it needs to change the nextPC 
if the current instruction is the branching instruction. 
Note that the lookupAndUpdateNextPC accepts the dynamic instruction 
we generated in the buildInst function.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre> <span class="mi">556</span> <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Impl</span><span class="p">&gt;</span>
 <span class="mi">557</span> <span class="kt">bool</span>
 <span class="mi">558</span> <span class="n">DefaultFetch</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;::</span><span class="n">lookupAndUpdateNextPC</span><span class="p">(</span>
 <span class="mi">559</span>         <span class="k">const</span> <span class="n">DynInstPtr</span> <span class="o">&amp;</span><span class="n">inst</span><span class="p">,</span> <span class="n">TheISA</span><span class="o">::</span><span class="n">PCState</span> <span class="o">&amp;</span><span class="n">nextPC</span><span class="p">)</span>
 <span class="mi">560</span> <span class="p">{</span>
 <span class="mi">561</span>     <span class="c1">// Do branch prediction check here.</span>
 <span class="mi">562</span>     <span class="c1">// A bit of a misnomer...next_PC is actually the current PC until</span>
 <span class="mi">563</span>     <span class="c1">// this function updates it.</span>
 <span class="mi">564</span>     <span class="kt">bool</span> <span class="n">predict_taken</span><span class="p">;</span>
 <span class="mi">565</span> 
 <span class="mi">566</span>     <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">isControl</span><span class="p">())</span> <span class="p">{</span>
 <span class="mi">567</span>         <span class="n">TheISA</span><span class="o">::</span><span class="n">advancePC</span><span class="p">(</span><span class="n">nextPC</span><span class="p">,</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">staticInst</span><span class="p">);</span>
 <span class="mi">568</span>         <span class="n">inst</span><span class="o">-&gt;</span><span class="n">setPredTarg</span><span class="p">(</span><span class="n">nextPC</span><span class="p">);</span>
 <span class="mi">569</span>         <span class="n">inst</span><span class="o">-&gt;</span><span class="n">setPredTaken</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
 <span class="mi">570</span>         <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
 <span class="mi">571</span>     <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>First of all, 
it can simply check if the current instruction affects execution control 
by invoking isControl method of the dynamic instruction. 
The isControl function of the dynamic instruction
just invokes the same method of the <strong>staticInst</strong> of the DynInst,
which is the static class representing <strong>microop operation</strong>. 
If the current instruction is not a control flow instruction,
it just updates nextPC by invoking <strong>advancePC</strong> function 
with the staticInst of the current dynamic instruction 
(because fetching is done with the macroop level).</p>

<h3 id="advancepc-advance-micro-pc-or-pc-based-on-the-architecture"><span class="me-2">advancePC: advance micro pc or pc based on the architecture</span><a href="#advancepc-advance-micro-pc-or-pc-based-on-the-architecture" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<p><em>gem5/src/arch/x86/utility.hh</em></p>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre> <span class="mi">78</span>     <span class="kr">inline</span> <span class="kt">void</span>
 <span class="mi">79</span>     <span class="nf">advancePC</span><span class="p">(</span><span class="n">PCState</span> <span class="o">&amp;</span><span class="n">pc</span><span class="p">,</span> <span class="k">const</span> <span class="n">StaticInstPtr</span> <span class="o">&amp;</span><span class="n">inst</span><span class="p">)</span>
 <span class="mi">80</span>     <span class="p">{</span>
 <span class="mi">81</span>         <span class="n">inst</span><span class="o">-&gt;</span><span class="n">advancePC</span><span class="p">(</span><span class="n">pc</span><span class="p">);</span>
 <span class="mi">82</span>     <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>The advancePC function invokes advancePC function 
of the StaticInstPtr class back to back. 
Because we are targeting X86 architecture,
the inst should be the object of the X86StaticInst class.</p>

<p><em>gem5/src/arch/x86/insts/static_inst.hh</em></p>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="rouge-code"><pre> <span class="mi">77</span>     <span class="cm">/**
 78      * Base class for all X86 static instructions.
 79      */</span>
 <span class="mi">80</span> 
 <span class="mi">81</span>     <span class="k">class</span> <span class="nc">X86StaticInst</span> <span class="o">:</span> <span class="k">public</span> <span class="n">StaticInst</span>
 <span class="mi">82</span>     <span class="p">{</span>
 <span class="mi">83</span>       <span class="k">protected</span><span class="o">:</span>
 <span class="mi">84</span>         <span class="c1">// Constructor.</span>
 <span class="mi">85</span>         <span class="n">X86StaticInst</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mnem</span><span class="p">,</span>
 <span class="mi">86</span>              <span class="n">ExtMachInst</span> <span class="n">_machInst</span><span class="p">,</span> <span class="n">OpClass</span> <span class="n">__opClass</span><span class="p">)</span>
 <span class="mi">87</span>                 <span class="o">:</span> <span class="n">StaticInst</span><span class="p">(</span><span class="n">mnem</span><span class="p">,</span> <span class="n">_machInst</span><span class="p">,</span> <span class="n">__opClass</span><span class="p">)</span>
 <span class="mi">88</span>             <span class="p">{</span>
 <span class="mi">89</span>             <span class="p">}</span>
<span class="p">......</span>
<span class="mi">179</span>         <span class="kt">void</span>
<span class="mi">180</span>         <span class="nf">advancePC</span><span class="p">(</span><span class="n">PCState</span> <span class="o">&amp;</span><span class="n">pcState</span><span class="p">)</span> <span class="k">const</span>
<span class="mi">181</span>         <span class="p">{</span>
<span class="mi">182</span>             <span class="n">pcState</span><span class="p">.</span><span class="n">advance</span><span class="p">();</span>
<span class="mi">183</span>         <span class="p">}</span>
<span class="mi">184</span>     <span class="p">};</span>
</pre></td></tr></tbody></table></code></div></div>

<p>Also, remind that 
X86 architecture executes the microop instead of the macroop.
Therefore, the StaticInstPtr points to microop object in x86.
Thus X86 on GEM5 provide another class 
called <strong>X86MicroopBase</strong> inheriting X86StaticInst class.</p>

<p><em>gem5/src/arch/x86/insts/microop.hh</em></p>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre></td><td class="rouge-code"><pre> <span class="mi">88</span>     <span class="c1">//A class which is the base of all x86 micro ops. It provides a function to</span>
 <span class="mi">89</span>     <span class="c1">//set necessary flags appropriately.</span>
 <span class="mi">90</span>     <span class="k">class</span> <span class="nc">X86MicroopBase</span> <span class="o">:</span> <span class="k">public</span> <span class="n">X86StaticInst</span>
 <span class="mi">91</span>     <span class="p">{</span>
 <span class="mi">92</span>       <span class="k">protected</span><span class="o">:</span>
 <span class="mi">93</span>         <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">instMnem</span><span class="p">;</span>
 <span class="mi">94</span>         <span class="kt">uint8_t</span> <span class="n">opSize</span><span class="p">;</span>
 <span class="mi">95</span>         <span class="kt">uint8_t</span> <span class="n">addrSize</span><span class="p">;</span>
 <span class="mi">96</span> 
 <span class="mi">97</span>         <span class="n">X86MicroopBase</span><span class="p">(</span><span class="n">ExtMachInst</span> <span class="n">_machInst</span><span class="p">,</span>
 <span class="mi">98</span>                 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mnem</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">_instMnem</span><span class="p">,</span>
 <span class="mi">99</span>                 <span class="kt">uint64_t</span> <span class="n">setFlags</span><span class="p">,</span> <span class="n">OpClass</span> <span class="n">__opClass</span><span class="p">)</span> <span class="o">:</span>
<span class="mi">100</span>             <span class="n">X86ISA</span><span class="o">::</span><span class="n">X86StaticInst</span><span class="p">(</span><span class="n">mnem</span><span class="p">,</span> <span class="n">_machInst</span><span class="p">,</span> <span class="n">__opClass</span><span class="p">),</span>
<span class="mi">101</span>             <span class="n">instMnem</span><span class="p">(</span><span class="n">_instMnem</span><span class="p">)</span>
<span class="mi">102</span>         <span class="p">{</span>
<span class="mi">103</span>             <span class="k">const</span> <span class="kt">int</span> <span class="n">ChunkSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="mi">104</span>             <span class="k">const</span> <span class="kt">int</span> <span class="n">Chunks</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">setFlags</span><span class="p">)</span> <span class="o">/</span> <span class="n">ChunkSize</span><span class="p">;</span>
<span class="mi">105</span> 
<span class="mi">106</span>             <span class="c1">// Since the bitset constructor can only handle unsigned long</span>
<span class="mi">107</span>             <span class="c1">// sized chunks, feed it those one at a time while oring them in.</span>
<span class="mi">108</span>             <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">Chunks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">109</span>                 <span class="kt">unsigned</span> <span class="n">shift</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">ChunkSize</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span>
<span class="mi">110</span>                 <span class="n">flags</span> <span class="o">|=</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">bitset</span><span class="o">&lt;</span><span class="n">Num_Flags</span><span class="o">&gt;</span><span class="p">(</span><span class="n">setFlags</span> <span class="o">&gt;&gt;</span> <span class="n">shift</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">shift</span><span class="p">);</span>
<span class="mi">111</span>             <span class="p">}</span>
<span class="mi">112</span>         <span class="p">}</span>
<span class="mi">113</span> 
<span class="mi">114</span>         <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">generateDisassembly</span><span class="p">(</span><span class="n">Addr</span> <span class="n">pc</span><span class="p">,</span>
<span class="mi">115</span>                 <span class="k">const</span> <span class="n">SymbolTable</span> <span class="o">*</span><span class="n">symtab</span><span class="p">)</span> <span class="k">const</span>
<span class="mi">116</span>         <span class="p">{</span>
<span class="mi">117</span>             <span class="n">std</span><span class="o">::</span><span class="n">stringstream</span> <span class="n">ss</span><span class="p">;</span>
<span class="mi">118</span> 
<span class="mi">119</span>             <span class="n">ccprintf</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="s">"</span><span class="se">\t</span><span class="s">%s.%s"</span><span class="p">,</span> <span class="n">instMnem</span><span class="p">,</span> <span class="n">mnemonic</span><span class="p">);</span>
<span class="mi">120</span> 
<span class="mi">121</span>             <span class="k">return</span> <span class="n">ss</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
<span class="mi">122</span>         <span class="p">}</span>
<span class="mi">123</span> 
<span class="mi">124</span>         <span class="kt">bool</span> <span class="n">checkCondition</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">condition</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="mi">125</span> 
<span class="mi">126</span>         <span class="kt">void</span>
<span class="mi">127</span>         <span class="nf">advancePC</span><span class="p">(</span><span class="n">PCState</span> <span class="o">&amp;</span><span class="n">pcState</span><span class="p">)</span> <span class="k">const</span>
<span class="mi">128</span>         <span class="p">{</span>
<span class="mi">129</span>             <span class="k">if</span> <span class="p">(</span><span class="n">flags</span><span class="p">[</span><span class="n">IsLastMicroop</span><span class="p">])</span>
<span class="mi">130</span>                 <span class="n">pcState</span><span class="p">.</span><span class="n">uEnd</span><span class="p">();</span>
<span class="mi">131</span>             <span class="k">else</span>
<span class="mi">132</span>                 <span class="n">pcState</span><span class="p">.</span><span class="n">uAdvance</span><span class="p">();</span>
<span class="mi">133</span>         <span class="p">}</span>
<span class="mi">134</span>     <span class="p">};</span>
</pre></td></tr></tbody></table></code></div></div>

<p>Based on whether it is the last microop, 
it invokes different function of the PCState, 
UEnd and uAdvance respectively. 
Here the pcState object is the architecture specific 
PCState object defined as below.</p>

<h3 id="pcstate-class"><span class="me-2">PCState class</span><a href="#pcstate-class" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<p><em>gem5/src/arch/x86/types.hh</em></p>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre><span class="mi">289</span>     <span class="k">class</span> <span class="nc">PCState</span> <span class="o">:</span> <span class="k">public</span> <span class="n">GenericISA</span><span class="o">::</span><span class="n">UPCState</span><span class="o">&lt;</span><span class="n">MachInst</span><span class="o">&gt;</span>
<span class="mi">290</span>     <span class="p">{</span>
<span class="mi">291</span>       <span class="k">protected</span><span class="o">:</span>
<span class="mi">292</span>         <span class="k">typedef</span> <span class="n">GenericISA</span><span class="o">::</span><span class="n">UPCState</span><span class="o">&lt;</span><span class="n">MachInst</span><span class="o">&gt;</span> <span class="n">Base</span><span class="p">;</span>
<span class="p">......</span>
<span class="mi">324</span>         <span class="kt">void</span>
<span class="mi">325</span>         <span class="n">advance</span><span class="p">()</span>
<span class="mi">326</span>         <span class="p">{</span>
<span class="mi">327</span>             <span class="n">Base</span><span class="o">::</span><span class="n">advance</span><span class="p">();</span>
<span class="mi">328</span>             <span class="n">_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="mi">329</span>         <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>Because the PCState doesn’t implement the uEnd and uAdvance function, 
we should take a look at its parent class,
GenericISA::UPCState<MachInst>.</MachInst></p>

<p><em>gem5/src/arch/generic/types.hh</em></p>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre></td><td class="rouge-code"><pre><span class="mi">193</span> <span class="c1">// A PC and microcode PC.</span>
<span class="mi">194</span> <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">MachInst</span><span class="p">&gt;</span>
<span class="mi">195</span> <span class="k">class</span> <span class="nc">UPCState</span> <span class="o">:</span> <span class="k">public</span> <span class="n">SimplePCState</span><span class="o">&lt;</span><span class="n">MachInst</span><span class="o">&gt;</span>
<span class="mi">196</span> <span class="p">{</span>
<span class="mi">197</span>   <span class="k">protected</span><span class="o">:</span>
<span class="mi">198</span>     <span class="k">typedef</span> <span class="n">SimplePCState</span><span class="o">&lt;</span><span class="n">MachInst</span><span class="o">&gt;</span> <span class="n">Base</span><span class="p">;</span>
<span class="mi">199</span> 
<span class="mi">200</span>     <span class="n">MicroPC</span> <span class="n">_upc</span><span class="p">;</span>
<span class="mi">201</span>     <span class="n">MicroPC</span> <span class="n">_nupc</span><span class="p">;</span>
<span class="mi">202</span> 
<span class="mi">203</span>   <span class="k">public</span><span class="o">:</span>
<span class="mi">204</span> 
<span class="mi">205</span>     <span class="n">MicroPC</span> <span class="n">upc</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_upc</span><span class="p">;</span> <span class="p">}</span>
<span class="mi">206</span>     <span class="kt">void</span> <span class="nf">upc</span><span class="p">(</span><span class="n">MicroPC</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="n">_upc</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span> <span class="p">}</span>
<span class="mi">207</span> 
<span class="mi">208</span>     <span class="n">MicroPC</span> <span class="n">nupc</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_nupc</span><span class="p">;</span> <span class="p">}</span>
<span class="mi">209</span>     <span class="kt">void</span> <span class="nf">nupc</span><span class="p">(</span><span class="n">MicroPC</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="n">_nupc</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span> <span class="p">}</span>
<span class="p">......</span>
<span class="mi">228</span>     <span class="kt">bool</span>
<span class="mi">229</span>     <span class="n">branching</span><span class="p">()</span> <span class="k">const</span>
<span class="mi">230</span>     <span class="p">{</span>
<span class="mi">231</span>         <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">npc</span><span class="p">()</span> <span class="o">!=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">pc</span><span class="p">()</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">MachInst</span><span class="p">)</span> <span class="o">||</span>
<span class="mi">232</span>                <span class="k">this</span><span class="o">-&gt;</span><span class="n">nupc</span><span class="p">()</span> <span class="o">!=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">upc</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="mi">233</span>     <span class="p">}</span>
<span class="mi">234</span> 
<span class="mi">235</span>     <span class="c1">// Advance the upc within the instruction.</span>
<span class="mi">236</span>     <span class="kt">void</span>
<span class="mi">237</span>     <span class="n">uAdvance</span><span class="p">()</span>
<span class="mi">238</span>     <span class="p">{</span>
<span class="mi">239</span>         <span class="n">_upc</span> <span class="o">=</span> <span class="n">_nupc</span><span class="p">;</span>
<span class="mi">240</span>         <span class="n">_nupc</span><span class="o">++</span><span class="p">;</span>
<span class="mi">241</span>     <span class="p">}</span>
<span class="mi">242</span> 
<span class="mi">243</span>     <span class="c1">// End the macroop by resetting the upc and advancing the regular pc.</span>
<span class="mi">244</span>     <span class="kt">void</span>
<span class="mi">245</span>     <span class="nf">uEnd</span><span class="p">()</span>
<span class="mi">246</span>     <span class="p">{</span>
<span class="mi">247</span>         <span class="k">this</span><span class="o">-&gt;</span><span class="n">advance</span><span class="p">();</span>
<span class="mi">248</span>         <span class="n">_upc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="mi">249</span>         <span class="n">_nupc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="mi">250</span>     <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>When uAdvance function is invoked, 
it just updates the <strong>_upc</strong> member field
representing the micro pc of the current hardware thread. 
However, when the uEnd is invoked, 
it should update the pc instead of the micro pc (upc).
Because UPCState doesn’t implement the PC related member fields and functions,
it invokes the advance function of its parent, SimplePCState. 
Note that PC represents microop, and 
upc represent instruction pointer among the microops 
consisting of one macroop.</p>

<p><em>gem5/src/arch/generic/types.hh</em></p>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre></td><td class="rouge-code"><pre><span class="mi">139</span> <span class="c1">// The most basic type of PC.</span>
<span class="mi">140</span> <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">MachInst</span><span class="p">&gt;</span>
<span class="mi">141</span> <span class="k">class</span> <span class="nc">SimplePCState</span> <span class="o">:</span> <span class="k">public</span> <span class="n">PCStateBase</span>
<span class="mi">142</span> <span class="p">{</span>
<span class="mi">143</span>   <span class="k">protected</span><span class="o">:</span>
<span class="mi">144</span>     <span class="k">typedef</span> <span class="n">PCStateBase</span> <span class="n">Base</span><span class="p">;</span>
<span class="mi">145</span> 
<span class="mi">146</span>   <span class="k">public</span><span class="o">:</span>
<span class="mi">147</span> 
<span class="mi">148</span>     <span class="n">Addr</span> <span class="n">pc</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_pc</span><span class="p">;</span> <span class="p">}</span>
<span class="mi">149</span>     <span class="kt">void</span> <span class="nf">pc</span><span class="p">(</span><span class="n">Addr</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="n">_pc</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span> <span class="p">}</span>
<span class="mi">150</span> 
<span class="mi">151</span>     <span class="n">Addr</span> <span class="n">npc</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_npc</span><span class="p">;</span> <span class="p">}</span>
<span class="mi">152</span>     <span class="kt">void</span> <span class="nf">npc</span><span class="p">(</span><span class="n">Addr</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="n">_npc</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span> <span class="p">}</span>
<span class="mi">153</span> 
<span class="mi">154</span>     <span class="kt">void</span>
<span class="mi">155</span>     <span class="nf">set</span><span class="p">(</span><span class="n">Addr</span> <span class="n">val</span><span class="p">)</span>
<span class="mi">156</span>     <span class="p">{</span>
<span class="mi">157</span>         <span class="n">pc</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
<span class="mi">158</span>         <span class="nf">npc</span><span class="p">(</span><span class="n">val</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">MachInst</span><span class="p">));</span>
<span class="mi">159</span>     <span class="p">};</span>
<span class="mi">160</span> 
<span class="mi">161</span>     <span class="kt">void</span>
<span class="mi">162</span>     <span class="nf">setNPC</span><span class="p">(</span><span class="n">Addr</span> <span class="n">val</span><span class="p">)</span>
<span class="mi">163</span>     <span class="p">{</span>
<span class="mi">164</span>         <span class="n">npc</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
<span class="mi">165</span>     <span class="p">}</span>
<span class="mi">166</span> 
<span class="mi">167</span>     <span class="nf">SimplePCState</span><span class="p">()</span> <span class="p">{}</span>
<span class="mi">168</span>     <span class="nf">SimplePCState</span><span class="p">(</span><span class="n">Addr</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="n">set</span><span class="p">(</span><span class="n">val</span><span class="p">);</span> <span class="p">}</span>
<span class="mi">169</span> 
<span class="mi">170</span>     <span class="kt">bool</span>
<span class="mi">171</span>     <span class="nf">branching</span><span class="p">()</span> <span class="k">const</span>
<span class="mi">172</span>     <span class="p">{</span>
<span class="mi">173</span>         <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">npc</span><span class="p">()</span> <span class="o">!=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">pc</span><span class="p">()</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">MachInst</span><span class="p">);</span>
<span class="mi">174</span>     <span class="p">}</span>
<span class="mi">175</span> 
<span class="mi">176</span>     <span class="c1">// Advance the PC.</span>
<span class="mi">177</span>     <span class="kt">void</span>
<span class="mi">178</span>     <span class="n">advance</span><span class="p">()</span>
<span class="mi">179</span>     <span class="p">{</span>
<span class="mi">180</span>         <span class="n">_pc</span> <span class="o">=</span> <span class="n">_npc</span><span class="p">;</span>
<span class="mi">181</span>         <span class="n">_npc</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">MachInst</span><span class="p">);</span>
<span class="mi">182</span>     <span class="p">}</span>
<span class="mi">183</span> <span class="p">};</span>
</pre></td></tr></tbody></table></code></div></div>

<p>It just updates the _pc as the _npc 
which was as a result of 
adding size of macroop instruction to the current pc. 
In other words, if it is not a control flow instruction, 
just adding the size of current instruction to the pc is enough 
to get the next pc address.</p>

<h3 id="asking-branch-predictor-for-a-control-flow-instruction"><span class="me-2">Asking branch predictor for a control flow instruction</span><a href="#asking-branch-predictor-for-a-control-flow-instruction" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<p>Now let’s go back to the rest of the lookupAndUpdateNextPC function to understand
what happens if the current instruction turns out to be control flow instruction.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="rouge-code"><pre> <span class="mi">572</span> 
 <span class="mi">573</span>     <span class="n">ThreadID</span> <span class="n">tid</span> <span class="o">=</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">threadNumber</span><span class="p">;</span>
 <span class="mi">574</span>     <span class="n">predict_taken</span> <span class="o">=</span> <span class="n">branchPred</span><span class="o">-&gt;</span><span class="n">predict</span><span class="p">(</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">staticInst</span><span class="p">,</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">seqNum</span><span class="p">,</span>
 <span class="mi">575</span>                                         <span class="n">nextPC</span><span class="p">,</span> <span class="n">tid</span><span class="p">);</span>
 <span class="mi">576</span> 
 <span class="mi">577</span>     <span class="nf">if</span> <span class="p">(</span><span class="n">predict_taken</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">578</span>         <span class="n">DPRINTF</span><span class="p">(</span><span class="n">Fetch</span><span class="p">,</span> <span class="s">"[tid:%i] [sn:%llu] Branch at PC %#x "</span>
 <span class="mi">579</span>                 <span class="s">"predicted to be taken to %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
 <span class="mi">580</span>                 <span class="n">tid</span><span class="p">,</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">seqNum</span><span class="p">,</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">pcState</span><span class="p">().</span><span class="n">instAddr</span><span class="p">(),</span> <span class="n">nextPC</span><span class="p">);</span>
 <span class="mi">581</span>     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
 <span class="mi">582</span>         <span class="n">DPRINTF</span><span class="p">(</span><span class="n">Fetch</span><span class="p">,</span> <span class="s">"[tid:%i] [sn:%llu] Branch at PC %#x "</span>
 <span class="mi">583</span>                 <span class="s">"predicted to be not taken</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
 <span class="mi">584</span>                 <span class="n">tid</span><span class="p">,</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">seqNum</span><span class="p">,</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">pcState</span><span class="p">().</span><span class="n">instAddr</span><span class="p">());</span>
 <span class="mi">585</span>     <span class="p">}</span>
 <span class="mi">586</span> 
 <span class="mi">587</span>     <span class="nf">DPRINTF</span><span class="p">(</span><span class="n">Fetch</span><span class="p">,</span> <span class="s">"[tid:%i] [sn:%llu] Branch at PC %#x "</span>
 <span class="mi">588</span>             <span class="s">"predicted to go to %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
 <span class="mi">589</span>             <span class="n">tid</span><span class="p">,</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">seqNum</span><span class="p">,</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">pcState</span><span class="p">().</span><span class="n">instAddr</span><span class="p">(),</span> <span class="n">nextPC</span><span class="p">);</span>
 <span class="mi">590</span>     <span class="n">inst</span><span class="o">-&gt;</span><span class="n">setPredTarg</span><span class="p">(</span><span class="n">nextPC</span><span class="p">);</span>
 <span class="mi">591</span>     <span class="n">inst</span><span class="o">-&gt;</span><span class="n">setPredTaken</span><span class="p">(</span><span class="n">predict_taken</span><span class="p">);</span>
 <span class="mi">592</span> 
 <span class="mi">593</span>     <span class="o">++</span><span class="n">fetchedBranches</span><span class="p">;</span>
 <span class="mi">594</span> 
 <span class="mi">595</span>     <span class="nf">if</span> <span class="p">(</span><span class="n">predict_taken</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">596</span>         <span class="o">++</span><span class="n">predictedBranches</span><span class="p">;</span>
 <span class="mi">597</span>     <span class="p">}</span>
 <span class="mi">598</span> 
 <span class="mi">599</span>     <span class="k">return</span> <span class="n">predict_taken</span><span class="p">;</span>
 <span class="mi">600</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>It invokes the predict function and store the return value to the predict_taken.
The predict function returns the prediction result, 
whether the branching instruction should be taken or not-taken 
(when it is not a control flow instruction, it returns not-taken 
to allow the next following instructions to be executed sequentially). 
Also, note that the reference of the <strong>nextPC</strong> is passed to the branch predictor. 
This is because the prediction affects the next instruction’s address.
Therefore, based on the prediction result, it changes the nextPC 
to make the fetch stage to fetch instructions from the proper location.</p>

<h3 id="end-of-the-second-loop"><span class="me-2">End of the second loop</span><a href="#end-of-the-second-loop" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="mi">1356</span> 
<span class="mi">1357</span>             <span class="n">newMacro</span> <span class="o">|=</span> <span class="n">thisPC</span><span class="p">.</span><span class="n">instAddr</span><span class="p">()</span> <span class="o">!=</span> <span class="n">nextPC</span><span class="p">.</span><span class="n">instAddr</span><span class="p">();</span>
<span class="mi">1358</span> 
</pre></td></tr></tbody></table></code></div></div>

<p>Remind that we are currently executing the second loop 
to translate curMacroop to microops. 
However, when one of its microop turns out to be a control flow instruction
and is predicted to be taken, 
it should change the PC.
For that purpose, it checks the PC addresses of the thisPC and nextPC.
Previously, before invoking the lookupAndUpdateNextPC function,
it has allocated the thisPC to the nextPC (line 1346). 
However, when the prediction made as a taken,
pc address of the nextPC will be changed to the location of the taken branch. 
Therefore, by comparing pc addresses of nextPC and thisPC, we can understand that 
whether we are facing another macroop or still executing the microops 
of the current macroop (line 1357).</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
</pre></td><td class="rouge-code"><pre> <span class="mi">53</span> <span class="c1">// The guaranteed interface.</span>
 <span class="mi">54</span> <span class="k">class</span> <span class="nc">PCStateBase</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Serializable</span>
 <span class="mi">55</span> <span class="p">{</span>
 <span class="mi">56</span>   <span class="k">protected</span><span class="o">:</span>
 <span class="mi">57</span>     <span class="n">Addr</span> <span class="n">_pc</span><span class="p">;</span>
 <span class="mi">58</span>     <span class="n">Addr</span> <span class="n">_npc</span><span class="p">;</span>
 <span class="mi">59</span> 
 <span class="mi">60</span>     <span class="n">PCStateBase</span><span class="p">()</span> <span class="o">:</span> <span class="n">_pc</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">_npc</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
 <span class="mi">61</span>     <span class="nf">PCStateBase</span><span class="p">(</span><span class="n">Addr</span> <span class="n">val</span><span class="p">)</span> <span class="o">:</span> <span class="n">_pc</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">_npc</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="n">set</span><span class="p">(</span><span class="n">val</span><span class="p">);</span> <span class="p">}</span>
 <span class="mi">62</span> 
 <span class="mi">63</span>   <span class="k">public</span><span class="o">:</span>
 <span class="mi">64</span>     <span class="cm">/**
 65      * Returns the memory address the bytes of this instruction came from.
 66      *
 67      * @return Memory address of the current instruction's encoding.
 68      */</span>
 <span class="mi">69</span>     <span class="n">Addr</span>
 <span class="mi">70</span>     <span class="n">instAddr</span><span class="p">()</span> <span class="k">const</span>
 <span class="mi">71</span>     <span class="p">{</span>
 <span class="mi">72</span>         <span class="k">return</span> <span class="n">_pc</span><span class="p">;</span>
 <span class="mi">73</span>     <span class="p">}</span>
 <span class="mi">74</span> 
 <span class="mi">75</span>     <span class="cm">/**
 76      * Returns the memory address the bytes of the next instruction came from.
 77      *
 78      * @return Memory address of the next instruction's encoding.
 79      */</span>
 <span class="mi">80</span>     <span class="n">Addr</span>
 <span class="mi">81</span>     <span class="n">nextInstAddr</span><span class="p">()</span> <span class="k">const</span>
 <span class="mi">82</span>     <span class="p">{</span>
 <span class="mi">83</span>         <span class="k">return</span> <span class="n">_npc</span><span class="p">;</span>
 <span class="mi">84</span>     <span class="p">}</span>
 <span class="mi">85</span> 
 <span class="mi">86</span>     <span class="cm">/**
 87      * Returns the current micropc.
 88      *
 89      * @return The current micropc.
 90      */</span>
 <span class="mi">91</span>     <span class="n">MicroPC</span>
 <span class="mi">92</span>     <span class="n">microPC</span><span class="p">()</span> <span class="k">const</span>
 <span class="mi">93</span>     <span class="p">{</span>
 <span class="mi">94</span>         <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
 <span class="mi">95</span>     <span class="p">}</span>


<span class="n">After</span> <span class="n">the</span> <span class="n">newMacro</span> <span class="n">flag</span> <span class="n">has</span> <span class="n">been</span> <span class="n">set</span><span class="p">,</span>
<span class="n">it</span> <span class="n">assigns</span> <span class="n">the</span> <span class="n">nextPC</span> <span class="n">to</span> <span class="n">the</span> <span class="n">thisPC</span><span class="p">.</span> 
<span class="n">One</span> <span class="n">might</span> <span class="n">think</span> <span class="n">that</span> <span class="n">nextPC</span> <span class="n">will</span> <span class="n">equal</span> <span class="n">to</span> <span class="n">the</span> <span class="n">thisPC</span>
<span class="n">when</span> <span class="n">the</span> <span class="n">branch</span> <span class="n">prediction</span> <span class="n">is</span> <span class="n">made</span> <span class="n">to</span> <span class="n">be</span> <span class="n">not</span><span class="o">-</span><span class="n">taken</span><span class="p">,</span> 
<span class="n">but</span> <span class="n">the</span> <span class="n">lookupAndUpdateNextPC</span> <span class="n">advances</span> <span class="n">micro</span><span class="o">-</span><span class="n">pc</span> <span class="n">by</span> <span class="n">invoking</span>
<span class="n">advancePC</span> <span class="n">function</span> <span class="n">when</span> <span class="n">the</span> <span class="n">instruction</span> <span class="n">is</span> <span class="n">not</span> <span class="n">a</span> <span class="n">control</span> <span class="n">flow</span> 
<span class="n">or</span> <span class="n">predicted</span> <span class="n">as</span> <span class="n">not</span><span class="o">-</span><span class="n">taken</span><span class="p">.</span> 

<span class="err">```</span><span class="n">cpp</span>
<span class="mi">1359</span>             <span class="c1">// Move to the next instruction, unless we have a branch.</span>
<span class="mi">1360</span>             <span class="n">thisPC</span> <span class="o">=</span> <span class="n">nextPC</span><span class="p">;</span>
<span class="mi">1361</span>             <span class="n">inRom</span> <span class="o">=</span> <span class="n">isRomMicroPC</span><span class="p">(</span><span class="n">thisPC</span><span class="p">.</span><span class="n">microPC</span><span class="p">());</span>
<span class="mi">1362</span> 
<span class="mi">1363</span>             <span class="nf">if</span> <span class="p">(</span><span class="n">newMacro</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1364</span>                 <span class="n">fetchAddr</span> <span class="o">=</span> <span class="n">thisPC</span><span class="p">.</span><span class="n">instAddr</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">BaseCPU</span><span class="o">::</span><span class="n">PCMask</span><span class="p">;</span>
<span class="mi">1365</span>                 <span class="n">blkOffset</span> <span class="o">=</span> <span class="p">(</span><span class="n">fetchAddr</span> <span class="o">-</span> <span class="n">fetchBufferPC</span><span class="p">[</span><span class="n">tid</span><span class="p">])</span> <span class="o">/</span> <span class="n">instSize</span><span class="p">;</span>
<span class="mi">1366</span>                 <span class="n">pcOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="mi">1367</span>                 <span class="n">curMacroop</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="mi">1368</span>             <span class="p">}</span>
<span class="mi">1369</span> 
<span class="mi">1370</span>             <span class="nf">if</span> <span class="p">(</span><span class="n">instruction</span><span class="o">-&gt;</span><span class="n">isQuiesce</span><span class="p">())</span> <span class="p">{</span>
<span class="mi">1371</span>                 <span class="n">DPRINTF</span><span class="p">(</span><span class="n">Fetch</span><span class="p">,</span>
<span class="mi">1372</span>                         <span class="s">"Quiesce instruction encountered, halting fetch!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="mi">1373</span>                 <span class="n">fetchStatus</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">=</span> <span class="n">QuiescePending</span><span class="p">;</span>
<span class="mi">1374</span>                 <span class="n">status_change</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="mi">1375</span>                 <span class="n">quiesce</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="mi">1376</span>                 <span class="k">break</span><span class="p">;</span>
<span class="mi">1377</span>             <span class="p">}</span>
<span class="mi">1378</span>         <span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">curMacroop</span> <span class="o">||</span> <span class="n">decoder</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">instReady</span><span class="p">())</span> <span class="o">&amp;&amp;</span>
<span class="mi">1379</span>                  <span class="n">numInst</span> <span class="o">&lt;</span> <span class="n">fetchWidth</span> <span class="o">&amp;&amp;</span>
<span class="mi">1380</span>                  <span class="n">fetchQueue</span><span class="p">[</span><span class="n">tid</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">fetchQueueSize</span><span class="p">);</span>
<span class="mi">1381</span>
<span class="mi">1382</span>         <span class="c1">// Re-evaluate whether the next instruction to fetch is in micro-op ROM</span>
<span class="mi">1383</span>         <span class="c1">// or not.</span>
</pre></td></tr></tbody></table></code></div></div>

<p>If the newMacro flag is set to true, 
then it should updates the addresses required to fetch next instruction
and set the curMacroop as NULL.
Therefore, when the new macroop is found, 
the second loop will exit and 
try to continue executing the first loop.</p>

<h2 id="end-of-the-first-loop-and-rest"><span class="me-2">End of the first loop and rest</span><a href="#end-of-the-first-loop-and-rest" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre><span class="mi">1263</span>     <span class="c1">// Loop through instruction memory from the cache.</span>
<span class="mi">1264</span>     <span class="c1">// Keep issuing while fetchWidth is available and branch is not</span>
<span class="mi">1265</span>     <span class="c1">// predicted taken</span>
<span class="mi">1266</span>     <span class="nf">while</span> <span class="p">(</span><span class="n">numInst</span> <span class="o">&lt;</span> <span class="n">fetchWidth</span> <span class="o">&amp;&amp;</span> <span class="n">fetchQueue</span><span class="p">[</span><span class="n">tid</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">fetchQueueSize</span>
<span class="mi">1267</span>            <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">predictedBranch</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">quiesce</span><span class="p">)</span> <span class="p">{</span>
<span class="p">......</span>
<span class="mi">1382</span>         <span class="c1">// Re-evaluate whether the next instruction to fetch is in micro-op ROM</span>
<span class="mi">1383</span>         <span class="c1">// or not.</span>
<span class="mi">1384</span>         <span class="n">inRom</span> <span class="o">=</span> <span class="n">isRomMicroPC</span><span class="p">(</span><span class="n">thisPC</span><span class="p">.</span><span class="n">microPC</span><span class="p">());</span>
<span class="mi">1385</span>     <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>After translating macroop to microops by executing the second loop,
it should continue execution on the first loop. 
As we checked before,
when the number of fetched instruction does not exceed the fetchWidth (bandwidth)
and fetchQueue does not overflow and branch prediction is not made, 
it will continue the all the logic that we checked until now will be repeated. 
Then what should be done when the first loop exits?</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="rouge-code"><pre><span class="mi">1386</span>
<span class="mi">1387</span>     <span class="nf">if</span> <span class="p">(</span><span class="n">predictedBranch</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1388</span>         <span class="n">DPRINTF</span><span class="p">(</span><span class="n">Fetch</span><span class="p">,</span> <span class="s">"[tid:%i] Done fetching, predicted branch "</span>
<span class="mi">1389</span>                 <span class="s">"instruction encountered.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">tid</span><span class="p">);</span>
<span class="mi">1390</span>     <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">numInst</span> <span class="o">&gt;=</span> <span class="n">fetchWidth</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1391</span>         <span class="n">DPRINTF</span><span class="p">(</span><span class="n">Fetch</span><span class="p">,</span> <span class="s">"[tid:%i] Done fetching, reached fetch bandwidth "</span>
<span class="mi">1392</span>                 <span class="s">"for this cycle.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">tid</span><span class="p">);</span>
<span class="mi">1393</span>     <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">blkOffset</span> <span class="o">&gt;=</span> <span class="n">fetchBufferSize</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1394</span>         <span class="n">DPRINTF</span><span class="p">(</span><span class="n">Fetch</span><span class="p">,</span> <span class="s">"[tid:%i] Done fetching, reached the end of the"</span>
<span class="mi">1395</span>                 <span class="s">"fetch buffer.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">tid</span><span class="p">);</span>
<span class="mi">1396</span>     <span class="p">}</span>
<span class="mi">1397</span> 
<span class="mi">1398</span>     <span class="n">macroop</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">=</span> <span class="n">curMacroop</span><span class="p">;</span>
<span class="mi">1399</span>     <span class="n">fetchOffset</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">=</span> <span class="n">pcOffset</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></div></div>
<p>First it prints out debugging messages based on the exit condition of the first loop.
And then it updates the macroop of the current hardware thread with the 
curMacroop. Also the fetchOffset will be updated with pcOffset.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre><span class="mi">1400</span> 
<span class="mi">1401</span>     <span class="nf">if</span> <span class="p">(</span><span class="n">numInst</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1402</span>         <span class="n">wroteToTimeBuffer</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="mi">1403</span>     <span class="p">}</span>
<span class="mi">1404</span> 
<span class="mi">1405</span>     <span class="n">pc</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">=</span> <span class="n">thisPC</span><span class="p">;</span>
<span class="mi">1406</span> 
<span class="mi">1407</span>     <span class="c1">// pipeline a fetch if we're crossing a fetch buffer boundary and not in</span>
<span class="mi">1408</span>     <span class="c1">// a state that would preclude fetching</span>
<span class="mi">1409</span>     <span class="n">fetchAddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">thisPC</span><span class="p">.</span><span class="n">instAddr</span><span class="p">()</span> <span class="o">+</span> <span class="n">pcOffset</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">BaseCPU</span><span class="o">::</span><span class="n">PCMask</span><span class="p">;</span>
<span class="mi">1410</span>     <span class="n">Addr</span> <span class="n">fetchBufferBlockPC</span> <span class="o">=</span> <span class="n">fetchBufferAlignPC</span><span class="p">(</span><span class="n">fetchAddr</span><span class="p">);</span>
<span class="mi">1411</span>     <span class="n">issuePipelinedIfetch</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">=</span> <span class="n">fetchBufferBlockPC</span> <span class="o">!=</span> <span class="n">fetchBufferPC</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
<span class="mi">1412</span>         <span class="n">fetchStatus</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">!=</span> <span class="n">IcacheWaitResponse</span> <span class="o">&amp;&amp;</span>
<span class="mi">1413</span>         <span class="n">fetchStatus</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ItlbWait</span> <span class="o">&amp;&amp;</span>
<span class="mi">1414</span>         <span class="n">fetchStatus</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">!=</span> <span class="n">IcacheWaitRetry</span> <span class="o">&amp;&amp;</span>
<span class="mi">1415</span>         <span class="n">fetchStatus</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">!=</span> <span class="n">QuiescePending</span> <span class="o">&amp;&amp;</span>
<span class="mi">1416</span>         <span class="o">!</span><span class="n">curMacroop</span><span class="p">;</span>
<span class="mi">1417</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<h2 id="rest-of-the-tick-function-of-the-fetch"><span class="me-2">Rest of the tick function of the fetch.</span><a href="#rest-of-the-tick-function-of-the-fetch" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>
<h3 id="issuing-the-icache-access-for-split-accessxxxtodo"><span class="me-2">Issuing the Icache access for split access?\XXX{TODO}</span><a href="#issuing-the-icache-access-for-split-accessxxxtodo" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="rouge-code"><pre> <span class="mi">936</span>     <span class="c1">// Record number of instructions fetched this cycle for distribution.</span>
 <span class="mi">937</span>     <span class="n">fetchNisnDist</span><span class="p">.</span><span class="n">sample</span><span class="p">(</span><span class="n">numInst</span><span class="p">);</span>
 <span class="mi">938</span> 
 <span class="mi">939</span>     <span class="nf">if</span> <span class="p">(</span><span class="n">status_change</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">940</span>         <span class="c1">// Change the fetch stage status if there was a status change.</span>
 <span class="mi">941</span>         <span class="n">_status</span> <span class="o">=</span> <span class="n">updateFetchStatus</span><span class="p">();</span>
 <span class="mi">942</span>     <span class="p">}</span>
 <span class="mi">943</span> 
 <span class="mi">944</span>     <span class="c1">// Issue the next I-cache request if possible.</span>
 <span class="mi">945</span>     <span class="k">for</span> <span class="p">(</span><span class="n">ThreadID</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numThreads</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">946</span>         <span class="k">if</span> <span class="p">(</span><span class="n">issuePipelinedIfetch</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
 <span class="mi">947</span>             <span class="n">pipelineIcacheAccesses</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
 <span class="mi">948</span>         <span class="p">}</span>
 <span class="mi">949</span>     <span class="p">}</span>
 <span class="mi">950</span> 
 <span class="mi">951</span>     <span class="c1">// Send instructions enqueued into the fetch queue to decode.</span>
 <span class="mi">952</span>     <span class="c1">// Limit rate by fetchWidth.  Stall if decode is stalled.</span>
 <span class="mi">953</span>     <span class="kt">unsigned</span> <span class="n">insts_to_decode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="mi">954</span>     <span class="kt">unsigned</span> <span class="n">available_insts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="mi">955</span> 
 <span class="mi">956</span>     <span class="nf">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">tid</span> <span class="o">:</span> <span class="o">*</span><span class="n">activeThreads</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">957</span>         <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stalls</span><span class="p">[</span><span class="n">tid</span><span class="p">].</span><span class="n">decode</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">958</span>             <span class="n">available_insts</span> <span class="o">+=</span> <span class="n">fetchQueue</span><span class="p">[</span><span class="n">tid</span><span class="p">].</span><span class="n">size</span><span class="p">();</span>
 <span class="mi">959</span>         <span class="p">}</span>
 <span class="mi">960</span>     <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<h2 id="sending-fetched-instructions-to-decode-stage"><span class="me-2">Sending fetched instructions to decode stage</span><a href="#sending-fetched-instructions-to-decode-stage" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>
<p><em>gem5/src/cpu/o3/fetch_impl.hh</em></p>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="rouge-code"><pre> <span class="mi">961</span> 
 <span class="mi">962</span>     <span class="c1">// Pick a random thread to start trying to grab instructions from</span>
 <span class="mi">963</span>     <span class="k">auto</span> <span class="n">tid_itr</span> <span class="o">=</span> <span class="n">activeThreads</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">();</span>
 <span class="mi">964</span>     <span class="n">std</span><span class="o">::</span><span class="n">advance</span><span class="p">(</span><span class="n">tid_itr</span><span class="p">,</span> <span class="n">random_mt</span><span class="p">.</span><span class="n">random</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">activeThreads</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
 <span class="mi">965</span> 
 <span class="mi">966</span>     <span class="nf">while</span> <span class="p">(</span><span class="n">available_insts</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">insts_to_decode</span> <span class="o">&lt;</span> <span class="n">decodeWidth</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">967</span>         <span class="n">ThreadID</span> <span class="n">tid</span> <span class="o">=</span> <span class="o">*</span><span class="n">tid_itr</span><span class="p">;</span>
 <span class="mi">968</span>         <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stalls</span><span class="p">[</span><span class="n">tid</span><span class="p">].</span><span class="n">decode</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">fetchQueue</span><span class="p">[</span><span class="n">tid</span><span class="p">].</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
 <span class="mi">969</span>             <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">inst</span> <span class="o">=</span> <span class="n">fetchQueue</span><span class="p">[</span><span class="n">tid</span><span class="p">].</span><span class="n">front</span><span class="p">();</span>
 <span class="mi">970</span>             <span class="n">toDecode</span><span class="o">-&gt;</span><span class="n">insts</span><span class="p">[</span><span class="n">toDecode</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">inst</span><span class="p">;</span>
 <span class="mi">971</span>             <span class="n">DPRINTF</span><span class="p">(</span><span class="n">Fetch</span><span class="p">,</span> <span class="s">"[tid:%i] [sn:%llu] Sending instruction to decode "</span>
 <span class="mi">972</span>                     <span class="s">"from fetch queue. Fetch queue size: %i.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
 <span class="mi">973</span>                     <span class="n">tid</span><span class="p">,</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">seqNum</span><span class="p">,</span> <span class="n">fetchQueue</span><span class="p">[</span><span class="n">tid</span><span class="p">].</span><span class="n">size</span><span class="p">());</span>
 <span class="mi">974</span> 
 <span class="mi">975</span>             <span class="n">wroteToTimeBuffer</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
 <span class="mi">976</span>             <span class="n">fetchQueue</span><span class="p">[</span><span class="n">tid</span><span class="p">].</span><span class="n">pop_front</span><span class="p">();</span>
 <span class="mi">977</span>             <span class="n">insts_to_decode</span><span class="o">++</span><span class="p">;</span>
 <span class="mi">978</span>             <span class="n">available_insts</span><span class="o">--</span><span class="p">;</span>
 <span class="mi">979</span>         <span class="p">}</span>
 <span class="mi">980</span> 
 <span class="mi">981</span>         <span class="n">tid_itr</span><span class="o">++</span><span class="p">;</span>
 <span class="mi">982</span>         <span class="c1">// Wrap around if at end of active threads list</span>
 <span class="mi">983</span>         <span class="nf">if</span> <span class="p">(</span><span class="n">tid_itr</span> <span class="o">==</span> <span class="n">activeThreads</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">())</span>
 <span class="mi">984</span>             <span class="n">tid_itr</span> <span class="o">=</span> <span class="n">activeThreads</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">();</span>
 <span class="mi">985</span>     <span class="p">}</span>
 <span class="mi">986</span> 
 <span class="mi">987</span>     <span class="c1">// If there was activity this cycle, inform the CPU of it.</span>
 <span class="mi">988</span>     <span class="nf">if</span> <span class="p">(</span><span class="n">wroteToTimeBuffer</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">989</span>         <span class="n">DPRINTF</span><span class="p">(</span><span class="n">Activity</span><span class="p">,</span> <span class="s">"Activity this cycle.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
 <span class="mi">990</span>         <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">activityThisCycle</span><span class="p">();</span>
 <span class="mi">991</span>     <span class="p">}</span>
 <span class="mi">992</span> 
 <span class="mi">993</span>     <span class="c1">// Reset the number of the instruction we've fetched.</span>
 <span class="mi">994</span>     <span class="n">numInst</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="mi">995</span> <span class="p">}</span>   <span class="c1">//end of the fetch.tick</span>
</pre></td></tr></tbody></table></code></div></div>
<p>The last job of the fetch stage is passing the fetched instructions
to the next stage, decode stage. 
One the above code, <strong>toDecode</strong> member field of the fetch 
is used as an storage located in between the fetch and decode stage.</p>

<h3 id="fetchstruct-passing-fetch-stages-information-to-decode-stage"><span class="me-2">FetchStruct: passing fetch stage’s information to decode stage</span><a href="#fetchstruct-passing-fetch-stages-information-to-decode-stage" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<p><em>gem5/src/cpu/o3/fetch.hh</em></p>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre><span class="mi">431</span>     <span class="c1">//Might be annoying how this name is different than the queue.</span>
<span class="mi">432</span>     <span class="cm">/** Wire used to write any information heading to decode. */</span>
<span class="mi">433</span>     <span class="k">typename</span> <span class="n">TimeBuffer</span><span class="o">&lt;</span><span class="n">FetchStruct</span><span class="o">&gt;::</span><span class="n">wire</span> <span class="n">toDecode</span><span class="p">;</span>
<span class="p">......</span>
<span class="mi">458</span>     <span class="cm">/** Source of possible stalls. */</span>
<span class="mi">459</span>     <span class="k">struct</span> <span class="nc">Stalls</span> <span class="p">{</span>
<span class="mi">460</span>         <span class="kt">bool</span> <span class="n">decode</span><span class="p">;</span>
<span class="mi">461</span>         <span class="kt">bool</span> <span class="n">drain</span><span class="p">;</span>
<span class="mi">462</span>     <span class="p">};</span>
<span class="mi">463</span> 
<span class="mi">464</span>     <span class="cm">/** Tracks which stages are telling fetch to stall. */</span>
<span class="mi">465</span>     <span class="n">Stalls</span> <span class="n">stalls</span><span class="p">[</span><span class="n">Impl</span><span class="o">::</span><span class="n">MaxThreads</span><span class="p">];</span>
</pre></td></tr></tbody></table></code></div></div>
<p>The toDecode is declared as a wire class defined in the TimeBuffer class. 
Also, because the TimerBuffer is a template class, 
it passes the FetchStruct that contains all fetch stage’s information
required by the decode stage. Let’s take a look at the FetchStruct 
to understand which information is passed to the decode stage.</p>

<p><em>gem5/src/cpu/o3/cpu_policy.hh</em></p>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="rouge-code"><pre> <span class="mi">60</span> <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Impl</span><span class="p">&gt;</span>
 <span class="mi">61</span> <span class="k">struct</span> <span class="nc">SimpleCPUPolicy</span>
 <span class="mi">62</span> <span class="p">{</span>
 <span class="p">......</span>
 <span class="mi">89</span>     <span class="cm">/** The struct for communication between fetch and decode. */</span>
 <span class="mi">90</span>     <span class="k">typedef</span> <span class="n">DefaultFetchDefaultDecode</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;</span> <span class="n">FetchStruct</span><span class="p">;</span>
 <span class="mi">91</span> 
 <span class="mi">92</span>     <span class="cm">/** The struct for communication between decode and rename. */</span>
 <span class="mi">93</span>     <span class="k">typedef</span> <span class="n">DefaultDecodeDefaultRename</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;</span> <span class="n">DecodeStruct</span><span class="p">;</span>
 <span class="mi">94</span> 
 <span class="mi">95</span>     <span class="cm">/** The struct for communication between rename and IEW. */</span>
 <span class="mi">96</span>     <span class="k">typedef</span> <span class="n">DefaultRenameDefaultIEW</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;</span> <span class="n">RenameStruct</span><span class="p">;</span>
 <span class="mi">97</span> 
 <span class="mi">98</span>     <span class="cm">/** The struct for communication between IEW and commit. */</span>
 <span class="mi">99</span>     <span class="k">typedef</span> <span class="n">DefaultIEWDefaultCommit</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;</span> <span class="n">IEWStruct</span><span class="p">;</span>
<span class="mi">100</span> 
<span class="mi">101</span>     <span class="cm">/** The struct for communication within the IEW stage. */</span>
<span class="mi">102</span>     <span class="k">typedef</span> <span class="o">::</span><span class="n">IssueStruct</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;</span> <span class="n">IssueStruct</span><span class="p">;</span>
<span class="mi">103</span> 
<span class="mi">104</span>     <span class="cm">/** The struct for all backwards communication. */</span>
<span class="mi">105</span>     <span class="k">typedef</span> <span class="n">TimeBufStruct</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;</span> <span class="n">TimeStruct</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></div></div>

<p><em>gem5/src/cpu/o3/comm.h</em></p>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre> <span class="mi">55</span> <span class="cm">/** Struct that defines the information passed from fetch to decode. */</span>
 <span class="mi">56</span> <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Impl</span><span class="p">&gt;</span>
 <span class="mi">57</span> <span class="k">struct</span> <span class="nc">DefaultFetchDefaultDecode</span> <span class="p">{</span>
 <span class="mi">58</span>     <span class="k">typedef</span> <span class="k">typename</span> <span class="n">Impl</span><span class="o">::</span><span class="n">DynInstPtr</span> <span class="n">DynInstPtr</span><span class="p">;</span>
 <span class="mi">59</span> 
 <span class="mi">60</span>     <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
 <span class="mi">61</span> 
 <span class="mi">62</span>     <span class="n">DynInstPtr</span> <span class="n">insts</span><span class="p">[</span><span class="n">Impl</span><span class="o">::</span><span class="n">MaxWidth</span><span class="p">];</span>
 <span class="mi">63</span>     <span class="n">Fault</span> <span class="n">fetchFault</span><span class="p">;</span>
 <span class="mi">64</span>     <span class="n">InstSeqNum</span> <span class="n">fetchFaultSN</span><span class="p">;</span>
 <span class="mi">65</span>     <span class="kt">bool</span> <span class="n">clearFetchFault</span><span class="p">;</span>
 <span class="mi">66</span> <span class="p">};</span>
</pre></td></tr></tbody></table></code></div></div>
<p>Most importantly, it passes the 
instructions fetched from the Icache.</p>

<h3 id="timebufferwire-generic-class-representing-wire"><span class="me-2">TimeBuffer::wire generic class representing wire</span><a href="#timebufferwire-generic-class-representing-wire" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<p>The information passed from the decode stage to fetch stage is 
represented as multiple wires conveying bits of information. 
For that purpose, GEM5 provides wire class.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
</pre></td><td class="rouge-code"><pre> <span class="mi">39</span> <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
 <span class="mi">40</span> <span class="k">class</span> <span class="nc">TimeBuffer</span>
 <span class="mi">41</span> <span class="p">{</span>
 <span class="mi">42</span>   <span class="k">protected</span><span class="o">:</span>
 <span class="mi">43</span>     <span class="kt">int</span> <span class="n">past</span><span class="p">;</span>
 <span class="mi">44</span>     <span class="kt">int</span> <span class="n">future</span><span class="p">;</span>
 <span class="mi">45</span>     <span class="kt">unsigned</span> <span class="n">size</span><span class="p">;</span>
 <span class="mi">46</span>     <span class="kt">int</span> <span class="n">_id</span><span class="p">;</span>
 <span class="mi">47</span> 
 <span class="mi">48</span>     <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
 <span class="mi">49</span>     <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span> <span class="o">*&gt;</span> <span class="n">index</span><span class="p">;</span>
 <span class="mi">50</span>     <span class="kt">unsigned</span> <span class="n">base</span><span class="p">;</span>
 <span class="mi">51</span> 
 <span class="mi">52</span>     <span class="kt">void</span> <span class="n">valid</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span> <span class="k">const</span>
 <span class="mi">53</span>     <span class="p">{</span>
 <span class="mi">54</span>         <span class="n">assert</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="n">past</span> <span class="o">&amp;&amp;</span> <span class="n">idx</span> <span class="o">&lt;=</span> <span class="n">future</span><span class="p">);</span>
 <span class="mi">55</span>     <span class="p">}</span>
 <span class="mi">56</span> 
 <span class="mi">57</span>   <span class="k">public</span><span class="o">:</span>
 <span class="mi">58</span>     <span class="k">friend</span> <span class="k">class</span> <span class="nc">wire</span><span class="p">;</span>
 <span class="mi">59</span>     <span class="k">class</span> <span class="nc">wire</span>
 <span class="mi">60</span>     <span class="p">{</span>
 <span class="mi">61</span>         <span class="k">friend</span> <span class="k">class</span> <span class="nc">TimeBuffer</span><span class="p">;</span>
 <span class="mi">62</span>       <span class="k">protected</span><span class="o">:</span>
 <span class="mi">63</span>         <span class="n">TimeBuffer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
 <span class="mi">64</span>         <span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
 <span class="mi">65</span> 
 <span class="mi">66</span>         <span class="kt">void</span> <span class="n">set</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
 <span class="mi">67</span>         <span class="p">{</span>   
 <span class="mi">68</span>             <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">valid</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
 <span class="mi">69</span>             <span class="n">index</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>
 <span class="mi">70</span>         <span class="p">}</span>
 <span class="mi">71</span> 
 <span class="mi">72</span>         <span class="n">wire</span><span class="p">(</span><span class="n">TimeBuffer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
 <span class="mi">73</span>             <span class="o">:</span> <span class="n">buffer</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
 <span class="mi">74</span>         <span class="p">{</span> <span class="p">}</span>
 <span class="mi">75</span> 
 <span class="mi">76</span>       <span class="k">public</span><span class="o">:</span>
 <span class="mi">77</span>         <span class="n">wire</span><span class="p">()</span>
 <span class="mi">78</span>         <span class="p">{</span> <span class="p">}</span>
 <span class="mi">79</span> 
 <span class="mi">80</span>         <span class="n">wire</span><span class="p">(</span><span class="k">const</span> <span class="n">wire</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)</span>
 <span class="mi">81</span>             <span class="o">:</span> <span class="n">buffer</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">buffer</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">index</span><span class="p">)</span>
 <span class="mi">82</span>         <span class="p">{</span> <span class="p">}</span>
 <span class="mi">83</span> 
 <span class="mi">84</span>         <span class="k">const</span> <span class="n">wire</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">wire</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)</span>
 <span class="mi">85</span>         <span class="p">{</span>
 <span class="mi">86</span>             <span class="n">buffer</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">buffer</span><span class="p">;</span>
 <span class="mi">87</span>             <span class="n">set</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">index</span><span class="p">);</span>
 <span class="mi">88</span>             <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
 <span class="mi">89</span>         <span class="p">}</span>
 <span class="mi">90</span> 
 <span class="mi">91</span>         <span class="k">const</span> <span class="n">wire</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
 <span class="mi">92</span>         <span class="p">{</span>
 <span class="mi">93</span>             <span class="n">set</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
 <span class="mi">94</span>             <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
 <span class="mi">95</span>         <span class="p">}</span>
 <span class="mi">96</span> 
 <span class="mi">97</span>         <span class="k">const</span> <span class="n">wire</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
 <span class="mi">98</span>         <span class="p">{</span>
 <span class="mi">99</span>             <span class="n">set</span><span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
<span class="mi">100</span>             <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="mi">101</span>         <span class="p">}</span>
<span class="mi">102</span> 
<span class="mi">103</span>         <span class="k">const</span> <span class="n">wire</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">-=</span><span class="p">(</span><span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="mi">104</span>         <span class="p">{</span>
<span class="mi">105</span>             <span class="n">set</span><span class="p">(</span><span class="n">index</span> <span class="o">-</span> <span class="n">offset</span><span class="p">);</span>
<span class="mi">106</span>             <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="mi">107</span>         <span class="p">}</span>
<span class="mi">108</span> 
<span class="mi">109</span>         <span class="n">wire</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">++</span><span class="p">()</span>
<span class="mi">110</span>         <span class="p">{</span>
<span class="mi">111</span>             <span class="n">set</span><span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="mi">112</span>             <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="mi">113</span>         <span class="p">}</span>
<span class="mi">114</span> 
<span class="mi">115</span>         <span class="n">wire</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
<span class="mi">116</span>         <span class="p">{</span>
<span class="mi">117</span>             <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
<span class="mi">118</span>             <span class="n">set</span><span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="mi">119</span>             <span class="k">return</span> <span class="n">wire</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="mi">120</span>         <span class="p">}</span>
<span class="mi">121</span> 
<span class="mi">122</span>         <span class="n">wire</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">--</span><span class="p">()</span>
<span class="mi">123</span>         <span class="p">{</span>
<span class="mi">124</span>             <span class="n">set</span><span class="p">(</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="mi">125</span>             <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="mi">126</span>         <span class="p">}</span>
<span class="mi">127</span> 
<span class="mi">128</span>         <span class="n">wire</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">--</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
<span class="mi">129</span>         <span class="p">{</span>
<span class="mi">130</span>             <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
<span class="mi">131</span>             <span class="n">set</span><span class="p">(</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="mi">132</span>             <span class="k">return</span> <span class="n">wire</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="mi">133</span>         <span class="p">}</span>
<span class="mi">134</span>         <span class="n">T</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">access</span><span class="p">(</span><span class="n">index</span><span class="p">);</span> <span class="p">}</span>
<span class="mi">135</span>         <span class="n">T</span> <span class="o">*</span><span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">access</span><span class="p">(</span><span class="n">index</span><span class="p">);</span> <span class="p">}</span>
<span class="mi">136</span>     <span class="p">};</span>
<span class="p">......</span>
<span class="mi">192</span>   <span class="k">protected</span><span class="o">:</span>
<span class="mi">193</span>     <span class="c1">//Calculate the index into this-&gt;index for element at position idx</span>
<span class="mi">194</span>     <span class="c1">//relative to now</span>
<span class="mi">195</span>     <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">calculateVectorIndex</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span> <span class="k">const</span>
<span class="mi">196</span>     <span class="p">{</span>
<span class="mi">197</span>         <span class="c1">//Need more complex math here to calculate index.</span>
<span class="mi">198</span>         <span class="n">valid</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
<span class="mi">199</span> 
<span class="mi">200</span>         <span class="kt">int</span> <span class="n">vector_index</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">base</span><span class="p">;</span>
<span class="mi">201</span>         <span class="nf">if</span> <span class="p">(</span><span class="n">vector_index</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">202</span>             <span class="n">vector_index</span> <span class="o">-=</span> <span class="n">size</span><span class="p">;</span>
<span class="mi">203</span>         <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">vector_index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">204</span>             <span class="n">vector_index</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
<span class="mi">205</span>         <span class="p">}</span>
<span class="mi">206</span> 
<span class="mi">207</span>         <span class="k">return</span> <span class="n">vector_index</span><span class="p">;</span>
<span class="mi">208</span>     <span class="p">}</span>
<span class="mi">209</span> 
<span class="mi">210</span>   <span class="k">public</span><span class="o">:</span>
<span class="mi">211</span>     <span class="n">T</span> <span class="o">*</span><span class="nf">access</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="mi">212</span>     <span class="p">{</span>
<span class="mi">213</span>         <span class="kt">int</span> <span class="n">vector_index</span> <span class="o">=</span> <span class="n">calculateVectorIndex</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
<span class="mi">214</span> 
<span class="mi">215</span>         <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">index</span><span class="p">[</span><span class="n">vector_index</span><span class="p">]);</span>
<span class="mi">216</span>     <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>As shown in the Line 970 of the tick function of the fetch stage,
it references insts member field through the -&gt; operator. 
Because toDecode is declared as the TimeBuffer::wire, and 
this class overrides the -&gt; operator, it will invoke the
`operator function shown in line 135. 
\XXX{ it needs to be explained more clearly with smartpointer..}</p>

  </div>

  <div class="post-tail-wrapper text-muted">
    <!-- categories -->
    
      <div class="post-meta mb-3">
        <i class="far fa-folder-open fa-fw me-1"></i>
        
          <a href="/categories/gem5/">GEM5</a>,
          <a href="/categories/pipeline/">Pipeline</a>,
          <a href="/categories/o3/">O3</a>
      </div>
    

    <!-- tags -->
    

    <div
      class="
        post-tail-bottom
        d-flex justify-content-between align-items-center mt-5 pb-2
      "
    >
      <div class="license-wrapper">
        
          

          This post is licensed under 
        <a href="https://creativecommons.org/licenses/by/4.0/">
          CC BY 4.0
        </a>
         by the author.
        
      </div>

      <!-- Post sharing snippet -->

<div class="share-wrapper d-flex align-items-center">
  <span class="share-label text-muted">Share</span>
  <span class="share-icons">
    
    
    

    

      

      <a
        href="https://twitter.com/intent/tweet?text=O3%20Cpu%20Fetch%20-%20Ruach&url=https%3A%2F%2Fruach.github.io%2Fposts%2FO3-CPU-Fetch%2F"
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="Twitter"
        target="_blank"
        rel="noopener"
        aria-label="Twitter"
      >
        <i class="fa-fw fa-brands fa-square-x-twitter"></i>
      </a>
    

      

      <a
        href="https://www.facebook.com/sharer/sharer.php?title=O3%20Cpu%20Fetch%20-%20Ruach&u=https%3A%2F%2Fruach.github.io%2Fposts%2FO3-CPU-Fetch%2F"
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="Facebook"
        target="_blank"
        rel="noopener"
        aria-label="Facebook"
      >
        <i class="fa-fw fab fa-facebook-square"></i>
      </a>
    

      

      <a
        href="https://t.me/share/url?url=https%3A%2F%2Fruach.github.io%2Fposts%2FO3-CPU-Fetch%2F&text=O3%20Cpu%20Fetch%20-%20Ruach"
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="Telegram"
        target="_blank"
        rel="noopener"
        aria-label="Telegram"
      >
        <i class="fa-fw fab fa-telegram"></i>
      </a>
    

      

      <a
        href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fruach.github.io%2Fposts%2FO3-CPU-Fetch%2F"
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="Linkedin"
        target="_blank"
        rel="noopener"
        aria-label="Linkedin"
      >
        <i class="fa-fw fab fa-linkedin"></i>
      </a>
    

    <button
      id="copy-link"
      aria-label="Copy link"
      class="btn small"
      data-bs-toggle="tooltip"
      data-bs-placement="top"
      title="Copy link"
      data-title-succeed="Link copied successfully!"
    >
      <i class="fa-fw fas fa-link pe-none fs-6"></i>
    </button>
  </span>
</div>

    </div>
    <!-- .post-tail-bottom -->
  </div>
  <!-- div.post-tail-wrapper -->
</article>


            
          </main>

          <!-- panel -->
          <aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 mb-5 text-muted">
            <div class="access">
              <!-- Get the last 5 posts from lastmod list. -->















              <!-- The trending tags list -->


















            </div>

            
              
              



  <section id="toc-wrapper" class="ps-0 pe-4">
    <h2 class="panel-heading ps-3 pt-2 mb-2">Contents</h2>
    <nav id="toc"></nav>
  </section>


            
          </aside>
        </div>

        <div class="row">
          <!-- tail -->
          <div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4">
            
              
              <!-- Recommend the other 3 posts according to the tags and categories of the current post. -->

<!-- The total size of related posts -->


<!-- An random integer that bigger than 0 -->


<!-- Equals to TAG_SCORE / {max_categories_hierarchy} -->














  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  
    
  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  











  <aside id="related-posts" aria-labelledby="related-label">
    <h3 class="mb-4" id="related-label">Further Reading</h3>
    <nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4">
      
        <article class="col">
          <a href="/posts/O3-CPU-Decode/" class="post-preview card h-100">
            <div class="card-body">
              <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->




<time
  
  data-ts="1622174400"
  data-df="ll"
  
>
  May 28, 2021
</time>

              <h4 class="pt-0 my-2">O3 Cpu Decode</h4>
              <div class="text-muted">
                <p>
                  





                  Sending fetched instructions to decode stage
gem5/src/cpu/o3/fetch_impl.hh
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
 961 
 962     // Pick a r...
                </p>
              </div>
            </div>
          </a>
        </article>
      
        <article class="col">
          <a href="/posts/O3-CPU-rename/" class="post-preview card h-100">
            <div class="card-body">
              <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->




<time
  
  data-ts="1622260800"
  data-df="ll"
  
>
  May 29, 2021
</time>

              <h4 class="pt-0 my-2">O3 Cpu Rename</h4>
              <div class="text-muted">
                <p>
                  





                  Rename
It maintains the rename history of all instructions 
with destination registers, storing the arch register, 
the new physical register, and the old physical register.
The information is requ...
                </p>
              </div>
            </div>
          </a>
        </article>
      
        <article class="col">
          <a href="/posts/O3-CPU-iew/" class="post-preview card h-100">
            <div class="card-body">
              <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->




<time
  
  data-ts="1622520000"
  data-df="ll"
  
>
  Jun  1, 2021
</time>

              <h4 class="pt-0 my-2">O3 Cpu Iew</h4>
              <div class="text-muted">
                <p>
                  





                  IEW: Issue/Execute/Writeback

  GEM5 handles both execute and writeback when the execute() 
function is called on an instruction. Therefore, GEM5 combines 
Issue, Execute, and Writeback stage into ...
                </p>
              </div>
            </div>
          </a>
        </article>
      
    </nav>
  </aside>
  <!-- #related-posts -->


            
              
              <!-- Navigation buttons at the bottom of the post. -->

<nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation">
  
  

  
    <a
      href="/posts/O3-CPU-GEM5/"
      class="btn btn-outline-primary"
      aria-label="Older"
    >
      <p>O3 Cpu Gem5</p>
    </a>
  

  
    <a
      href="/posts/O3-CPU-Decode/"
      class="btn btn-outline-primary"
      aria-label="Newer"
    >
      <p>O3 Cpu Decode</p>
    </a>
  
</nav>

            
              
              <!--  The comments switcher -->

  
  <!-- The Disqus lazy loading. -->

<div id="disqus_thread">
  <p class="text-center text-muted small">Comments powered by <a href="https://disqus.com/">Disqus</a>.</p>
</div>

<script type="text/javascript">
  var disqus_config = function () {
    this.page.url = 'https://ruach.github.io/posts/O3-CPU-Fetch/';
    this.page.identifier = '/posts/O3-CPU-Fetch/';
  };

  /* Lazy loading */
  var disqus_observer = new IntersectionObserver(
    function (entries) {
      if (entries[0].isIntersecting) {
        (function () {
          var d = document,
            s = d.createElement('script');
          s.src = 'https://ruach.disqus.com/embed.js';
          s.setAttribute('data-timestamp', +new Date());
          (d.head || d.body).appendChild(s);
        })();

        disqus_observer.disconnect();
      }
    },
    { threshold: [0] }
  );

  disqus_observer.observe(document.querySelector('#disqus_thread'));

  /* Auto switch theme */
  function reloadDisqus() {
    if (event.source === window && event.data && event.data.direction === ModeToggle.ID) {
      /* Disqus hasn't been loaded */
      if (typeof DISQUS === 'undefined') {
        return;
      }

      if (document.readyState == 'complete') {
        DISQUS.reset({ reload: true, config: disqus_config });
      }
    }
  }

  if (document.querySelector('.mode-toggle')) {
    window.addEventListener('message', reloadDisqus);
  }
</script>



            

            <!-- The Footer -->

<footer
  aria-label="Site Info"
  class="
    d-flex flex-column justify-content-center text-muted
    flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3
  "
>
  <p>
    ©
    <time>2023</time>
    <a href="https://ruach.github.io">Jaehyuk Lee</a>.
    
      <span
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author."
      >Some rights reserved.</span>
    
  </p>

  <p>Using the <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme for <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>
  </p>
</footer>

          </div>
        </div>

        <!-- The Search results -->

<div id="search-result-wrapper" class="d-flex justify-content-center unloaded">
  <div class="col-11 content">
    <div id="search-hints">
      <!-- The trending tags list -->


















    </div>
    <div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div>
  </div>
</div>

      </div>

      <aside aria-label="Scroll to Top">
        <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow">
          <i class="fas fa-angle-up"></i>
        </button>
      </aside>
    </div>

    <div id="mask"></div>

    
      <aside
  id="notification"
  class="toast"
  role="alert"
  aria-live="assertive"
  aria-atomic="true"
  data-bs-animation="true"
  data-bs-autohide="false"
>
  <div class="toast-header">
    <button
      type="button"
      class="btn-close ms-auto"
      data-bs-dismiss="toast"
      aria-label="Close"
    ></button>
  </div>
  <div class="toast-body text-center pt-0">
    <p class="px-2 mb-3">A new version of content is available.</p>
    <button type="button" class="btn btn-primary" aria-label="Update">
      Update
    </button>
  </div>
</aside>

    

    <!-- JavaScripts -->

    <!-- JS selector for site. -->

<!-- commons -->



<!-- layout specified -->


  

  
    <!-- image lazy-loading & popup & clipboard -->
    
  















  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  



  <script src="https://cdn.jsdelivr.net/combine/npm/jquery@3.7.1/dist/jquery.min.js,npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js,npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/magnific-popup@1.1.0/dist/jquery.magnific-popup.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.10/dayjs.min.js,npm/dayjs@1.11.10/locale/en.min.js,npm/dayjs@1.11.10/plugin/relativeTime.min.js,npm/dayjs@1.11.10/plugin/localizedFormat.min.js,npm/tocbot@4.21.2/dist/tocbot.min.js"></script>






<script defer src="/assets/js/dist/post.min.js"></script>






    

    <!--
  Jekyll Simple Search loader
  See: <https://github.com/christian-fei/Simple-Jekyll-Search>
-->





<script>
  /* Note: dependent library will be loaded in `js-selector.html` */
  SimpleJekyllSearch({
    searchInput: document.getElementById('search-input'),
    resultsContainer: document.getElementById('search-results'),
    json: '/assets/js/data/search.json',
    searchResultTemplate: '  <article class="px-1 px-sm-2 px-lg-4 px-xl-0">    <header>      <h2><a href="{url}">{title}</a></h2>      <div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1">        {categories}        {tags}      </div>    </header>    <p>{snippet}</p>  </article>',
    noResultsText: '<p class="mt-5"></p>',
    templateMiddleware: function(prop, value, template) {
      if (prop === 'categories') {
        if (value === '') {
          return `${value}`;
        } else {
          return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`;
        }
      }

      if (prop === 'tags') {
        if (value === '') {
          return `${value}`;
        } else {
          return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`;
        }
      }
    }
  });
</script>

  </body>
</html>

