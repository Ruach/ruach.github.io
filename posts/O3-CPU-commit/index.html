<!doctype html>














<!-- `site.alt_lang` can specify a language different from the UI -->
<html lang="en" data-mode="light">
  <!-- The Head -->

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta
    name="viewport"
    content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover"
  >

  

  

  
    <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v4.3.2" />
<meta property="og:title" content="O3 Cpu Commit" />
<meta property="og:locale" content="en" />
<meta name="description" content="Memory read and write of the O3 CPU" />
<meta property="og:description" content="Memory read and write of the O3 CPU" />
<link rel="canonical" href="https://ruach.github.io/posts/O3-CPU-commit/" />
<meta property="og:url" content="https://ruach.github.io/posts/O3-CPU-commit/" />
<meta property="og:site_name" content="Ruach" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-06-04T00:00:00-04:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="O3 Cpu Commit" />
<meta name="twitter:site" content="@ruach_lee" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2021-06-04T00:00:00-04:00","datePublished":"2021-06-04T00:00:00-04:00","description":"Memory read and write of the O3 CPU","headline":"O3 Cpu Commit","mainEntityOfPage":{"@type":"WebPage","@id":"https://ruach.github.io/posts/O3-CPU-commit/"},"url":"https://ruach.github.io/posts/O3-CPU-commit/"}</script>
<!-- End Jekyll SEO tag -->

  

  <title>O3 Cpu Commit | Ruach
  </title>

  <!--
  The Favicons for Web, Android, Microsoft, and iOS (iPhone and iPad) Apps
  Generated by: https://realfavicongenerator.net/
-->



<link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png">
<link rel="manifest" href="/assets/img/favicons/site.webmanifest">
<link rel="shortcut icon" href="/assets/img/favicons/favicon.ico">
<meta name="apple-mobile-web-app-title" content="Ruach">
<meta name="application-name" content="Ruach">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml">
<meta name="theme-color" content="#ffffff">


  
    
      <link rel="preconnect" href="https://fonts.googleapis.com" >
      <link rel="dns-prefetch" href="https://fonts.googleapis.com" >
    
      <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
      <link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin>
    
      <link rel="preconnect" href="https://fonts.googleapis.com" >
      <link rel="dns-prefetch" href="https://fonts.googleapis.com" >
    
      <link rel="preconnect" href="https://cdn.jsdelivr.net" >
      <link rel="dns-prefetch" href="https://cdn.jsdelivr.net" >
    

    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap">
  

  <!-- GA -->
  

  <!-- Bootstrap -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css">

  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.2/css/all.min.css">

  <link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css">

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.21.2/dist/tocbot.min.css">
  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css">
  

  
    <!-- Manific Popup -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css">
  

  <!-- JavaScript -->

  

  <!-- A placeholder to allow defining custom metadata -->

</head>


  <body>
    <!-- The Side Bar -->

<aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end">
  <header class="profile-wrapper">
    <a href="/" id="avatar" class="rounded-circle">
      
        
        <img src="/assets/img/jaehyuk.png" width="112" height="112" alt="avatar" onerror="this.style.display='none'">
      
    </a>

    <h1 class="site-title">
      <a href="/">Ruach</a>
    </h1>
    <p class="site-subtitle fst-italic mb-0">Jaehyuk Lee</p>
  </header>
  <!-- .profile-wrapper -->

  <nav class="flex-column flex-grow-1 w-100 ps-0">
    <ul class="nav">
      <!-- home -->
      <li class="nav-item">
        <a href="/" class="nav-link">
          <i class="fa-fw fas fa-home"></i>
          <span>HOME</span>
        </a>
      </li>
      <!-- the real tabs -->
      
        <li class="nav-item">
          <a href="/categories/" class="nav-link">
            <i class="fa-fw fas fa-stream"></i>
            

            <span>CATEGORIES</span>
          </a>
        </li>
        <!-- .nav-item -->
      
        <li class="nav-item">
          <a href="/tags/" class="nav-link">
            <i class="fa-fw fas fa-tags"></i>
            

            <span>TAGS</span>
          </a>
        </li>
        <!-- .nav-item -->
      
        <li class="nav-item">
          <a href="/archives/" class="nav-link">
            <i class="fa-fw fas fa-archive"></i>
            

            <span>ARCHIVES</span>
          </a>
        </li>
        <!-- .nav-item -->
      
        <li class="nav-item">
          <a href="/about/" class="nav-link">
            <i class="fa-fw fas fa-info-circle"></i>
            

            <span>ABOUT</span>
          </a>
        </li>
        <!-- .nav-item -->
      
    </ul>
  </nav>

  <div class="sidebar-bottom d-flex flex-wrap  align-items-center w-100">
    

    
      

      
        <a
          href="javascript:location.href = 'mailto:' + ['jaehyuk','gatech.edu'].join('@')"
          aria-label="email"
          

          

          

          
        >
          <i class="fas fa-envelope"></i>
        </a>
      
    
      

      
        <a
          href="https://www.linkedin.com/in/jaehyuk-lee-29b33b121/"
          aria-label="linkedin"
          

          
            target="_blank"
            
          

          

          
            rel="noopener noreferrer"
          
        >
          <i class="fab fa-linkedin"></i>
        </a>
      
    
      

      
        <a
          href="https://github.com/Ruach"
          aria-label="github"
          

          
            target="_blank"
            
          

          

          
            rel="noopener noreferrer"
          
        >
          <i class="fab fa-github"></i>
        </a>
      
    
      

      
        <a
          href="https://stackoverflow.com/users/4460514/ruach?tab=profile"
          aria-label="stack-overflow"
          

          
            target="_blank"
            
          

          

          
            rel="noopener noreferrer"
          
        >
          <i class="fab fa-stack-overflow"></i>
        </a>
      
    
  </div>
  <!-- .sidebar-bottom -->
</aside>
<!-- #sidebar -->


    <div id="main-wrapper" class="d-flex justify-content-center">
      <div class="container d-flex flex-column px-xxl-5">
        <!-- The Top Bar -->

<header id="topbar-wrapper" aria-label="Top Bar">
  <div
    id="topbar"
    class="d-flex align-items-center justify-content-between px-lg-3 h-100"
  >
    <nav id="breadcrumb" aria-label="Breadcrumb">
      

      
        
          
            <span>
              <a href="/">
                Home
              </a>
            </span>

          
        
          
        
          
            
              <span>O3 Cpu Commit</span>
            

          
        
      
    </nav>
    <!-- endof #breadcrumb -->

    <button type="button" id="sidebar-trigger" class="btn btn-link">
      <i class="fas fa-bars fa-fw"></i>
    </button>

    <div id="topbar-title">
      Post
    </div>

    <button type="button" id="search-trigger" class="btn btn-link">
      <i class="fas fa-search fa-fw"></i>
    </button>

    <search class="align-items-center ms-3 ms-lg-0">
      <i class="fas fa-search fa-fw"></i>
      <input
        class="form-control"
        id="search-input"
        type="search"
        aria-label="search"
        autocomplete="off"
        placeholder="Search..."
      >
    </search>
    <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button>
  </div>
</header>


        <div class="row flex-grow-1">
          <main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4">
            
              <!-- Refactor the HTML structure -->



<!--
  In order to allow a wide table to scroll horizontally,
  we suround the markdown table with `<div class="table-wrapper">` and `</div>`
-->



<!--
  Fixed kramdown code highlight rendering:
  https://github.com/penibelst/jekyll-compress-html/issues/101
  https://github.com/penibelst/jekyll-compress-html/issues/71#issuecomment-188144901
-->



<!-- Change the icon of checkbox -->



<!-- Handle images -->





<!-- Add header for code snippets -->



<!-- Create heading anchors -->





  
  

  
    
    

    
      
        
        
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    

    
  

  
  

  
    
    

    
      
        
        
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    

    
  

  
  

  

  
  

  




<!-- return -->




<article class="px-1">
  <header>
    <h1 data-toc-skip>O3 Cpu Commit</h1>

    <div class="post-meta text-muted">
      <!-- published date -->
      <span>
        Posted
        <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->




<time
  
  data-ts="1622779200"
  data-df="ll"
  
    data-bs-toggle="tooltip" data-bs-placement="bottom"
  
>
  Jun  4, 2021
</time>

      </span>

      <!-- lastmod date -->
      

      

      <div class="d-flex justify-content-between">
        <!-- author(s) -->
        <span>
          

          By

          <em>
            
              <a href="https://ruach.github.io">Jaehyuk Lee</a>
            
          </em>
        </span>

        <!-- read time -->
        <!-- Calculate the post's reading time, and display the word count in tooltip -->



<!-- words per minute -->










<!-- return element -->
<span
  class="readtime"
  data-bs-toggle="tooltip"
  data-bs-placement="bottom"
  title="22048 words"
>
  <em>122 min</em> read</span>

      </div>
      <!-- .d-flex -->
    </div>
    <!-- .post-meta -->
  </header>

  <div class="content">
    <h1 id="memory-read-and-write-of-the-o3-cpu">Memory read and write of the O3 CPU</h1>

<h2 id="memory-read"><span class="me-2">Memory read</span><a href="#memory-read" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
</pre></td><td class="rouge-code"><pre><span class="mi">621</span> <span class="n">LSQUnit</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;::</span><span class="n">read</span><span class="p">(</span><span class="n">LSQRequest</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="kt">int</span> <span class="n">load_idx</span><span class="p">)</span>
<span class="mi">622</span> <span class="p">{</span>
<span class="mi">623</span>     <span class="n">LQEntry</span><span class="o">&amp;</span> <span class="n">load_req</span> <span class="o">=</span> <span class="n">loadQueue</span><span class="p">[</span><span class="n">load_idx</span><span class="p">];</span>
<span class="mi">624</span>     <span class="k">const</span> <span class="n">DynInstPtr</span><span class="o">&amp;</span> <span class="n">load_inst</span> <span class="o">=</span> <span class="n">load_req</span><span class="p">.</span><span class="n">instruction</span><span class="p">();</span>
<span class="mi">625</span> 
<span class="mi">626</span>     <span class="n">load_req</span><span class="p">.</span><span class="n">setRequest</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
<span class="mi">627</span>     <span class="n">assert</span><span class="p">(</span><span class="n">load_inst</span><span class="p">);</span>
<span class="mi">628</span> 
<span class="mi">629</span>     <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">load_inst</span><span class="o">-&gt;</span><span class="n">isExecuted</span><span class="p">());</span>
<span class="mi">630</span> 
<span class="mi">631</span>     <span class="c1">// Make sure this isn't a strictly ordered load</span>
<span class="mi">632</span>     <span class="c1">// A bit of a hackish way to get strictly ordered accesses to work</span>
<span class="mi">633</span>     <span class="c1">// only if they're at the head of the LSQ and are ready to commit</span>
<span class="mi">634</span>     <span class="c1">// (at the head of the ROB too).</span>
<span class="mi">635</span> 
<span class="mi">636</span>     <span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">mainRequest</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">isStrictlyOrdered</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
<span class="mi">637</span>         <span class="p">(</span><span class="n">load_idx</span> <span class="o">!=</span> <span class="n">loadQueue</span><span class="p">.</span><span class="n">head</span><span class="p">()</span> <span class="o">||</span> <span class="o">!</span><span class="n">load_inst</span><span class="o">-&gt;</span><span class="n">isAtCommit</span><span class="p">()))</span> <span class="p">{</span>
<span class="mi">638</span>         <span class="c1">// Tell IQ/mem dep unit that this instruction will need to be</span>
<span class="mi">639</span>         <span class="c1">// rescheduled eventually</span>
<span class="mi">640</span>         <span class="n">iewStage</span><span class="o">-&gt;</span><span class="n">rescheduleMemInst</span><span class="p">(</span><span class="n">load_inst</span><span class="p">);</span>
<span class="mi">641</span>         <span class="n">load_inst</span><span class="o">-&gt;</span><span class="n">clearIssued</span><span class="p">();</span>
<span class="mi">642</span>         <span class="n">load_inst</span><span class="o">-&gt;</span><span class="n">effAddrValid</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
<span class="mi">643</span>         <span class="o">++</span><span class="n">lsqRescheduledLoads</span><span class="p">;</span>
<span class="mi">644</span>         <span class="n">DPRINTF</span><span class="p">(</span><span class="n">LSQUnit</span><span class="p">,</span> <span class="s">"Strictly ordered load [sn:%lli] PC %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
<span class="mi">645</span>                 <span class="n">load_inst</span><span class="o">-&gt;</span><span class="n">seqNum</span><span class="p">,</span> <span class="n">load_inst</span><span class="o">-&gt;</span><span class="n">pcState</span><span class="p">());</span>
<span class="mi">646</span> 
<span class="mi">647</span>         <span class="c1">// Must delete request now that it wasn't handed off to</span>
<span class="mi">648</span>         <span class="c1">// memory.  This is quite ugly.  @todo: Figure out the proper</span>
<span class="mi">649</span>         <span class="c1">// place to really handle request deletes.</span>
<span class="mi">650</span>         <span class="n">load_req</span><span class="p">.</span><span class="n">setRequest</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">);</span>
<span class="mi">651</span>         <span class="n">req</span><span class="o">-&gt;</span><span class="n">discard</span><span class="p">();</span>
<span class="mi">652</span>         <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">GenericISA</span><span class="o">::</span><span class="n">M5PanicFault</span><span class="o">&gt;</span><span class="p">(</span>
<span class="mi">653</span>             <span class="s">"Strictly ordered load [sn:%llx] PC %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
<span class="mi">654</span>             <span class="n">load_inst</span><span class="o">-&gt;</span><span class="n">seqNum</span><span class="p">,</span> <span class="n">load_inst</span><span class="o">-&gt;</span><span class="n">pcState</span><span class="p">());</span>
<span class="mi">655</span>     <span class="p">}</span>
<span class="mi">656</span> 
<span class="mi">657</span>     <span class="nf">DPRINTF</span><span class="p">(</span><span class="n">LSQUnit</span><span class="p">,</span> <span class="s">"Read called, load idx: %i, store idx: %i, "</span>
<span class="mi">658</span>             <span class="s">"storeHead: %i addr: %#x%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
<span class="mi">659</span>             <span class="n">load_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">load_inst</span><span class="o">-&gt;</span><span class="n">sqIt</span><span class="p">.</span><span class="n">_idx</span><span class="p">,</span> <span class="n">storeQueue</span><span class="p">.</span><span class="n">head</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
<span class="mi">660</span>             <span class="n">req</span><span class="o">-&gt;</span><span class="n">mainRequest</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getPaddr</span><span class="p">(),</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">isSplit</span><span class="p">()</span> <span class="o">?</span> <span class="s">" split"</span> <span class="o">:</span> <span class="s">""</span><span class="p">);</span>
<span class="mi">661</span> 
<span class="mi">662</span>     <span class="nf">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">mainRequest</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">isLLSC</span><span class="p">())</span> <span class="p">{</span>
<span class="mi">663</span>         <span class="c1">// Disable recording the result temporarily.  Writing to misc</span>
<span class="mi">664</span>         <span class="c1">// regs normally updates the result, but this is not the</span>
<span class="mi">665</span>         <span class="c1">// desired behavior when handling store conditionals.</span>
<span class="mi">666</span>         <span class="n">load_inst</span><span class="o">-&gt;</span><span class="n">recordResult</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
<span class="mi">667</span>         <span class="n">TheISA</span><span class="o">::</span><span class="n">handleLockedRead</span><span class="p">(</span><span class="n">load_inst</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">mainRequest</span><span class="p">());</span>
<span class="mi">668</span>         <span class="n">load_inst</span><span class="o">-&gt;</span><span class="n">recordResult</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
<span class="mi">669</span>     <span class="p">}</span>
<span class="mi">670</span> 
<span class="mi">671</span>     <span class="nf">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">mainRequest</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">isMmappedIpr</span><span class="p">())</span> <span class="p">{</span>
<span class="mi">672</span>         <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">load_inst</span><span class="o">-&gt;</span><span class="n">memData</span><span class="p">);</span>
<span class="mi">673</span>         <span class="n">load_inst</span><span class="o">-&gt;</span><span class="n">memData</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">uint8_t</span><span class="p">[</span><span class="n">MaxDataBytes</span><span class="p">];</span>
<span class="mi">674</span> 
<span class="mi">675</span>         <span class="n">ThreadContext</span> <span class="o">*</span><span class="kr">thread</span> <span class="o">=</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">tcBase</span><span class="p">(</span><span class="n">lsqID</span><span class="p">);</span>
<span class="mi">676</span>         <span class="n">PacketPtr</span> <span class="n">main_pkt</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Packet</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">mainRequest</span><span class="p">(),</span> <span class="n">MemCmd</span><span class="o">::</span><span class="n">ReadReq</span><span class="p">);</span>
<span class="mi">677</span> 
<span class="mi">678</span>         <span class="n">main_pkt</span><span class="o">-&gt;</span><span class="n">dataStatic</span><span class="p">(</span><span class="n">load_inst</span><span class="o">-&gt;</span><span class="n">memData</span><span class="p">);</span>
<span class="mi">679</span> 
<span class="mi">680</span>         <span class="n">Cycles</span> <span class="n">delay</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">handleIprRead</span><span class="p">(</span><span class="kr">thread</span><span class="p">,</span> <span class="n">main_pkt</span><span class="p">);</span>
<span class="mi">681</span> 
<span class="mi">682</span>         <span class="n">WritebackEvent</span> <span class="o">*</span><span class="n">wb</span> <span class="o">=</span> <span class="k">new</span> <span class="n">WritebackEvent</span><span class="p">(</span><span class="n">load_inst</span><span class="p">,</span> <span class="n">main_pkt</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
<span class="mi">683</span>         <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">schedule</span><span class="p">(</span><span class="n">wb</span><span class="p">,</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">clockEdge</span><span class="p">(</span><span class="n">delay</span><span class="p">));</span>
<span class="mi">684</span>         <span class="k">return</span> <span class="n">NoFault</span><span class="p">;</span>
<span class="mi">685</span>     <span class="p">}</span>
<span class="mi">686</span> 
<span class="mi">687</span>     <span class="c1">// Check the SQ for any previous stores that might lead to forwarding</span>
<span class="p">......</span>
<span class="mi">840</span>     <span class="c1">// If there's no forwarding case, then go access memory</span>
<span class="mi">841</span>     <span class="nf">DPRINTF</span><span class="p">(</span><span class="n">LSQUnit</span><span class="p">,</span> <span class="s">"Doing memory access for inst [sn:%lli] PC %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
<span class="mi">842</span>             <span class="n">load_inst</span><span class="o">-&gt;</span><span class="n">seqNum</span><span class="p">,</span> <span class="n">load_inst</span><span class="o">-&gt;</span><span class="n">pcState</span><span class="p">());</span>
<span class="mi">843</span> 
<span class="mi">844</span>     <span class="c1">// Allocate memory if this is the first time a load is issued.</span>
<span class="mi">845</span>     <span class="nf">if</span> <span class="p">(</span><span class="o">!</span><span class="n">load_inst</span><span class="o">-&gt;</span><span class="n">memData</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">846</span>         <span class="n">load_inst</span><span class="o">-&gt;</span><span class="n">memData</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">uint8_t</span><span class="p">[</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">mainRequest</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getSize</span><span class="p">()];</span>
<span class="mi">847</span>     <span class="p">}</span>
<span class="mi">848</span> 
<span class="mi">849</span>     <span class="c1">// For now, load throughput is constrained by the number of</span>
<span class="mi">850</span>     <span class="c1">// load FUs only, and loads do not consume a cache port (only</span>
<span class="mi">851</span>     <span class="c1">// stores do).</span>
<span class="mi">852</span>     <span class="c1">// @todo We should account for cache port contention</span>
<span class="mi">853</span>     <span class="c1">// and arbitrate between loads and stores.</span>
<span class="mi">854</span> 
<span class="mi">855</span>     <span class="c1">// if we the cache is not blocked, do cache access</span>
<span class="mi">856</span>     <span class="nf">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">senderState</span><span class="p">()</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">857</span>         <span class="n">LQSenderState</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LQSenderState</span><span class="p">(</span>
<span class="mi">858</span>                 <span class="n">loadQueue</span><span class="p">.</span><span class="n">getIterator</span><span class="p">(</span><span class="n">load_idx</span><span class="p">));</span>
<span class="mi">859</span>         <span class="n">state</span><span class="o">-&gt;</span><span class="n">isLoad</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="mi">860</span>         <span class="n">state</span><span class="o">-&gt;</span><span class="n">inst</span> <span class="o">=</span> <span class="n">load_inst</span><span class="p">;</span>
<span class="mi">861</span>         <span class="n">state</span><span class="o">-&gt;</span><span class="n">isSplit</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">isSplit</span><span class="p">();</span>
<span class="mi">862</span>         <span class="n">req</span><span class="o">-&gt;</span><span class="n">senderState</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
<span class="mi">863</span>     <span class="p">}</span>
<span class="mi">864</span>     <span class="n">req</span><span class="o">-&gt;</span><span class="n">buildPackets</span><span class="p">();</span>
<span class="mi">865</span>     <span class="n">req</span><span class="o">-&gt;</span><span class="n">sendPacketToCache</span><span class="p">();</span>
<span class="mi">866</span>     <span class="nf">if</span> <span class="p">(</span><span class="o">!</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">isSent</span><span class="p">())</span>
<span class="mi">867</span>         <span class="n">iewStage</span><span class="o">-&gt;</span><span class="n">blockMemInst</span><span class="p">(</span><span class="n">load_inst</span><span class="p">);</span>
<span class="mi">868</span> 
<span class="mi">869</span>     <span class="k">return</span> <span class="n">NoFault</span><span class="p">;</span>
<span class="mi">870</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>If the current instruction has not initiated the memory load operation before,
then it allocates a memory and make the memData of the instruction 
points to this allocated memory to store the actual data read from cache or memory.
After that, it generates senderState object if it doesn’t have.
The state object contains information such as 
whether this request is load or store, 
the instruction that initiated the memory operation, and 
information about whether the request is a split or single access. 
After the senderState is generated, it is stored in the request object.
Note that here the req is the object of LSQRequest.
Remember that the req is the same object used for the TLB resolution.
Because this object contains all information required for resolving one memory operation
including TLB, cache ports, etc, by invoking proper function,
CPU can handle read/write operations.</p>

<h3 id="build-packet"><span class="me-2">Build packet</span><a href="#build-packet" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre><span class="mi">1032</span> <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Impl</span><span class="p">&gt;</span>
<span class="mi">1033</span> <span class="kt">void</span>
<span class="mi">1034</span> <span class="n">LSQ</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;::</span><span class="n">SingleDataRequest</span><span class="o">::</span><span class="n">buildPackets</span><span class="p">()</span>
<span class="mi">1035</span> <span class="p">{</span>  
<span class="mi">1036</span>     <span class="n">assert</span><span class="p">(</span><span class="n">_senderState</span><span class="p">);</span>
<span class="mi">1037</span>     <span class="cm">/* Retries do not create new packets. */</span>
<span class="mi">1038</span>     <span class="k">if</span> <span class="p">(</span><span class="n">_packets</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1039</span>         <span class="n">_packets</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span>
<span class="mi">1040</span>                 <span class="n">isLoad</span><span class="p">()</span>
<span class="mi">1041</span>                     <span class="o">?</span>  <span class="n">Packet</span><span class="o">::</span><span class="n">createRead</span><span class="p">(</span><span class="n">request</span><span class="p">())</span>
<span class="mi">1042</span>                     <span class="o">:</span>  <span class="n">Packet</span><span class="o">::</span><span class="n">createWrite</span><span class="p">(</span><span class="n">request</span><span class="p">()));</span>
<span class="mi">1043</span>         <span class="n">_packets</span><span class="p">.</span><span class="n">back</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">dataStatic</span><span class="p">(</span><span class="n">_inst</span><span class="o">-&gt;</span><span class="n">memData</span><span class="p">);</span>
<span class="mi">1044</span>         <span class="n">_packets</span><span class="p">.</span><span class="n">back</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">senderState</span> <span class="o">=</span> <span class="n">_senderState</span><span class="p">;</span>
<span class="mi">1045</span>     <span class="p">}</span>
<span class="mi">1046</span>     <span class="nf">assert</span><span class="p">(</span><span class="n">_packets</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
<span class="mi">1047</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
</pre></td><td class="rouge-code"><pre> <span class="mi">276</span> <span class="cm">/**
 277  * A Packet is used to encapsulate a transfer between two objects in
 278  * the memory system (e.g., the L1 and L2 cache).  (In contrast, a
 279  * single Request travels all the way from the requestor to the
 280  * ultimate destination and back, possibly being conveyed by several
 281  * different Packets along the way.)
 282  */</span>
 <span class="mi">283</span> <span class="k">class</span> <span class="nc">Packet</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Printable</span>
 <span class="mi">284</span> <span class="p">{</span>
 <span class="mi">285</span>   <span class="k">public</span><span class="o">:</span>
 <span class="mi">286</span>     <span class="k">typedef</span> <span class="kt">uint32_t</span> <span class="n">FlagsType</span><span class="p">;</span>
 <span class="mi">287</span>     <span class="k">typedef</span> <span class="n">gem5</span><span class="o">::</span><span class="n">Flags</span><span class="o">&lt;</span><span class="n">FlagsType</span><span class="o">&gt;</span> <span class="n">Flags</span><span class="p">;</span>
<span class="p">......</span>
 <span class="mi">368</span>   <span class="k">private</span><span class="o">:</span>
 <span class="mi">369</span>    <span class="cm">/**
 370     * A pointer to the data being transferred. It can be different
 371     * sizes at each level of the hierarchy so it belongs to the
 372     * packet, not request. This may or may not be populated when a
 373     * responder receives the packet. If not populated memory should
 374     * be allocated.
 375     */</span>
 <span class="mi">376</span>     <span class="n">PacketDataPtr</span> <span class="n">data</span><span class="p">;</span>
<span class="p">......</span>
 <span class="mi">846</span>     <span class="cm">/**
 847      * Constructor. Note that a Request object must be constructed
 848      * first, but the Requests's physical address and size fields need
 849      * not be valid. The command must be supplied.
 850      */</span>
 <span class="mi">851</span>     <span class="n">Packet</span><span class="p">(</span><span class="k">const</span> <span class="n">RequestPtr</span> <span class="o">&amp;</span><span class="n">_req</span><span class="p">,</span> <span class="n">MemCmd</span> <span class="n">_cmd</span><span class="p">)</span>
 <span class="mi">852</span>         <span class="o">:</span>  <span class="n">cmd</span><span class="p">(</span><span class="n">_cmd</span><span class="p">),</span> <span class="n">id</span><span class="p">((</span><span class="n">PacketId</span><span class="p">)</span><span class="n">_req</span><span class="p">.</span><span class="n">get</span><span class="p">()),</span> <span class="n">req</span><span class="p">(</span><span class="n">_req</span><span class="p">),</span>
 <span class="mi">853</span>            <span class="n">data</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">),</span> <span class="n">addr</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">_isSecure</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span> <span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
 <span class="mi">854</span>            <span class="n">_qosValue</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
 <span class="mi">855</span>            <span class="n">htmReturnReason</span><span class="p">(</span><span class="n">HtmCacheFailure</span><span class="o">::</span><span class="n">NO_FAIL</span><span class="p">),</span>
 <span class="mi">856</span>            <span class="n">htmTransactionUid</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
 <span class="mi">857</span>            <span class="n">headerDelay</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">snoopDelay</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
 <span class="mi">858</span>            <span class="n">payloadDelay</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">senderState</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span>
 <span class="mi">859</span>     <span class="p">{</span>
 <span class="mi">860</span>         <span class="n">flags</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
 <span class="mi">861</span>         <span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">hasPaddr</span><span class="p">())</span> <span class="p">{</span>
 <span class="mi">862</span>             <span class="n">addr</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">getPaddr</span><span class="p">();</span>
 <span class="mi">863</span>             <span class="n">flags</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="n">VALID_ADDR</span><span class="p">);</span>
 <span class="mi">864</span>             <span class="n">_isSecure</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">isSecure</span><span class="p">();</span>
 <span class="mi">865</span>         <span class="p">}</span>
 <span class="mi">866</span> 
 <span class="mi">867</span>         <span class="cm">/**
 868          * hardware transactional memory
 869          *
 870          * This is a bit of a hack!
 871          * Technically the address of a HTM command is set to zero
 872          * but is not valid. The reason that we pretend it's valid is
 873          * to void the getAddr() function from failing. It would be
 874          * cumbersome to add control flow in many places to check if the
 875          * packet represents a HTM command before calling getAddr().
 876          */</span>
 <span class="mi">877</span>         <span class="nf">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">isHTMCmd</span><span class="p">())</span> <span class="p">{</span>
 <span class="mi">878</span>             <span class="n">flags</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="n">VALID_ADDR</span><span class="p">);</span>
 <span class="mi">879</span>             <span class="n">assert</span><span class="p">(</span><span class="n">addr</span> <span class="o">==</span> <span class="mh">0x0</span><span class="p">);</span>
 <span class="mi">880</span>         <span class="p">}</span>
 <span class="mi">881</span>         <span class="nf">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">hasSize</span><span class="p">())</span> <span class="p">{</span>
 <span class="mi">882</span>             <span class="n">size</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">getSize</span><span class="p">();</span>
 <span class="mi">883</span>             <span class="n">flags</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="n">VALID_SIZE</span><span class="p">);</span>
 <span class="mi">884</span>         <span class="p">}</span>
 <span class="mi">885</span>     <span class="p">}</span>
<span class="p">......</span>
<span class="mi">1002</span>     <span class="cm">/**
1003      * Constructor-like methods that return Packets based on Request objects.
1004      * Fine-tune the MemCmd type if it's not a vanilla read or write.
1005      */</span>
<span class="mi">1006</span>     <span class="k">static</span> <span class="n">PacketPtr</span>
<span class="mi">1007</span>     <span class="nf">createRead</span><span class="p">(</span><span class="k">const</span> <span class="n">RequestPtr</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">)</span>
<span class="mi">1008</span>     <span class="p">{</span>
<span class="mi">1009</span>         <span class="k">return</span> <span class="k">new</span> <span class="n">Packet</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">makeReadCmd</span><span class="p">(</span><span class="n">req</span><span class="p">));</span>
<span class="mi">1010</span>     <span class="p">}</span>
<span class="mi">1011</span> 
<span class="mi">1012</span>     <span class="k">static</span> <span class="n">PacketPtr</span>
<span class="mi">1013</span>     <span class="nf">createWrite</span><span class="p">(</span><span class="k">const</span> <span class="n">RequestPtr</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">)</span>
<span class="mi">1014</span>     <span class="p">{</span>
<span class="mi">1015</span>         <span class="k">return</span> <span class="k">new</span> <span class="n">Packet</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">makeWriteCmd</span><span class="p">(</span><span class="n">req</span><span class="p">));</span>
<span class="mi">1016</span>     <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>buildPackets function generates new packet that will be sent to the cache.
The generated packet is maintained in the internal vector called _packets. 
Also, it sets the buffer allocated for storing the data, _inst-&gt;memData to 
internal data member field of the packet. Also, the senderState is stored.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="rouge-code"><pre> <span class="mi">386</span>     <span class="cm">/**
 387      * A virtual base opaque structure used to hold state associated
 388      * with the packet (e.g., an MSHR), specific to a SimObject that
 389      * sees the packet. A pointer to this state is returned in the
 390      * packet's response so that the SimObject in question can quickly
 391      * look up the state needed to process it. A specific subclass
 392      * would be derived from this to carry state specific to a
 393      * particular sending device.
 394      *
 395      * As multiple SimObjects may add their SenderState throughout the
 396      * memory system, the SenderStates create a stack, where a
 397      * SimObject can add a new Senderstate, as long as the
 398      * predecessing SenderState is restored when the response comes
 399      * back. For this reason, the predecessor should always be
 400      * populated with the current SenderState of a packet before
 401      * modifying the senderState field in the request packet.
 402      */</span>
 <span class="mi">403</span>     <span class="k">struct</span> <span class="nc">SenderState</span>
 <span class="mi">404</span>     <span class="p">{</span>
 <span class="mi">405</span>         <span class="n">SenderState</span><span class="o">*</span> <span class="n">predecessor</span><span class="p">;</span>
 <span class="mi">406</span>         <span class="n">SenderState</span><span class="p">()</span> <span class="o">:</span> <span class="n">predecessor</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{}</span>
 <span class="mi">407</span>         <span class="k">virtual</span> <span class="o">~</span><span class="n">SenderState</span><span class="p">()</span> <span class="p">{}</span>
 <span class="mi">408</span>     <span class="p">};</span>
</pre></td></tr></tbody></table></code></div></div>

<h3 id="attribute-of-the-packet"><span class="me-2">attribute of the packet</span><a href="#attribute-of-the-packet" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<p><em>mem/packet.hh</em></p>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="rouge-code"><pre> <span class="mi">209</span>     <span class="kt">bool</span>
 <span class="mi">210</span>     <span class="n">testCmdAttrib</span><span class="p">(</span><span class="n">MemCmd</span><span class="o">::</span><span class="n">Attribute</span> <span class="n">attrib</span><span class="p">)</span> <span class="k">const</span>
 <span class="mi">211</span>     <span class="p">{</span>
 <span class="mi">212</span>         <span class="k">return</span> <span class="n">commandInfo</span><span class="p">[</span><span class="n">cmd</span><span class="p">].</span><span class="n">attributes</span><span class="p">[</span><span class="n">attrib</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="mi">213</span>     <span class="p">}</span>
 <span class="mi">214</span> 
 <span class="mi">215</span>   <span class="k">public</span><span class="o">:</span>
 <span class="mi">216</span> 
 <span class="mi">217</span>     <span class="kt">bool</span> <span class="nf">isRead</span><span class="p">()</span> <span class="k">const</span>            <span class="p">{</span> <span class="k">return</span> <span class="n">testCmdAttrib</span><span class="p">(</span><span class="n">IsRead</span><span class="p">);</span> <span class="p">}</span>
 <span class="mi">218</span>     <span class="kt">bool</span> <span class="nf">isWrite</span><span class="p">()</span> <span class="k">const</span>           <span class="p">{</span> <span class="k">return</span> <span class="n">testCmdAttrib</span><span class="p">(</span><span class="n">IsWrite</span><span class="p">);</span> <span class="p">}</span>
 <span class="mi">219</span>     <span class="kt">bool</span> <span class="nf">isUpgrade</span><span class="p">()</span> <span class="k">const</span>         <span class="p">{</span> <span class="k">return</span> <span class="n">testCmdAttrib</span><span class="p">(</span><span class="n">IsUpgrade</span><span class="p">);</span> <span class="p">}</span>
 <span class="mi">220</span>     <span class="kt">bool</span> <span class="nf">isRequest</span><span class="p">()</span> <span class="k">const</span>         <span class="p">{</span> <span class="k">return</span> <span class="n">testCmdAttrib</span><span class="p">(</span><span class="n">IsRequest</span><span class="p">);</span> <span class="p">}</span>
 <span class="mi">221</span>     <span class="kt">bool</span> <span class="nf">isResponse</span><span class="p">()</span> <span class="k">const</span>        <span class="p">{</span> <span class="k">return</span> <span class="n">testCmdAttrib</span><span class="p">(</span><span class="n">IsResponse</span><span class="p">);</span> <span class="p">}</span>
 <span class="mi">222</span>     <span class="kt">bool</span> <span class="nf">needsWritable</span><span class="p">()</span> <span class="k">const</span>     <span class="p">{</span> <span class="k">return</span> <span class="n">testCmdAttrib</span><span class="p">(</span><span class="n">NeedsWritable</span><span class="p">);</span> <span class="p">}</span>
 <span class="mi">223</span>     <span class="kt">bool</span> <span class="nf">needsResponse</span><span class="p">()</span> <span class="k">const</span>     <span class="p">{</span> <span class="k">return</span> <span class="n">testCmdAttrib</span><span class="p">(</span><span class="n">NeedsResponse</span><span class="p">);</span> <span class="p">}</span>
 <span class="mi">224</span>     <span class="kt">bool</span> <span class="nf">isInvalidate</span><span class="p">()</span> <span class="k">const</span>      <span class="p">{</span> <span class="k">return</span> <span class="n">testCmdAttrib</span><span class="p">(</span><span class="n">IsInvalidate</span><span class="p">);</span> <span class="p">}</span>
 <span class="mi">225</span>     <span class="kt">bool</span> <span class="nf">isEviction</span><span class="p">()</span> <span class="k">const</span>        <span class="p">{</span> <span class="k">return</span> <span class="n">testCmdAttrib</span><span class="p">(</span><span class="n">IsEviction</span><span class="p">);</span> <span class="p">}</span>
 <span class="mi">226</span>     <span class="kt">bool</span> <span class="nf">isClean</span><span class="p">()</span> <span class="k">const</span>           <span class="p">{</span> <span class="k">return</span> <span class="n">testCmdAttrib</span><span class="p">(</span><span class="n">IsClean</span><span class="p">);</span> <span class="p">}</span>
 <span class="mi">227</span>     <span class="kt">bool</span> <span class="nf">fromCache</span><span class="p">()</span> <span class="k">const</span>         <span class="p">{</span> <span class="k">return</span> <span class="n">testCmdAttrib</span><span class="p">(</span><span class="n">FromCache</span><span class="p">);</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p><em>mem/packet.cc</em></p>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="rouge-code"><pre> <span class="mi">64</span> <span class="k">const</span> <span class="n">MemCmd</span><span class="o">::</span><span class="n">CommandInfo</span>
 <span class="mi">65</span> <span class="n">MemCmd</span><span class="o">::</span><span class="n">commandInfo</span><span class="p">[]</span> <span class="o">=</span>
 <span class="mi">66</span> <span class="p">{</span>
 <span class="mi">67</span>     <span class="cm">/* InvalidCmd */</span>
 <span class="mi">68</span>     <span class="p">{</span> <span class="p">{},</span> <span class="n">InvalidCmd</span><span class="p">,</span> <span class="s">"InvalidCmd"</span> <span class="p">},</span>
 <span class="mi">69</span>     <span class="cm">/* ReadReq - Read issued by a non-caching agent such as a CPU or
 70      * device, with no restrictions on alignment. */</span>
 <span class="mi">71</span>     <span class="p">{</span> <span class="p">{</span><span class="n">IsRead</span><span class="p">,</span> <span class="n">IsRequest</span><span class="p">,</span> <span class="n">NeedsResponse</span><span class="p">},</span> <span class="n">ReadResp</span><span class="p">,</span> <span class="s">"ReadReq"</span> <span class="p">},</span>
 <span class="mi">72</span>     <span class="cm">/* ReadResp */</span>
 <span class="mi">73</span>     <span class="p">{</span> <span class="p">{</span><span class="n">IsRead</span><span class="p">,</span> <span class="n">IsResponse</span><span class="p">,</span> <span class="n">HasData</span><span class="p">},</span> <span class="n">InvalidCmd</span><span class="p">,</span> <span class="s">"ReadResp"</span> <span class="p">},</span>
 <span class="mi">74</span>     <span class="cm">/* ReadRespWithInvalidate */</span>
 <span class="mi">75</span>     <span class="p">{</span> <span class="p">{</span><span class="n">IsRead</span><span class="p">,</span> <span class="n">IsResponse</span><span class="p">,</span> <span class="n">HasData</span><span class="p">,</span> <span class="n">IsInvalidate</span><span class="p">},</span>
 <span class="mi">76</span>             <span class="n">InvalidCmd</span><span class="p">,</span> <span class="s">"ReadRespWithInvalidate"</span> <span class="p">},</span>
 <span class="mi">77</span>     <span class="cm">/* WriteReq */</span>
 <span class="mi">78</span>     <span class="p">{</span> <span class="p">{</span><span class="n">IsWrite</span><span class="p">,</span> <span class="n">NeedsWritable</span><span class="p">,</span> <span class="n">IsRequest</span><span class="p">,</span> <span class="n">NeedsResponse</span><span class="p">,</span> <span class="n">HasData</span><span class="p">},</span>
 <span class="mi">79</span>             <span class="n">WriteResp</span><span class="p">,</span> <span class="s">"WriteReq"</span> <span class="p">},</span>
 <span class="mi">80</span>     <span class="cm">/* WriteResp */</span>
 <span class="mi">81</span>     <span class="p">{</span> <span class="p">{</span><span class="n">IsWrite</span><span class="p">,</span> <span class="n">IsResponse</span><span class="p">},</span> <span class="n">InvalidCmd</span><span class="p">,</span> <span class="s">"WriteResp"</span> <span class="p">},</span>
 <span class="mi">82</span>     <span class="cm">/* WriteCompleteResp - The WriteCompleteResp command is needed
 83      * because in the GPU memory model we use a WriteResp to indicate
 84      * that a write has reached the cache controller so we can free
 85      * resources at the coalescer. Later, when the write succesfully
 86      * completes we send a WriteCompleteResp to the CU so its wait
 87      * counters can be updated. Wait counters in the CU is how memory
 88      * dependences are handled in the GPU ISA. */</span>
 <span class="mi">89</span>     <span class="p">{</span> <span class="p">{</span><span class="n">IsWrite</span><span class="p">,</span> <span class="n">IsResponse</span><span class="p">},</span> <span class="n">InvalidCmd</span><span class="p">,</span> <span class="s">"WriteCompleteResp"</span> <span class="p">},</span>


</pre></td></tr></tbody></table></code></div></div>

<h3 id="send-packet-to-the-cache"><span class="me-2">send packet to the cache</span><a href="#send-packet-to-the-cache" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="mi">1083</span> <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Impl</span><span class="p">&gt;</span>
<span class="mi">1084</span> <span class="kt">void</span>
<span class="mi">1085</span> <span class="n">LSQ</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;::</span><span class="n">SingleDataRequest</span><span class="o">::</span><span class="n">sendPacketToCache</span><span class="p">()</span>
<span class="mi">1086</span> <span class="p">{</span>  
<span class="mi">1087</span>     <span class="n">assert</span><span class="p">(</span><span class="n">_numOutstandingPackets</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
<span class="mi">1088</span>     <span class="k">if</span> <span class="p">(</span><span class="n">lsqUnit</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">trySendPacket</span><span class="p">(</span><span class="n">isLoad</span><span class="p">(),</span> <span class="n">_packets</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span>
<span class="mi">1089</span>         <span class="n">_numOutstandingPackets</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="mi">1090</span> <span class="p">}</span>  
</pre></td></tr></tbody></table></code></div></div>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="rouge-code"><pre><span class="mi">1083</span> <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Impl</span><span class="p">&gt;</span>
<span class="mi">1084</span> <span class="kt">bool</span>
<span class="mi">1085</span> <span class="n">LSQUnit</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;::</span><span class="n">trySendPacket</span><span class="p">(</span><span class="kt">bool</span> <span class="n">isLoad</span><span class="p">,</span> <span class="n">PacketPtr</span> <span class="n">data_pkt</span><span class="p">)</span>
<span class="mi">1086</span> <span class="p">{</span>  
<span class="mi">1087</span>     <span class="kt">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="mi">1088</span>     <span class="kt">bool</span> <span class="n">cache_got_blocked</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="mi">1089</span>         
<span class="mi">1090</span>     <span class="k">auto</span> <span class="n">state</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">LSQSenderState</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">data_pkt</span><span class="o">-&gt;</span><span class="n">senderState</span><span class="p">);</span>
<span class="mi">1091</span>                 
<span class="mi">1092</span>     <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lsq</span><span class="o">-&gt;</span><span class="n">cacheBlocked</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
<span class="mi">1093</span>         <span class="n">lsq</span><span class="o">-&gt;</span><span class="n">cachePortAvailable</span><span class="p">(</span><span class="n">isLoad</span><span class="p">))</span> <span class="p">{</span>
<span class="mi">1094</span>         <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dcachePort</span><span class="o">-&gt;</span><span class="n">sendTimingReq</span><span class="p">(</span><span class="n">data_pkt</span><span class="p">))</span> <span class="p">{</span>
<span class="mi">1095</span>             <span class="n">ret</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="mi">1096</span>             <span class="n">cache_got_blocked</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="mi">1097</span>         <span class="p">}</span> 
<span class="mi">1098</span>     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="mi">1099</span>         <span class="n">ret</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="mi">1100</span>     <span class="p">}</span>   
<span class="mi">1101</span>     
<span class="mi">1102</span>     <span class="nf">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1103</span>         <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isLoad</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1104</span>             <span class="n">isStoreBlocked</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="mi">1105</span>         <span class="p">}</span>
<span class="mi">1106</span>         <span class="n">lsq</span><span class="o">-&gt;</span><span class="n">cachePortBusy</span><span class="p">(</span><span class="n">isLoad</span><span class="p">);</span>
<span class="mi">1107</span>         <span class="n">state</span><span class="o">-&gt;</span><span class="n">outstanding</span><span class="o">++</span><span class="p">;</span>                
<span class="mi">1108</span>         <span class="n">state</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">packetSent</span><span class="p">();</span>
<span class="mi">1109</span>     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="mi">1110</span>         <span class="k">if</span> <span class="p">(</span><span class="n">cache_got_blocked</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1111</span>             <span class="n">lsq</span><span class="o">-&gt;</span><span class="n">cacheBlocked</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
<span class="mi">1112</span>             <span class="o">++</span><span class="n">lsqCacheBlocked</span><span class="p">;</span>
<span class="mi">1113</span>         <span class="p">}</span>
<span class="mi">1114</span>         <span class="nf">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isLoad</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1115</span>             <span class="n">assert</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">()</span> <span class="o">==</span> <span class="n">storeWBIt</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">());</span>
<span class="mi">1116</span>             <span class="n">isStoreBlocked</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="mi">1117</span>         <span class="p">}</span>
<span class="mi">1118</span>         <span class="n">state</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">packetNotSent</span><span class="p">();</span>
<span class="mi">1119</span>     <span class="p">}</span>
<span class="mi">1120</span>     <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="mi">1121</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>This packet will be sent to the cache through the cache port 
connected to the LSQ. 
It first checks whether the cache is currently blocked.
If it is not blocked and there are available read port for the cache,
then it sends the request packet through the dcachePort. 
It can initiate memory access by sending request packet 
through a <em>sendTimingReq</em> method.
Because CPU goes through the data cache 
before touching the physical memory, 
the sendTimingReq is invoked on the DcachePort.</p>

<p><em>gem5/src/mem/port.hh</em></p>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="mi">444</span> <span class="kr">inline</span> <span class="kt">bool</span>
<span class="mi">445</span> <span class="n">MasterPort</span><span class="o">::</span><span class="n">sendTimingReq</span><span class="p">(</span><span class="n">PacketPtr</span> <span class="n">pkt</span><span class="p">)</span>
<span class="mi">446</span> <span class="p">{</span>
<span class="mi">447</span>     <span class="k">return</span> <span class="n">TimingRequestProtocol</span><span class="o">::</span><span class="n">sendReq</span><span class="p">(</span><span class="n">_slavePort</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
<span class="mi">448</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p><em>mem/protocol/timing.cc</em></p>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre> <span class="mi">47</span> <span class="cm">/* The request protocol. */</span>
 <span class="mi">48</span> 
 <span class="mi">49</span> <span class="kt">bool</span>
 <span class="mi">50</span> <span class="n">TimingRequestProtocol</span><span class="o">::</span><span class="n">sendReq</span><span class="p">(</span><span class="n">TimingResponseProtocol</span> <span class="o">*</span><span class="n">peer</span><span class="p">,</span> <span class="n">PacketPtr</span> <span class="n">pkt</span><span class="p">)</span>
 <span class="mi">51</span> <span class="p">{</span>
 <span class="mi">52</span>     <span class="n">assert</span><span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">isRequest</span><span class="p">());</span>
 <span class="mi">53</span>     <span class="k">return</span> <span class="n">peer</span><span class="o">-&gt;</span><span class="n">recvTimingReq</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>
 <span class="mi">54</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>The sendTimingReq function is very simple. 
Just invoke the recvTimingReq function of the peer connected to the dcachePort
as a slave. 
Because the cache unit is connected to the dcachePort on the other side of the CPU,
we will take a look at the recvTimingReq implementation of the cache unit.</p>

<h1 id="cache-cache-cache">Cache, Cache, Cache!</h1>
<h2 id="recvtimingreq-of-the-basecache-how-to-process-the-cache-access"><span class="me-2">recvTimingReq of the BaseCache: how to process the cache access?</span><a href="#recvtimingreq-of-the-basecache-how-to-process-the-cache-access" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre><span class="mi">2448</span> <span class="kt">bool</span>
<span class="mi">2449</span> <span class="n">BaseCache</span><span class="o">::</span><span class="n">CpuSidePort</span><span class="o">::</span><span class="n">recvTimingReq</span><span class="p">(</span><span class="n">PacketPtr</span> <span class="n">pkt</span><span class="p">)</span>
<span class="mi">2450</span> <span class="p">{</span>
<span class="mi">2451</span>     <span class="n">assert</span><span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">isRequest</span><span class="p">());</span>
<span class="mi">2452</span> 
<span class="mi">2453</span>     <span class="k">if</span> <span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">system</span><span class="o">-&gt;</span><span class="n">bypassCaches</span><span class="p">())</span> <span class="p">{</span>
<span class="mi">2454</span>         <span class="c1">// Just forward the packet if caches are disabled.</span>
<span class="mi">2455</span>         <span class="c1">// @todo This should really enqueue the packet rather</span>
<span class="mi">2456</span>         <span class="n">GEM5_VAR_USED</span> <span class="kt">bool</span> <span class="n">success</span> <span class="o">=</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">memSidePort</span><span class="p">.</span><span class="n">sendTimingReq</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>
<span class="mi">2457</span>         <span class="n">assert</span><span class="p">(</span><span class="n">success</span><span class="p">);</span>
<span class="mi">2458</span>         <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="mi">2459</span>     <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">tryTiming</span><span class="p">(</span><span class="n">pkt</span><span class="p">))</span> <span class="p">{</span>
<span class="mi">2460</span>         <span class="n">cache</span><span class="o">-&gt;</span><span class="n">recvTimingReq</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>
<span class="mi">2461</span>         <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="mi">2462</span>     <span class="p">}</span>
<span class="mi">2463</span>     <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="mi">2464</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>First of all, the cache port connected to the CPU side 
will be in charge of handling timing request generated from CPU side. 
Because the BaseCache contains dedicated port for communicating with the CPU side,
called CpuSidePort, its recvTimingReq function will be invoked.
However, the main cache operations are done by the BaseCache’s recvTimingReq</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="rouge-code"><pre> <span class="mi">349</span> <span class="kt">void</span>
 <span class="mi">350</span> <span class="n">BaseCache</span><span class="o">::</span><span class="n">recvTimingReq</span><span class="p">(</span><span class="n">PacketPtr</span> <span class="n">pkt</span><span class="p">)</span>
 <span class="mi">351</span> <span class="p">{</span>   
 <span class="mi">352</span>     <span class="c1">// anything that is merely forwarded pays for the forward latency and</span>
 <span class="mi">353</span>     <span class="c1">// the delay provided by the crossbar</span>
 <span class="mi">354</span>     <span class="n">Tick</span> <span class="n">forward_time</span> <span class="o">=</span> <span class="n">clockEdge</span><span class="p">(</span><span class="n">forwardLatency</span><span class="p">)</span> <span class="o">+</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">headerDelay</span><span class="p">;</span>
 <span class="mi">355</span>     
 <span class="mi">356</span>     <span class="n">Cycles</span> <span class="n">lat</span><span class="p">;</span>
 <span class="mi">357</span>     <span class="n">CacheBlk</span> <span class="o">*</span><span class="n">blk</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
 <span class="mi">358</span>     <span class="kt">bool</span> <span class="n">satisfied</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
 <span class="mi">359</span>     <span class="p">{</span>   
 <span class="mi">360</span>         <span class="n">PacketList</span> <span class="n">writebacks</span><span class="p">;</span>
 <span class="mi">361</span>         <span class="c1">// Note that lat is passed by reference here. The function</span>
 <span class="mi">362</span>         <span class="c1">// access() will set the lat value.</span>
 <span class="mi">363</span>         <span class="n">satisfied</span> <span class="o">=</span> <span class="n">access</span><span class="p">(</span><span class="n">pkt</span><span class="p">,</span> <span class="n">blk</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">writebacks</span><span class="p">);</span>
 <span class="mi">364</span>         
 <span class="mi">365</span>         <span class="c1">// After the evicted blocks are selected, they must be forwarded</span>
 <span class="mi">366</span>         <span class="c1">// to the write buffer to ensure they logically precede anything</span>
 <span class="mi">367</span>         <span class="c1">// happening below</span>
 <span class="mi">368</span>         <span class="n">doWritebacks</span><span class="p">(</span><span class="n">writebacks</span><span class="p">,</span> <span class="n">clockEdge</span><span class="p">(</span><span class="n">lat</span> <span class="o">+</span> <span class="n">forwardLatency</span><span class="p">));</span>
 <span class="mi">369</span>     <span class="p">}</span>
 <span class="mi">370</span>     
</pre></td></tr></tbody></table></code></div></div>
<p>Because the recvTimingReq is pretty complex and long, 
I will explain important parts one by one. 
First of all, it invokes the access function
to access the cache entry if the data mapped to the 
request address exists in the cache. 
After that, it invokes doWritebacks function to 
write backs evicted entries if exist. 
Btw, why the access generates victim entry and write back is required?
I will show you the answer soon.</p>

<h2 id="access-function-another-long-journey-in-the-midst-of-recvtimingreq"><span class="me-2">access function, another long journey in the midst of recvTimingReq</span><a href="#access-function-another-long-journey-in-the-midst-of-recvtimingreq" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>
<p>Unfortunately, the access function is more complex function 
than the recvTimingReq cause it emulates 
actual cache accesses in the GEM5 cache. 
Let’s take a look at its implementation one by one.</p>

<h3 id="access1-check-if-the-cache-block-exist-in-current-cache"><span class="me-2">access1: check if the cache block exist in current cache</span><a href="#access1-check-if-the-cache-block-exist-in-current-cache" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre><span class="mi">1152</span> <span class="kt">bool</span>
<span class="mi">1153</span> <span class="n">BaseCache</span><span class="o">::</span><span class="n">access</span><span class="p">(</span><span class="n">PacketPtr</span> <span class="n">pkt</span><span class="p">,</span> <span class="n">CacheBlk</span> <span class="o">*&amp;</span><span class="n">blk</span><span class="p">,</span> <span class="n">Cycles</span> <span class="o">&amp;</span><span class="n">lat</span><span class="p">,</span>
<span class="mi">1154</span>                   <span class="n">PacketList</span> <span class="o">&amp;</span><span class="n">writebacks</span><span class="p">)</span>
<span class="mi">1155</span> <span class="p">{</span>
<span class="mi">1156</span>     <span class="c1">// sanity check</span>
<span class="mi">1157</span>     <span class="n">assert</span><span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">isRequest</span><span class="p">());</span>
<span class="mi">1158</span> 
<span class="mi">1159</span>     <span class="n">chatty_assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">isReadOnly</span> <span class="o">&amp;&amp;</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">isWrite</span><span class="p">()),</span>
<span class="mi">1160</span>                   <span class="s">"Should never see a write in a read-only cache %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
<span class="mi">1161</span>                   <span class="n">name</span><span class="p">());</span>
<span class="mi">1162</span> 
<span class="mi">1163</span>     <span class="c1">// Access block in the tags</span>
<span class="mi">1164</span>     <span class="n">Cycles</span> <span class="n">tag_latency</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="mi">1165</span>     <span class="n">blk</span> <span class="o">=</span> <span class="n">tags</span><span class="o">-&gt;</span><span class="n">accessBlock</span><span class="p">(</span><span class="n">pkt</span><span class="p">,</span> <span class="n">tag_latency</span><span class="p">);</span>
<span class="mi">1166</span> 
<span class="mi">1167</span>     <span class="n">DPRINTF</span><span class="p">(</span><span class="n">Cache</span><span class="p">,</span> <span class="s">"%s for %s %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">print</span><span class="p">(),</span>
<span class="mi">1168</span>             <span class="n">blk</span> <span class="o">?</span> <span class="s">"hit "</span> <span class="o">+</span> <span class="n">blk</span><span class="o">-&gt;</span><span class="n">print</span><span class="p">()</span> <span class="o">:</span> <span class="s">"miss"</span><span class="p">);</span>
<span class="mi">1169</span> 
</pre></td></tr></tbody></table></code></div></div>
<p>The first job done by the access function is retrieving the CacheBlk 
associated with current request address. 
Because the tags member field manages all CacheBlk of the cache,
it invokes the accessBlock function of the tags.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre></td><td class="rouge-code"><pre><span class="mi">117</span>     <span class="cm">/**
118      * Access block and update replacement data. May not succeed, in which case
119      * nullptr is returned. This has all the implications of a cache access and
120      * should only be used as such. Returns the tag lookup latency as a side
121      * effect.
122      *
123      * @param pkt The packet holding the address to find.
124      * @param lat The latency of the tag lookup.
125      * @return Pointer to the cache block if found.
126      */</span>
<span class="mi">127</span>     <span class="n">CacheBlk</span><span class="o">*</span> <span class="nf">accessBlock</span><span class="p">(</span><span class="k">const</span> <span class="n">PacketPtr</span> <span class="n">pkt</span><span class="p">,</span> <span class="n">Cycles</span> <span class="o">&amp;</span><span class="n">lat</span><span class="p">)</span> <span class="k">override</span>
<span class="mi">128</span>     <span class="p">{</span>
<span class="mi">129</span>         <span class="n">CacheBlk</span> <span class="o">*</span><span class="n">blk</span> <span class="o">=</span> <span class="n">findBlock</span><span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">getAddr</span><span class="p">(),</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">isSecure</span><span class="p">());</span>
<span class="mi">130</span> 
<span class="mi">131</span>         <span class="c1">// Access all tags in parallel, hence one in each way.  The data side</span>
<span class="mi">132</span>         <span class="c1">// either accesses all blocks in parallel, or one block sequentially on</span>
<span class="mi">133</span>         <span class="c1">// a hit.  Sequential access with a miss doesn't access data.</span>
<span class="mi">134</span>         <span class="n">stats</span><span class="p">.</span><span class="n">tagAccesses</span> <span class="o">+=</span> <span class="n">allocAssoc</span><span class="p">;</span>
<span class="mi">135</span>         <span class="nf">if</span> <span class="p">(</span><span class="n">sequentialAccess</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">136</span>             <span class="k">if</span> <span class="p">(</span><span class="n">blk</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">137</span>                 <span class="n">stats</span><span class="p">.</span><span class="n">dataAccesses</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="mi">138</span>             <span class="p">}</span>
<span class="mi">139</span>         <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="mi">140</span>             <span class="n">stats</span><span class="p">.</span><span class="n">dataAccesses</span> <span class="o">+=</span> <span class="n">allocAssoc</span><span class="p">;</span>
<span class="mi">141</span>         <span class="p">}</span>
<span class="mi">142</span> 
<span class="mi">143</span>         <span class="c1">// If a cache hit</span>
<span class="mi">144</span>         <span class="nf">if</span> <span class="p">(</span><span class="n">blk</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">145</span>             <span class="c1">// Update number of references to accessed block</span>
<span class="mi">146</span>             <span class="n">blk</span><span class="o">-&gt;</span><span class="n">increaseRefCount</span><span class="p">();</span>
<span class="mi">147</span> 
<span class="mi">148</span>             <span class="c1">// Update replacement data of accessed block</span>
<span class="mi">149</span>             <span class="n">replacementPolicy</span><span class="o">-&gt;</span><span class="n">touch</span><span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">replacementData</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
<span class="mi">150</span>         <span class="p">}</span>
<span class="mi">151</span> 
<span class="mi">152</span>         <span class="c1">// The tag lookup latency is the same for a hit or a miss</span>
<span class="mi">153</span>         <span class="n">lat</span> <span class="o">=</span> <span class="n">lookupLatency</span><span class="p">;</span>
<span class="mi">154</span> 
<span class="mi">155</span>         <span class="k">return</span> <span class="n">blk</span><span class="p">;</span>
<span class="mi">156</span>     <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="rouge-code"><pre> <span class="mi">79</span> <span class="n">CacheBlk</span><span class="o">*</span>
 <span class="mi">80</span> <span class="n">BaseTags</span><span class="o">::</span><span class="n">findBlock</span><span class="p">(</span><span class="n">Addr</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">is_secure</span><span class="p">)</span> <span class="k">const</span>
 <span class="mi">81</span> <span class="p">{</span>
 <span class="mi">82</span>     <span class="c1">// Extract block tag</span>
 <span class="mi">83</span>     <span class="n">Addr</span> <span class="n">tag</span> <span class="o">=</span> <span class="n">extractTag</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
 <span class="mi">84</span> 
 <span class="mi">85</span>     <span class="c1">// Find possible entries that may contain the given address</span>
 <span class="mi">86</span>     <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ReplaceableEntry</span><span class="o">*&gt;</span> <span class="n">entries</span> <span class="o">=</span>
 <span class="mi">87</span>         <span class="n">indexingPolicy</span><span class="o">-&gt;</span><span class="n">getPossibleEntries</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
 <span class="mi">88</span> 
 <span class="mi">89</span>     <span class="c1">// Search for block</span>
 <span class="mi">90</span>     <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">location</span> <span class="o">:</span> <span class="n">entries</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">91</span>         <span class="n">CacheBlk</span><span class="o">*</span> <span class="n">blk</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">CacheBlk</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">location</span><span class="p">);</span>
 <span class="mi">92</span>         <span class="k">if</span> <span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">matchTag</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="n">is_secure</span><span class="p">))</span> <span class="p">{</span>
 <span class="mi">93</span>             <span class="k">return</span> <span class="n">blk</span><span class="p">;</span>
 <span class="mi">94</span>         <span class="p">}</span>
 <span class="mi">95</span>     <span class="p">}</span>
 <span class="mi">96</span> 
 <span class="mi">97</span>     <span class="c1">// Did not find block</span>
 <span class="mi">98</span>     <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
 <span class="mi">99</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>Because the CacheBlk is associated with one address 
based on the Tag value, by checking the tag value 
of way entries in one set mapped to current request’s address,
it can find whether the cache already contains the cache block
mapped to current request address.</p>

<p>Also, note that it can return nullptr
when there is no cache hit.
Therefore, by checking the returned CacheBlk 
as a result of the findBlock function,
it can distinguish cache hit and miss. 
When the cache hit happens, 
it invokes touch function of the replacementPolicy
to update the replacement policy 
associated with current CacheBlk.</p>

<h3 id="access2-handling-cache-maintenance-packet"><span class="me-2">access2: handling cache maintenance packet</span><a href="#access2-handling-cache-maintenance-packet" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<p>Let’s go back to the access function. 
After the accessBlock function returns, it checks 
types of the packet.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="rouge-code"><pre><span class="mi">1170</span>     <span class="nf">if</span> <span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">isCacheMaintenance</span><span class="p">())</span> <span class="p">{</span>
<span class="mi">1171</span>         <span class="c1">// A cache maintenance operation is always forwarded to the</span>
<span class="mi">1172</span>         <span class="c1">// memory below even if the block is found in dirty state.</span>
<span class="mi">1173</span> 
<span class="mi">1174</span>         <span class="c1">// We defer any changes to the state of the block until we</span>
<span class="mi">1175</span>         <span class="c1">// create and mark as in service the mshr for the downstream</span>
<span class="mi">1176</span>         <span class="c1">// packet.</span>
<span class="mi">1177</span> 
<span class="mi">1178</span>         <span class="c1">// Calculate access latency on top of when the packet arrives. This</span>
<span class="mi">1179</span>         <span class="c1">// takes into account the bus delay.</span>
<span class="mi">1180</span>         <span class="n">lat</span> <span class="o">=</span> <span class="n">calculateTagOnlyLatency</span><span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">headerDelay</span><span class="p">,</span> <span class="n">tag_latency</span><span class="p">);</span>
<span class="mi">1181</span> 
<span class="mi">1182</span>         <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="mi">1183</span>     <span class="p">}</span>

<span class="err">```</span><span class="n">cpp</span>
<span class="mi">1001</span>     <span class="cm">/**
1002      * Accessor functions to determine whether this request is part of
1003      * a cache maintenance operation. At the moment three operations
1004      * are supported:
1005 
1006      * 1) A cache clean operation updates all copies of a memory
1007      * location to the point of reference,
1008      * 2) A cache invalidate operation invalidates all copies of the
1009      * specified block in the memory above the point of reference,
1010      * 3) A clean and invalidate operation is a combination of the two
1011      * operations.
1012      * @{ */</span>
<span class="mi">1013</span>     <span class="kt">bool</span> <span class="nf">isCacheClean</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_flags</span><span class="p">.</span><span class="n">isSet</span><span class="p">(</span><span class="n">CLEAN</span><span class="p">);</span> <span class="p">}</span>
<span class="mi">1014</span>     <span class="kt">bool</span> <span class="nf">isCacheInvalidate</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_flags</span><span class="p">.</span><span class="n">isSet</span><span class="p">(</span><span class="n">INVALIDATE</span><span class="p">);</span> <span class="p">}</span>
<span class="mi">1015</span>     <span class="kt">bool</span> <span class="nf">isCacheMaintenance</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_flags</span><span class="p">.</span><span class="n">isSet</span><span class="p">(</span><span class="n">CLEAN</span><span class="o">|</span><span class="n">INVALIDATE</span><span class="p">);</span> <span class="p">}</span>
<span class="mi">1016</span>     <span class="cm">/** @} */</span>
</pre></td></tr></tbody></table></code></div></div>
<p>Currently, GEM5 provide three different requests for cache maintenance:
cache clean, cache invalidate, and clean and invalidate. 
Here is a good definition about invalidate and clean event in general.</p>

<blockquote>
  <p>Invalidate simply marks a cache line as “invalid”, meaning you won’t hit upon.
Clean causes the contents of the cache line to be written back to memory (or the next level of cache), 
but only if the cache line is “dirty”.
That is, the cache line holds the latest copy of that memory.
Clean &amp; Invalidate, as the name suggests, does both.
Dirty lines normally get back to memory through evictions. 
When the line is selected to be evicted, 
there is a check to see if it’s dirty.
If yes, it gets written back to memory.
Cleaning is way to force this to happen at a particular time.
For example, because something else is going to read the buffer.
In theory, if you invalidated a dirty line you could loose data.
As an invalid line won’t get written back to memory automatically through eviction.
In practice many cores will treat Invalidate as Clean&amp;Invalidate - 
but you shouldn’t rely on that.
If the line is potentially dirty, and you care about the data, 
you should use Clean&amp;Invalidate rather than Invalidate.</p>
</blockquote>

<p>Because the cache maintenance request is related with cache flushing 
and coherency, it should be specially handled by the cache unit. 
When the packet is sent to the cache for its maintenance 
it returns immediately from the access function and set the 
satisfied variable as false, which indicates the miss event happens.</p>

<h3 id="access3-handling-eviction-request-packet"><span class="me-2">access3: handling eviction request packet</span><a href="#access3-handling-eviction-request-packet" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre></td><td class="rouge-code"><pre><span class="mi">1185</span>     <span class="nf">if</span> <span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">isEviction</span><span class="p">())</span> <span class="p">{</span>
<span class="mi">1186</span>         <span class="c1">// We check for presence of block in above caches before issuing</span>
<span class="mi">1187</span>         <span class="c1">// Writeback or CleanEvict to write buffer. Therefore the only</span>
<span class="mi">1188</span>         <span class="c1">// possible cases can be of a CleanEvict packet coming from above</span>
<span class="mi">1189</span>         <span class="c1">// encountering a Writeback generated in this cache peer cache and</span>
<span class="mi">1190</span>         <span class="c1">// waiting in the write buffer. Cases of upper level peer caches</span>
<span class="mi">1191</span>         <span class="c1">// generating CleanEvict and Writeback or simply CleanEvict and</span>
<span class="mi">1192</span>         <span class="c1">// CleanEvict almost simultaneously will be caught by snoops sent out</span>
<span class="mi">1193</span>         <span class="c1">// by crossbar.</span>
<span class="mi">1194</span>         <span class="n">WriteQueueEntry</span> <span class="o">*</span><span class="n">wb_entry</span> <span class="o">=</span> <span class="n">writeBuffer</span><span class="p">.</span><span class="n">findMatch</span><span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">getAddr</span><span class="p">(),</span>
<span class="mi">1195</span>                                                           <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">isSecure</span><span class="p">());</span>
<span class="mi">1196</span>         <span class="k">if</span> <span class="p">(</span><span class="n">wb_entry</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1197</span>             <span class="n">assert</span><span class="p">(</span><span class="n">wb_entry</span><span class="o">-&gt;</span><span class="n">getNumTargets</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
<span class="mi">1198</span>             <span class="n">PacketPtr</span> <span class="n">wbPkt</span> <span class="o">=</span> <span class="n">wb_entry</span><span class="o">-&gt;</span><span class="n">getTarget</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">pkt</span><span class="p">;</span>
<span class="mi">1199</span>             <span class="n">assert</span><span class="p">(</span><span class="n">wbPkt</span><span class="o">-&gt;</span><span class="n">isWriteback</span><span class="p">());</span>
<span class="mi">1200</span> 
<span class="mi">1201</span>             <span class="k">if</span> <span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">isCleanEviction</span><span class="p">())</span> <span class="p">{</span>
<span class="mi">1202</span>                 <span class="c1">// The CleanEvict and WritebackClean snoops into other</span>
<span class="mi">1203</span>                 <span class="c1">// peer caches of the same level while traversing the</span>
<span class="mi">1204</span>                 <span class="c1">// crossbar. If a copy of the block is found, the</span>
<span class="mi">1205</span>                 <span class="c1">// packet is deleted in the crossbar. Hence, none of</span>
<span class="mi">1206</span>                 <span class="c1">// the other upper level caches connected to this</span>
<span class="mi">1207</span>                 <span class="c1">// cache have the block, so we can clear the</span>
<span class="mi">1208</span>                 <span class="c1">// BLOCK_CACHED flag in the Writeback if set and</span>
<span class="mi">1209</span>                 <span class="c1">// discard the CleanEvict by returning true.</span>
<span class="mi">1210</span>                 <span class="n">wbPkt</span><span class="o">-&gt;</span><span class="n">clearBlockCached</span><span class="p">();</span>
<span class="mi">1211</span> 
<span class="mi">1212</span>                 <span class="c1">// A clean evict does not need to access the data array</span>
<span class="mi">1213</span>                 <span class="n">lat</span> <span class="o">=</span> <span class="n">calculateTagOnlyLatency</span><span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">headerDelay</span><span class="p">,</span> <span class="n">tag_latency</span><span class="p">);</span>
<span class="mi">1214</span> 
<span class="mi">1215</span>                 <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="mi">1216</span>             <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="mi">1217</span>                 <span class="n">assert</span><span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">MemCmd</span><span class="o">::</span><span class="n">WritebackDirty</span><span class="p">);</span>
<span class="mi">1218</span>                 <span class="c1">// Dirty writeback from above trumps our clean</span>
<span class="mi">1219</span>                 <span class="c1">// writeback... discard here</span>
<span class="mi">1220</span>                 <span class="c1">// Note: markInService will remove entry from writeback buffer.</span>
<span class="mi">1221</span>                 <span class="n">markInService</span><span class="p">(</span><span class="n">wb_entry</span><span class="p">);</span>
<span class="mi">1222</span>                 <span class="k">delete</span> <span class="n">wbPkt</span><span class="p">;</span>
<span class="mi">1223</span>             <span class="p">}</span>
<span class="mi">1224</span>         <span class="p">}</span>
<span class="mi">1225</span>     <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre> <span class="mi">91</span>     <span class="p">{</span> <span class="p">{</span><span class="n">IsWrite</span><span class="p">,</span> <span class="n">IsRequest</span><span class="p">,</span> <span class="n">IsEviction</span><span class="p">,</span> <span class="n">HasData</span><span class="p">,</span> <span class="n">FromCache</span><span class="p">},</span>
 <span class="mi">92</span>             <span class="n">InvalidCmd</span><span class="p">,</span> <span class="s">"WritebackDirty"</span> <span class="p">},</span>
 <span class="mi">93</span>     <span class="cm">/* WritebackClean - This allows the upstream cache to writeback a
 94      * line to the downstream cache without it being considered
 95      * dirty. */</span>
 <span class="mi">96</span>     <span class="p">{</span> <span class="p">{</span><span class="n">IsWrite</span><span class="p">,</span> <span class="n">IsRequest</span><span class="p">,</span> <span class="n">IsEviction</span><span class="p">,</span> <span class="n">HasData</span><span class="p">,</span> <span class="n">FromCache</span><span class="p">},</span>
 <span class="mi">97</span>             <span class="n">InvalidCmd</span><span class="p">,</span> <span class="s">"WritebackClean"</span> <span class="p">},</span>
<span class="mi">101</span>     <span class="cm">/* CleanEvict */</span>
<span class="mi">102</span>     <span class="p">{</span> <span class="p">{</span><span class="n">IsRequest</span><span class="p">,</span> <span class="n">IsEviction</span><span class="p">,</span> <span class="n">FromCache</span><span class="p">},</span> <span class="n">InvalidCmd</span><span class="p">,</span> <span class="s">"CleanEvict"</span> <span class="p">},</span>
</pre></td></tr></tbody></table></code></div></div>

<h3 id="access4-handle-writeback-packets"><span class="me-2">access4: handle writeback packets</span><a href="#access4-handle-writeback-packets" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
</pre></td><td class="rouge-code"><pre><span class="mi">1227</span>     <span class="c1">// The critical latency part of a write depends only on the tag access</span>
<span class="mi">1228</span>     <span class="nf">if</span> <span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">isWrite</span><span class="p">())</span> <span class="p">{</span>
<span class="mi">1229</span>         <span class="n">lat</span> <span class="o">=</span> <span class="n">calculateTagOnlyLatency</span><span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">headerDelay</span><span class="p">,</span> <span class="n">tag_latency</span><span class="p">);</span>
<span class="mi">1230</span>     <span class="p">}</span>
<span class="mi">1231</span> 
<span class="mi">1232</span>     <span class="c1">// Writeback handling is special case.  We can write the block into</span>
<span class="mi">1233</span>     <span class="c1">// the cache without having a writeable copy (or any copy at all).</span>
<span class="mi">1234</span>     <span class="nf">if</span> <span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">isWriteback</span><span class="p">())</span> <span class="p">{</span>
<span class="mi">1235</span>         <span class="n">assert</span><span class="p">(</span><span class="n">blkSize</span> <span class="o">==</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">getSize</span><span class="p">());</span>
<span class="mi">1236</span> 
<span class="mi">1237</span>         <span class="c1">// we could get a clean writeback while we are having</span>
<span class="mi">1238</span>         <span class="c1">// outstanding accesses to a block, do the simple thing for</span>
<span class="mi">1239</span>         <span class="c1">// now and drop the clean writeback so that we do not upset</span>
<span class="mi">1240</span>         <span class="c1">// any ordering/decisions about ownership already taken</span>
<span class="mi">1241</span>         <span class="k">if</span> <span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">MemCmd</span><span class="o">::</span><span class="n">WritebackClean</span> <span class="o">&amp;&amp;</span>
<span class="mi">1242</span>             <span class="n">mshrQueue</span><span class="p">.</span><span class="n">findMatch</span><span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">getAddr</span><span class="p">(),</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">isSecure</span><span class="p">()))</span> <span class="p">{</span>
<span class="mi">1243</span>             <span class="n">DPRINTF</span><span class="p">(</span><span class="n">Cache</span><span class="p">,</span> <span class="s">"Clean writeback %#llx to block with MSHR, "</span>
<span class="mi">1244</span>                     <span class="s">"dropping</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">getAddr</span><span class="p">());</span>
<span class="mi">1245</span> 
<span class="mi">1246</span>             <span class="c1">// A writeback searches for the block, then writes the data.</span>
<span class="mi">1247</span>             <span class="c1">// As the writeback is being dropped, the data is not touched,</span>
<span class="mi">1248</span>             <span class="c1">// and we just had to wait for the time to find a match in the</span>
<span class="mi">1249</span>             <span class="c1">// MSHR. As of now assume a mshr queue search takes as long as</span>
<span class="mi">1250</span>             <span class="c1">// a tag lookup for simplicity.</span>
<span class="mi">1251</span>             <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="mi">1252</span>         <span class="p">}</span>
<span class="mi">1253</span> 
<span class="mi">1254</span>         <span class="k">const</span> <span class="kt">bool</span> <span class="n">has_old_data</span> <span class="o">=</span> <span class="n">blk</span> <span class="o">&amp;&amp;</span> <span class="n">blk</span><span class="o">-&gt;</span><span class="n">isValid</span><span class="p">();</span>
<span class="mi">1255</span>         <span class="nf">if</span> <span class="p">(</span><span class="o">!</span><span class="n">blk</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1256</span>             <span class="c1">// need to do a replacement</span>
<span class="mi">1257</span>             <span class="n">blk</span> <span class="o">=</span> <span class="n">allocateBlock</span><span class="p">(</span><span class="n">pkt</span><span class="p">,</span> <span class="n">writebacks</span><span class="p">);</span>
<span class="mi">1258</span>             <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">blk</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1259</span>                 <span class="c1">// no replaceable block available: give up, fwd to next level.</span>
<span class="mi">1260</span>                 <span class="n">incMissCount</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>
<span class="mi">1261</span>                 <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="mi">1262</span>             <span class="p">}</span>
<span class="mi">1263</span> 
<span class="mi">1264</span>             <span class="n">blk</span><span class="o">-&gt;</span><span class="n">setCoherenceBits</span><span class="p">(</span><span class="n">CacheBlk</span><span class="o">::</span><span class="n">ReadableBit</span><span class="p">);</span>
<span class="mi">1265</span>         <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">compressor</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1266</span>             <span class="c1">// This is an overwrite to an existing block, therefore we need</span>
<span class="mi">1267</span>             <span class="c1">// to check for data expansion (i.e., block was compressed with</span>
<span class="mi">1268</span>             <span class="c1">// a smaller size, and now it doesn't fit the entry anymore).</span>
<span class="mi">1269</span>             <span class="c1">// If that is the case we might need to evict blocks.</span>
<span class="mi">1270</span>             <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">updateCompressionData</span><span class="p">(</span><span class="n">blk</span><span class="p">,</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">getConstPtr</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="o">&gt;</span><span class="p">(),</span>
<span class="mi">1271</span>                 <span class="n">writebacks</span><span class="p">))</span> <span class="p">{</span>
<span class="mi">1272</span>                 <span class="n">invalidateBlock</span><span class="p">(</span><span class="n">blk</span><span class="p">);</span>
<span class="mi">1273</span>                 <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="mi">1274</span>             <span class="p">}</span>
<span class="mi">1275</span>         <span class="p">}</span>
<span class="mi">1276</span> 
<span class="mi">1277</span>         <span class="c1">// only mark the block dirty if we got a writeback command,</span>
<span class="mi">1278</span>         <span class="c1">// and leave it as is for a clean writeback</span>
<span class="mi">1279</span>         <span class="nf">if</span> <span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">MemCmd</span><span class="o">::</span><span class="n">WritebackDirty</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1280</span>             <span class="c1">// TODO: the coherent cache can assert that the dirty bit is set</span>
<span class="mi">1281</span>             <span class="n">blk</span><span class="o">-&gt;</span><span class="n">setCoherenceBits</span><span class="p">(</span><span class="n">CacheBlk</span><span class="o">::</span><span class="n">DirtyBit</span><span class="p">);</span>
<span class="mi">1282</span>         <span class="p">}</span>
<span class="mi">1283</span>         <span class="c1">// if the packet does not have sharers, it is passing</span>
<span class="mi">1284</span>         <span class="c1">// writable, and we got the writeback in Modified or Exclusive</span>
<span class="mi">1285</span>         <span class="c1">// state, if not we are in the Owned or Shared state</span>
<span class="mi">1286</span>         <span class="nf">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">hasSharers</span><span class="p">())</span> <span class="p">{</span>
<span class="mi">1287</span>             <span class="n">blk</span><span class="o">-&gt;</span><span class="n">setCoherenceBits</span><span class="p">(</span><span class="n">CacheBlk</span><span class="o">::</span><span class="n">WritableBit</span><span class="p">);</span>
<span class="mi">1288</span>         <span class="p">}</span>
<span class="mi">1289</span>         <span class="c1">// nothing else to do; writeback doesn't expect response</span>
<span class="mi">1290</span>         <span class="nf">assert</span><span class="p">(</span><span class="o">!</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">needsResponse</span><span class="p">());</span>
<span class="mi">1291</span> 
<span class="mi">1292</span>         <span class="nf">updateBlockData</span><span class="p">(</span><span class="n">blk</span><span class="p">,</span> <span class="n">pkt</span><span class="p">,</span> <span class="n">has_old_data</span><span class="p">);</span>
<span class="mi">1293</span>         <span class="nf">DPRINTF</span><span class="p">(</span><span class="n">Cache</span><span class="p">,</span> <span class="s">"%s new state is %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">blk</span><span class="o">-&gt;</span><span class="n">print</span><span class="p">());</span>
<span class="mi">1294</span>         <span class="nf">incHitCount</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>
<span class="mi">1295</span> 
<span class="mi">1296</span>         <span class="c1">// When the packet metadata arrives, the tag lookup will be done while</span>
<span class="mi">1297</span>         <span class="c1">// the payload is arriving. Then the block will be ready to access as</span>
<span class="mi">1298</span>         <span class="c1">// soon as the fill is done</span>
<span class="mi">1299</span>         <span class="n">blk</span><span class="o">-&gt;</span><span class="n">setWhenReady</span><span class="p">(</span><span class="n">clockEdge</span><span class="p">(</span><span class="n">fillLatency</span><span class="p">)</span> <span class="o">+</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">headerDelay</span> <span class="o">+</span>
<span class="mi">1300</span>             <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">cyclesToTicks</span><span class="p">(</span><span class="n">tag_latency</span><span class="p">),</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">payloadDelay</span><span class="p">));</span>
<span class="mi">1301</span> 
<span class="mi">1302</span>         <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="mi">1303</span>     <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">MemCmd</span><span class="o">::</span><span class="n">CleanEvict</span><span class="p">)</span> <span class="p">{</span>
</pre></td></tr></tbody></table></code></div></div>

<p>The GEM5 defines the condition for writeback as below.</p>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre> <span class="mi">229</span>     <span class="cm">/**
 230      * A writeback is an eviction that carries data.
 231      */</span>
 <span class="mi">232</span>     <span class="kt">bool</span> <span class="nf">isWriteback</span><span class="p">()</span> <span class="k">const</span>       <span class="p">{</span> <span class="k">return</span> <span class="n">testCmdAttrib</span><span class="p">(</span><span class="n">IsEviction</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
 <span class="mi">233</span>                                             <span class="n">testCmdAttrib</span><span class="p">(</span><span class="n">HasData</span><span class="p">);</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>When the request packet sets IsEviction and HasData, 
it means that current request packet invoked the access function
was the writeback request packet. 
Below code specified the commands that satisfy above condition.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre> <span class="mi">91</span>     <span class="p">{</span> <span class="p">{</span><span class="n">IsWrite</span><span class="p">,</span> <span class="n">IsRequest</span><span class="p">,</span> <span class="n">IsEviction</span><span class="p">,</span> <span class="n">HasData</span><span class="p">,</span> <span class="n">FromCache</span><span class="p">},</span>
 <span class="mi">92</span>             <span class="n">InvalidCmd</span><span class="p">,</span> <span class="s">"WritebackDirty"</span> <span class="p">},</span>
 <span class="mi">93</span>     <span class="cm">/* WritebackClean - This allows the upstream cache to writeback a
 94      * line to the downstream cache without it being considered
 95      * dirty. */</span>
 <span class="mi">96</span>     <span class="p">{</span> <span class="p">{</span><span class="n">IsWrite</span><span class="p">,</span> <span class="n">IsRequest</span><span class="p">,</span> <span class="n">IsEviction</span><span class="p">,</span> <span class="n">HasData</span><span class="p">,</span> <span class="n">FromCache</span><span class="p">},</span>
 <span class="mi">97</span>             <span class="n">InvalidCmd</span><span class="p">,</span> <span class="s">"WritebackClean"</span> <span class="p">},</span>
</pre></td></tr></tbody></table></code></div></div>

<p>When those conditions are met, the access function handles writeback packet.
\XXX{need more explain for this case}</p>

<h3 id="access5-handle-cleanevict-and-writeclean-packets"><span class="me-2">access5: handle CleanEvict and writeClean packets</span><a href="#access5-handle-cleanevict-and-writeclean-packets" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
</pre></td><td class="rouge-code"><pre><span class="mi">1303</span>     <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">MemCmd</span><span class="o">::</span><span class="n">CleanEvict</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1304</span>         <span class="c1">// A CleanEvict does not need to access the data array</span>
<span class="mi">1305</span>         <span class="n">lat</span> <span class="o">=</span> <span class="n">calculateTagOnlyLatency</span><span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">headerDelay</span><span class="p">,</span> <span class="n">tag_latency</span><span class="p">);</span>
<span class="mi">1306</span> 
<span class="mi">1307</span>         <span class="k">if</span> <span class="p">(</span><span class="n">blk</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1308</span>             <span class="c1">// Found the block in the tags, need to stop CleanEvict from</span>
<span class="mi">1309</span>             <span class="c1">// propagating further down the hierarchy. Returning true will</span>
<span class="mi">1310</span>             <span class="c1">// treat the CleanEvict like a satisfied write request and delete</span>
<span class="mi">1311</span>             <span class="c1">// it.</span>
<span class="mi">1312</span>             <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="mi">1313</span>         <span class="p">}</span>
<span class="mi">1314</span>         <span class="c1">// We didn't find the block here, propagate the CleanEvict further</span>
<span class="mi">1315</span>         <span class="c1">// down the memory hierarchy. Returning false will treat the CleanEvict</span>
<span class="mi">1316</span>         <span class="c1">// like a Writeback which could not find a replaceable block so has to</span>
<span class="mi">1317</span>         <span class="c1">// go to next level.</span>
<span class="mi">1318</span>         <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="mi">1319</span>     <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">MemCmd</span><span class="o">::</span><span class="n">WriteClean</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1320</span>         <span class="c1">// WriteClean handling is a special case. We can allocate a</span>
<span class="mi">1321</span>         <span class="c1">// block directly if it doesn't exist and we can update the</span>
<span class="mi">1322</span>         <span class="c1">// block immediately. The WriteClean transfers the ownership</span>
<span class="mi">1323</span>         <span class="c1">// of the block as well.</span>
<span class="mi">1324</span>         <span class="n">assert</span><span class="p">(</span><span class="n">blkSize</span> <span class="o">==</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">getSize</span><span class="p">());</span>
<span class="mi">1325</span> 
<span class="mi">1326</span>         <span class="k">const</span> <span class="kt">bool</span> <span class="n">has_old_data</span> <span class="o">=</span> <span class="n">blk</span> <span class="o">&amp;&amp;</span> <span class="n">blk</span><span class="o">-&gt;</span><span class="n">isValid</span><span class="p">();</span>
<span class="mi">1327</span>         <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">blk</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1328</span>             <span class="k">if</span> <span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">writeThrough</span><span class="p">())</span> <span class="p">{</span>
<span class="mi">1329</span>                 <span class="c1">// if this is a write through packet, we don't try to</span>
<span class="mi">1330</span>                 <span class="c1">// allocate if the block is not present</span>
<span class="mi">1331</span>                 <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="mi">1332</span>             <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="mi">1333</span>                 <span class="c1">// a writeback that misses needs to allocate a new block</span>
<span class="mi">1334</span>                 <span class="n">blk</span> <span class="o">=</span> <span class="n">allocateBlock</span><span class="p">(</span><span class="n">pkt</span><span class="p">,</span> <span class="n">writebacks</span><span class="p">);</span>
<span class="mi">1335</span>                 <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">blk</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1336</span>                     <span class="c1">// no replaceable block available: give up, fwd to</span>
<span class="mi">1337</span>                     <span class="c1">// next level.</span>
<span class="mi">1338</span>                     <span class="n">incMissCount</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>
<span class="mi">1339</span>                     <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="mi">1340</span>                 <span class="p">}</span>
<span class="mi">1341</span> 
<span class="mi">1342</span>                 <span class="n">blk</span><span class="o">-&gt;</span><span class="n">setCoherenceBits</span><span class="p">(</span><span class="n">CacheBlk</span><span class="o">::</span><span class="n">ReadableBit</span><span class="p">);</span>
<span class="mi">1343</span>             <span class="p">}</span>
<span class="mi">1344</span>         <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">compressor</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1345</span>             <span class="c1">// This is an overwrite to an existing block, therefore we need</span>
<span class="mi">1346</span>             <span class="c1">// to check for data expansion (i.e., block was compressed with</span>
<span class="mi">1347</span>             <span class="c1">// a smaller size, and now it doesn't fit the entry anymore).</span>
<span class="mi">1348</span>             <span class="c1">// If that is the case we might need to evict blocks.</span>
<span class="mi">1349</span>             <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">updateCompressionData</span><span class="p">(</span><span class="n">blk</span><span class="p">,</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">getConstPtr</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="o">&gt;</span><span class="p">(),</span>
<span class="mi">1350</span>                 <span class="n">writebacks</span><span class="p">))</span> <span class="p">{</span>
<span class="mi">1351</span>                 <span class="n">invalidateBlock</span><span class="p">(</span><span class="n">blk</span><span class="p">);</span>
<span class="mi">1352</span>                 <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="mi">1353</span>             <span class="p">}</span>
<span class="mi">1354</span>         <span class="p">}</span>
<span class="mi">1355</span> 
<span class="mi">1356</span>         <span class="c1">// at this point either this is a writeback or a write-through</span>
<span class="mi">1357</span>         <span class="c1">// write clean operation and the block is already in this</span>
<span class="mi">1358</span>         <span class="c1">// cache, we need to update the data and the block flags</span>
<span class="mi">1359</span>         <span class="nf">assert</span><span class="p">(</span><span class="n">blk</span><span class="p">);</span>
<span class="mi">1360</span>         <span class="c1">// TODO: the coherent cache can assert that the dirty bit is set</span>
<span class="mi">1361</span>         <span class="nf">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">writeThrough</span><span class="p">())</span> <span class="p">{</span>
<span class="mi">1362</span>             <span class="n">blk</span><span class="o">-&gt;</span><span class="n">setCoherenceBits</span><span class="p">(</span><span class="n">CacheBlk</span><span class="o">::</span><span class="n">DirtyBit</span><span class="p">);</span>
<span class="mi">1363</span>         <span class="p">}</span>
<span class="mi">1364</span>         <span class="c1">// nothing else to do; writeback doesn't expect response</span>
<span class="mi">1365</span>         <span class="nf">assert</span><span class="p">(</span><span class="o">!</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">needsResponse</span><span class="p">());</span>
<span class="mi">1366</span> 
<span class="mi">1367</span>         <span class="nf">updateBlockData</span><span class="p">(</span><span class="n">blk</span><span class="p">,</span> <span class="n">pkt</span><span class="p">,</span> <span class="n">has_old_data</span><span class="p">);</span>
<span class="mi">1368</span>         <span class="nf">DPRINTF</span><span class="p">(</span><span class="n">Cache</span><span class="p">,</span> <span class="s">"%s new state is %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">blk</span><span class="o">-&gt;</span><span class="n">print</span><span class="p">());</span>
<span class="mi">1369</span> 
<span class="mi">1370</span>         <span class="nf">incHitCount</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>
<span class="mi">1371</span> 
<span class="mi">1372</span>         <span class="c1">// When the packet metadata arrives, the tag lookup will be done while</span>
<span class="mi">1373</span>         <span class="c1">// the payload is arriving. Then the block will be ready to access as</span>
<span class="mi">1374</span>         <span class="c1">// soon as the fill is done</span>
<span class="mi">1375</span>         <span class="n">blk</span><span class="o">-&gt;</span><span class="n">setWhenReady</span><span class="p">(</span><span class="n">clockEdge</span><span class="p">(</span><span class="n">fillLatency</span><span class="p">)</span> <span class="o">+</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">headerDelay</span> <span class="o">+</span>
<span class="mi">1376</span>             <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">cyclesToTicks</span><span class="p">(</span><span class="n">tag_latency</span><span class="p">),</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">payloadDelay</span><span class="p">));</span>
<span class="mi">1377</span> 
<span class="mi">1378</span>         <span class="c1">// If this a write-through packet it will be sent to cache below</span>
<span class="mi">1379</span>         <span class="k">return</span> <span class="o">!</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">writeThrough</span><span class="p">();</span>
</pre></td></tr></tbody></table></code></div></div>

<h3 id="access6-handle-normal-read-or-write-request-to-existing-block-with-adequate-properties"><span class="me-2">access6: handle normal read or write request to existing block with adequate properties</span><a href="#access6-handle-normal-read-or-write-request-to-existing-block-with-adequate-properties" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="rouge-code"><pre><span class="mi">1380</span>     <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">blk</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">needsWritable</span><span class="p">()</span> <span class="o">?</span>
<span class="mi">1381</span>             <span class="n">blk</span><span class="o">-&gt;</span><span class="n">isSet</span><span class="p">(</span><span class="n">CacheBlk</span><span class="o">::</span><span class="n">WritableBit</span><span class="p">)</span> <span class="o">:</span>
<span class="mi">1382</span>             <span class="n">blk</span><span class="o">-&gt;</span><span class="n">isSet</span><span class="p">(</span><span class="n">CacheBlk</span><span class="o">::</span><span class="n">ReadableBit</span><span class="p">)))</span> <span class="p">{</span>
<span class="mi">1383</span>         <span class="c1">// OK to satisfy access</span>
<span class="mi">1384</span>         <span class="n">incHitCount</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>
<span class="mi">1385</span> 
<span class="mi">1386</span>         <span class="c1">// Calculate access latency based on the need to access the data array</span>
<span class="mi">1387</span>         <span class="k">if</span> <span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">isRead</span><span class="p">())</span> <span class="p">{</span>
<span class="mi">1388</span>             <span class="n">lat</span> <span class="o">=</span> <span class="n">calculateAccessLatency</span><span class="p">(</span><span class="n">blk</span><span class="p">,</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">headerDelay</span><span class="p">,</span> <span class="n">tag_latency</span><span class="p">);</span>
<span class="mi">1389</span> 
<span class="mi">1390</span>             <span class="c1">// When a block is compressed, it must first be decompressed</span>
<span class="mi">1391</span>             <span class="c1">// before being read. This adds to the access latency.</span>
<span class="mi">1392</span>             <span class="k">if</span> <span class="p">(</span><span class="n">compressor</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1393</span>                 <span class="n">lat</span> <span class="o">+=</span> <span class="n">compressor</span><span class="o">-&gt;</span><span class="n">getDecompressionLatency</span><span class="p">(</span><span class="n">blk</span><span class="p">);</span>
<span class="mi">1394</span>             <span class="p">}</span>
<span class="mi">1395</span>         <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="mi">1396</span>             <span class="n">lat</span> <span class="o">=</span> <span class="n">calculateTagOnlyLatency</span><span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">headerDelay</span><span class="p">,</span> <span class="n">tag_latency</span><span class="p">);</span>
<span class="mi">1397</span>         <span class="p">}</span>
<span class="mi">1398</span> 
<span class="mi">1399</span>         <span class="nf">satisfyRequest</span><span class="p">(</span><span class="n">pkt</span><span class="p">,</span> <span class="n">blk</span><span class="p">);</span>
<span class="mi">1400</span>         <span class="nf">maintainClusivity</span><span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">fromCache</span><span class="p">(),</span> <span class="n">blk</span><span class="p">);</span>
<span class="mi">1401</span> 
<span class="mi">1402</span>         <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="mi">1403</span>     <span class="p">}</span>
<span class="mi">1404</span> 
</pre></td></tr></tbody></table></code></div></div>
<p>To handle the read and write access to existing cache block,
it first should check the properties of the 
existing cache block such as writable and readable bit.
If those conditions of the cached block met 
requirement of the current request’s type such as read or write,
then it can be handled in the above condition statement. 
Note that it returns true at the end because 
the request can be handled with the cached block, which means cache hit.</p>

<p>Also, it invokes the satisfyRequest function to \XXX{do what?}
The satisfyRequest function is the virtual function of the BaseCache
and implemented also by its children class Cache class.
There are two main places that satisfyRequest is invoked,
the access function and serviceMSHRTarget.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre>

</pre></td></tr></tbody></table></code></div></div>

<h3 id="access7-other-cases-mainly-cache-misses"><span class="me-2">access7: other cases, mainly cache misses</span><a href="#access7-other-cases-mainly-cache-misses" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre><span class="mi">1405</span>     <span class="c1">// Can't satisfy access normally... either no block (blk == nullptr)</span>
<span class="mi">1406</span>     <span class="c1">// or have block but need writable</span>
<span class="mi">1407</span> 
<span class="mi">1408</span>     <span class="nf">incMissCount</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>
<span class="mi">1409</span> 
<span class="mi">1410</span>     <span class="n">lat</span> <span class="o">=</span> <span class="n">calculateAccessLatency</span><span class="p">(</span><span class="n">blk</span><span class="p">,</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">headerDelay</span><span class="p">,</span> <span class="n">tag_latency</span><span class="p">);</span>
<span class="mi">1411</span> 
<span class="mi">1412</span>     <span class="nf">if</span> <span class="p">(</span><span class="o">!</span><span class="n">blk</span> <span class="o">&amp;&amp;</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">isLLSC</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">isWrite</span><span class="p">())</span> <span class="p">{</span>
<span class="mi">1413</span>         <span class="c1">// complete miss on store conditional... just give up now</span>
<span class="mi">1414</span>         <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">setExtraData</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="mi">1415</span>         <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="mi">1416</span>     <span class="p">}</span>
<span class="mi">1417</span> 
<span class="mi">1418</span>     <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="mi">1419</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>This cases includes cache misses, write request to non-writable block,
or read request to non-readable block, etc.
When all conditions doesn’t match with the current’ request,
then it should be handled by the 
rest of the recvTimingReq function, particularly cache miss handling.
Note that it returns false.</p>

<h3 id="revisiting-revtimingreq-of-the-basecache-to-handle-cache-hit-and-miss"><span class="me-2">Revisiting revTimingReq of the BaseCache to handle cache hit and miss</span><a href="#revisiting-revtimingreq-of-the-basecache-to-handle-cache-hit-and-miss" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="rouge-code"><pre> <span class="mi">349</span> <span class="kt">void</span>
 <span class="mi">350</span> <span class="n">BaseCache</span><span class="o">::</span><span class="n">recvTimingReq</span><span class="p">(</span><span class="n">PacketPtr</span> <span class="n">pkt</span><span class="p">)</span>
 <span class="p">......</span>
 <span class="mi">371</span>     <span class="c1">// Here we charge the headerDelay that takes into account the latencies</span>
 <span class="mi">372</span>     <span class="c1">// of the bus, if the packet comes from it.</span>
 <span class="mi">373</span>     <span class="c1">// The latency charged is just the value set by the access() function.</span>
 <span class="mi">374</span>     <span class="c1">// In case of a hit we are neglecting response latency.</span>
 <span class="mi">375</span>     <span class="c1">// In case of a miss we are neglecting forward latency.</span>
 <span class="mi">376</span>     <span class="n">Tick</span> <span class="n">request_time</span> <span class="o">=</span> <span class="n">clockEdge</span><span class="p">(</span><span class="n">lat</span><span class="p">);</span>
 <span class="mi">377</span>     <span class="c1">// Here we reset the timing of the packet.</span>
 <span class="mi">378</span>     <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">headerDelay</span> <span class="o">=</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">payloadDelay</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="mi">379</span>     
 <span class="mi">380</span>     <span class="nf">if</span> <span class="p">(</span><span class="n">satisfied</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">381</span>         <span class="c1">// notify before anything else as later handleTimingReqHit might turn</span>
 <span class="mi">382</span>         <span class="c1">// the packet in a response</span>
 <span class="mi">383</span>         <span class="n">ppHit</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>
 <span class="mi">384</span>         
 <span class="mi">385</span>         <span class="k">if</span> <span class="p">(</span><span class="n">prefetcher</span> <span class="o">&amp;&amp;</span> <span class="n">blk</span> <span class="o">&amp;&amp;</span> <span class="n">blk</span><span class="o">-&gt;</span><span class="n">wasPrefetched</span><span class="p">())</span> <span class="p">{</span>
 <span class="mi">386</span>             <span class="n">DPRINTF</span><span class="p">(</span><span class="n">Cache</span><span class="p">,</span> <span class="s">"Hit on prefetch for addr %#x (%s)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
 <span class="mi">387</span>                     <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">getAddr</span><span class="p">(),</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">isSecure</span><span class="p">()</span> <span class="o">?</span> <span class="s">"s"</span> <span class="o">:</span> <span class="s">"ns"</span><span class="p">);</span>
 <span class="mi">388</span>             <span class="n">blk</span><span class="o">-&gt;</span><span class="n">clearPrefetched</span><span class="p">();</span>
 <span class="mi">389</span>         <span class="p">}</span>
 <span class="mi">390</span>         
 <span class="mi">391</span>         <span class="nf">handleTimingReqHit</span><span class="p">(</span><span class="n">pkt</span><span class="p">,</span> <span class="n">blk</span><span class="p">,</span> <span class="n">request_time</span><span class="p">);</span>
 <span class="mi">392</span>     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
 <span class="mi">393</span>         <span class="n">handleTimingReqMiss</span><span class="p">(</span><span class="n">pkt</span><span class="p">,</span> <span class="n">blk</span><span class="p">,</span> <span class="n">forward_time</span><span class="p">,</span> <span class="n">request_time</span><span class="p">);</span>
 <span class="mi">394</span>         
 <span class="mi">395</span>         <span class="n">ppMiss</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>
 <span class="mi">396</span>     <span class="p">}</span>
 <span class="mi">397</span>     
 <span class="mi">398</span>     <span class="nf">if</span> <span class="p">(</span><span class="n">prefetcher</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">399</span>         <span class="c1">// track time of availability of next prefetch, if any</span>
 <span class="mi">400</span>         <span class="n">Tick</span> <span class="n">next_pf_time</span> <span class="o">=</span> <span class="n">prefetcher</span><span class="o">-&gt;</span><span class="n">nextPrefetchReadyTime</span><span class="p">();</span>
 <span class="mi">401</span>         <span class="k">if</span> <span class="p">(</span><span class="n">next_pf_time</span> <span class="o">!=</span> <span class="n">MaxTick</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">402</span>             <span class="n">schedMemSideSendEvent</span><span class="p">(</span><span class="n">next_pf_time</span><span class="p">);</span>
 <span class="mi">403</span>         <span class="p">}</span>
 <span class="mi">404</span>     <span class="p">}</span>
 <span class="mi">405</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>After executing the access function that asks caches 
if the requested data exists in the cache, 
it returns value to indicate whether there was an item in the cache or not.
The satisfied variable contains the return value of the access.
Therefore, based on the satisfied condition,
it should handle cache hit and miss event differently.</p>

<h2 id="when-the-cache-hit-happens"><span class="me-2">When the cache hit happens</span><a href="#when-the-cache-hit-happens" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="rouge-code"><pre> <span class="mi">223</span> <span class="kt">void</span>
 <span class="mi">224</span> <span class="n">BaseCache</span><span class="o">::</span><span class="n">handleTimingReqHit</span><span class="p">(</span><span class="n">PacketPtr</span> <span class="n">pkt</span><span class="p">,</span> <span class="n">CacheBlk</span> <span class="o">*</span><span class="n">blk</span><span class="p">,</span> <span class="n">Tick</span> <span class="n">request_time</span><span class="p">)</span>
 <span class="mi">225</span> <span class="p">{</span>
 <span class="mi">226</span>     <span class="k">if</span> <span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">needsResponse</span><span class="p">())</span> <span class="p">{</span>
 <span class="mi">227</span>         <span class="c1">// These delays should have been consumed by now</span>
 <span class="mi">228</span>         <span class="n">assert</span><span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">headerDelay</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
 <span class="mi">229</span>         <span class="n">assert</span><span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">payloadDelay</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
 <span class="mi">230</span> 
 <span class="mi">231</span>         <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">makeTimingResponse</span><span class="p">();</span>
 <span class="mi">232</span> 
 <span class="mi">233</span>         <span class="c1">// In this case we are considering request_time that takes</span>
 <span class="mi">234</span>         <span class="c1">// into account the delay of the xbar, if any, and just</span>
 <span class="mi">235</span>         <span class="c1">// lat, neglecting responseLatency, modelling hit latency</span>
 <span class="mi">236</span>         <span class="c1">// just as the value of lat overriden by access(), which calls</span>
 <span class="mi">237</span>         <span class="c1">// the calculateAccessLatency() function.</span>
 <span class="mi">238</span>         <span class="n">cpuSidePort</span><span class="p">.</span><span class="n">schedTimingResp</span><span class="p">(</span><span class="n">pkt</span><span class="p">,</span> <span class="n">request_time</span><span class="p">);</span>
 <span class="mi">239</span>     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
 <span class="mi">240</span>         <span class="n">DPRINTF</span><span class="p">(</span><span class="n">Cache</span><span class="p">,</span> <span class="s">"%s satisfied %s, no response needed</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
 <span class="mi">241</span>                 <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">print</span><span class="p">());</span>
 <span class="mi">242</span> 
 <span class="mi">243</span>         <span class="c1">// queue the packet for deletion, as the sending cache is</span>
 <span class="mi">244</span>         <span class="c1">// still relying on it; if the block is found in access(),</span>
 <span class="mi">245</span>         <span class="c1">// CleanEvict and Writeback messages will be deleted</span>
 <span class="mi">246</span>         <span class="c1">// here as well</span>
 <span class="mi">247</span>         <span class="n">pendingDelete</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>
 <span class="mi">248</span>     <span class="p">}</span>
 <span class="mi">249</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>Based on the request type of the memory operation, it may or may not require response.
Therefore, it first checks whether the packet requires response 
with the needsResponse method. 
When it requires response, it invokes schedTimingResp of the cpuSidePort.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre> <span class="mi">93</span>     <span class="kt">void</span> <span class="nf">schedTimingResp</span><span class="p">(</span><span class="n">PacketPtr</span> <span class="n">pkt</span><span class="p">,</span> <span class="n">Tick</span> <span class="n">when</span><span class="p">)</span>
 <span class="mi">94</span>     <span class="p">{</span> <span class="n">respQueue</span><span class="p">.</span><span class="n">schedSendTiming</span><span class="p">(</span><span class="n">pkt</span><span class="p">,</span> <span class="n">when</span><span class="p">);</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>The schedTimingResp function is defined in the QueuedResponsePort class
which is one of the ancestor class of the CpuSidePort class. 
Also, schedSendTiming is defined as the member function of the RespPacketQueue 
which is the type of the respQueue. 
The PacketQueue class defines the schedSendTiming method, and 
the RespPacketQueue inherits PacketQueue.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre></td><td class="rouge-code"><pre><span class="mi">106</span> <span class="kt">void</span>
<span class="mi">107</span> <span class="n">PacketQueue</span><span class="o">::</span><span class="n">schedSendTiming</span><span class="p">(</span><span class="n">PacketPtr</span> <span class="n">pkt</span><span class="p">,</span> <span class="n">Tick</span> <span class="n">when</span><span class="p">)</span>
<span class="mi">108</span> <span class="p">{</span>
<span class="mi">109</span>     <span class="n">DPRINTF</span><span class="p">(</span><span class="n">PacketQueue</span><span class="p">,</span> <span class="s">"%s for %s address %x size %d when %lu ord: %i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
<span class="mi">110</span>             <span class="n">__func__</span><span class="p">,</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">cmdString</span><span class="p">(),</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">getAddr</span><span class="p">(),</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">getSize</span><span class="p">(),</span> <span class="n">when</span><span class="p">,</span>
<span class="mi">111</span>             <span class="n">forceOrder</span><span class="p">);</span>
<span class="mi">112</span> 
<span class="mi">113</span>     <span class="c1">// we can still send a packet before the end of this tick</span>
<span class="mi">114</span>     <span class="n">assert</span><span class="p">(</span><span class="n">when</span> <span class="o">&gt;=</span> <span class="n">curTick</span><span class="p">());</span>
<span class="mi">115</span> 
<span class="mi">116</span>     <span class="c1">// express snoops should never be queued</span>
<span class="mi">117</span>     <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">isExpressSnoop</span><span class="p">());</span>
<span class="mi">118</span> 
<span class="mi">119</span>     <span class="c1">// add a very basic sanity check on the port to ensure the</span>
<span class="mi">120</span>     <span class="c1">// invisible buffer is not growing beyond reasonable limits</span>
<span class="mi">121</span>     <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_disableSanityCheck</span> <span class="o">&amp;&amp;</span> <span class="n">transmitList</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">128</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">122</span>         <span class="n">panic</span><span class="p">(</span><span class="s">"Packet queue %s has grown beyond 128 packets</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
<span class="mi">123</span>               <span class="n">name</span><span class="p">());</span>
<span class="mi">124</span>     <span class="p">}</span>
<span class="mi">125</span> 
<span class="mi">126</span>     <span class="c1">// we should either have an outstanding retry, or a send event</span>
<span class="mi">127</span>     <span class="c1">// scheduled, but there is an unfortunate corner case where the</span>
<span class="mi">128</span>     <span class="c1">// x86 page-table walker and timing CPU send out a new request as</span>
<span class="mi">129</span>     <span class="c1">// part of the receiving of a response (called by</span>
<span class="mi">130</span>     <span class="c1">// PacketQueue::sendDeferredPacket), in which we end up calling</span>
<span class="mi">131</span>     <span class="c1">// ourselves again before we had a chance to update waitingOnRetry</span>
<span class="mi">132</span>     <span class="c1">// assert(waitingOnRetry || sendEvent.scheduled());</span>
<span class="mi">133</span> 
<span class="mi">134</span>     <span class="c1">// this belongs in the middle somewhere, so search from the end to</span>
<span class="mi">135</span>     <span class="c1">// order by tick; however, if forceOrder is set, also make sure</span>
<span class="mi">136</span>     <span class="c1">// not to re-order in front of some existing packet with the same</span>
<span class="mi">137</span>     <span class="c1">// address</span>
<span class="mi">138</span>     <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">transmitList</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
<span class="mi">139</span>     <span class="nf">while</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">transmitList</span><span class="p">.</span><span class="n">begin</span><span class="p">())</span> <span class="p">{</span>
<span class="mi">140</span>         <span class="o">--</span><span class="n">it</span><span class="p">;</span>
<span class="mi">141</span>         <span class="k">if</span> <span class="p">((</span><span class="n">forceOrder</span> <span class="o">&amp;&amp;</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">matchAddr</span><span class="p">(</span><span class="n">pkt</span><span class="p">))</span> <span class="o">||</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">tick</span> <span class="o">&lt;=</span> <span class="n">when</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">142</span>             <span class="c1">// emplace inserts the element before the position pointed to by</span>
<span class="mi">143</span>             <span class="c1">// the iterator, so advance it one step</span>
<span class="mi">144</span>             <span class="n">transmitList</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="o">++</span><span class="n">it</span><span class="p">,</span> <span class="n">when</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
<span class="mi">145</span>             <span class="k">return</span><span class="p">;</span>
<span class="mi">146</span>         <span class="p">}</span>
<span class="mi">147</span>     <span class="p">}</span>
<span class="mi">148</span>     <span class="c1">// either the packet list is empty or this has to be inserted</span>
<span class="mi">149</span>     <span class="c1">// before every other packet</span>
<span class="mi">150</span>     <span class="n">transmitList</span><span class="p">.</span><span class="n">emplace_front</span><span class="p">(</span><span class="n">when</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
<span class="mi">151</span>     <span class="nf">schedSendEvent</span><span class="p">(</span><span class="n">when</span><span class="p">);</span>
<span class="mi">152</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<h3 id="transmitlist-maintains-all-the-packets-need-to-be-sent-to-other-end-of-the-port"><span class="me-2">transmitList maintains all the packets need to be sent to other end of the port</span><a href="#transmitlist-maintains-all-the-packets-need-to-be-sent-to-other-end-of-the-port" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre> <span class="mi">68</span>     <span class="cm">/** A deferred packet, buffered to transmit later. */</span>
 <span class="mi">69</span>     <span class="k">class</span> <span class="nc">DeferredPacket</span>
 <span class="mi">70</span>     <span class="p">{</span>
 <span class="mi">71</span>       <span class="k">public</span><span class="o">:</span>
 <span class="mi">72</span>         <span class="n">Tick</span> <span class="n">tick</span><span class="p">;</span>      <span class="c1">///&lt; The tick when the packet is ready to transmit</span>
 <span class="mi">73</span>         <span class="n">PacketPtr</span> <span class="n">pkt</span><span class="p">;</span>  <span class="c1">///&lt; Pointer to the packet to transmit</span>
 <span class="mi">74</span>         <span class="n">DeferredPacket</span><span class="p">(</span><span class="n">Tick</span> <span class="n">t</span><span class="p">,</span> <span class="n">PacketPtr</span> <span class="n">p</span><span class="p">)</span>
 <span class="mi">75</span>             <span class="o">:</span> <span class="n">tick</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">pkt</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
 <span class="mi">76</span>         <span class="p">{}</span>
 <span class="mi">77</span>     <span class="p">};</span>
 <span class="mi">78</span> 
 <span class="mi">79</span>     <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">DeferredPacket</span><span class="o">&gt;</span> <span class="n">DeferredPacketList</span><span class="p">;</span>
 <span class="mi">80</span> 
 <span class="mi">81</span>     <span class="cm">/** A list of outgoing packets. */</span>
 <span class="mi">82</span>     <span class="n">DeferredPacketList</span> <span class="n">transmitList</span><span class="p">;</span>
 <span class="mi">83</span> 
</pre></td></tr></tbody></table></code></div></div>
<p>tranmitList contains all the deferrredPackets that are waiting to be sent.
Therefore, it contains the packet itself and when should it be sent.
Note that when which is the Tick is required because GEM5 is emulator not the hardware. 
Anyway the maintained packets will be sent 
when the schedSendEvent fires. 
Note that it is scheduled to be fired at when clock cycle 
through schedSendEvent function.</p>

<h3 id="schedsendevent-function-schedules-event-to-handle-the-deferred-packet"><span class="me-2">schedSendEvent function schedules event to handle the deferred packet</span><a href="#schedsendevent-function-schedules-event-to-handle-the-deferred-packet" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="rouge-code"><pre><span class="mi">154</span> <span class="kt">void</span>
<span class="mi">155</span> <span class="n">PacketQueue</span><span class="o">::</span><span class="n">schedSendEvent</span><span class="p">(</span><span class="n">Tick</span> <span class="n">when</span><span class="p">)</span>
<span class="mi">156</span> <span class="p">{</span>
<span class="mi">157</span>     <span class="c1">// if we are waiting on a retry just hold off</span>
<span class="mi">158</span>     <span class="k">if</span> <span class="p">(</span><span class="n">waitingOnRetry</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">159</span>         <span class="n">DPRINTF</span><span class="p">(</span><span class="n">PacketQueue</span><span class="p">,</span> <span class="s">"Not scheduling send as waiting for retry</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="mi">160</span>         <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">sendEvent</span><span class="p">.</span><span class="n">scheduled</span><span class="p">());</span>
<span class="mi">161</span>         <span class="k">return</span><span class="p">;</span>
<span class="mi">162</span>     <span class="p">}</span>
<span class="mi">163</span> 
<span class="mi">164</span>     <span class="nf">if</span> <span class="p">(</span><span class="n">when</span> <span class="o">!=</span> <span class="n">MaxTick</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">165</span>         <span class="c1">// we cannot go back in time, and to be consistent we stick to</span>
<span class="mi">166</span>         <span class="c1">// one tick in the future</span>
<span class="mi">167</span>         <span class="n">when</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">when</span><span class="p">,</span> <span class="n">curTick</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="mi">168</span>         <span class="c1">// @todo Revisit the +1</span>
<span class="mi">169</span> 
<span class="mi">170</span>         <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sendEvent</span><span class="p">.</span><span class="n">scheduled</span><span class="p">())</span> <span class="p">{</span>
<span class="mi">171</span>             <span class="n">em</span><span class="p">.</span><span class="n">schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sendEvent</span><span class="p">,</span> <span class="n">when</span><span class="p">);</span>
<span class="mi">172</span>         <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">when</span> <span class="o">&lt;</span> <span class="n">sendEvent</span><span class="p">.</span><span class="n">when</span><span class="p">())</span> <span class="p">{</span>
<span class="mi">173</span>             <span class="c1">// if the new time is earlier than when the event</span>
<span class="mi">174</span>             <span class="c1">// currently is scheduled, move it forward</span>
<span class="mi">175</span>             <span class="n">em</span><span class="p">.</span><span class="n">reschedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sendEvent</span><span class="p">,</span> <span class="n">when</span><span class="p">);</span>
<span class="mi">176</span>         <span class="p">}</span>
<span class="mi">177</span>     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="mi">178</span>         <span class="c1">// we get a MaxTick when there is no more to send, so if we're</span>
<span class="mi">179</span>         <span class="c1">// draining, we may be done at this point</span>
<span class="mi">180</span>         <span class="k">if</span> <span class="p">(</span><span class="n">drainState</span><span class="p">()</span> <span class="o">==</span> <span class="n">DrainState</span><span class="o">::</span><span class="n">Draining</span> <span class="o">&amp;&amp;</span>
<span class="mi">181</span>             <span class="n">transmitList</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">sendEvent</span><span class="p">.</span><span class="n">scheduled</span><span class="p">())</span> <span class="p">{</span>
<span class="mi">182</span> 
<span class="mi">183</span>             <span class="n">DPRINTF</span><span class="p">(</span><span class="n">Drain</span><span class="p">,</span> <span class="s">"PacketQueue done draining,"</span>
<span class="mi">184</span>                     <span class="s">"processing drain event</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="mi">185</span>             <span class="n">signalDrainDone</span><span class="p">();</span>
<span class="mi">186</span>         <span class="p">}</span>
<span class="mi">187</span>     <span class="p">}</span>
<span class="mi">188</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>The most important things done by the schedSendEvent is the scheduling event 
to make it fire at the exact time specified by the GEM5 emulator. 
As shown in Line 170-176,
it first checks whether the sendEvent is already scheduled before.
If there is no scheduled event, then it schedule the event with schedule function.
Note that the em member field points to the BaseCache. 
Also, if there is already pre-scheduled event for the sendEvent and 
if the current event should be raised before the pre-scheduled one,
then it reschedule the event. 
BTW, if there were events that should be handled later then newly scheduled event,
how those events can be processed!?
To understand the how the deferred packet will be processed 
and resolve question, let’s take a look at the function invoked 
when the scheduled event raises.</p>

<h3 id="processsendevent-event-to-handle-deferred-packet-processing"><span class="me-2">processSendEvent: event to handle deferred packet processing</span><a href="#processsendevent-event-to-handle-deferred-packet-processing" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre> <span class="mi">50</span> <span class="n">PacketQueue</span><span class="o">::</span><span class="n">PacketQueue</span><span class="p">(</span><span class="n">EventManager</span><span class="o">&amp;</span> <span class="n">_em</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">_label</span><span class="p">,</span>
 <span class="mi">51</span>                          <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">_sendEventName</span><span class="p">,</span>
 <span class="mi">52</span>                          <span class="kt">bool</span> <span class="n">force_order</span><span class="p">,</span>
 <span class="mi">53</span>                          <span class="kt">bool</span> <span class="n">disable_sanity_check</span><span class="p">)</span>
 <span class="mi">54</span>     <span class="o">:</span> <span class="n">em</span><span class="p">(</span><span class="n">_em</span><span class="p">),</span> <span class="n">sendEvent</span><span class="p">([</span><span class="k">this</span><span class="p">]{</span> <span class="n">processSendEvent</span><span class="p">();</span> <span class="p">},</span> <span class="n">_sendEventName</span><span class="p">),</span>
 <span class="mi">55</span>       <span class="nf">_disableSanityCheck</span><span class="p">(</span><span class="n">disable_sanity_check</span><span class="p">),</span>
 <span class="mi">56</span>       <span class="n">forceOrder</span><span class="p">(</span><span class="n">force_order</span><span class="p">),</span>
 <span class="mi">57</span>       <span class="n">label</span><span class="p">(</span><span class="n">_label</span><span class="p">),</span> <span class="n">waitingOnRetry</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span>
 <span class="mi">58</span> <span class="p">{</span>
 <span class="mi">59</span> <span class="p">}</span>
<span class="p">......</span>
<span class="mi">220</span> <span class="kt">void</span> 
<span class="mi">221</span> <span class="n">PacketQueue</span><span class="o">::</span><span class="n">processSendEvent</span><span class="p">()</span>
<span class="mi">222</span> <span class="p">{</span>
<span class="mi">223</span>     <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">waitingOnRetry</span><span class="p">);</span>
<span class="mi">224</span>     <span class="nf">sendDeferredPacket</span><span class="p">();</span>
<span class="mi">225</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>I can easily find that the sendEvent is initialized with processSendEvent
in the constructor of the PacketQueue. 
Therefore, when the sendEvent fires, it invokes the processSendEvent function.
Note that it further invokes sendDeferredPacket function of the PacketQueue.</p>

<h3 id="senddeferredpacket-handles-deferred-packet-processing-at-right-time"><span class="me-2">sendDeferredPacket handles deferred packet processing at right time</span><a href="#senddeferredpacket-handles-deferred-packet-processing-at-right-time" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="rouge-code"><pre><span class="mi">190</span> <span class="kt">void</span> 
<span class="mi">191</span> <span class="n">PacketQueue</span><span class="o">::</span><span class="n">sendDeferredPacket</span><span class="p">()</span>
<span class="mi">192</span> <span class="p">{</span>
<span class="mi">193</span>     <span class="c1">// sanity checks</span>
<span class="mi">194</span>     <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">waitingOnRetry</span><span class="p">);</span>
<span class="mi">195</span>     <span class="n">assert</span><span class="p">(</span><span class="n">deferredPacketReady</span><span class="p">());</span>
<span class="mi">196</span> 
<span class="mi">197</span>     <span class="n">DeferredPacket</span> <span class="n">dp</span> <span class="o">=</span> <span class="n">transmitList</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
<span class="mi">198</span> 
<span class="mi">199</span>     <span class="c1">// take the packet of the list before sending it, as sending of</span>
<span class="mi">200</span>     <span class="c1">// the packet in some cases causes a new packet to be enqueued</span>
<span class="mi">201</span>     <span class="c1">// (most notaly when responding to the timing CPU, leading to a </span>
<span class="mi">202</span>     <span class="c1">// new request hitting in the L1 icache, leading to a new</span>
<span class="mi">203</span>     <span class="c1">// response)</span>
<span class="mi">204</span>     <span class="n">transmitList</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
<span class="mi">205</span> 
<span class="mi">206</span>     <span class="c1">// use the appropriate implementation of sendTiming based on the</span>
<span class="mi">207</span>     <span class="c1">// type of queue</span>
<span class="mi">208</span>     <span class="n">waitingOnRetry</span> <span class="o">=</span> <span class="o">!</span><span class="n">sendTiming</span><span class="p">(</span><span class="n">dp</span><span class="p">.</span><span class="n">pkt</span><span class="p">);</span>
<span class="mi">209</span> 
<span class="mi">210</span>     <span class="c1">// if we succeeded and are not waiting for a retry, schedule the</span>
<span class="mi">211</span>     <span class="c1">// next send </span>
<span class="mi">212</span>     <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">waitingOnRetry</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">213</span>         <span class="n">schedSendEvent</span><span class="p">(</span><span class="n">deferredPacketReadyTime</span><span class="p">());</span>
<span class="mi">214</span>     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="mi">215</span>         <span class="c1">// put the packet back at the front of the list </span>
<span class="mi">216</span>         <span class="n">transmitList</span><span class="p">.</span><span class="n">emplace_front</span><span class="p">(</span><span class="n">dp</span><span class="p">);</span>
<span class="mi">217</span>     <span class="p">}</span>    
<span class="mi">218</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>You might remember that the transmitList contains all the packet and when should it be fired.
And because the sendDeferredPacket is the function that process the packet in the transmitList
at the right time specified. 
Therefore, the sendDeferredPacket extracts the packet from the transmitList (line 197-204).
After getting the packet to send, it invokes sendTiming function to actually send the 
packet to the unit that waits for the response. 
However, you can find that sendTiming function is not implemented on the PacketQueue, 
and implemented as a virtual function, which means 
it should invoke its child’s sendTiming.
Remind that the schedTimingResp of the cpuSidePort makes us to all the way down to here. 
Also the respQueue used to schedule sendTiming event was the RespPacketQueue object.
And the RespPacketQueue inherits PacketQueue, which means it has the sendTiming function.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="mi">275</span> <span class="kt">bool</span>
<span class="mi">276</span> <span class="n">RespPacketQueue</span><span class="o">::</span><span class="n">sendTiming</span><span class="p">(</span><span class="n">PacketPtr</span> <span class="n">pkt</span><span class="p">)</span>
<span class="mi">277</span> <span class="p">{</span>
<span class="mi">278</span>     <span class="k">return</span> <span class="n">cpuSidePort</span><span class="p">.</span><span class="n">sendTimingResp</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>
<span class="mi">279</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>Finally it invokes sendTimingResp function of the cpuSidePort to send packet to the CPU.
Yeah… It is kind of a long detour to get to the sendTimingResp.
The important reason of this complicated process for handling packets is because 
it wants to decouple the CpuSidePort from the managing response packets.
After the cache generates the response packet, 
instead of directly invoking the sendTimingResp function of the cpuSidePort 
it let the PacketQueue handles all relevant operations to manage response packets.
Anyway, after sendTimingResp is invoked, 
it returns the waitingOnRetry which indicates whether 
the CPU is currently not available for receiving the response packet from the cache. 
In that case, the waitingOnRetry field is set and should send the packet once again
when the CPU send the retry message to the cache at some point.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="mi">169</span>     <span class="cm">/**
170      * Get the next packet ready time.
171      */</span>
<span class="mi">172</span>     <span class="n">Tick</span> <span class="n">deferredPacketReadyTime</span><span class="p">()</span> <span class="k">const</span>
<span class="mi">173</span>     <span class="p">{</span> <span class="k">return</span> <span class="n">transmitList</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">?</span> <span class="n">MaxTick</span> <span class="o">:</span> <span class="n">transmitList</span><span class="p">.</span><span class="n">front</span><span class="p">().</span><span class="n">tick</span><span class="p">;</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>Now this is the time for answering previous question: after one packet is processed,
if there are remaining packets need to be sent at some later point, what should we do?
Yeah the deferredPacketReadyTime checks the transmitList and returns the tick 
if deferred packet still remains. 
This tick is passed to the schedSendEvent function, and 
will schedule the sendEvent. 
That’s it!</p>

<h3 id="waitingonretry"><span class="me-2">waitingOnRetry</span><a href="#waitingonretry" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<p>\TODO{need to explain some particular details regarding waitingOnRetry}</p>

<h2 id="when-the-cache-miss-happens"><span class="me-2">When the cache miss happens</span><a href="#when-the-cache-miss-happens" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>
<p>When the access function cannot return cache block associated with 
current request, the satisfied condition is set as false.
Therefore, the handleTimingReqMiss function is executed to fetch 
cache block from the upper level cache or memory.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
</pre></td><td class="rouge-code"><pre> <span class="mi">323</span> <span class="kt">void</span>
 <span class="mi">324</span> <span class="n">Cache</span><span class="o">::</span><span class="n">handleTimingReqMiss</span><span class="p">(</span><span class="n">PacketPtr</span> <span class="n">pkt</span><span class="p">,</span> <span class="n">CacheBlk</span> <span class="o">*</span><span class="n">blk</span><span class="p">,</span> <span class="n">Tick</span> <span class="n">forward_time</span><span class="p">,</span>
 <span class="mi">325</span>                            <span class="n">Tick</span> <span class="n">request_time</span><span class="p">)</span>
 <span class="mi">326</span> <span class="p">{</span>
 <span class="mi">327</span>     <span class="k">if</span> <span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">isUncacheable</span><span class="p">())</span> <span class="p">{</span>
 <span class="mi">328</span>         <span class="c1">// ignore any existing MSHR if we are dealing with an</span>
 <span class="mi">329</span>         <span class="c1">// uncacheable request</span>
 <span class="mi">330</span> 
 <span class="mi">331</span>         <span class="c1">// should have flushed and have no valid block</span>
 <span class="mi">332</span>         <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">blk</span> <span class="o">||</span> <span class="o">!</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">isValid</span><span class="p">());</span>
 <span class="mi">333</span> 
 <span class="mi">334</span>         <span class="n">stats</span><span class="p">.</span><span class="n">cmdStats</span><span class="p">(</span><span class="n">pkt</span><span class="p">).</span><span class="n">mshrUncacheable</span><span class="p">[</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">requestorId</span><span class="p">()]</span><span class="o">++</span><span class="p">;</span>
 <span class="mi">335</span> 
 <span class="mi">336</span>         <span class="k">if</span> <span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">isWrite</span><span class="p">())</span> <span class="p">{</span>
 <span class="mi">337</span>             <span class="n">allocateWriteBuffer</span><span class="p">(</span><span class="n">pkt</span><span class="p">,</span> <span class="n">forward_time</span><span class="p">);</span>
 <span class="mi">338</span>         <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
 <span class="mi">339</span>             <span class="n">assert</span><span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">isRead</span><span class="p">());</span>
 <span class="mi">340</span> 
 <span class="mi">341</span>             <span class="c1">// uncacheable accesses always allocate a new MSHR</span>
 <span class="mi">342</span> 
 <span class="mi">343</span>             <span class="c1">// Here we are using forward_time, modelling the latency of</span>
 <span class="mi">344</span>             <span class="c1">// a miss (outbound) just as forwardLatency, neglecting the</span>
 <span class="mi">345</span>             <span class="c1">// lookupLatency component.</span>
 <span class="mi">346</span>             <span class="n">allocateMissBuffer</span><span class="p">(</span><span class="n">pkt</span><span class="p">,</span> <span class="n">forward_time</span><span class="p">);</span>
 <span class="mi">347</span>         <span class="p">}</span>
 <span class="mi">348</span> 
 <span class="mi">349</span>         <span class="k">return</span><span class="p">;</span>
 <span class="mi">350</span>     <span class="p">}</span>
 <span class="mi">351</span> 
 <span class="mi">352</span>     <span class="n">Addr</span> <span class="n">blk_addr</span> <span class="o">=</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">getBlockAddr</span><span class="p">(</span><span class="n">blkSize</span><span class="p">);</span>
 <span class="mi">353</span> 
 <span class="mi">354</span>     <span class="n">MSHR</span> <span class="o">*</span><span class="n">mshr</span> <span class="o">=</span> <span class="n">mshrQueue</span><span class="p">.</span><span class="n">findMatch</span><span class="p">(</span><span class="n">blk_addr</span><span class="p">,</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">isSecure</span><span class="p">());</span>
 <span class="mi">355</span> 
 <span class="mi">356</span>     <span class="c1">// Software prefetch handling:</span>
 <span class="mi">357</span>     <span class="c1">// To keep the core from waiting on data it won't look at</span>
 <span class="mi">358</span>     <span class="c1">// anyway, send back a response with dummy data. Miss handling</span>
 <span class="mi">359</span>     <span class="c1">// will continue asynchronously. Unfortunately, the core will</span>
 <span class="mi">360</span>     <span class="c1">// insist upon freeing original Packet/Request, so we have to</span>
 <span class="mi">361</span>     <span class="c1">// create a new pair with a different lifecycle. Note that this</span>
 <span class="mi">362</span>     <span class="c1">// processing happens before any MSHR munging on the behalf of</span>
 <span class="mi">363</span>     <span class="c1">// this request because this new Request will be the one stored</span>
 <span class="mi">364</span>     <span class="c1">// into the MSHRs, not the original.</span>
 <span class="mi">365</span>     <span class="nf">if</span> <span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">.</span><span class="n">isSWPrefetch</span><span class="p">())</span> <span class="p">{</span>
 <span class="mi">366</span>         <span class="n">assert</span><span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">needsResponse</span><span class="p">());</span>
 <span class="mi">367</span>         <span class="n">assert</span><span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">hasPaddr</span><span class="p">());</span>
 <span class="mi">368</span>         <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">isUncacheable</span><span class="p">());</span>
 <span class="mi">369</span> 
 <span class="mi">370</span>         <span class="c1">// There's no reason to add a prefetch as an additional target</span>
 <span class="mi">371</span>         <span class="c1">// to an existing MSHR. If an outstanding request is already</span>
 <span class="mi">372</span>         <span class="c1">// in progress, there is nothing for the prefetch to do.</span>
 <span class="mi">373</span>         <span class="c1">// If this is the case, we don't even create a request at all.</span>
 <span class="mi">374</span>         <span class="n">PacketPtr</span> <span class="n">pf</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
 <span class="mi">375</span> 
 <span class="mi">376</span>         <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mshr</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">377</span>             <span class="c1">// copy the request and create a new SoftPFReq packet</span>
 <span class="mi">378</span>             <span class="n">RequestPtr</span> <span class="n">req</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Request</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">getPaddr</span><span class="p">(),</span>
 <span class="mi">379</span>                                                     <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">getSize</span><span class="p">(),</span>
 <span class="mi">380</span>                                                     <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">getFlags</span><span class="p">(),</span>
 <span class="mi">381</span>                                                     <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">requestorId</span><span class="p">());</span>
 <span class="mi">382</span>             <span class="n">pf</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Packet</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">);</span>
 <span class="mi">383</span>             <span class="n">pf</span><span class="o">-&gt;</span><span class="n">allocate</span><span class="p">();</span>
 <span class="mi">384</span>             <span class="n">assert</span><span class="p">(</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">matchAddr</span><span class="p">(</span><span class="n">pkt</span><span class="p">));</span>
 <span class="mi">385</span>             <span class="n">assert</span><span class="p">(</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">getSize</span><span class="p">()</span> <span class="o">==</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">getSize</span><span class="p">());</span>
 <span class="mi">386</span>         <span class="p">}</span>
 <span class="mi">387</span> 
 <span class="mi">388</span>         <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">makeTimingResponse</span><span class="p">();</span>
 <span class="mi">389</span> 
 <span class="mi">390</span>         <span class="c1">// request_time is used here, taking into account lat and the delay</span>
 <span class="mi">391</span>         <span class="c1">// charged if the packet comes from the xbar.</span>
 <span class="mi">392</span>         <span class="n">cpuSidePort</span><span class="p">.</span><span class="n">schedTimingResp</span><span class="p">(</span><span class="n">pkt</span><span class="p">,</span> <span class="n">request_time</span><span class="p">);</span>
 <span class="mi">393</span> 
 <span class="mi">394</span>         <span class="c1">// If an outstanding request is in progress (we found an</span>
 <span class="mi">395</span>         <span class="c1">// MSHR) this is set to null</span>
 <span class="mi">396</span>         <span class="n">pkt</span> <span class="o">=</span> <span class="n">pf</span><span class="p">;</span>
 <span class="mi">397</span>     <span class="p">}</span>
 <span class="mi">398</span> 
 <span class="mi">399</span>     <span class="n">BaseCache</span><span class="o">::</span><span class="n">handleTimingReqMiss</span><span class="p">(</span><span class="n">pkt</span><span class="p">,</span> <span class="n">mshr</span><span class="p">,</span> <span class="n">blk</span><span class="p">,</span> <span class="n">forward_time</span><span class="p">,</span> <span class="n">request_time</span><span class="p">);</span>
 <span class="mi">400</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>When cache miss happens, the first thing to do is 
searching the MSHR entry.
The findMatch function of the mshrQueue containing 
all the previous MSHR entries 
will be invoked to search 
if there is MSHR entry associated with the current request.</p>

<p>Whether it has matching MSHR entry or not,
it invokes the handleTimingReqMiss of the BaseCache 
to further handles the cache miss.
Briefly speaking, 
this function handles cache miss 
based on whether the MSHR entry exists or not.
Because this function is quite long, I will split it in two parts: 
when MSHR exists and when MSHR doesn’t existing.</p>

<h2 id="when-mshr-does-exist"><span class="me-2">When MSHR does exist</span><a href="#when-mshr-does-exist" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
</pre></td><td class="rouge-code"><pre> <span class="mi">251</span> <span class="kt">void</span>
 <span class="mi">252</span> <span class="n">BaseCache</span><span class="o">::</span><span class="n">handleTimingReqMiss</span><span class="p">(</span><span class="n">PacketPtr</span> <span class="n">pkt</span><span class="p">,</span> <span class="n">MSHR</span> <span class="o">*</span><span class="n">mshr</span><span class="p">,</span> <span class="n">CacheBlk</span> <span class="o">*</span><span class="n">blk</span><span class="p">,</span>
 <span class="mi">253</span>                                <span class="n">Tick</span> <span class="n">forward_time</span><span class="p">,</span> <span class="n">Tick</span> <span class="n">request_time</span><span class="p">)</span>
 <span class="mi">254</span> <span class="p">{</span>
 <span class="mi">255</span>     <span class="k">if</span> <span class="p">(</span><span class="n">writeAllocator</span> <span class="o">&amp;&amp;</span>
 <span class="mi">256</span>         <span class="n">pkt</span> <span class="o">&amp;&amp;</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">isWrite</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">isUncacheable</span><span class="p">())</span> <span class="p">{</span>
 <span class="mi">257</span>         <span class="n">writeAllocator</span><span class="o">-&gt;</span><span class="n">updateMode</span><span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">getAddr</span><span class="p">(),</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">getSize</span><span class="p">(),</span>
 <span class="mi">258</span>                                    <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">getBlockAddr</span><span class="p">(</span><span class="n">blkSize</span><span class="p">));</span>
 <span class="mi">259</span>     <span class="p">}</span>
 <span class="mi">260</span> 
 <span class="mi">261</span>     <span class="nf">if</span> <span class="p">(</span><span class="n">mshr</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">262</span>         <span class="c1">/// MSHR hit</span>
 <span class="mi">263</span>         <span class="c1">/// @note writebacks will be checked in getNextMSHR()</span>
 <span class="mi">264</span>         <span class="c1">/// for any conflicting requests to the same block</span>
 <span class="mi">265</span>         
 <span class="mi">266</span>         <span class="c1">//@todo remove hw_pf here</span>
 <span class="mi">267</span>         
 <span class="mi">268</span>         <span class="c1">// Coalesce unless it was a software prefetch (see above).</span>
 <span class="mi">269</span>         <span class="k">if</span> <span class="p">(</span><span class="n">pkt</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">270</span>             <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">isWriteback</span><span class="p">());</span>
 <span class="mi">271</span>             <span class="c1">// CleanEvicts corresponding to blocks which have</span>
 <span class="mi">272</span>             <span class="c1">// outstanding requests in MSHRs are simply sunk here</span>
 <span class="mi">273</span>             <span class="k">if</span> <span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">MemCmd</span><span class="o">::</span><span class="n">CleanEvict</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">274</span>                 <span class="n">pendingDelete</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>
 <span class="mi">275</span>             <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">MemCmd</span><span class="o">::</span><span class="n">WriteClean</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">276</span>                 <span class="c1">// A WriteClean should never coalesce with any</span>
 <span class="mi">277</span>                 <span class="c1">// outstanding cache maintenance requests.</span>
 <span class="mi">278</span>                 
 <span class="mi">279</span>                 <span class="c1">// We use forward_time here because there is an</span>
 <span class="mi">280</span>                 <span class="c1">// uncached memory write, forwarded to WriteBuffer.</span>
 <span class="mi">281</span>                 <span class="n">allocateWriteBuffer</span><span class="p">(</span><span class="n">pkt</span><span class="p">,</span> <span class="n">forward_time</span><span class="p">);</span>
 <span class="mi">282</span>             <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
 <span class="mi">283</span>                 <span class="n">DPRINTF</span><span class="p">(</span><span class="n">Cache</span><span class="p">,</span> <span class="s">"%s coalescing MSHR for %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
 <span class="mi">284</span>                         <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">print</span><span class="p">());</span>
 <span class="mi">285</span>                 
 <span class="mi">286</span>                 <span class="n">assert</span><span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">requestorId</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">system</span><span class="o">-&gt;</span><span class="n">maxRequestors</span><span class="p">());</span>
 <span class="mi">287</span>                 <span class="n">stats</span><span class="p">.</span><span class="n">cmdStats</span><span class="p">(</span><span class="n">pkt</span><span class="p">).</span><span class="n">mshrHits</span><span class="p">[</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">requestorId</span><span class="p">()]</span><span class="o">++</span><span class="p">;</span>
 <span class="mi">288</span>                 
 <span class="mi">289</span>                 <span class="c1">// We use forward_time here because it is the same</span>
 <span class="mi">290</span>                 <span class="c1">// considering new targets. We have multiple</span>
 <span class="mi">291</span>                 <span class="c1">// requests for the same address here. It</span>
 <span class="mi">292</span>                 <span class="c1">// specifies the latency to allocate an internal</span>
 <span class="mi">293</span>                 <span class="c1">// buffer and to schedule an event to the queued</span>
 <span class="mi">294</span>                 <span class="c1">// port and also takes into account the additional</span>
 <span class="mi">295</span>                 <span class="c1">// delay of the xbar.</span>
 <span class="mi">296</span>                 <span class="n">mshr</span><span class="o">-&gt;</span><span class="n">allocateTarget</span><span class="p">(</span><span class="n">pkt</span><span class="p">,</span> <span class="n">forward_time</span><span class="p">,</span> <span class="n">order</span><span class="o">++</span><span class="p">,</span>
 <span class="mi">297</span>                                      <span class="n">allocOnFill</span><span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">));</span>
 <span class="mi">298</span>                 <span class="k">if</span> <span class="p">(</span><span class="n">mshr</span><span class="o">-&gt;</span><span class="n">getNumTargets</span><span class="p">()</span> <span class="o">==</span> <span class="n">numTarget</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">299</span>                     <span class="n">noTargetMSHR</span> <span class="o">=</span> <span class="n">mshr</span><span class="p">;</span>
 <span class="mi">300</span>                     <span class="n">setBlocked</span><span class="p">(</span><span class="n">Blocked_NoTargets</span><span class="p">);</span>
 <span class="mi">301</span>                     <span class="c1">// need to be careful with this... if this mshr isn't</span>
 <span class="mi">302</span>                     <span class="c1">// ready yet (i.e. time &gt; curTick()), we don't want to</span>
 <span class="mi">303</span>                     <span class="c1">// move it ahead of mshrs that are ready</span>
 <span class="mi">304</span>                     <span class="c1">// mshrQueue.moveToFront(mshr);</span>
 <span class="mi">305</span>                 <span class="p">}</span>
 <span class="mi">306</span>             <span class="p">}</span>
 <span class="mi">307</span>         <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>You have to understand that one MSHR entry can track 
multiple memory requests associated with 
the address handled by the particular MSHR entry. 
Therefore, the first job needs to be done is 
registering the missed request 
to the MSHR entry as its <strong>target</strong>. 
Based on the type of the memory request,
it might not add the missed request as the targets of the MSHR entry.
However, in most of the cases, when the L1 cache miss happens, 
it will be added to the found MSHR entry by invoking 
allocateTarget function of the MSHR entry.</p>

<h3 id="allocatetarget-associates-the-missed-requests-to-the-found-mshr-entry"><span class="me-2">allocateTarget associates the missed requests to the found MSHR entry</span><a href="#allocatetarget-associates-the-missed-requests-to-the-found-mshr-entry" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
</pre></td><td class="rouge-code"><pre><span class="mi">372</span> <span class="cm">/*          
373  * Adds a target to an MSHR
374  */</span>         
<span class="mi">375</span> <span class="kt">void</span>        
<span class="mi">376</span> <span class="n">MSHR</span><span class="o">::</span><span class="n">allocateTarget</span><span class="p">(</span><span class="n">PacketPtr</span> <span class="n">pkt</span><span class="p">,</span> <span class="n">Tick</span> <span class="n">whenReady</span><span class="p">,</span> <span class="n">Counter</span> <span class="n">_order</span><span class="p">,</span>
<span class="mi">377</span>                      <span class="kt">bool</span> <span class="n">alloc_on_fill</span><span class="p">)</span>
<span class="mi">378</span> <span class="p">{</span>           
<span class="mi">379</span>     <span class="c1">// assume we'd never issue a prefetch when we've got an</span>
<span class="mi">380</span>     <span class="c1">// outstanding miss</span>
<span class="mi">381</span>     <span class="n">assert</span><span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">!=</span> <span class="n">MemCmd</span><span class="o">::</span><span class="n">HardPFReq</span><span class="p">);</span>
<span class="mi">382</span>                 
<span class="mi">383</span>     <span class="c1">// if there's a request already in service for this MSHR, we will</span>
<span class="mi">384</span>     <span class="c1">// have to defer the new target until after the response if any of</span>
<span class="mi">385</span>     <span class="c1">// the following are true:</span>
<span class="mi">386</span>     <span class="c1">// - there are other targets already deferred</span>
<span class="mi">387</span>     <span class="c1">// - there's a pending invalidate to be applied after the response</span>
<span class="mi">388</span>     <span class="c1">//   comes back (but before this target is processed)</span>
<span class="mi">389</span>     <span class="c1">// - the MSHR's first (and only) non-deferred target is a cache</span>
<span class="mi">390</span>     <span class="c1">//   maintenance packet</span>
<span class="mi">391</span>     <span class="c1">// - the new target is a cache maintenance packet (this is probably</span>
<span class="mi">392</span>     <span class="c1">//   overly conservative but certainly safe)</span>
<span class="mi">393</span>     <span class="c1">// - this target requires a writable block and either we're not</span>
<span class="mi">394</span>     <span class="c1">//   getting a writable block back or we have already snooped</span>
<span class="mi">395</span>     <span class="c1">//   another read request that will downgrade our writable block</span>
<span class="mi">396</span>     <span class="c1">//   to non-writable (Shared or Owned)</span>
<span class="mi">397</span>     <span class="n">PacketPtr</span> <span class="n">tgt_pkt</span> <span class="o">=</span> <span class="n">targets</span><span class="p">.</span><span class="n">front</span><span class="p">().</span><span class="n">pkt</span><span class="p">;</span>
<span class="mi">398</span>     <span class="k">if</span> <span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">isCacheMaintenance</span><span class="p">()</span> <span class="o">||</span>
<span class="mi">399</span>         <span class="n">tgt_pkt</span><span class="o">-&gt;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">isCacheMaintenance</span><span class="p">()</span> <span class="o">||</span>
<span class="mi">400</span>         <span class="o">!</span><span class="n">deferredTargets</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">||</span>
<span class="mi">401</span>         <span class="p">(</span><span class="n">inService</span> <span class="o">&amp;&amp;</span>
<span class="mi">402</span>          <span class="p">(</span><span class="n">hasPostInvalidate</span><span class="p">()</span> <span class="o">||</span>
<span class="mi">403</span>           <span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">needsWritable</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
<span class="mi">404</span>            <span class="p">(</span><span class="o">!</span><span class="n">isPendingModified</span><span class="p">()</span> <span class="o">||</span> <span class="n">hasPostDowngrade</span><span class="p">()</span> <span class="o">||</span> <span class="n">isForward</span><span class="p">)))))</span> <span class="p">{</span>
<span class="mi">405</span>         <span class="c1">// need to put on deferred list</span>
<span class="mi">406</span>         <span class="k">if</span> <span class="p">(</span><span class="n">inService</span> <span class="o">&amp;&amp;</span> <span class="n">hasPostInvalidate</span><span class="p">())</span>
<span class="mi">407</span>             <span class="n">replaceUpgrade</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>
<span class="mi">408</span>         <span class="n">deferredTargets</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">pkt</span><span class="p">,</span> <span class="n">whenReady</span><span class="p">,</span> <span class="n">_order</span><span class="p">,</span> <span class="n">Target</span><span class="o">::</span><span class="n">FromCPU</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span>
<span class="mi">409</span>                             <span class="n">alloc_on_fill</span><span class="p">);</span>
<span class="mi">410</span>     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="mi">411</span>         <span class="c1">// No request outstanding, or still OK to append to</span>
<span class="mi">412</span>         <span class="c1">// outstanding request: append to regular target list.  Only</span>
<span class="mi">413</span>         <span class="c1">// mark pending if current request hasn't been issued yet</span>
<span class="mi">414</span>         <span class="c1">// (isn't in service).</span>
<span class="mi">415</span>         <span class="n">targets</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">pkt</span><span class="p">,</span> <span class="n">whenReady</span><span class="p">,</span> <span class="n">_order</span><span class="p">,</span> <span class="n">Target</span><span class="o">::</span><span class="n">FromCPU</span><span class="p">,</span> <span class="o">!</span><span class="n">inService</span><span class="p">,</span>
<span class="mi">416</span>                     <span class="n">alloc_on_fill</span><span class="p">);</span>
<span class="mi">417</span>     <span class="p">}</span>
<span class="mi">418</span> 
<span class="mi">419</span>     <span class="nf">DPRINTF</span><span class="p">(</span><span class="n">MSHR</span><span class="p">,</span> <span class="s">"After target allocation: %s"</span><span class="p">,</span> <span class="n">print</span><span class="p">());</span>
<span class="mi">420</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>The basic functionality of the allocateTarget is adding the missed memory request 
to one particular MSHR entries’ target list. 
Because MSHR collects every memory accesses targeting specific address 
and maintains them as its targets, 
this function must associates the missed packet to proper MSHR entry. 
Also, based on the current condition of the MSHR and pending requests associated with that MSHR entry,
the new packet can be added to either deferredTargets and targets.
Because they are all TargetList objects, let’s take a look at it first.</p>

<h3 id="target-and-targetlist"><span class="me-2">Target and TargetList</span><a href="#target-and-targetlist" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<p>The TargetList is the expanded vector class with Target type. 
Because one MSHR should record all the memory request 
associated with that entry, 
the TargetList vector stores all the missed request and associated information together
represented as a Target type.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre></td><td class="rouge-code"><pre><span class="mi">129</span>     <span class="k">class</span> <span class="nc">Target</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QueueEntry</span><span class="o">::</span><span class="n">Target</span>
<span class="mi">130</span>     <span class="p">{</span>   
<span class="mi">131</span>       <span class="k">public</span><span class="o">:</span>
<span class="mi">132</span>         
<span class="mi">133</span>         <span class="k">enum</span> <span class="n">Source</span>
<span class="mi">134</span>         <span class="p">{</span>
<span class="mi">135</span>             <span class="n">FromCPU</span><span class="p">,</span>
<span class="mi">136</span>             <span class="n">FromSnoop</span><span class="p">,</span>
<span class="mi">137</span>             <span class="n">FromPrefetcher</span>
<span class="mi">138</span>         <span class="p">};</span>
<span class="mi">139</span> 
<span class="mi">140</span>         <span class="k">const</span> <span class="n">Source</span> <span class="n">source</span><span class="p">;</span>  <span class="c1">//!&lt; Request from cpu, memory, or prefetcher?</span>
<span class="mi">141</span> 
<span class="mi">142</span>         <span class="cm">/**
143          * We use this flag to track whether we have cleared the
144          * downstreamPending flag for the MSHR of the cache above
145          * where this packet originates from and guard noninitial
146          * attempts to clear it.
147          *
148          * The flag markedPending needs to be updated when the
149          * TargetList is in service which can be:
150          * 1) during the Target instantiation if the MSHR is in
151          * service and the target is not deferred,
152          * 2) when the MSHR becomes in service if the target is not
153          * deferred,
154          * 3) or when the TargetList is promoted (deferredTargets -&gt;
155          * targets).
156          */</span>
<span class="mi">157</span>         <span class="kt">bool</span> <span class="n">markedPending</span><span class="p">;</span>
<span class="mi">158</span> 
<span class="mi">159</span>         <span class="k">const</span> <span class="kt">bool</span> <span class="n">allocOnFill</span><span class="p">;</span>   <span class="c1">//!&lt; Should the response servicing this</span>
<span class="mi">160</span>                                   <span class="c1">//!&lt; target list allocate in the cache?</span>
<span class="mi">161</span> 
<span class="mi">162</span>         <span class="n">Target</span><span class="p">(</span><span class="n">PacketPtr</span> <span class="n">_pkt</span><span class="p">,</span> <span class="n">Tick</span> <span class="n">_readyTime</span><span class="p">,</span> <span class="n">Counter</span> <span class="n">_order</span><span class="p">,</span>
<span class="mi">163</span>                <span class="n">Source</span> <span class="n">_source</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">_markedPending</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">alloc_on_fill</span><span class="p">)</span>
<span class="mi">164</span>             <span class="o">:</span> <span class="n">QueueEntry</span><span class="o">::</span><span class="n">Target</span><span class="p">(</span><span class="n">_pkt</span><span class="p">,</span> <span class="n">_readyTime</span><span class="p">,</span> <span class="n">_order</span><span class="p">),</span> <span class="n">source</span><span class="p">(</span><span class="n">_source</span><span class="p">),</span>
<span class="mi">165</span>               <span class="n">markedPending</span><span class="p">(</span><span class="n">_markedPending</span><span class="p">),</span> <span class="n">allocOnFill</span><span class="p">(</span><span class="n">alloc_on_fill</span><span class="p">)</span>
<span class="mi">166</span>         <span class="p">{}</span>
<span class="mi">167</span>     <span class="p">};</span>
<span class="mi">168</span> 
<span class="mi">169</span>     <span class="k">class</span> <span class="nc">TargetList</span> <span class="o">:</span> <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">Target</span><span class="o">&gt;</span><span class="p">,</span> <span class="k">public</span> <span class="n">Named</span>
<span class="mi">170</span>     <span class="p">{</span>
</pre></td></tr></tbody></table></code></div></div>

<h3 id="when-no-mshr-is-present"><span class="me-2">When no MSHR is present</span><a href="#when-no-mshr-is-present" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre></td><td class="rouge-code"><pre> <span class="mi">308</span>     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
 <span class="mi">309</span>         <span class="c1">// no MSHR</span>
 <span class="mi">310</span>         <span class="n">assert</span><span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">requestorId</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">system</span><span class="o">-&gt;</span><span class="n">maxRequestors</span><span class="p">());</span>
 <span class="mi">311</span>         <span class="n">stats</span><span class="p">.</span><span class="n">cmdStats</span><span class="p">(</span><span class="n">pkt</span><span class="p">).</span><span class="n">mshrMisses</span><span class="p">[</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">requestorId</span><span class="p">()]</span><span class="o">++</span><span class="p">;</span>
 <span class="mi">312</span>         <span class="k">if</span> <span class="p">(</span><span class="n">prefetcher</span> <span class="o">&amp;&amp;</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">isDemand</span><span class="p">())</span>
 <span class="mi">313</span>             <span class="n">prefetcher</span><span class="o">-&gt;</span><span class="n">incrDemandMhsrMisses</span><span class="p">();</span>
 <span class="mi">314</span> 
 <span class="mi">315</span>         <span class="k">if</span> <span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">isEviction</span><span class="p">()</span> <span class="o">||</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">MemCmd</span><span class="o">::</span><span class="n">WriteClean</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">316</span>             <span class="c1">// We use forward_time here because there is an</span>
 <span class="mi">317</span>             <span class="c1">// writeback or writeclean, forwarded to WriteBuffer.</span>
 <span class="mi">318</span>             <span class="n">allocateWriteBuffer</span><span class="p">(</span><span class="n">pkt</span><span class="p">,</span> <span class="n">forward_time</span><span class="p">);</span>
 <span class="mi">319</span>         <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
 <span class="mi">320</span>             <span class="k">if</span> <span class="p">(</span><span class="n">blk</span> <span class="o">&amp;&amp;</span> <span class="n">blk</span><span class="o">-&gt;</span><span class="n">isValid</span><span class="p">())</span> <span class="p">{</span>
 <span class="mi">321</span>                 <span class="c1">// If we have a write miss to a valid block, we</span>
 <span class="mi">322</span>                 <span class="c1">// need to mark the block non-readable.  Otherwise</span>
 <span class="mi">323</span>                 <span class="c1">// if we allow reads while there's an outstanding</span>
 <span class="mi">324</span>                 <span class="c1">// write miss, the read could return stale data</span>
 <span class="mi">325</span>                 <span class="c1">// out of the cache block... a more aggressive</span>
 <span class="mi">326</span>                 <span class="c1">// system could detect the overlap (if any) and</span>
 <span class="mi">327</span>                 <span class="c1">// forward data out of the MSHRs, but we don't do</span>
 <span class="mi">328</span>                 <span class="c1">// that yet.  Note that we do need to leave the</span>
 <span class="mi">329</span>                 <span class="c1">// block valid so that it stays in the cache, in</span>
 <span class="mi">330</span>                 <span class="c1">// case we get an upgrade response (and hence no</span>
 <span class="mi">331</span>                 <span class="c1">// new data) when the write miss completes.</span>
 <span class="mi">332</span>                 <span class="c1">// As long as CPUs do proper store/load forwarding</span>
 <span class="mi">333</span>                 <span class="c1">// internally, and have a sufficiently weak memory</span>
 <span class="mi">334</span>                 <span class="c1">// model, this is probably unnecessary, but at some</span>
 <span class="mi">335</span>                 <span class="c1">// point it must have seemed like we needed it...</span>
 <span class="mi">336</span>                 <span class="n">assert</span><span class="p">((</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">needsWritable</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
 <span class="mi">337</span>                     <span class="o">!</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">isSet</span><span class="p">(</span><span class="n">CacheBlk</span><span class="o">::</span><span class="n">WritableBit</span><span class="p">))</span> <span class="o">||</span>
 <span class="mi">338</span>                     <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">isCacheMaintenance</span><span class="p">());</span>
 <span class="mi">339</span>                 <span class="n">blk</span><span class="o">-&gt;</span><span class="n">clearCoherenceBits</span><span class="p">(</span><span class="n">CacheBlk</span><span class="o">::</span><span class="n">ReadableBit</span><span class="p">);</span>
 <span class="mi">340</span>             <span class="p">}</span>
 <span class="mi">341</span>             <span class="c1">// Here we are using forward_time, modelling the latency of</span>
 <span class="mi">342</span>             <span class="c1">// a miss (outbound) just as forwardLatency, neglecting the</span>
 <span class="mi">343</span>             <span class="c1">// lookupLatency component.</span>
 <span class="mi">344</span>             <span class="nf">allocateMissBuffer</span><span class="p">(</span><span class="n">pkt</span><span class="p">,</span> <span class="n">forward_time</span><span class="p">);</span>
 <span class="mi">345</span>         <span class="p">}</span>
 <span class="mi">346</span>     <span class="p">}</span>
 <span class="mi">347</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>It first checks whether the current memory request is Eviction request. 
Note that cache miss can happen either because of the read and write operation.
When it already has a valid block, but the cache access returns miss,
it means that the block exists but not writable. 
In that case, it first set the selected block as non-readable (line 339)
because the data should not be read until
the write miss is resolved through the XBar.
To handle the write miss request, it invokes allocateMissBuffer function.</p>

<h3 id="allocatemissbuffer-allocate-mshr-entry-for-the-write-miss-event"><span class="me-2">allocateMissBuffer: allocate MSHR entry for the write miss event</span><a href="#allocatemissbuffer-allocate-mshr-entry-for-the-write-miss-event" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre><span class="mi">1164</span>     <span class="n">MSHR</span> <span class="o">*</span><span class="nf">allocateMissBuffer</span><span class="p">(</span><span class="n">PacketPtr</span> <span class="n">pkt</span><span class="p">,</span> <span class="n">Tick</span> <span class="n">time</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">sched_send</span> <span class="o">=</span> <span class="nb">true</span><span class="p">)</span>
<span class="mi">1165</span>     <span class="p">{</span>
<span class="mi">1166</span>         <span class="n">MSHR</span> <span class="o">*</span><span class="n">mshr</span> <span class="o">=</span> <span class="n">mshrQueue</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">getBlockAddr</span><span class="p">(</span><span class="n">blkSize</span><span class="p">),</span> <span class="n">blkSize</span><span class="p">,</span>
<span class="mi">1167</span>                                         <span class="n">pkt</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">order</span><span class="o">++</span><span class="p">,</span>
<span class="mi">1168</span>                                         <span class="n">allocOnFill</span><span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">));</span>
<span class="mi">1169</span> 
<span class="mi">1170</span>         <span class="nf">if</span> <span class="p">(</span><span class="n">mshrQueue</span><span class="p">.</span><span class="n">isFull</span><span class="p">())</span> <span class="p">{</span>
<span class="mi">1171</span>             <span class="n">setBlocked</span><span class="p">((</span><span class="n">BlockedCause</span><span class="p">)</span><span class="n">MSHRQueue_MSHRs</span><span class="p">);</span>
<span class="mi">1172</span>         <span class="p">}</span>
<span class="mi">1173</span> 
<span class="mi">1174</span>         <span class="nf">if</span> <span class="p">(</span><span class="n">sched_send</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1175</span>             <span class="c1">// schedule the send</span>
<span class="mi">1176</span>             <span class="n">schedMemSideSendEvent</span><span class="p">(</span><span class="n">time</span><span class="p">);</span>
<span class="mi">1177</span>         <span class="p">}</span>
<span class="mi">1178</span> 
<span class="mi">1179</span>         <span class="k">return</span> <span class="n">mshr</span><span class="p">;</span>
<span class="mi">1180</span>     <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>When there is no MSHR entry associated with current request, 
the first priority job is allocating new MSHR entry 
for this memory request and further memory requests.
mshrQueue maintains all MSHR entries and provide allocate interface
that adds new MSHR entry to the queue. 
After that, because the allocateMissBuffer by default set sched_send parameter,
it invokes schedMemSideSendEvent to let the lower level cache or memory
to fetch data. 
Let’s take a look at how the MSHR entry is allocated and 
processed by the schedMemSideSendEvent later.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="rouge-code"><pre> <span class="mi">62</span> <span class="n">MSHR</span> <span class="o">*</span>
 <span class="mi">63</span> <span class="n">MSHRQueue</span><span class="o">::</span><span class="n">allocate</span><span class="p">(</span><span class="n">Addr</span> <span class="n">blk_addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">blk_size</span><span class="p">,</span> <span class="n">PacketPtr</span> <span class="n">pkt</span><span class="p">,</span>
 <span class="mi">64</span>                     <span class="n">Tick</span> <span class="n">when_ready</span><span class="p">,</span> <span class="n">Counter</span> <span class="n">order</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">alloc_on_fill</span><span class="p">)</span>
 <span class="mi">65</span> <span class="p">{</span>
 <span class="mi">66</span>     <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">freeList</span><span class="p">.</span><span class="n">empty</span><span class="p">());</span>
 <span class="mi">67</span>     <span class="n">MSHR</span> <span class="o">*</span><span class="n">mshr</span> <span class="o">=</span> <span class="n">freeList</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
 <span class="mi">68</span>     <span class="n">assert</span><span class="p">(</span><span class="n">mshr</span><span class="o">-&gt;</span><span class="n">getNumTargets</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
 <span class="mi">69</span>     <span class="n">freeList</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
 <span class="mi">70</span> 
 <span class="mi">71</span>     <span class="n">DPRINTF</span><span class="p">(</span><span class="n">MSHR</span><span class="p">,</span> <span class="s">"Allocating new MSHR. Number in use will be %lu/%lu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
 <span class="mi">72</span>             <span class="n">allocatedList</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">numEntries</span><span class="p">);</span>
 <span class="mi">73</span> 
 <span class="mi">74</span>     <span class="n">mshr</span><span class="o">-&gt;</span><span class="n">allocate</span><span class="p">(</span><span class="n">blk_addr</span><span class="p">,</span> <span class="n">blk_size</span><span class="p">,</span> <span class="n">pkt</span><span class="p">,</span> <span class="n">when_ready</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">alloc_on_fill</span><span class="p">);</span>
 <span class="mi">75</span>     <span class="n">mshr</span><span class="o">-&gt;</span><span class="n">allocIter</span> <span class="o">=</span> <span class="n">allocatedList</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">allocatedList</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">mshr</span><span class="p">);</span>
 <span class="mi">76</span>     <span class="n">mshr</span><span class="o">-&gt;</span><span class="n">readyIter</span> <span class="o">=</span> <span class="n">addToReadyList</span><span class="p">(</span><span class="n">mshr</span><span class="p">);</span>
 <span class="mi">77</span> 
 <span class="mi">78</span>     <span class="n">allocated</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
 <span class="mi">79</span>     <span class="k">return</span> <span class="n">mshr</span><span class="p">;</span>
 <span class="mi">80</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>The MSHRQueue manages entire MSHR entries in the system.
Also, the MSHRQueue is the child class of the Queue class.
Therefore, to understand how each MSHR entry is allocated,
we should take a look at the methods and fields 
implemented in the Queue class. 
Note that the Queue is template class so that it can 
manage any type of queue entries. 
Each Queue has a list called freeList 
which have free queue entries typed passed at template initialization.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="rouge-code"><pre><span class="mi">302</span> <span class="kt">void</span>
<span class="mi">303</span> <span class="n">MSHR</span><span class="o">::</span><span class="n">allocate</span><span class="p">(</span><span class="n">Addr</span> <span class="n">blk_addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">blk_size</span><span class="p">,</span> <span class="n">PacketPtr</span> <span class="n">target</span><span class="p">,</span>
<span class="mi">304</span>                <span class="n">Tick</span> <span class="n">when_ready</span><span class="p">,</span> <span class="n">Counter</span> <span class="n">_order</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">alloc_on_fill</span><span class="p">)</span>
<span class="mi">305</span> <span class="p">{</span>
<span class="mi">306</span>     <span class="n">blkAddr</span> <span class="o">=</span> <span class="n">blk_addr</span><span class="p">;</span>
<span class="mi">307</span>     <span class="n">blkSize</span> <span class="o">=</span> <span class="n">blk_size</span><span class="p">;</span>
<span class="mi">308</span>     <span class="n">isSecure</span> <span class="o">=</span> <span class="n">target</span><span class="o">-&gt;</span><span class="n">isSecure</span><span class="p">();</span>
<span class="mi">309</span>     <span class="n">readyTime</span> <span class="o">=</span> <span class="n">when_ready</span><span class="p">;</span>
<span class="mi">310</span>     <span class="n">order</span> <span class="o">=</span> <span class="n">_order</span><span class="p">;</span>
<span class="mi">311</span>     <span class="n">assert</span><span class="p">(</span><span class="n">target</span><span class="p">);</span>
<span class="mi">312</span>     <span class="n">isForward</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="mi">313</span>     <span class="n">wasWholeLineWrite</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="mi">314</span>     <span class="n">_isUncacheable</span> <span class="o">=</span> <span class="n">target</span><span class="o">-&gt;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">isUncacheable</span><span class="p">();</span>
<span class="mi">315</span>     <span class="n">inService</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="mi">316</span>     <span class="n">downstreamPending</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="mi">317</span> 
<span class="mi">318</span>     <span class="n">targets</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">blkAddr</span><span class="p">,</span> <span class="n">blkSize</span><span class="p">);</span>
<span class="mi">319</span>     <span class="n">deferredTargets</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">blkAddr</span><span class="p">,</span> <span class="n">blkSize</span><span class="p">);</span>
<span class="mi">320</span> 
<span class="mi">321</span>     <span class="c1">// Don't know of a case where we would allocate a new MSHR for a</span>
<span class="mi">322</span>     <span class="c1">// snoop (mem-side request), so set source according to request here</span>
<span class="mi">323</span>     <span class="n">Target</span><span class="o">::</span><span class="n">Source</span> <span class="n">source</span> <span class="o">=</span> <span class="p">(</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">MemCmd</span><span class="o">::</span><span class="n">HardPFReq</span><span class="p">)</span> <span class="o">?</span>
<span class="mi">324</span>         <span class="n">Target</span><span class="o">::</span><span class="n">FromPrefetcher</span> <span class="o">:</span> <span class="n">Target</span><span class="o">::</span><span class="n">FromCPU</span><span class="p">;</span>
<span class="mi">325</span>     <span class="n">targets</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">when_ready</span><span class="p">,</span> <span class="n">_order</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="n">alloc_on_fill</span><span class="p">);</span>
<span class="mi">326</span> 
<span class="mi">327</span>     <span class="c1">// All targets must refer to the same block</span>
<span class="mi">328</span>     <span class="n">assert</span><span class="p">(</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">matchBlockAddr</span><span class="p">(</span><span class="n">targets</span><span class="p">.</span><span class="n">front</span><span class="p">().</span><span class="n">pkt</span><span class="p">,</span> <span class="n">blkSize</span><span class="p">));</span>
<span class="mi">329</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>First of all, the retrieved MSHR entry should be initialized. 
The allocation function of the MSHR object
first initialize the targets list. 
Remember that one MSHR entry can have multiple targets.
Also, those targets are maintained by targets and deferredTargets 
TargetList. Therefore, the two TargetLists should be initialized first.
After the initialization, it adds the current request 
to the targets list.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="rouge-code"><pre><span class="mi">104</span>     <span class="k">typename</span> <span class="n">Entry</span><span class="o">::</span><span class="n">Iterator</span> <span class="nf">addToReadyList</span><span class="p">(</span><span class="n">Entry</span><span class="o">*</span> <span class="n">entry</span><span class="p">)</span>
<span class="mi">105</span>     <span class="p">{</span>
<span class="mi">106</span>         <span class="k">if</span> <span class="p">(</span><span class="n">readyList</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">||</span>
<span class="mi">107</span>             <span class="n">readyList</span><span class="p">.</span><span class="n">back</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">readyTime</span> <span class="o">&lt;=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">readyTime</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">108</span>             <span class="k">return</span> <span class="n">readyList</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">readyList</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">entry</span><span class="p">);</span>
<span class="mi">109</span>         <span class="p">}</span>
<span class="mi">110</span> 
<span class="mi">111</span>         <span class="nf">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="n">readyList</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">readyList</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">112</span>             <span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">readyTime</span> <span class="o">&gt;</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">readyTime</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">113</span>                 <span class="k">return</span> <span class="n">readyList</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
<span class="mi">114</span>             <span class="p">}</span>
<span class="mi">115</span>         <span class="p">}</span>
<span class="mi">116</span>         <span class="nf">panic</span><span class="p">(</span><span class="s">"Failed to add to ready list."</span><span class="p">);</span>
<span class="mi">117</span>     <span class="p">}</span> 
</pre></td></tr></tbody></table></code></div></div>

<p>After the MSHR entry is initialized,
the packet should also be registered to the readyList
of the MSHRQueue. 
The readyList manages all MSHR entries 
in ascending order of the readyTime of the 
initial packet that populated the MSHR entry. 
Because the MSHR entries should be processed 
in the readyTime order, 
when the time specified by the readyTime reaches,
the waiting MSHR will be processed. 
You can think of the readyList is kind of a queue 
determines the order 
which entry should be processed first among all MSHR entries.</p>

<h3 id="schedmemsidesendevent-schedule-sending-deferred-packet"><span class="me-2">schedMemSideSendEvent: schedule sending deferred packet</span><a href="#schedmemsidesendevent-schedule-sending-deferred-packet" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<p>After allocating the MSHR entry for the missed packet, 
the missed request should be forwarded to the next cache level 
or the memory based on where the current cache is located on.
However, the real hardware cannot process 
cache miss and forwarding at the same clock cycle.
Therefore, it schedules the sending missed cache request packet
after a few clock cycles elapsed. 
For that purpose, the schedMemSideSendEvent function is invoked.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre><span class="mi">1257</span>     <span class="cm">/**
1258      * Schedule a send event for the memory-side port. If already
1259      * scheduled, this may reschedule the event at an earlier
1260      * time. When the specified time is reached, the port is free to
1261      * send either a response, a request, or a prefetch request.
1262      *      
1263      * @param time The time when to attempt sending a packet.
1264      */</span> 
<span class="mi">1265</span>     <span class="kt">void</span> <span class="nf">schedMemSideSendEvent</span><span class="p">(</span><span class="n">Tick</span> <span class="n">time</span><span class="p">)</span> 
<span class="mi">1266</span>     <span class="p">{</span> 
<span class="mi">1267</span>         <span class="n">memSidePort</span><span class="p">.</span><span class="n">schedSendEvent</span><span class="p">(</span><span class="n">time</span><span class="p">);</span>
<span class="mi">1268</span>     <span class="p">}</span>  
</pre></td></tr></tbody></table></code></div></div>

<p>We took a look at the schedSendEvent function provided by the PacketQueue. 
The major job of the function was registering event to process 
deferred packet and send response to the CpuSidePort.
However, note that we are currently looking at the <strong>memSidePort’s 
schedSendEvent</strong>.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="rouge-code"><pre> <span class="mi">234</span>     <span class="cm">/**
 235      * The memory-side port extends the base cache request port with
 236      * access functions for functional, atomic and timing snoops.
 237      */</span>
 <span class="mi">238</span>     <span class="k">class</span> <span class="nc">MemSidePort</span> <span class="o">:</span> <span class="k">public</span> <span class="n">CacheRequestPort</span>
 <span class="mi">239</span>     <span class="p">{</span>
 <span class="mi">240</span>       <span class="k">private</span><span class="o">:</span>
 <span class="mi">241</span> 
 <span class="mi">242</span>         <span class="cm">/** The cache-specific queue. */</span>
 <span class="mi">243</span>         <span class="n">CacheReqPacketQueue</span> <span class="n">_reqQueue</span><span class="p">;</span>
 <span class="mi">244</span> 
 <span class="mi">245</span>         <span class="n">SnoopRespPacketQueue</span> <span class="n">_snoopRespQueue</span><span class="p">;</span>
 <span class="mi">246</span> 
 <span class="mi">247</span>         <span class="c1">// a pointer to our specific cache implementation</span>
 <span class="mi">248</span>         <span class="n">BaseCache</span> <span class="o">*</span><span class="n">cache</span><span class="p">;</span>
 <span class="mi">249</span> 
 <span class="mi">250</span>       <span class="k">protected</span><span class="o">:</span>
 <span class="mi">251</span> 
 <span class="mi">252</span>         <span class="k">virtual</span> <span class="kt">void</span> <span class="n">recvTimingSnoopReq</span><span class="p">(</span><span class="n">PacketPtr</span> <span class="n">pkt</span><span class="p">);</span>
 <span class="mi">253</span> 
 <span class="mi">254</span>         <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">recvTimingResp</span><span class="p">(</span><span class="n">PacketPtr</span> <span class="n">pkt</span><span class="p">);</span>
 <span class="mi">255</span> 
 <span class="mi">256</span>         <span class="k">virtual</span> <span class="n">Tick</span> <span class="n">recvAtomicSnoop</span><span class="p">(</span><span class="n">PacketPtr</span> <span class="n">pkt</span><span class="p">);</span>
 <span class="mi">257</span> 
 <span class="mi">258</span>         <span class="k">virtual</span> <span class="kt">void</span> <span class="n">recvFunctionalSnoop</span><span class="p">(</span><span class="n">PacketPtr</span> <span class="n">pkt</span><span class="p">);</span>
 <span class="mi">259</span> 
 <span class="mi">260</span>       <span class="k">public</span><span class="o">:</span>
 <span class="mi">261</span> 
 <span class="mi">262</span>         <span class="n">MemSidePort</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">_name</span><span class="p">,</span> <span class="n">BaseCache</span> <span class="o">*</span><span class="n">_cache</span><span class="p">,</span>
 <span class="mi">263</span>                     <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">_label</span><span class="p">);</span>
 <span class="mi">264</span>     <span class="p">};</span>
</pre></td></tr></tbody></table></code></div></div>

<p>Because it doesn’t provide the function schedSendEvent,
we should go deeper to its parent class, CacheRequestPort.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="rouge-code"><pre> <span class="mi">143</span>     <span class="cm">/**
 144      * A cache request port is used for the memory-side port of the
 145      * cache, and in addition to the basic timing port that only sends
 146      * response packets through a transmit list, it also offers the
 147      * ability to schedule and send request packets (requests &amp;
 148      * writebacks). The send event is scheduled through schedSendEvent,
 149      * and the sendDeferredPacket of the timing port is modified to
 150      * consider both the transmit list and the requests from the MSHR.
 151      */</span>
 <span class="mi">152</span>     <span class="k">class</span> <span class="nc">CacheRequestPort</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QueuedRequestPort</span>
 <span class="mi">153</span>     <span class="p">{</span>
 <span class="mi">154</span> 
 <span class="mi">155</span>       <span class="k">public</span><span class="o">:</span>
 <span class="mi">156</span> 
 <span class="mi">157</span>         <span class="cm">/**
 158          * Schedule a send of a request packet (from the MSHR). Note
 159          * that we could already have a retry outstanding.
 160          */</span>
 <span class="mi">161</span>         <span class="kt">void</span> <span class="n">schedSendEvent</span><span class="p">(</span><span class="n">Tick</span> <span class="n">time</span><span class="p">)</span>
 <span class="mi">162</span>         <span class="p">{</span>
 <span class="mi">163</span>             <span class="n">DPRINTF</span><span class="p">(</span><span class="n">CachePort</span><span class="p">,</span> <span class="s">"Scheduling send event at %llu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">time</span><span class="p">);</span>
 <span class="mi">164</span>             <span class="n">reqQueue</span><span class="p">.</span><span class="n">schedSendEvent</span><span class="p">(</span><span class="n">time</span><span class="p">);</span>
 <span class="mi">165</span>         <span class="p">}</span>
 <span class="mi">166</span> 
 <span class="mi">167</span>       <span class="k">protected</span><span class="o">:</span>
 <span class="mi">168</span> 
 <span class="mi">169</span>         <span class="n">CacheRequestPort</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">_name</span><span class="p">,</span> <span class="n">BaseCache</span> <span class="o">*</span><span class="n">_cache</span><span class="p">,</span>
 <span class="mi">170</span>                         <span class="n">ReqPacketQueue</span> <span class="o">&amp;</span><span class="n">_reqQueue</span><span class="p">,</span>
 <span class="mi">171</span>                         <span class="n">SnoopRespPacketQueue</span> <span class="o">&amp;</span><span class="n">_snoopRespQueue</span><span class="p">)</span> <span class="o">:</span>
 <span class="mi">172</span>             <span class="n">QueuedRequestPort</span><span class="p">(</span><span class="n">_name</span><span class="p">,</span> <span class="n">_cache</span><span class="p">,</span> <span class="n">_reqQueue</span><span class="p">,</span> <span class="n">_snoopRespQueue</span><span class="p">)</span>
 <span class="mi">173</span>         <span class="p">{</span> <span class="p">}</span>
 <span class="mi">174</span> 
 <span class="mi">175</span>         <span class="cm">/**
 176          * Memory-side port always snoops.
 177          *
 178          * @return always true
 179          */</span>
 <span class="mi">180</span>         <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">isSnooping</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span>
 <span class="mi">181</span>     <span class="p">};</span>
</pre></td></tr></tbody></table></code></div></div>

<p>Yeah this has very similar interfaces with the CpuSidePort. 
However, the schedSendEvent function invokes schedSendEvent function 
of the <strong>reqQueue</strong> instead of the respQueue.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="rouge-code"><pre><span class="mi">154</span> <span class="kt">void</span>
<span class="mi">155</span> <span class="n">PacketQueue</span><span class="o">::</span><span class="n">schedSendEvent</span><span class="p">(</span><span class="n">Tick</span> <span class="n">when</span><span class="p">)</span>
<span class="mi">156</span> <span class="p">{</span>
<span class="mi">157</span>     <span class="c1">// if we are waiting on a retry just hold off</span>
<span class="mi">158</span>     <span class="k">if</span> <span class="p">(</span><span class="n">waitingOnRetry</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">159</span>         <span class="n">DPRINTF</span><span class="p">(</span><span class="n">PacketQueue</span><span class="p">,</span> <span class="s">"Not scheduling send as waiting for retry</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="mi">160</span>         <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">sendEvent</span><span class="p">.</span><span class="n">scheduled</span><span class="p">());</span>
<span class="mi">161</span>         <span class="k">return</span><span class="p">;</span>
<span class="mi">162</span>     <span class="p">}</span>
<span class="mi">163</span> 
<span class="mi">164</span>     <span class="nf">if</span> <span class="p">(</span><span class="n">when</span> <span class="o">!=</span> <span class="n">MaxTick</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">165</span>         <span class="c1">// we cannot go back in time, and to be consistent we stick to</span>
<span class="mi">166</span>         <span class="c1">// one tick in the future</span>
<span class="mi">167</span>         <span class="n">when</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">when</span><span class="p">,</span> <span class="n">curTick</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="mi">168</span>         <span class="c1">// @todo Revisit the +1</span>
<span class="mi">169</span> 
<span class="mi">170</span>         <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sendEvent</span><span class="p">.</span><span class="n">scheduled</span><span class="p">())</span> <span class="p">{</span>
<span class="mi">171</span>             <span class="n">em</span><span class="p">.</span><span class="n">schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sendEvent</span><span class="p">,</span> <span class="n">when</span><span class="p">);</span>
<span class="mi">172</span>         <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">when</span> <span class="o">&lt;</span> <span class="n">sendEvent</span><span class="p">.</span><span class="n">when</span><span class="p">())</span> <span class="p">{</span>
<span class="mi">173</span>             <span class="c1">// if the new time is earlier than when the event</span>
<span class="mi">174</span>             <span class="c1">// currently is scheduled, move it forward</span>
<span class="mi">175</span>             <span class="n">em</span><span class="p">.</span><span class="n">reschedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sendEvent</span><span class="p">,</span> <span class="n">when</span><span class="p">);</span>
<span class="mi">176</span>         <span class="p">}</span>
<span class="mi">177</span>     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="mi">178</span>         <span class="c1">// we get a MaxTick when there is no more to send, so if we're</span>
<span class="mi">179</span>         <span class="c1">// draining, we may be done at this point</span>
<span class="mi">180</span>         <span class="k">if</span> <span class="p">(</span><span class="n">drainState</span><span class="p">()</span> <span class="o">==</span> <span class="n">DrainState</span><span class="o">::</span><span class="n">Draining</span> <span class="o">&amp;&amp;</span>
<span class="mi">181</span>             <span class="n">transmitList</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">sendEvent</span><span class="p">.</span><span class="n">scheduled</span><span class="p">())</span> <span class="p">{</span>
<span class="mi">182</span> 
<span class="mi">183</span>             <span class="n">DPRINTF</span><span class="p">(</span><span class="n">Drain</span><span class="p">,</span> <span class="s">"PacketQueue done draining,"</span>
<span class="mi">184</span>                     <span class="s">"processing drain event</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="mi">185</span>             <span class="n">signalDrainDone</span><span class="p">();</span>
<span class="mi">186</span>         <span class="p">}</span>
<span class="mi">187</span>     <span class="p">}</span>
<span class="mi">188</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>Although the reqQueue type is different from respQueue,
note that the same methods are invoked 
because they both inherit the PacketQueue class.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre> <span class="mi">50</span> <span class="n">PacketQueue</span><span class="o">::</span><span class="n">PacketQueue</span><span class="p">(</span><span class="n">EventManager</span><span class="o">&amp;</span> <span class="n">_em</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">_label</span><span class="p">,</span>
 <span class="mi">51</span>                          <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">_sendEventName</span><span class="p">,</span>
 <span class="mi">52</span>                          <span class="kt">bool</span> <span class="n">force_order</span><span class="p">,</span>
 <span class="mi">53</span>                          <span class="kt">bool</span> <span class="n">disable_sanity_check</span><span class="p">)</span>
 <span class="mi">54</span>     <span class="o">:</span> <span class="n">em</span><span class="p">(</span><span class="n">_em</span><span class="p">),</span> <span class="n">sendEvent</span><span class="p">([</span><span class="k">this</span><span class="p">]{</span> <span class="n">processSendEvent</span><span class="p">();</span> <span class="p">},</span> <span class="n">_sendEventName</span><span class="p">),</span>
 <span class="mi">55</span>       <span class="nf">_disableSanityCheck</span><span class="p">(</span><span class="n">disable_sanity_check</span><span class="p">),</span>
 <span class="mi">56</span>       <span class="n">forceOrder</span><span class="p">(</span><span class="n">force_order</span><span class="p">),</span>
 <span class="mi">57</span>       <span class="n">label</span><span class="p">(</span><span class="n">_label</span><span class="p">),</span> <span class="n">waitingOnRetry</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span>
 <span class="mi">58</span> <span class="p">{</span>
 <span class="mi">59</span> <span class="p">}</span>
<span class="p">......</span>
<span class="mi">220</span> <span class="kt">void</span> 
<span class="mi">221</span> <span class="n">PacketQueue</span><span class="o">::</span><span class="n">processSendEvent</span><span class="p">()</span>
<span class="mi">222</span> <span class="p">{</span>
<span class="mi">223</span>     <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">waitingOnRetry</span><span class="p">);</span>
<span class="mi">224</span>     <span class="nf">sendDeferredPacket</span><span class="p">();</span>
<span class="mi">225</span> <span class="p">}</span>

</pre></td></tr></tbody></table></code></div></div>
<p>It schedules sendEvent and involves processSendEvent when the event fires. 
However, when the sendEvent raises, processSendEvent function invokes 
different <strong>sendDeferredPacket</strong> function.
Note that respQueue is CacheReqPacketQueue inheriting ReqPacketQueue. 
Also, the <strong>CacheReqPacketQueue</strong> overrides sendDeferredPacket implemented in the 
PacketQueue class. Although the CacheReqPacketQueue inherits the PacketQueue class,
the overidden implementation of sendDeferredPacket will be invoked instead.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="rouge-code"><pre><span class="mi">2549</span> <span class="kt">void</span>
<span class="mi">2550</span> <span class="n">BaseCache</span><span class="o">::</span><span class="n">CacheReqPacketQueue</span><span class="o">::</span><span class="n">sendDeferredPacket</span><span class="p">()</span>
<span class="mi">2551</span> <span class="p">{</span>
<span class="mi">2552</span>     <span class="c1">// sanity check</span>
<span class="mi">2553</span>     <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">waitingOnRetry</span><span class="p">);</span>
<span class="mi">2554</span> 
<span class="mi">2555</span>     <span class="c1">// there should never be any deferred request packets in the</span>
<span class="mi">2556</span>     <span class="c1">// queue, instead we rely on the cache to provide the packets</span>
<span class="mi">2557</span>     <span class="c1">// from the MSHR queue or write queue</span>
<span class="mi">2558</span>     <span class="n">assert</span><span class="p">(</span><span class="n">deferredPacketReadyTime</span><span class="p">()</span> <span class="o">==</span> <span class="n">MaxTick</span><span class="p">);</span>
<span class="mi">2559</span> 
<span class="mi">2560</span>     <span class="c1">// check for request packets (requests &amp; writebacks)</span>
<span class="mi">2561</span>     <span class="n">QueueEntry</span><span class="o">*</span> <span class="n">entry</span> <span class="o">=</span> <span class="n">cache</span><span class="p">.</span><span class="n">getNextQueueEntry</span><span class="p">();</span>
<span class="mi">2562</span> 
<span class="mi">2563</span>     <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">2564</span>         <span class="c1">// can happen if e.g. we attempt a writeback and fail, but</span>
<span class="mi">2565</span>         <span class="c1">// before the retry, the writeback is eliminated because</span>
<span class="mi">2566</span>         <span class="c1">// we snoop another cache's ReadEx.</span>
<span class="mi">2567</span>     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="mi">2568</span>         <span class="c1">// let our snoop responses go first if there are responses to</span>
<span class="mi">2569</span>         <span class="c1">// the same addresses</span>
<span class="mi">2570</span>         <span class="k">if</span> <span class="p">(</span><span class="n">checkConflictingSnoop</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">getTarget</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">pkt</span><span class="p">))</span> <span class="p">{</span>
<span class="mi">2571</span>             <span class="k">return</span><span class="p">;</span>
<span class="mi">2572</span>         <span class="p">}</span>
<span class="mi">2573</span>         <span class="n">waitingOnRetry</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">sendPacket</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>
<span class="mi">2574</span>     <span class="p">}</span>
<span class="mi">2575</span> 
<span class="mi">2576</span>     <span class="c1">// if we succeeded and are not waiting for a retry, schedule the</span>
<span class="mi">2577</span>     <span class="c1">// next send considering when the next queue is ready, note that</span>
<span class="mi">2578</span>     <span class="c1">// snoop responses have their own packet queue and thus schedule</span>
<span class="mi">2579</span>     <span class="c1">// their own events</span>
<span class="mi">2580</span>     <span class="nf">if</span> <span class="p">(</span><span class="o">!</span><span class="n">waitingOnRetry</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">2581</span>         <span class="n">schedSendEvent</span><span class="p">(</span><span class="n">cache</span><span class="p">.</span><span class="n">nextQueueReadyTime</span><span class="p">());</span>
<span class="mi">2582</span>     <span class="p">}</span>
<span class="mi">2583</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>You might remember that the sendDeferredPacket of the PacketQueue utilizes the 
transmitList to dequeue the packets and send it to the CPU in our previous 
cache hit cases (sending response to the CPU). 
However, when the cache miss happens, it needs help from complicated cache units 
MSHR and writeBuffer. 
Also, you might have noticed that the packet had not been pushed to the 
transmitList but MSHR or writeBuffer. 
Instead of searching the transmitList, 
it invokes getNextQueueEntry function to find the next entry to process.</p>

<h2 id="getnextqueueentry-select-entry-to-send-to-the-memory-either-from-mshr-or-writebuffer"><span class="me-2">getNextQueueEntry: select entry to send to the memory either from MSHR or writeBuffer</span><a href="#getnextqueueentry-select-entry-to-send-to-the-memory-either-from-mshr-or-writebuffer" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre> <span class="mi">773</span> <span class="n">QueueEntry</span><span class="o">*</span>
 <span class="mi">774</span> <span class="n">BaseCache</span><span class="o">::</span><span class="n">getNextQueueEntry</span><span class="p">()</span>
 <span class="mi">775</span> <span class="p">{</span>
 <span class="mi">776</span>     <span class="c1">// Check both MSHR queue and write buffer for potential requests,</span>
 <span class="mi">777</span>     <span class="c1">// note that null does not mean there is no request, it could</span>
 <span class="mi">778</span>     <span class="c1">// simply be that it is not ready</span>
 <span class="mi">779</span>     <span class="n">MSHR</span> <span class="o">*</span><span class="n">miss_mshr</span>  <span class="o">=</span> <span class="n">mshrQueue</span><span class="p">.</span><span class="n">getNext</span><span class="p">();</span>
 <span class="mi">780</span>     <span class="n">WriteQueueEntry</span> <span class="o">*</span><span class="n">wq_entry</span> <span class="o">=</span> <span class="n">writeBuffer</span><span class="p">.</span><span class="n">getNext</span><span class="p">();</span>
</pre></td></tr></tbody></table></code></div></div>
<p>When the cache miss happens, 
the missed request packet could be stored in
either MSHR or WriteBuffer. 
This is because the sending memory request operations 
can be issued from two different units depending on the type 
of the memory request.
However, the sending response to the upper cache or processor
can be handled in unified way regardless of 
the request type.</p>

<h3 id="getnext-functions-return-entry-which-becomes-ready-to-be-processed"><span class="me-2">getNext functions return entry which becomes ready to be processed</span><a href="#getnext-functions-return-entry-which-becomes-ready-to-be-processed" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<p>When one entry is retrieved with the getNext method in 
the getNextQueueEntry function, it returns the MSHR entry or writeBack entry
that waits the longest time among them. 
Note that getNext function is defined in the Queue class, and
the WriteBuffer and MSHRQueue inherits the Queue class.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre><span class="mi">217</span>     <span class="cm">/**
218      * Returns the WriteQueueEntry at the head of the readyList.
219      * @return The next request to service.
220      */</span>
<span class="mi">221</span>     <span class="n">Entry</span><span class="o">*</span> <span class="nf">getNext</span><span class="p">()</span> <span class="k">const</span>
<span class="mi">222</span>     <span class="p">{</span>
<span class="mi">223</span>         <span class="k">if</span> <span class="p">(</span><span class="n">readyList</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">||</span> <span class="n">readyList</span><span class="p">.</span><span class="n">front</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">readyTime</span> <span class="o">&gt;</span> <span class="n">curTick</span><span class="p">())</span> <span class="p">{</span>
<span class="mi">224</span>             <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="mi">225</span>         <span class="p">}</span>
<span class="mi">226</span>         <span class="k">return</span> <span class="n">readyList</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
<span class="mi">227</span>     <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>The getNext function returns the first entry
stored in the readyList.
Note that the front entry of the readyList 
is the entry that has highest priority 
based on the readyTime. 
Therefore, it can process the entry 
that needs to be handled as soon as possible.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="rouge-code"><pre> <span class="mi">782</span>     <span class="c1">// If we got a write buffer request ready, first priority is a</span>
 <span class="mi">783</span>     <span class="c1">// full write buffer, otherwise we favour the miss requests</span>
 <span class="mi">784</span>     <span class="nf">if</span> <span class="p">(</span><span class="n">wq_entry</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">writeBuffer</span><span class="p">.</span><span class="n">isFull</span><span class="p">()</span> <span class="o">||</span> <span class="o">!</span><span class="n">miss_mshr</span><span class="p">))</span> <span class="p">{</span>
 <span class="mi">785</span>         <span class="c1">// need to search MSHR queue for conflicting earlier miss.</span>
 <span class="mi">786</span>         <span class="n">MSHR</span> <span class="o">*</span><span class="n">conflict_mshr</span> <span class="o">=</span> <span class="n">mshrQueue</span><span class="p">.</span><span class="n">findPending</span><span class="p">(</span><span class="n">wq_entry</span><span class="p">);</span>
 <span class="mi">787</span> 
 <span class="mi">788</span>         <span class="k">if</span> <span class="p">(</span><span class="n">conflict_mshr</span> <span class="o">&amp;&amp;</span> <span class="n">conflict_mshr</span><span class="o">-&gt;</span><span class="n">order</span> <span class="o">&lt;</span> <span class="n">wq_entry</span><span class="o">-&gt;</span><span class="n">order</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">789</span>             <span class="c1">// Service misses in order until conflict is cleared.</span>
 <span class="mi">790</span>             <span class="k">return</span> <span class="n">conflict_mshr</span><span class="p">;</span>
 <span class="mi">791</span> 
 <span class="mi">792</span>             <span class="c1">// @todo Note that we ignore the ready time of the conflict here</span>
 <span class="mi">793</span>         <span class="p">}</span>
 <span class="mi">794</span> 
 <span class="mi">795</span>         <span class="c1">// No conflicts; issue write</span>
 <span class="mi">796</span>         <span class="k">return</span> <span class="n">wq_entry</span><span class="p">;</span>
 <span class="mi">797</span>     <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">miss_mshr</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">798</span>         <span class="c1">// need to check for conflicting earlier writeback</span>
 <span class="mi">799</span>         <span class="n">WriteQueueEntry</span> <span class="o">*</span><span class="n">conflict_mshr</span> <span class="o">=</span> <span class="n">writeBuffer</span><span class="p">.</span><span class="n">findPending</span><span class="p">(</span><span class="n">miss_mshr</span><span class="p">);</span>
 <span class="mi">800</span>         <span class="k">if</span> <span class="p">(</span><span class="n">conflict_mshr</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">801</span>             <span class="c1">// not sure why we don't check order here... it was in the</span>
 <span class="mi">802</span>             <span class="c1">// original code but commented out.</span>
 <span class="mi">803</span> 
 <span class="mi">804</span>             <span class="c1">// The only way this happens is if we are</span>
 <span class="mi">805</span>             <span class="c1">// doing a write and we didn't have permissions</span>
 <span class="mi">806</span>             <span class="c1">// then subsequently saw a writeback (owned got evicted)</span>
 <span class="mi">807</span>             <span class="c1">// We need to make sure to perform the writeback first</span>
 <span class="mi">808</span>             <span class="c1">// To preserve the dirty data, then we can issue the write</span>
 <span class="mi">809</span> 
 <span class="mi">810</span>             <span class="c1">// should we return wq_entry here instead?  I.e. do we</span>
 <span class="mi">811</span>             <span class="c1">// have to flush writes in order?  I don't think so... not</span>
 <span class="mi">812</span>             <span class="c1">// for Alpha anyway.  Maybe for x86?</span>
 <span class="mi">813</span>             <span class="k">return</span> <span class="n">conflict_mshr</span><span class="p">;</span>
 <span class="mi">814</span> 
 <span class="mi">815</span>             <span class="c1">// @todo Note that we ignore the ready time of the conflict here</span>
 <span class="mi">816</span>         <span class="p">}</span>
 <span class="mi">817</span> 
 <span class="mi">818</span>         <span class="c1">// No conflicts; issue read</span>
 <span class="mi">819</span>         <span class="k">return</span> <span class="n">miss_mshr</span><span class="p">;</span>
 <span class="mi">820</span>     <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>After the two entries from the MSHR and writeBack queue are retrieved, 
it should check condition of two entries 
to determine which entry should be processed first. 
It is important to note that the port from the cache unit to the memory is 
limited resource. However, because we have two input sources to choose
we need to determine which packet retrieved from where should be sent to the memory.
Here, the logic put more priority in consuming full writeBuffer.
When the writeBuffer is not full, then MSHRqueue will be consumed.
Also, even when the writeBuffer is full, 
if there is conflicting and earlier entry in the MSHR, 
then the selected entry should be replaced with the conflicting MSHR entry. 
Otherwise, the selected entry from the writeBuffer will be returned. 
Based on the comment in the left part of the getNextQueueEntry function,
it seems that the selecting order is somewhat controversial, so I will skip them.</p>

<h3 id="generate-prefetching-request-when-there-is-no-entries-to-process"><span class="me-2">Generate prefetching request when there is no entries to process</span><a href="#generate-prefetching-request-when-there-is-no-entries-to-process" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre></td><td class="rouge-code"><pre> <span class="mi">822</span>     <span class="c1">// fall through... no pending requests.  Try a prefetch.</span>
 <span class="mi">823</span>     <span class="nf">assert</span><span class="p">(</span><span class="o">!</span><span class="n">miss_mshr</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">wq_entry</span><span class="p">);</span>
 <span class="mi">824</span>     <span class="nf">if</span> <span class="p">(</span><span class="n">prefetcher</span> <span class="o">&amp;&amp;</span> <span class="n">mshrQueue</span><span class="p">.</span><span class="n">canPrefetch</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isBlocked</span><span class="p">())</span> <span class="p">{</span>
 <span class="mi">825</span>         <span class="c1">// If we have a miss queue slot, we can try a prefetch</span>
 <span class="mi">826</span>         <span class="n">PacketPtr</span> <span class="n">pkt</span> <span class="o">=</span> <span class="n">prefetcher</span><span class="o">-&gt;</span><span class="n">getPacket</span><span class="p">();</span>
 <span class="mi">827</span>         <span class="k">if</span> <span class="p">(</span><span class="n">pkt</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">828</span>             <span class="n">Addr</span> <span class="n">pf_addr</span> <span class="o">=</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">getBlockAddr</span><span class="p">(</span><span class="n">blkSize</span><span class="p">);</span>
 <span class="mi">829</span>             <span class="k">if</span> <span class="p">(</span><span class="n">tags</span><span class="o">-&gt;</span><span class="n">findBlock</span><span class="p">(</span><span class="n">pf_addr</span><span class="p">,</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">isSecure</span><span class="p">()))</span> <span class="p">{</span>
 <span class="mi">830</span>                 <span class="n">DPRINTF</span><span class="p">(</span><span class="n">HWPrefetch</span><span class="p">,</span> <span class="s">"Prefetch %#x has hit in cache, "</span>
 <span class="mi">831</span>                         <span class="s">"dropped.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pf_addr</span><span class="p">);</span>
 <span class="mi">832</span>                 <span class="n">prefetcher</span><span class="o">-&gt;</span><span class="n">pfHitInCache</span><span class="p">();</span>
 <span class="mi">833</span>                 <span class="c1">// free the request and packet</span>
 <span class="mi">834</span>                 <span class="k">delete</span> <span class="n">pkt</span><span class="p">;</span>
 <span class="mi">835</span>             <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">mshrQueue</span><span class="p">.</span><span class="n">findMatch</span><span class="p">(</span><span class="n">pf_addr</span><span class="p">,</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">isSecure</span><span class="p">()))</span> <span class="p">{</span>
 <span class="mi">836</span>                 <span class="n">DPRINTF</span><span class="p">(</span><span class="n">HWPrefetch</span><span class="p">,</span> <span class="s">"Prefetch %#x has hit in a MSHR, "</span>
 <span class="mi">837</span>                         <span class="s">"dropped.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pf_addr</span><span class="p">);</span>
 <span class="mi">838</span>                 <span class="n">prefetcher</span><span class="o">-&gt;</span><span class="n">pfHitInMSHR</span><span class="p">();</span>
 <span class="mi">839</span>                 <span class="c1">// free the request and packet</span>
 <span class="mi">840</span>                 <span class="k">delete</span> <span class="n">pkt</span><span class="p">;</span>
 <span class="mi">841</span>             <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">writeBuffer</span><span class="p">.</span><span class="n">findMatch</span><span class="p">(</span><span class="n">pf_addr</span><span class="p">,</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">isSecure</span><span class="p">()))</span> <span class="p">{</span>
 <span class="mi">842</span>                 <span class="n">DPRINTF</span><span class="p">(</span><span class="n">HWPrefetch</span><span class="p">,</span> <span class="s">"Prefetch %#x has hit in the "</span>
 <span class="mi">843</span>                         <span class="s">"Write Buffer, dropped.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pf_addr</span><span class="p">);</span>
 <span class="mi">844</span>                 <span class="n">prefetcher</span><span class="o">-&gt;</span><span class="n">pfHitInWB</span><span class="p">();</span>
 <span class="mi">845</span>                 <span class="c1">// free the request and packet</span>
 <span class="mi">846</span>                 <span class="k">delete</span> <span class="n">pkt</span><span class="p">;</span>
 <span class="mi">847</span>             <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
 <span class="mi">848</span>                 <span class="c1">// Update statistic on number of prefetches issued</span>
 <span class="mi">849</span>                 <span class="c1">// (hwpf_mshr_misses)</span>
 <span class="mi">850</span>                 <span class="n">assert</span><span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">requestorId</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">system</span><span class="o">-&gt;</span><span class="n">maxRequestors</span><span class="p">());</span>
 <span class="mi">851</span>                 <span class="n">stats</span><span class="p">.</span><span class="n">cmdStats</span><span class="p">(</span><span class="n">pkt</span><span class="p">).</span><span class="n">mshrMisses</span><span class="p">[</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">requestorId</span><span class="p">()]</span><span class="o">++</span><span class="p">;</span>
 <span class="mi">852</span> 
 <span class="mi">853</span>                 <span class="c1">// allocate an MSHR and return it, note</span>
 <span class="mi">854</span>                 <span class="c1">// that we send the packet straight away, so do not</span>
 <span class="mi">855</span>                 <span class="c1">// schedule the send</span>
 <span class="mi">856</span>                 <span class="k">return</span> <span class="n">allocateMissBuffer</span><span class="p">(</span><span class="n">pkt</span><span class="p">,</span> <span class="n">curTick</span><span class="p">(),</span> <span class="nb">false</span><span class="p">);</span>
 <span class="mi">857</span>             <span class="p">}</span>
 <span class="mi">858</span>         <span class="p">}</span>
 <span class="mi">859</span>     <span class="p">}</span>
 <span class="mi">860</span> 
 <span class="mi">861</span>     <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
 <span class="mi">862</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>The fall through pass can only be reachable when 
there are no suitable request waiting in the writeBuffer and mshrQueue. 
In that case, it tries to prefetch entries.
Note that this prefetching is not software thing, but 
a hardware prefetcher generated addresses are accessed.
Because hardware prefetcher doesn’t know whether the cache 
or other waiting queues already have entry for that prefetched cache line,
it checks them to confirm this is the fresh prefetch request. 
If it is the fresh request, then add the request to the MSHR.
Because the added request will be handled later when the next events happen,
so it returns nullptr to report that there is no packet to be sent to the memory
at this cycle.</p>

<h3 id="checkconflictingsnoop"><span class="me-2">checkConflictingSnoop</span><a href="#checkconflictingsnoop" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre><span class="mi">2563</span>     <span class="nf">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">2564</span>         <span class="c1">// can happen if e.g. we attempt a writeback and fail, but</span>
<span class="mi">2565</span>         <span class="c1">// before the retry, the writeback is eliminated because</span>
<span class="mi">2566</span>         <span class="c1">// we snoop another cache's ReadEx.</span>
<span class="mi">2567</span>     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="mi">2568</span>         <span class="c1">// let our snoop responses go first if there are responses to</span>
<span class="mi">2569</span>         <span class="c1">// the same addresses</span>
<span class="mi">2570</span>         <span class="k">if</span> <span class="p">(</span><span class="n">checkConflictingSnoop</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">getTarget</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">pkt</span><span class="p">))</span> <span class="p">{</span>
<span class="mi">2571</span>             <span class="k">return</span><span class="p">;</span>
<span class="mi">2572</span>         <span class="p">}</span>
<span class="mi">2573</span>         <span class="n">waitingOnRetry</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">sendPacket</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>
<span class="mi">2574</span>     <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>After the entry is found it should check that 
whether the found entry has conflicting snoop response.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="rouge-code"><pre> <span class="mi">212</span>         <span class="cm">/**
 213          * Check if there is a conflicting snoop response about to be
 214          * send out, and if so simply stall any requests, and schedule
 215          * a send event at the same time as the next snoop response is
 216          * being sent out.
 217          *
 218          * @param pkt The packet to check for conflicts against.
 219          */</span>
 <span class="mi">220</span>         <span class="kt">bool</span> <span class="nf">checkConflictingSnoop</span><span class="p">(</span><span class="k">const</span> <span class="n">PacketPtr</span> <span class="n">pkt</span><span class="p">)</span>
 <span class="mi">221</span>         <span class="p">{</span>   
 <span class="mi">222</span>             <span class="k">if</span> <span class="p">(</span><span class="n">snoopRespQueue</span><span class="p">.</span><span class="n">checkConflict</span><span class="p">(</span><span class="n">pkt</span><span class="p">,</span> <span class="n">cache</span><span class="p">.</span><span class="n">blkSize</span><span class="p">))</span> <span class="p">{</span>
 <span class="mi">223</span>                 <span class="n">DPRINTF</span><span class="p">(</span><span class="n">CachePort</span><span class="p">,</span> <span class="s">"Waiting for snoop response to be "</span>
 <span class="mi">224</span>                         <span class="s">"sent</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
 <span class="mi">225</span>                 <span class="n">Tick</span> <span class="n">when</span> <span class="o">=</span> <span class="n">snoopRespQueue</span><span class="p">.</span><span class="n">deferredPacketReadyTime</span><span class="p">();</span>
 <span class="mi">226</span>                 <span class="n">schedSendEvent</span><span class="p">(</span><span class="n">when</span><span class="p">);</span>
 <span class="mi">227</span>                 <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
 <span class="mi">228</span>             <span class="p">}</span>
 <span class="mi">229</span>             <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
 <span class="mi">230</span>         <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>In other words, 
if there are the waiting snoop response
for the same address,
currently selected entry should be deferred 
until the snooping response is handled. 
The deferredPacketReadyTime function calculates 
the required time to send the snoop response, so that
the cache miss handling is done 
after the elapsed time passes (by schedSendEvent).</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre> <span class="mi">74</span> <span class="kt">bool</span>             
 <span class="mi">75</span> <span class="n">PacketQueue</span><span class="o">::</span><span class="n">checkConflict</span><span class="p">(</span><span class="k">const</span> <span class="n">PacketPtr</span> <span class="n">pkt</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">blk_size</span><span class="p">)</span> <span class="k">const</span>
 <span class="mi">76</span> <span class="p">{</span>
 <span class="mi">77</span>     <span class="c1">// caller is responsible for ensuring that all packets have the</span>
 <span class="mi">78</span>     <span class="c1">// same alignment</span>
 <span class="mi">79</span>     <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">p</span> <span class="o">:</span> <span class="n">transmitList</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">80</span>         <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">matchBlockAddr</span><span class="p">(</span><span class="n">pkt</span><span class="p">,</span> <span class="n">blk_size</span><span class="p">))</span>
 <span class="mi">81</span>             <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
 <span class="mi">82</span>     <span class="p">}</span>
 <span class="mi">83</span>     <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
 <span class="mi">84</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>Because the SnoopRespPacketQueue is the child of PacketQueue,
it invokes the above checkConflict function
to figure out if there is waiting snoopResponse packet 
for the same address of the selected entry.</p>

<h2 id="finally-sendpacket"><span class="me-2">finally sendPacket</span><a href="#finally-sendpacket" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>
<p>When there is no conflict between the selected entry 
and the snoop response,
it will send the request stored in the selected entry.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="rouge-code"><pre><span class="mi">2549</span> <span class="kt">void</span>
<span class="mi">2550</span> <span class="n">BaseCache</span><span class="o">::</span><span class="n">CacheReqPacketQueue</span><span class="o">::</span><span class="n">sendDeferredPacket</span><span class="p">()</span>
<span class="p">......</span>
<span class="mi">2561</span>     <span class="n">QueueEntry</span><span class="o">*</span> <span class="n">entry</span> <span class="o">=</span> <span class="n">cache</span><span class="p">.</span><span class="n">getNextQueueEntry</span><span class="p">();</span>
<span class="mi">2562</span>
<span class="mi">2563</span>     <span class="nf">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">2564</span>         <span class="c1">// can happen if e.g. we attempt a writeback and fail, but</span>
<span class="mi">2565</span>         <span class="c1">// before the retry, the writeback is eliminated because</span>
<span class="mi">2566</span>         <span class="c1">// we snoop another cache's ReadEx.</span>
<span class="mi">2567</span>     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="mi">2568</span>         <span class="c1">// let our snoop responses go first if there are responses to</span>
<span class="mi">2569</span>         <span class="c1">// the same addresses</span>
<span class="mi">2570</span>         <span class="k">if</span> <span class="p">(</span><span class="n">checkConflictingSnoop</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">getTarget</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">pkt</span><span class="p">))</span> <span class="p">{</span>
<span class="mi">2571</span>             <span class="k">return</span><span class="p">;</span>
<span class="mi">2572</span>         <span class="p">}</span>
<span class="mi">2573</span>         <span class="n">waitingOnRetry</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">sendPacket</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>
<span class="mi">2574</span>     <span class="p">}</span>
<span class="mi">2575</span>
<span class="mi">2576</span>     <span class="c1">// if we succeeded and are not waiting for a retry, schedule the</span>
<span class="mi">2577</span>     <span class="c1">// next send considering when the next queue is ready, note that</span>
<span class="mi">2578</span>     <span class="c1">// snoop responses have their own packet queue and thus schedule</span>
<span class="mi">2579</span>     <span class="c1">// their own events</span>
<span class="mi">2580</span>     <span class="nf">if</span> <span class="p">(</span><span class="o">!</span><span class="n">waitingOnRetry</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">2581</span>         <span class="n">schedSendEvent</span><span class="p">(</span><span class="n">cache</span><span class="p">.</span><span class="n">nextQueueReadyTime</span><span class="p">());</span>
<span class="mi">2582</span>     <span class="p">}</span>
<span class="mi">2583</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>The sendPacket function is defined as a virtual function 
in the QueueEntry class. 
Therefore, the corresponding implementation 
of the sendPacket function should be implemented 
in the MSHR class and WriteQueueEntry class.</p>

<p>Therefore, based on which type of packet is selected,
one of below sendPacket implementation will be invoked. 
Also note that the CacheReqPacketQueue has member field cache 
which is the reference of the BaseCache. 
And this cache field is initialized as the cache object itself 
who owns this CacheReqPacketQueue. 
In our case it will be the Cache object.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="mi">705</span> <span class="kt">bool</span>
<span class="mi">706</span> <span class="n">MSHR</span><span class="o">::</span><span class="n">sendPacket</span><span class="p">(</span><span class="n">BaseCache</span> <span class="o">&amp;</span><span class="n">cache</span><span class="p">)</span>
<span class="mi">707</span> <span class="p">{</span>
<span class="mi">708</span>     <span class="k">return</span> <span class="n">cache</span><span class="p">.</span><span class="n">sendMSHRQueuePacket</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="mi">709</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="mi">140</span> <span class="kt">bool</span>
<span class="mi">141</span> <span class="n">WriteQueueEntry</span><span class="o">::</span><span class="n">sendPacket</span><span class="p">(</span><span class="n">BaseCache</span> <span class="o">&amp;</span><span class="n">cache</span><span class="p">)</span>
<span class="mi">142</span> <span class="p">{</span>
<span class="mi">143</span>     <span class="k">return</span> <span class="n">cache</span><span class="p">.</span><span class="n">sendWriteQueuePacket</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="mi">144</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<h2 id="processing-selected-mshr-entry"><span class="me-2">Processing selected MSHR entry</span><a href="#processing-selected-mshr-entry" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>
<h3 id="cachesendmshrqueuepacket"><span class="me-2">Cache::sendMSHRQueuePacket</span><a href="#cachesendmshrqueuepacket" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
</pre></td><td class="rouge-code"><pre><span class="mi">1358</span> <span class="kt">bool</span>
<span class="mi">1359</span> <span class="n">Cache</span><span class="o">::</span><span class="n">sendMSHRQueuePacket</span><span class="p">(</span><span class="n">MSHR</span><span class="o">*</span> <span class="n">mshr</span><span class="p">)</span>
<span class="mi">1360</span> <span class="p">{</span>
<span class="mi">1361</span>     <span class="n">assert</span><span class="p">(</span><span class="n">mshr</span><span class="p">);</span>
<span class="mi">1362</span> 
<span class="mi">1363</span>     <span class="c1">// use request from 1st target</span>
<span class="mi">1364</span>     <span class="n">PacketPtr</span> <span class="n">tgt_pkt</span> <span class="o">=</span> <span class="n">mshr</span><span class="o">-&gt;</span><span class="n">getTarget</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">pkt</span><span class="p">;</span>
<span class="mi">1365</span> 
<span class="mi">1366</span>     <span class="k">if</span> <span class="p">(</span><span class="n">tgt_pkt</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">MemCmd</span><span class="o">::</span><span class="n">HardPFReq</span> <span class="o">&amp;&amp;</span> <span class="n">forwardSnoops</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1367</span>         <span class="n">DPRINTF</span><span class="p">(</span><span class="n">Cache</span><span class="p">,</span> <span class="s">"%s: MSHR %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">tgt_pkt</span><span class="o">-&gt;</span><span class="n">print</span><span class="p">());</span>
<span class="mi">1368</span> 
<span class="mi">1369</span>         <span class="c1">// we should never have hardware prefetches to allocated</span>
<span class="mi">1370</span>         <span class="c1">// blocks</span>
<span class="mi">1371</span>         <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">tags</span><span class="o">-&gt;</span><span class="n">findBlock</span><span class="p">(</span><span class="n">mshr</span><span class="o">-&gt;</span><span class="n">blkAddr</span><span class="p">,</span> <span class="n">mshr</span><span class="o">-&gt;</span><span class="n">isSecure</span><span class="p">));</span>
<span class="mi">1372</span> 
<span class="mi">1373</span>         <span class="c1">// We need to check the caches above us to verify that</span>
<span class="mi">1374</span>         <span class="c1">// they don't have a copy of this block in the dirty state</span>
<span class="mi">1375</span>         <span class="c1">// at the moment. Without this check we could get a stale</span>
<span class="mi">1376</span>         <span class="c1">// copy from memory that might get used in place of the</span>
<span class="mi">1377</span>         <span class="c1">// dirty one.</span>
<span class="mi">1378</span>         <span class="n">Packet</span> <span class="n">snoop_pkt</span><span class="p">(</span><span class="n">tgt_pkt</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="mi">1379</span>         <span class="n">snoop_pkt</span><span class="p">.</span><span class="n">setExpressSnoop</span><span class="p">();</span>
<span class="mi">1380</span>         <span class="c1">// We are sending this packet upwards, but if it hits we will</span>
<span class="mi">1381</span>         <span class="c1">// get a snoop response that we end up treating just like a</span>
<span class="mi">1382</span>         <span class="c1">// normal response, hence it needs the MSHR as its sender</span>
<span class="mi">1383</span>         <span class="c1">// state</span>
<span class="mi">1384</span>         <span class="n">snoop_pkt</span><span class="p">.</span><span class="n">senderState</span> <span class="o">=</span> <span class="n">mshr</span><span class="p">;</span>
<span class="mi">1385</span>         <span class="n">cpuSidePort</span><span class="p">.</span><span class="n">sendTimingSnoopReq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">snoop_pkt</span><span class="p">);</span>
<span class="mi">1386</span> 
<span class="mi">1387</span>         <span class="c1">// Check to see if the prefetch was squashed by an upper cache (to</span>
<span class="mi">1388</span>         <span class="c1">// prevent us from grabbing the line) or if a Check to see if a</span>
<span class="mi">1389</span>         <span class="c1">// writeback arrived between the time the prefetch was placed in</span>
<span class="mi">1390</span>         <span class="c1">// the MSHRs and when it was selected to be sent or if the</span>
<span class="mi">1391</span>         <span class="c1">// prefetch was squashed by an upper cache.</span>
<span class="mi">1392</span> 
<span class="mi">1393</span>         <span class="c1">// It is important to check cacheResponding before</span>
<span class="mi">1394</span>         <span class="c1">// prefetchSquashed. If another cache has committed to</span>
<span class="mi">1395</span>         <span class="c1">// responding, it will be sending a dirty response which will</span>
<span class="mi">1396</span>         <span class="c1">// arrive at the MSHR allocated for this request. Checking the</span>
<span class="mi">1397</span>         <span class="c1">// prefetchSquash first may result in the MSHR being</span>
<span class="mi">1398</span>         <span class="c1">// prematurely deallocated.</span>
<span class="mi">1399</span>         <span class="k">if</span> <span class="p">(</span><span class="n">snoop_pkt</span><span class="p">.</span><span class="n">cacheResponding</span><span class="p">())</span> <span class="p">{</span>
<span class="mi">1400</span>             <span class="n">GEM5_VAR_USED</span> <span class="k">auto</span> <span class="n">r</span> <span class="o">=</span> <span class="n">outstandingSnoop</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">snoop_pkt</span><span class="p">.</span><span class="n">req</span><span class="p">);</span>
<span class="mi">1401</span>             <span class="n">assert</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
<span class="mi">1402</span> 
<span class="mi">1403</span>             <span class="c1">// if we are getting a snoop response with no sharers it</span>
<span class="mi">1404</span>             <span class="c1">// will be allocated as Modified</span>
<span class="mi">1405</span>             <span class="kt">bool</span> <span class="n">pending_modified_resp</span> <span class="o">=</span> <span class="o">!</span><span class="n">snoop_pkt</span><span class="p">.</span><span class="n">hasSharers</span><span class="p">();</span>
<span class="mi">1406</span>             <span class="n">markInService</span><span class="p">(</span><span class="n">mshr</span><span class="p">,</span> <span class="n">pending_modified_resp</span><span class="p">);</span>
<span class="mi">1407</span> 
<span class="mi">1408</span>             <span class="n">DPRINTF</span><span class="p">(</span><span class="n">Cache</span><span class="p">,</span> <span class="s">"Upward snoop of prefetch for addr"</span>
<span class="mi">1409</span>                     <span class="s">" %#x (%s) hit</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
<span class="mi">1410</span>                     <span class="n">tgt_pkt</span><span class="o">-&gt;</span><span class="n">getAddr</span><span class="p">(),</span> <span class="n">tgt_pkt</span><span class="o">-&gt;</span><span class="n">isSecure</span><span class="p">()</span><span class="o">?</span> <span class="s">"s"</span><span class="o">:</span> <span class="s">"ns"</span><span class="p">);</span>
<span class="mi">1411</span>             <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="mi">1412</span>         <span class="p">}</span>
<span class="mi">1413</span> 
<span class="mi">1414</span>         <span class="nf">if</span> <span class="p">(</span><span class="n">snoop_pkt</span><span class="p">.</span><span class="n">isBlockCached</span><span class="p">())</span> <span class="p">{</span>
<span class="mi">1415</span>             <span class="n">DPRINTF</span><span class="p">(</span><span class="n">Cache</span><span class="p">,</span> <span class="s">"Block present, prefetch squashed by cache.  "</span>
<span class="mi">1416</span>                     <span class="s">"Deallocating mshr target %#x.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
<span class="mi">1417</span>                     <span class="n">mshr</span><span class="o">-&gt;</span><span class="n">blkAddr</span><span class="p">);</span>
<span class="mi">1418</span> 
<span class="mi">1419</span>             <span class="c1">// Deallocate the mshr target</span>
<span class="mi">1420</span>             <span class="k">if</span> <span class="p">(</span><span class="n">mshrQueue</span><span class="p">.</span><span class="n">forceDeallocateTarget</span><span class="p">(</span><span class="n">mshr</span><span class="p">))</span> <span class="p">{</span>
<span class="mi">1421</span>                 <span class="c1">// Clear block if this deallocation resulted freed an</span>
<span class="mi">1422</span>                 <span class="c1">// mshr when all had previously been utilized</span>
<span class="mi">1423</span>                 <span class="n">clearBlocked</span><span class="p">(</span><span class="n">Blocked_NoMSHRs</span><span class="p">);</span>
<span class="mi">1424</span>             <span class="p">}</span>
<span class="mi">1425</span> 
<span class="mi">1426</span>             <span class="c1">// given that no response is expected, delete Request and Packet</span>
<span class="mi">1427</span>             <span class="k">delete</span> <span class="n">tgt_pkt</span><span class="p">;</span>
<span class="mi">1428</span> 
<span class="mi">1429</span>             <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="mi">1430</span>         <span class="p">}</span>
<span class="mi">1431</span>     <span class="p">}</span>
<span class="mi">1432</span> 
<span class="mi">1433</span>     <span class="k">return</span> <span class="n">BaseCache</span><span class="o">::</span><span class="n">sendMSHRQueuePacket</span><span class="p">(</span><span class="n">mshr</span><span class="p">);</span>
<span class="mi">1434</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>Because we are currently dealing with Cache not the BaseCache,
it should first invokes sendMSHRQueuePacket of the Cache class.
Although it has pretty complicated code,
most of the code are not relevant to general 
MSHR packet handling. 
At the end of the function it invokes 
sendMSHRQueuePacket function of the BaseCache 
to handle the packets in common scenario.</p>

<h3 id="basecachesendmshrqueuepacket"><span class="me-2">BaseCache::sendMSHRQueuePacket</span><a href="#basecachesendmshrqueuepacket" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="rouge-code"><pre><span class="mi">1789</span> <span class="kt">bool</span>
<span class="mi">1790</span> <span class="n">BaseCache</span><span class="o">::</span><span class="n">sendMSHRQueuePacket</span><span class="p">(</span><span class="n">MSHR</span><span class="o">*</span> <span class="n">mshr</span><span class="p">)</span>
<span class="mi">1791</span> <span class="p">{</span>
<span class="mi">1792</span>     <span class="n">assert</span><span class="p">(</span><span class="n">mshr</span><span class="p">);</span>
<span class="mi">1793</span> 
<span class="mi">1794</span>     <span class="c1">// use request from 1st target</span>
<span class="mi">1795</span>     <span class="n">PacketPtr</span> <span class="n">tgt_pkt</span> <span class="o">=</span> <span class="n">mshr</span><span class="o">-&gt;</span><span class="n">getTarget</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">pkt</span><span class="p">;</span>
<span class="mi">1796</span> 
<span class="mi">1797</span>     <span class="n">DPRINTF</span><span class="p">(</span><span class="n">Cache</span><span class="p">,</span> <span class="s">"%s: MSHR %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">tgt_pkt</span><span class="o">-&gt;</span><span class="n">print</span><span class="p">());</span>
<span class="mi">1798</span> 
<span class="mi">1799</span>     <span class="c1">// if the cache is in write coalescing mode or (additionally) in</span>
<span class="mi">1800</span>     <span class="c1">// no allocation mode, and we have a write packet with an MSHR</span>
<span class="mi">1801</span>     <span class="c1">// that is not a whole-line write (due to incompatible flags etc),</span>
<span class="mi">1802</span>     <span class="c1">// then reset the write mode</span>
<span class="mi">1803</span>     <span class="k">if</span> <span class="p">(</span><span class="n">writeAllocator</span> <span class="o">&amp;&amp;</span> <span class="n">writeAllocator</span><span class="o">-&gt;</span><span class="n">coalesce</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">tgt_pkt</span><span class="o">-&gt;</span><span class="n">isWrite</span><span class="p">())</span> <span class="p">{</span>
<span class="mi">1804</span>         <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mshr</span><span class="o">-&gt;</span><span class="n">isWholeLineWrite</span><span class="p">())</span> <span class="p">{</span>
<span class="mi">1805</span>             <span class="c1">// if we are currently write coalescing, hold on the</span>
<span class="mi">1806</span>             <span class="c1">// MSHR as many cycles extra as we need to completely</span>
<span class="mi">1807</span>             <span class="c1">// write a cache line</span>
<span class="mi">1808</span>             <span class="k">if</span> <span class="p">(</span><span class="n">writeAllocator</span><span class="o">-&gt;</span><span class="n">delay</span><span class="p">(</span><span class="n">mshr</span><span class="o">-&gt;</span><span class="n">blkAddr</span><span class="p">))</span> <span class="p">{</span>
<span class="mi">1809</span>                 <span class="n">Tick</span> <span class="n">delay</span> <span class="o">=</span> <span class="n">blkSize</span> <span class="o">/</span> <span class="n">tgt_pkt</span><span class="o">-&gt;</span><span class="n">getSize</span><span class="p">()</span> <span class="o">*</span> <span class="n">clockPeriod</span><span class="p">();</span>
<span class="mi">1810</span>                 <span class="n">DPRINTF</span><span class="p">(</span><span class="n">CacheVerbose</span><span class="p">,</span> <span class="s">"Delaying pkt %s %llu ticks to allow "</span>
<span class="mi">1811</span>                         <span class="s">"for write coalescing</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">tgt_pkt</span><span class="o">-&gt;</span><span class="n">print</span><span class="p">(),</span> <span class="n">delay</span><span class="p">);</span>
<span class="mi">1812</span>                 <span class="n">mshrQueue</span><span class="p">.</span><span class="n">delay</span><span class="p">(</span><span class="n">mshr</span><span class="p">,</span> <span class="n">delay</span><span class="p">);</span>
<span class="mi">1813</span>                 <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="mi">1814</span>             <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="mi">1815</span>                 <span class="n">writeAllocator</span><span class="o">-&gt;</span><span class="n">reset</span><span class="p">();</span>
<span class="mi">1816</span>             <span class="p">}</span>
<span class="mi">1817</span>         <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="mi">1818</span>             <span class="n">writeAllocator</span><span class="o">-&gt;</span><span class="n">resetDelay</span><span class="p">(</span><span class="n">mshr</span><span class="o">-&gt;</span><span class="n">blkAddr</span><span class="p">);</span>
<span class="mi">1819</span>         <span class="p">}</span>
<span class="mi">1820</span>     <span class="p">}</span>
<span class="mi">1821</span> 
<span class="mi">1822</span>     <span class="n">CacheBlk</span> <span class="o">*</span><span class="n">blk</span> <span class="o">=</span> <span class="n">tags</span><span class="o">-&gt;</span><span class="n">findBlock</span><span class="p">(</span><span class="n">mshr</span><span class="o">-&gt;</span><span class="n">blkAddr</span><span class="p">,</span> <span class="n">mshr</span><span class="o">-&gt;</span><span class="n">isSecure</span><span class="p">);</span>
<span class="mi">1823</span> 
<span class="mi">1824</span>     <span class="c1">// either a prefetch that is not present upstream, or a normal</span>
<span class="mi">1825</span>     <span class="c1">// MSHR request, proceed to get the packet to send downstream</span>
<span class="mi">1826</span>     <span class="n">PacketPtr</span> <span class="n">pkt</span> <span class="o">=</span> <span class="n">createMissPacket</span><span class="p">(</span><span class="n">tgt_pkt</span><span class="p">,</span> <span class="n">blk</span><span class="p">,</span> <span class="n">mshr</span><span class="o">-&gt;</span><span class="n">needsWritable</span><span class="p">(),</span>
<span class="mi">1827</span>                                      <span class="n">mshr</span><span class="o">-&gt;</span><span class="n">isWholeLineWrite</span><span class="p">());</span>
</pre></td></tr></tbody></table></code></div></div>

<p>Note that we are currently have information about the MSHR entry 
selected based on the priority and timing. 
Therefore, the first job is find the associated cache block if exist
and generate MissPacket to send it to next level cache or memory.</p>

<h3 id="createmisspacket"><span class="me-2">createMissPacket</span><a href="#createmisspacket" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<p>Remind that we are here because of the cache miss event.
However, based on the event,
the cache miss request might be already associated with 
specific cache block.
For example, 
when the cache block is allocated and 
set as non-writable state,
the cache miss event happens and 
make the allocated block as exclusively writable.
For that purpose,
it should generate proper packet 
and send it through the XBar 
to the other components that might share the cache block.
Let’s take a look at more details.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
</pre></td><td class="rouge-code"><pre> <span class="mi">476</span> <span class="n">PacketPtr</span>
 <span class="mi">477</span> <span class="n">Cache</span><span class="o">::</span><span class="n">createMissPacket</span><span class="p">(</span><span class="n">PacketPtr</span> <span class="n">cpu_pkt</span><span class="p">,</span> <span class="n">CacheBlk</span> <span class="o">*</span><span class="n">blk</span><span class="p">,</span>
 <span class="mi">478</span>                         <span class="kt">bool</span> <span class="n">needsWritable</span><span class="p">,</span>
 <span class="mi">479</span>                         <span class="kt">bool</span> <span class="n">is_whole_line_write</span><span class="p">)</span> <span class="k">const</span>
 <span class="mi">480</span> <span class="p">{</span>
 <span class="mi">481</span>     <span class="c1">// should never see evictions here</span>
 <span class="mi">482</span>     <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">cpu_pkt</span><span class="o">-&gt;</span><span class="n">isEviction</span><span class="p">());</span>
 <span class="mi">483</span> 
 <span class="mi">484</span>     <span class="kt">bool</span> <span class="n">blkValid</span> <span class="o">=</span> <span class="n">blk</span> <span class="o">&amp;&amp;</span> <span class="n">blk</span><span class="o">-&gt;</span><span class="n">isValid</span><span class="p">();</span>
 <span class="mi">485</span> 
 <span class="mi">486</span>     <span class="k">if</span> <span class="p">(</span><span class="n">cpu_pkt</span><span class="o">-&gt;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">isUncacheable</span><span class="p">()</span> <span class="o">||</span>
 <span class="mi">487</span>         <span class="p">(</span><span class="o">!</span><span class="n">blkValid</span> <span class="o">&amp;&amp;</span> <span class="n">cpu_pkt</span><span class="o">-&gt;</span><span class="n">isUpgrade</span><span class="p">())</span> <span class="o">||</span>
 <span class="mi">488</span>         <span class="n">cpu_pkt</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">MemCmd</span><span class="o">::</span><span class="n">InvalidateReq</span> <span class="o">||</span> <span class="n">cpu_pkt</span><span class="o">-&gt;</span><span class="n">isClean</span><span class="p">())</span> <span class="p">{</span>
 <span class="mi">489</span>         <span class="c1">// uncacheable requests and upgrades from upper-level caches</span>
 <span class="mi">490</span>         <span class="c1">// that missed completely just go through as is</span>
 <span class="mi">491</span>         <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
 <span class="mi">492</span>     <span class="p">}</span>
 <span class="mi">493</span> 
 <span class="mi">494</span>     <span class="nf">assert</span><span class="p">(</span><span class="n">cpu_pkt</span><span class="o">-&gt;</span><span class="n">needsResponse</span><span class="p">());</span>
 <span class="mi">495</span> 
 <span class="mi">496</span>     <span class="n">MemCmd</span> <span class="n">cmd</span><span class="p">;</span>
 <span class="mi">497</span>     <span class="c1">// @TODO make useUpgrades a parameter.</span>
 <span class="mi">498</span>     <span class="c1">// Note that ownership protocols require upgrade, otherwise a</span>
 <span class="mi">499</span>     <span class="c1">// write miss on a shared owned block will generate a ReadExcl,</span>
 <span class="mi">500</span>     <span class="c1">// which will clobber the owned copy.</span>
 <span class="mi">501</span>     <span class="k">const</span> <span class="kt">bool</span> <span class="n">useUpgrades</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
 <span class="mi">502</span>     <span class="nf">assert</span><span class="p">(</span><span class="n">cpu_pkt</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">!=</span> <span class="n">MemCmd</span><span class="o">::</span><span class="n">WriteLineReq</span> <span class="o">||</span> <span class="n">is_whole_line_write</span><span class="p">);</span>
 <span class="mi">503</span>     <span class="nf">if</span> <span class="p">(</span><span class="n">is_whole_line_write</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">504</span>         <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">blkValid</span> <span class="o">||</span> <span class="o">!</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">isSet</span><span class="p">(</span><span class="n">CacheBlk</span><span class="o">::</span><span class="n">WritableBit</span><span class="p">));</span>
 <span class="mi">505</span>         <span class="c1">// forward as invalidate to all other caches, this gives us</span>
 <span class="mi">506</span>         <span class="c1">// the line in Exclusive state, and invalidates all other</span>
 <span class="mi">507</span>         <span class="c1">// copies</span>
 <span class="mi">508</span>         <span class="n">cmd</span> <span class="o">=</span> <span class="n">MemCmd</span><span class="o">::</span><span class="n">InvalidateReq</span><span class="p">;</span>
 <span class="mi">509</span>     <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">blkValid</span> <span class="o">&amp;&amp;</span> <span class="n">useUpgrades</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">510</span>         <span class="c1">// only reason to be here is that blk is read only and we need</span>
 <span class="mi">511</span>         <span class="c1">// it to be writable</span>
 <span class="mi">512</span>         <span class="n">assert</span><span class="p">(</span><span class="n">needsWritable</span><span class="p">);</span>
 <span class="mi">513</span>         <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">isSet</span><span class="p">(</span><span class="n">CacheBlk</span><span class="o">::</span><span class="n">WritableBit</span><span class="p">));</span>
 <span class="mi">514</span>         <span class="n">cmd</span> <span class="o">=</span> <span class="n">cpu_pkt</span><span class="o">-&gt;</span><span class="n">isLLSC</span><span class="p">()</span> <span class="o">?</span> <span class="n">MemCmd</span><span class="o">::</span><span class="n">SCUpgradeReq</span> <span class="o">:</span> <span class="n">MemCmd</span><span class="o">::</span><span class="n">UpgradeReq</span><span class="p">;</span>
 <span class="mi">515</span>     <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">cpu_pkt</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">MemCmd</span><span class="o">::</span><span class="n">SCUpgradeFailReq</span> <span class="o">||</span>
 <span class="mi">516</span>                <span class="n">cpu_pkt</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">MemCmd</span><span class="o">::</span><span class="n">StoreCondFailReq</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">517</span>         <span class="c1">// Even though this SC will fail, we still need to send out the</span>
 <span class="mi">518</span>         <span class="c1">// request and get the data to supply it to other snoopers in the case</span>
 <span class="mi">519</span>         <span class="c1">// where the determination the StoreCond fails is delayed due to</span>
 <span class="mi">520</span>         <span class="c1">// all caches not being on the same local bus.</span>
 <span class="mi">521</span>         <span class="n">cmd</span> <span class="o">=</span> <span class="n">MemCmd</span><span class="o">::</span><span class="n">SCUpgradeFailReq</span><span class="p">;</span>
 <span class="mi">522</span>     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
 <span class="mi">523</span>         <span class="c1">// block is invalid</span>
 <span class="mi">524</span> 
 <span class="mi">525</span>         <span class="c1">// If the request does not need a writable there are two cases</span>
 <span class="mi">526</span>         <span class="c1">// where we need to ensure the response will not fetch the</span>
 <span class="mi">527</span>         <span class="c1">// block in dirty state:</span>
 <span class="mi">528</span>         <span class="c1">// * this cache is read only and it does not perform</span>
 <span class="mi">529</span>         <span class="c1">//   writebacks,</span>
 <span class="mi">530</span>         <span class="c1">// * this cache is mostly exclusive and will not fill (since</span>
 <span class="mi">531</span>         <span class="c1">//   it does not fill it will have to writeback the dirty data</span>
 <span class="mi">532</span>         <span class="c1">//   immediately which generates uneccesary writebacks).</span>
 <span class="mi">533</span>         <span class="kt">bool</span> <span class="n">force_clean_rsp</span> <span class="o">=</span> <span class="n">isReadOnly</span> <span class="o">||</span> <span class="n">clusivity</span> <span class="o">==</span> <span class="n">enums</span><span class="o">::</span><span class="n">mostly_excl</span><span class="p">;</span>
 <span class="mi">534</span>         <span class="n">cmd</span> <span class="o">=</span> <span class="n">needsWritable</span> <span class="o">?</span> <span class="n">MemCmd</span><span class="o">::</span><span class="n">ReadExReq</span> <span class="o">:</span>
 <span class="mi">535</span>             <span class="p">(</span><span class="n">force_clean_rsp</span> <span class="o">?</span> <span class="n">MemCmd</span><span class="o">::</span><span class="n">ReadCleanReq</span> <span class="o">:</span> <span class="n">MemCmd</span><span class="o">::</span><span class="n">ReadSharedReq</span><span class="p">);</span>
 <span class="mi">536</span>     <span class="p">}</span>
 <span class="mi">537</span>     <span class="n">PacketPtr</span> <span class="n">pkt</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Packet</span><span class="p">(</span><span class="n">cpu_pkt</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">blkSize</span><span class="p">);</span>
 <span class="mi">538</span> 
 <span class="mi">539</span>     <span class="c1">// if there are upstream caches that have already marked the</span>
 <span class="mi">540</span>     <span class="c1">// packet as having sharers (not passing writable), pass that info</span>
 <span class="mi">541</span>     <span class="c1">// downstream</span>
 <span class="mi">542</span>     <span class="nf">if</span> <span class="p">(</span><span class="n">cpu_pkt</span><span class="o">-&gt;</span><span class="n">hasSharers</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">needsWritable</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">543</span>         <span class="c1">// note that cpu_pkt may have spent a considerable time in the</span>
 <span class="mi">544</span>         <span class="c1">// MSHR queue and that the information could possibly be out</span>
 <span class="mi">545</span>         <span class="c1">// of date, however, there is no harm in conservatively</span>
 <span class="mi">546</span>         <span class="c1">// assuming the block has sharers</span>
 <span class="mi">547</span>         <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">setHasSharers</span><span class="p">();</span>
 <span class="mi">548</span>         <span class="n">DPRINTF</span><span class="p">(</span><span class="n">Cache</span><span class="p">,</span> <span class="s">"%s: passing hasSharers from %s to %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
 <span class="mi">549</span>                 <span class="n">__func__</span><span class="p">,</span> <span class="n">cpu_pkt</span><span class="o">-&gt;</span><span class="n">print</span><span class="p">(),</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">print</span><span class="p">());</span>
 <span class="mi">550</span>     <span class="p">}</span>
 <span class="mi">551</span> 
 <span class="mi">552</span>     <span class="c1">// the packet should be block aligned</span>
 <span class="mi">553</span>     <span class="nf">assert</span><span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">getAddr</span><span class="p">()</span> <span class="o">==</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">getBlockAddr</span><span class="p">(</span><span class="n">blkSize</span><span class="p">));</span>
 <span class="mi">554</span> 
 <span class="mi">555</span>     <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">allocate</span><span class="p">();</span>
 <span class="mi">556</span>     <span class="nf">DPRINTF</span><span class="p">(</span><span class="n">Cache</span><span class="p">,</span> <span class="s">"%s: created %s from %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">print</span><span class="p">(),</span>
 <span class="mi">557</span>             <span class="n">cpu_pkt</span><span class="o">-&gt;</span><span class="n">print</span><span class="p">());</span>
 <span class="mi">558</span>     <span class="k">return</span> <span class="n">pkt</span><span class="p">;</span>
 <span class="mi">559</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>Most of the time the else condition will be excuted 
and the ReadExReq packet will be generated 
for the cache miss event caused by read operation.</p>

<h3 id="sending-miss-packet-"><span class="me-2">Sending miss packet !</span><a href="#sending-miss-packet-" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
</pre></td><td class="rouge-code"><pre><span class="mi">1789</span> <span class="kt">bool</span>
<span class="mi">1790</span> <span class="n">BaseCache</span><span class="o">::</span><span class="n">sendMSHRQueuePacket</span><span class="p">(</span><span class="n">MSHR</span><span class="o">*</span> <span class="n">mshr</span><span class="p">)</span>
<span class="mi">1791</span> <span class="p">{</span>
<span class="p">......</span>
<span class="mi">1829</span>     <span class="n">mshr</span><span class="o">-&gt;</span><span class="n">isForward</span> <span class="o">=</span> <span class="p">(</span><span class="n">pkt</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">);</span>
<span class="mi">1830</span> 
<span class="mi">1831</span>     <span class="k">if</span> <span class="p">(</span><span class="n">mshr</span><span class="o">-&gt;</span><span class="n">isForward</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1832</span>         <span class="c1">// not a cache block request, but a response is expected</span>
<span class="mi">1833</span>         <span class="c1">// make copy of current packet to forward, keep current</span>
<span class="mi">1834</span>         <span class="c1">// copy for response handling</span>
<span class="mi">1835</span>         <span class="n">pkt</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Packet</span><span class="p">(</span><span class="n">tgt_pkt</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="mi">1836</span>         <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">isWrite</span><span class="p">());</span>
<span class="mi">1837</span>     <span class="p">}</span>
<span class="mi">1838</span> 
<span class="mi">1839</span>     <span class="c1">// play it safe and append (rather than set) the sender state,</span>
<span class="mi">1840</span>     <span class="c1">// as forwarded packets may already have existing state</span>
<span class="mi">1841</span>     <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">pushSenderState</span><span class="p">(</span><span class="n">mshr</span><span class="p">);</span>
<span class="mi">1842</span> 
<span class="mi">1843</span>     <span class="nf">if</span> <span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">isClean</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">blk</span> <span class="o">&amp;&amp;</span> <span class="n">blk</span><span class="o">-&gt;</span><span class="n">isSet</span><span class="p">(</span><span class="n">CacheBlk</span><span class="o">::</span><span class="n">DirtyBit</span><span class="p">))</span> <span class="p">{</span>
<span class="mi">1844</span>         <span class="c1">// A cache clean opearation is looking for a dirty block. Mark</span>
<span class="mi">1845</span>         <span class="c1">// the packet so that the destination xbar can determine that</span>
<span class="mi">1846</span>         <span class="c1">// there will be a follow-up write packet as well.</span>
<span class="mi">1847</span>         <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">setSatisfied</span><span class="p">();</span>
<span class="mi">1848</span>     <span class="p">}</span>
<span class="mi">1849</span> 
<span class="mi">1850</span>     <span class="nf">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memSidePort</span><span class="p">.</span><span class="n">sendTimingReq</span><span class="p">(</span><span class="n">pkt</span><span class="p">))</span> <span class="p">{</span>
<span class="mi">1851</span>         <span class="c1">// we are awaiting a retry, but we</span>
<span class="mi">1852</span>         <span class="c1">// delete the packet and will be creating a new packet</span>
<span class="mi">1853</span>         <span class="c1">// when we get the opportunity</span>
<span class="mi">1854</span>         <span class="k">delete</span> <span class="n">pkt</span><span class="p">;</span>
<span class="mi">1855</span> 
<span class="mi">1856</span>         <span class="c1">// note that we have now masked any requestBus and</span>
<span class="mi">1857</span>         <span class="c1">// schedSendEvent (we will wait for a retry before</span>
<span class="mi">1858</span>         <span class="c1">// doing anything), and this is so even if we do not</span>
<span class="mi">1859</span>         <span class="c1">// care about this packet and might override it before</span>
<span class="mi">1860</span>         <span class="c1">// it gets retried</span>
<span class="mi">1861</span>         <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="mi">1862</span>     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="mi">1863</span>         <span class="c1">// As part of the call to sendTimingReq the packet is</span>
<span class="mi">1864</span>         <span class="c1">// forwarded to all neighbouring caches (and any caches</span>
<span class="mi">1865</span>         <span class="c1">// above them) as a snoop. Thus at this point we know if</span>
<span class="mi">1866</span>         <span class="c1">// any of the neighbouring caches are responding, and if</span>
<span class="mi">1867</span>         <span class="c1">// so, we know it is dirty, and we can determine if it is</span>
<span class="mi">1868</span>         <span class="c1">// being passed as Modified, making our MSHR the ordering</span>
<span class="mi">1869</span>         <span class="c1">// point</span>
<span class="mi">1870</span>         <span class="kt">bool</span> <span class="n">pending_modified_resp</span> <span class="o">=</span> <span class="o">!</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">hasSharers</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
<span class="mi">1871</span>             <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">cacheResponding</span><span class="p">();</span>
<span class="mi">1872</span>         <span class="n">markInService</span><span class="p">(</span><span class="n">mshr</span><span class="p">,</span> <span class="n">pending_modified_resp</span><span class="p">);</span>
<span class="mi">1873</span> 
<span class="mi">1874</span>         <span class="k">if</span> <span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">isClean</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">blk</span> <span class="o">&amp;&amp;</span> <span class="n">blk</span><span class="o">-&gt;</span><span class="n">isSet</span><span class="p">(</span><span class="n">CacheBlk</span><span class="o">::</span><span class="n">DirtyBit</span><span class="p">))</span> <span class="p">{</span>
<span class="mi">1875</span>             <span class="c1">// A cache clean opearation is looking for a dirty</span>
<span class="mi">1876</span>             <span class="c1">// block. If a dirty block is encountered a WriteClean</span>
<span class="mi">1877</span>             <span class="c1">// will update any copies to the path to the memory</span>
<span class="mi">1878</span>             <span class="c1">// until the point of reference.</span>
<span class="mi">1879</span>             <span class="n">DPRINTF</span><span class="p">(</span><span class="n">CacheVerbose</span><span class="p">,</span> <span class="s">"%s: packet %s found block: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
<span class="mi">1880</span>                     <span class="n">__func__</span><span class="p">,</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">print</span><span class="p">(),</span> <span class="n">blk</span><span class="o">-&gt;</span><span class="n">print</span><span class="p">());</span>
<span class="mi">1881</span>             <span class="n">PacketPtr</span> <span class="n">wb_pkt</span> <span class="o">=</span> <span class="n">writecleanBlk</span><span class="p">(</span><span class="n">blk</span><span class="p">,</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">getDest</span><span class="p">(),</span>
<span class="mi">1882</span>                                              <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
<span class="mi">1883</span>             <span class="n">PacketList</span> <span class="n">writebacks</span><span class="p">;</span>
<span class="mi">1884</span>             <span class="n">writebacks</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">wb_pkt</span><span class="p">);</span>
<span class="mi">1885</span>             <span class="n">doWritebacks</span><span class="p">(</span><span class="n">writebacks</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="mi">1886</span>         <span class="p">}</span>
<span class="mi">1887</span> 
<span class="mi">1888</span>         <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="mi">1889</span>     <span class="p">}</span>
<span class="mi">1890</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<h1 id="end-of-the-recvtimingreq-of-the-cache">end of the recvTimingReq of the cache.</h1>

<h1 id="two-ports-in-the-cache">Two ports in the cache</h1>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre>  <span class="mi">92</span> <span class="cm">/**
  93  * A basic cache interface. Implements some common functions for speed.
  94  */</span>
  <span class="mi">95</span> <span class="k">class</span> <span class="nc">BaseCache</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ClockedObject</span>
  <span class="mi">96</span> <span class="p">{</span>
<span class="p">......</span>
 <span class="mi">338</span>     <span class="n">CpuSidePort</span> <span class="n">cpuSidePort</span><span class="p">;</span>
 <span class="mi">339</span>     <span class="n">MemSidePort</span> <span class="n">memSidePort</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></div></div>

<h2 id="cpusideport-receive-request-from-the-processor-and-send-response"><span class="me-2">CpuSidePort: receive request from the processor and send response</span><a href="#cpusideport-receive-request-from-the-processor-and-send-response" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="rouge-code"><pre> <span class="mi">307</span>     <span class="cm">/**
 308      * The CPU-side port extends the base cache response port with access
 309      * functions for functional, atomic and timing requests.
 310      */</span>
 <span class="mi">311</span>     <span class="k">class</span> <span class="nc">CpuSidePort</span> <span class="o">:</span> <span class="k">public</span> <span class="n">CacheResponsePort</span>
 <span class="mi">312</span>     <span class="p">{</span>
 <span class="mi">313</span>       <span class="k">private</span><span class="o">:</span>
 <span class="mi">314</span> 
 <span class="mi">315</span>         <span class="c1">// a pointer to our specific cache implementation</span>
 <span class="mi">316</span>         <span class="n">BaseCache</span> <span class="o">*</span><span class="n">cache</span><span class="p">;</span>
 <span class="mi">317</span> 
 <span class="mi">318</span>       <span class="k">protected</span><span class="o">:</span>
 <span class="mi">319</span>         <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">recvTimingSnoopResp</span><span class="p">(</span><span class="n">PacketPtr</span> <span class="n">pkt</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
 <span class="mi">320</span> 
 <span class="mi">321</span>         <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">tryTiming</span><span class="p">(</span><span class="n">PacketPtr</span> <span class="n">pkt</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
 <span class="mi">322</span> 
 <span class="mi">323</span>         <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">recvTimingReq</span><span class="p">(</span><span class="n">PacketPtr</span> <span class="n">pkt</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
 <span class="mi">324</span> 
 <span class="mi">325</span>         <span class="k">virtual</span> <span class="n">Tick</span> <span class="n">recvAtomic</span><span class="p">(</span><span class="n">PacketPtr</span> <span class="n">pkt</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
 <span class="mi">326</span> 
 <span class="mi">327</span>         <span class="k">virtual</span> <span class="kt">void</span> <span class="n">recvFunctional</span><span class="p">(</span><span class="n">PacketPtr</span> <span class="n">pkt</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
 <span class="mi">328</span> 
 <span class="mi">329</span>         <span class="k">virtual</span> <span class="n">AddrRangeList</span> <span class="n">getAddrRanges</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
 <span class="mi">330</span> 
 <span class="mi">331</span>       <span class="k">public</span><span class="o">:</span>
 <span class="mi">332</span> 
 <span class="mi">333</span>         <span class="n">CpuSidePort</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">_name</span><span class="p">,</span> <span class="n">BaseCache</span> <span class="o">*</span><span class="n">_cache</span><span class="p">,</span>
 <span class="mi">334</span>                     <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">_label</span><span class="p">);</span>
 <span class="mi">335</span> 
 <span class="mi">336</span>     <span class="p">};</span>
 <span class="mi">337</span> 
</pre></td></tr></tbody></table></code></div></div>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre>  <span class="mi">79</span> <span class="n">BaseCache</span><span class="o">::</span><span class="n">BaseCache</span><span class="p">(</span><span class="k">const</span> <span class="n">BaseCacheParams</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">blk_size</span><span class="p">)</span>
  <span class="mi">80</span>     <span class="o">:</span> <span class="n">ClockedObject</span><span class="p">(</span><span class="n">p</span><span class="p">),</span>
  <span class="mi">81</span>       <span class="n">cpuSidePort</span> <span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">name</span> <span class="o">+</span> <span class="s">".cpu_side_port"</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="s">"CpuSidePort"</span><span class="p">),</span>
  <span class="mi">82</span>       <span class="n">memSidePort</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">name</span> <span class="o">+</span> <span class="s">".mem_side_port"</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="s">"MemSidePort"</span><span class="p">),</span>
  <span class="mi">83</span>       <span class="n">mshrQueue</span><span class="p">(</span><span class="s">"MSHRs"</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">mshrs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">demand_mshr_reserve</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">name</span><span class="p">),</span>
  <span class="mi">84</span>       <span class="n">writeBuffer</span><span class="p">(</span><span class="s">"write buffer"</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">write_buffers</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">mshrs</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">name</span><span class="p">),</span>
</pre></td></tr></tbody></table></code></div></div>
<p>cpuSidePort is a member field of the BaseCache, but it has cache member field
which is a pointer to the BaseCache.
Note that this field is initialized as pointing to the BaseCache itself 
that embeds the cpuSidePort.
Also, it has recvTimingReq function that will be invoked 
when the processor tries to send request to the cache.</p>

<h3 id="cacheresponseport"><span class="me-2">CacheResponsePort</span><a href="#cacheresponseport" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre></td><td class="rouge-code"><pre> <span class="mi">266</span>     <span class="cm">/**
 267      * A cache response port is used for the CPU-side port of the cache,
 268      * and it is basically a simple timing port that uses a transmit
 269      * list for responses to the CPU (or connected requestor). In
 270      * addition, it has the functionality to block the port for
 271      * incoming requests. If blocked, the port will issue a retry once
 272      * unblocked.
 273      */</span>
 <span class="mi">274</span>     <span class="k">class</span> <span class="nc">CacheResponsePort</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QueuedResponsePort</span>
 <span class="mi">275</span>     <span class="p">{</span>
 <span class="mi">276</span> 
 <span class="mi">277</span>       <span class="k">public</span><span class="o">:</span>
 <span class="mi">278</span> 
 <span class="mi">279</span>         <span class="cm">/** Do not accept any new requests. */</span>
 <span class="mi">280</span>         <span class="kt">void</span> <span class="n">setBlocked</span><span class="p">();</span>
 <span class="mi">281</span> 
 <span class="mi">282</span>         <span class="cm">/** Return to normal operation and accept new requests. */</span>
 <span class="mi">283</span>         <span class="kt">void</span> <span class="n">clearBlocked</span><span class="p">();</span>
 <span class="mi">284</span> 
 <span class="mi">285</span>         <span class="kt">bool</span> <span class="n">isBlocked</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">blocked</span><span class="p">;</span> <span class="p">}</span>
 <span class="mi">286</span> 
 <span class="mi">287</span>       <span class="k">protected</span><span class="o">:</span>
 <span class="mi">288</span> 
 <span class="mi">289</span>         <span class="nf">CacheResponsePort</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">_name</span><span class="p">,</span> <span class="n">BaseCache</span> <span class="o">*</span><span class="n">_cache</span><span class="p">,</span>
 <span class="mi">290</span>                        <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">_label</span><span class="p">);</span>
 <span class="mi">291</span> 
 <span class="mi">292</span>         <span class="cm">/** A normal packet queue used to store responses. */</span>
 <span class="mi">293</span>         <span class="n">RespPacketQueue</span> <span class="n">queue</span><span class="p">;</span>
 <span class="mi">294</span> 
 <span class="mi">295</span>         <span class="kt">bool</span> <span class="n">blocked</span><span class="p">;</span>
 <span class="mi">296</span> 
 <span class="mi">297</span>         <span class="kt">bool</span> <span class="n">mustSendRetry</span><span class="p">;</span>
 <span class="mi">298</span> 
 <span class="mi">299</span>       <span class="k">private</span><span class="o">:</span>
 <span class="mi">300</span> 
 <span class="mi">301</span>         <span class="kt">void</span> <span class="nf">processSendRetry</span><span class="p">();</span>
 <span class="mi">302</span> 
 <span class="mi">303</span>         <span class="n">EventFunctionWrapper</span> <span class="n">sendRetryEvent</span><span class="p">;</span>
 <span class="mi">304</span> 
 <span class="mi">305</span>     <span class="p">};</span>
</pre></td></tr></tbody></table></code></div></div>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre>  <span class="mi">69</span> <span class="n">BaseCache</span><span class="o">::</span><span class="n">CacheResponsePort</span><span class="o">::</span><span class="n">CacheResponsePort</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">_name</span><span class="p">,</span>
  <span class="mi">70</span>                                           <span class="n">BaseCache</span> <span class="o">*</span><span class="n">_cache</span><span class="p">,</span>
  <span class="mi">71</span>                                           <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">_label</span><span class="p">)</span>
  <span class="mi">72</span>     <span class="o">:</span> <span class="n">QueuedResponsePort</span><span class="p">(</span><span class="n">_name</span><span class="p">,</span> <span class="n">_cache</span><span class="p">,</span> <span class="n">queue</span><span class="p">),</span>
  <span class="mi">73</span>       <span class="nf">queue</span><span class="p">(</span><span class="o">*</span><span class="n">_cache</span><span class="p">,</span> <span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="n">_label</span><span class="p">),</span>
  <span class="mi">74</span>       <span class="n">blocked</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span> <span class="n">mustSendRetry</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span>
  <span class="mi">75</span>       <span class="n">sendRetryEvent</span><span class="p">([</span><span class="k">this</span><span class="p">]{</span> <span class="n">processSendRetry</span><span class="p">();</span> <span class="p">},</span> <span class="n">_name</span><span class="p">)</span>
  <span class="mi">76</span> <span class="p">{</span>
  <span class="mi">77</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>The CpuSidePort class inherits the CacheResponsePort. 
The main functionality of the CacheResponsePort is allowing the port 
to be blocked while it is busy to process previous packets.</p>

<h3 id="queuedresponseport"><span class="me-2">QueuedResponsePort</span><a href="#queuedresponseport" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre></td><td class="rouge-code"><pre> <span class="mi">53</span> <span class="cm">/**
 54  * A queued port is a port that has an infinite queue for outgoing
 55  * packets and thus decouples the module that wants to send
 56  * request/responses from the flow control (retry mechanism) of the
 57  * port. A queued port can be used by both a requestor and a responder. The
 58  * queue is a parameter to allow tailoring of the queue implementation
 59  * (used in the cache).
 60  */</span>      
 <span class="mi">61</span> <span class="k">class</span> <span class="nc">QueuedResponsePort</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ResponsePort</span>
 <span class="mi">62</span> <span class="p">{</span>      
 <span class="mi">63</span> 
 <span class="mi">64</span>   <span class="k">protected</span><span class="o">:</span>
 <span class="mi">65</span> 
 <span class="mi">66</span>     <span class="cm">/** Packet queue used to store outgoing responses. */</span>
 <span class="mi">67</span>     <span class="n">RespPacketQueue</span> <span class="o">&amp;</span><span class="n">respQueue</span><span class="p">;</span>
 <span class="mi">68</span> 
 <span class="mi">69</span>     <span class="kt">void</span> <span class="n">recvRespRetry</span><span class="p">()</span> <span class="p">{</span> <span class="n">respQueue</span><span class="p">.</span><span class="n">retry</span><span class="p">();</span> <span class="p">}</span>
 <span class="mi">70</span> 
 <span class="mi">71</span>   <span class="k">public</span><span class="o">:</span>
 <span class="mi">72</span> 
 <span class="mi">73</span>     <span class="cm">/**
 74      * Create a QueuedPort with a given name, owner, and a supplied
 75      * implementation of a packet queue. The external definition of
 76      * the queue enables e.g. the cache to implement a specific queue
 77      * behaviuor in a subclass, and provide the latter to the
 78      * QueuePort constructor. 
 79      */</span>
 <span class="mi">80</span>     <span class="nf">QueuedResponsePort</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="n">SimObject</span><span class="o">*</span> <span class="n">owner</span><span class="p">,</span>
 <span class="mi">81</span>                     <span class="n">RespPacketQueue</span> <span class="o">&amp;</span><span class="n">resp_queue</span><span class="p">,</span> <span class="n">PortID</span> <span class="n">id</span> <span class="o">=</span> <span class="n">InvalidPortID</span><span class="p">)</span> <span class="o">:</span>
 <span class="mi">82</span>         <span class="n">ResponsePort</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">owner</span><span class="p">,</span> <span class="n">id</span><span class="p">),</span> <span class="n">respQueue</span><span class="p">(</span><span class="n">resp_queue</span><span class="p">)</span>
 <span class="mi">83</span>     <span class="p">{</span> <span class="p">}</span>
 <span class="mi">84</span> 
 <span class="mi">85</span>     <span class="k">virtual</span> <span class="o">~</span><span class="n">QueuedResponsePort</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
 <span class="mi">86</span> 
 <span class="mi">87</span>     <span class="cm">/**
 88      * Schedule the sending of a timing response.
 89      *
 90      * @param pkt Packet to send
 91      * @param when Absolute time (in ticks) to send packet
 92      */</span>
 <span class="mi">93</span>     <span class="kt">void</span> <span class="nf">schedTimingResp</span><span class="p">(</span><span class="n">PacketPtr</span> <span class="n">pkt</span><span class="p">,</span> <span class="n">Tick</span> <span class="n">when</span><span class="p">)</span>
 <span class="mi">94</span>     <span class="p">{</span> <span class="n">respQueue</span><span class="p">.</span><span class="n">schedSendTiming</span><span class="p">(</span><span class="n">pkt</span><span class="p">,</span> <span class="n">when</span><span class="p">);</span> <span class="p">}</span>
 <span class="mi">95</span> 
 <span class="mi">96</span>     <span class="cm">/** Check the list of buffered packets against the supplied
 97      * functional request. */</span>
 <span class="mi">98</span>     <span class="kt">bool</span> <span class="nf">trySatisfyFunctional</span><span class="p">(</span><span class="n">PacketPtr</span> <span class="n">pkt</span><span class="p">)</span>
 <span class="mi">99</span>     <span class="p">{</span> <span class="k">return</span> <span class="n">respQueue</span><span class="p">.</span><span class="n">trySatisfyFunctional</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span> <span class="p">}</span>
<span class="mi">100</span> <span class="p">};</span>
</pre></td></tr></tbody></table></code></div></div>

<h3 id="responseport"><span class="me-2">ResponsePort</span><a href="#responseport" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
</pre></td><td class="rouge-code"><pre><span class="mi">259</span> <span class="cm">/**
260  * A ResponsePort is a specialization of a port. In addition to the
261  * basic functionality of sending packets to its requestor peer, it also
262  * has functions specific to a responder, e.g. to send range changes
263  * and get the address ranges that the port responds to.
264  *
265  * The three protocols are atomic, timing, and functional, each with its own
266  * header file.
267  */</span>
<span class="mi">268</span> <span class="k">class</span> <span class="nc">ResponsePort</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Port</span><span class="p">,</span> <span class="k">public</span> <span class="n">AtomicResponseProtocol</span><span class="p">,</span>
<span class="mi">269</span>     <span class="k">public</span> <span class="n">TimingResponseProtocol</span><span class="p">,</span> <span class="k">public</span> <span class="n">FunctionalResponseProtocol</span>
<span class="mi">270</span> <span class="p">{</span>
<span class="mi">271</span>     <span class="k">friend</span> <span class="k">class</span> <span class="nc">RequestPort</span><span class="p">;</span>
<span class="mi">272</span> 
<span class="mi">273</span>   <span class="k">private</span><span class="o">:</span>
<span class="mi">274</span>     <span class="n">RequestPort</span><span class="o">*</span> <span class="n">_requestPort</span><span class="p">;</span>
<span class="mi">275</span> 
<span class="mi">276</span>     <span class="kt">bool</span> <span class="n">defaultBackdoorWarned</span><span class="p">;</span>
<span class="mi">277</span> 
<span class="mi">278</span>   <span class="k">protected</span><span class="o">:</span>
<span class="mi">279</span>     <span class="n">SimObject</span><span class="o">&amp;</span> <span class="n">owner</span><span class="p">;</span>
<span class="mi">280</span> 
<span class="mi">281</span>   <span class="k">public</span><span class="o">:</span>
<span class="mi">282</span>     <span class="n">ResponsePort</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="n">SimObject</span><span class="o">*</span> <span class="n">_owner</span><span class="p">,</span>
<span class="mi">283</span>               <span class="n">PortID</span> <span class="n">id</span><span class="o">=</span><span class="n">InvalidPortID</span><span class="p">);</span>
<span class="mi">284</span>     <span class="k">virtual</span> <span class="o">~</span><span class="n">ResponsePort</span><span class="p">();</span>
<span class="mi">285</span> 
<span class="mi">286</span>     <span class="cm">/**
287      * Find out if the peer request port is snooping or not.
288      *
289      * @return true if the peer request port is snooping
290      */</span>
<span class="mi">291</span>     <span class="kt">bool</span> <span class="n">isSnooping</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_requestPort</span><span class="o">-&gt;</span><span class="n">isSnooping</span><span class="p">();</span> <span class="p">}</span>
<span class="mi">292</span> 
<span class="mi">293</span>     <span class="cm">/**
294      * Called by the owner to send a range change
295      */</span>
<span class="mi">296</span>     <span class="kt">void</span> <span class="nf">sendRangeChange</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="n">_requestPort</span><span class="o">-&gt;</span><span class="n">recvRangeChange</span><span class="p">();</span> <span class="p">}</span>
<span class="mi">297</span> 
<span class="mi">298</span>     <span class="cm">/**
299      * Get a list of the non-overlapping address ranges the owner is
300      * responsible for. All response ports must override this function
301      * and return a populated list with at least one item.
302      *
303      * @return a list of ranges responded to
304      */</span>
<span class="mi">305</span>     <span class="k">virtual</span> <span class="n">AddrRangeList</span> <span class="n">getAddrRanges</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="mi">306</span> 
<span class="mi">307</span>     <span class="cm">/**
308      * We let the request port do the work, so these don't do anything.
309      */</span>
<span class="mi">310</span>     <span class="kt">void</span> <span class="nf">unbind</span><span class="p">()</span> <span class="k">override</span> <span class="p">{}</span>
<span class="mi">311</span>     <span class="kt">void</span> <span class="n">bind</span><span class="p">(</span><span class="n">Port</span> <span class="o">&amp;</span><span class="n">peer</span><span class="p">)</span> <span class="k">override</span> <span class="p">{}</span>
<span class="mi">312</span> 
<span class="mi">313</span>   <span class="k">public</span><span class="o">:</span>
<span class="mi">314</span>     <span class="cm">/* The atomic protocol. */</span>
<span class="mi">315</span> 
<span class="mi">316</span>     <span class="cm">/**
317      * Send an atomic snoop request packet, where the data is moved
318      * and the state is updated in zero time, without interleaving
319      * with other memory accesses.
320      *
321      * @param pkt Snoop packet to send.
322      *
323      * @return Estimated latency of access.
324      */</span>
<span class="mi">325</span>     <span class="n">Tick</span>
<span class="mi">326</span>     <span class="n">sendAtomicSnoop</span><span class="p">(</span><span class="n">PacketPtr</span> <span class="n">pkt</span><span class="p">)</span>
<span class="mi">327</span>     <span class="p">{</span>
<span class="mi">328</span>         <span class="k">try</span> <span class="p">{</span>
<span class="mi">329</span>             <span class="k">return</span> <span class="n">AtomicResponseProtocol</span><span class="o">::</span><span class="n">sendSnoop</span><span class="p">(</span><span class="n">_requestPort</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
<span class="mi">330</span>         <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">UnboundPortException</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">331</span>             <span class="n">reportUnbound</span><span class="p">();</span>
<span class="mi">332</span>         <span class="p">}</span>
<span class="mi">333</span>     <span class="p">}</span>
<span class="mi">334</span> 
<span class="mi">335</span>   <span class="k">public</span><span class="o">:</span>
<span class="mi">336</span>     <span class="cm">/* The functional protocol. */</span>
<span class="mi">337</span> 
<span class="mi">338</span>     <span class="cm">/**
339      * Send a functional snoop request packet, where the data is
340      * instantly updated everywhere in the memory system, without
341      * affecting the current state of any block or moving the block.
342      *
343      * @param pkt Snoop packet to send.
344      */</span>
<span class="mi">345</span>     <span class="kt">void</span>
<span class="mi">346</span>     <span class="nf">sendFunctionalSnoop</span><span class="p">(</span><span class="n">PacketPtr</span> <span class="n">pkt</span><span class="p">)</span> <span class="k">const</span>
<span class="mi">347</span>     <span class="p">{</span>
<span class="mi">348</span>         <span class="k">try</span> <span class="p">{</span>
<span class="mi">349</span>             <span class="n">FunctionalResponseProtocol</span><span class="o">::</span><span class="n">sendSnoop</span><span class="p">(</span><span class="n">_requestPort</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
<span class="mi">350</span>         <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">UnboundPortException</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">351</span>             <span class="n">reportUnbound</span><span class="p">();</span>
<span class="mi">352</span>         <span class="p">}</span>
<span class="mi">353</span>     <span class="p">}</span>
<span class="mi">354</span> 
<span class="mi">355</span>   <span class="k">public</span><span class="o">:</span>
<span class="mi">356</span>     <span class="cm">/* The timing protocol. */</span>
<span class="mi">357</span> 
<span class="mi">358</span>     <span class="cm">/**
359      * Attempt to send a timing response to the request port by calling
360      * its corresponding receive function. If the send does not
361      * succeed, as indicated by the return value, then the sender must
362      * wait for a recvRespRetry at which point it can re-issue a
363      * sendTimingResp.
364      *
365      * @param pkt Packet to send.
366      *
367      * @return If the send was successful or not.
368     */</span>
<span class="mi">369</span>     <span class="kt">bool</span>
<span class="mi">370</span>     <span class="nf">sendTimingResp</span><span class="p">(</span><span class="n">PacketPtr</span> <span class="n">pkt</span><span class="p">)</span>
<span class="mi">371</span>     <span class="p">{</span>
<span class="mi">372</span>         <span class="k">try</span> <span class="p">{</span>
<span class="mi">373</span>             <span class="k">return</span> <span class="n">TimingResponseProtocol</span><span class="o">::</span><span class="n">sendResp</span><span class="p">(</span><span class="n">_requestPort</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
<span class="mi">374</span>         <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">UnboundPortException</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">375</span>             <span class="n">reportUnbound</span><span class="p">();</span>
<span class="mi">376</span>         <span class="p">}</span>
<span class="mi">377</span>     <span class="p">}</span>
<span class="mi">378</span> 
<span class="mi">379</span>     <span class="cm">/**
380      * Attempt to send a timing snoop request packet to the request port
381      * by calling its corresponding receive function. Snoop requests
382      * always succeed and hence no return value is needed.
383      *
384      * @param pkt Packet to send.
385      */</span>
<span class="mi">386</span>     <span class="kt">void</span>
<span class="mi">387</span>     <span class="nf">sendTimingSnoopReq</span><span class="p">(</span><span class="n">PacketPtr</span> <span class="n">pkt</span><span class="p">)</span>
<span class="mi">388</span>     <span class="p">{</span>
<span class="mi">389</span>         <span class="k">try</span> <span class="p">{</span>
<span class="mi">390</span>             <span class="n">TimingResponseProtocol</span><span class="o">::</span><span class="n">sendSnoopReq</span><span class="p">(</span><span class="n">_requestPort</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
<span class="mi">391</span>         <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">UnboundPortException</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">392</span>             <span class="n">reportUnbound</span><span class="p">();</span>
<span class="mi">393</span>         <span class="p">}</span>
<span class="mi">394</span>     <span class="p">}</span>
<span class="mi">395</span> 
<span class="mi">396</span>     <span class="cm">/**
397      * Send a retry to the request port that previously attempted a
398      * sendTimingReq to this response port and failed.
399      */</span>
<span class="mi">400</span>     <span class="kt">void</span>
<span class="mi">401</span>     <span class="nf">sendRetryReq</span><span class="p">()</span>
<span class="mi">402</span>     <span class="p">{</span>
<span class="mi">403</span>         <span class="k">try</span> <span class="p">{</span>
<span class="mi">404</span>             <span class="n">TimingResponseProtocol</span><span class="o">::</span><span class="n">sendRetryReq</span><span class="p">(</span><span class="n">_requestPort</span><span class="p">);</span>
<span class="mi">405</span>         <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">UnboundPortException</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">406</span>             <span class="n">reportUnbound</span><span class="p">();</span>
<span class="mi">407</span>         <span class="p">}</span>
<span class="mi">408</span>     <span class="p">}</span>
<span class="mi">409</span> 
<span class="mi">410</span>     <span class="cm">/**
411      * Send a retry to the request port that previously attempted a
412      * sendTimingSnoopResp to this response port and failed.
413      */</span>
<span class="mi">414</span>     <span class="kt">void</span>
<span class="mi">415</span>     <span class="nf">sendRetrySnoopResp</span><span class="p">()</span>
<span class="mi">416</span>     <span class="p">{</span>
<span class="mi">417</span>         <span class="k">try</span> <span class="p">{</span>
<span class="mi">418</span>             <span class="n">TimingResponseProtocol</span><span class="o">::</span><span class="n">sendRetrySnoopResp</span><span class="p">(</span><span class="n">_requestPort</span><span class="p">);</span>
<span class="mi">419</span>         <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">UnboundPortException</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">420</span>             <span class="n">reportUnbound</span><span class="p">();</span>
<span class="mi">421</span>         <span class="p">}</span>
<span class="mi">422</span>     <span class="p">}</span>
<span class="mi">423</span> 
<span class="mi">424</span>   <span class="k">protected</span><span class="o">:</span>
<span class="mi">425</span>     <span class="cm">/**
426      * Called by the request port to unbind. Should never be called
427      * directly.
428      */</span>
<span class="mi">429</span>     <span class="kt">void</span> <span class="nf">responderUnbind</span><span class="p">();</span>
<span class="mi">430</span> 
<span class="mi">431</span>     <span class="cm">/**
432      * Called by the request port to bind. Should never be called
433      * directly.
434      */</span>
<span class="mi">435</span>     <span class="kt">void</span> <span class="nf">responderBind</span><span class="p">(</span><span class="n">RequestPort</span><span class="o">&amp;</span> <span class="n">request_port</span><span class="p">);</span>
<span class="mi">436</span> 
<span class="mi">437</span>     <span class="cm">/**
438      * Default implementations.
439      */</span>
<span class="mi">440</span>     <span class="n">Tick</span> <span class="n">recvAtomicBackdoor</span><span class="p">(</span><span class="n">PacketPtr</span> <span class="n">pkt</span><span class="p">,</span> <span class="n">MemBackdoorPtr</span> <span class="o">&amp;</span><span class="n">backdoor</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
<span class="mi">441</span> 
<span class="mi">442</span>     <span class="kt">bool</span>
<span class="mi">443</span>     <span class="nf">tryTiming</span><span class="p">(</span><span class="n">PacketPtr</span> <span class="n">pkt</span><span class="p">)</span> <span class="k">override</span>
<span class="mi">444</span>     <span class="p">{</span>
<span class="mi">445</span>         <span class="n">panic</span><span class="p">(</span><span class="s">"%s was not expecting a %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">name</span><span class="p">(),</span> <span class="n">__func__</span><span class="p">);</span>
<span class="mi">446</span>     <span class="p">}</span>
<span class="mi">447</span> 
<span class="mi">448</span>     <span class="kt">bool</span>
<span class="mi">449</span>     <span class="nf">recvTimingSnoopResp</span><span class="p">(</span><span class="n">PacketPtr</span> <span class="n">pkt</span><span class="p">)</span> <span class="k">override</span>
<span class="mi">450</span>     <span class="p">{</span>
<span class="mi">451</span>         <span class="n">panic</span><span class="p">(</span><span class="s">"%s was not expecting a timing snoop response</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">name</span><span class="p">());</span>
<span class="mi">452</span>     <span class="p">}</span>
<span class="mi">453</span> <span class="p">};</span>
</pre></td></tr></tbody></table></code></div></div>
<p>This is the basic class that provides most of the interfaces 
required for handling receive operations.
Although some operations are not provided by the ResponsePort,
but they are provided by the TimingResponseProtocol 
inherited by the ResponsePort.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="rouge-code"><pre><span class="mi">169</span> <span class="cm">/**
170  * Response port
171  */</span>
<span class="mi">172</span> <span class="n">ResponsePort</span><span class="o">::</span><span class="n">ResponsePort</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="n">SimObject</span><span class="o">*</span> <span class="n">_owner</span><span class="p">,</span>
<span class="mi">173</span>     <span class="n">PortID</span> <span class="n">id</span><span class="p">)</span> <span class="o">:</span> <span class="n">Port</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">id</span><span class="p">),</span> <span class="n">_requestPort</span><span class="p">(</span><span class="o">&amp;</span><span class="n">defaultRequestPort</span><span class="p">),</span>
<span class="mi">174</span>     <span class="n">defaultBackdoorWarned</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span> <span class="n">owner</span><span class="p">(</span><span class="o">*</span><span class="n">_owner</span><span class="p">)</span>
<span class="mi">175</span> <span class="p">{</span>
<span class="mi">176</span> <span class="p">}</span>
<span class="mi">177</span> 
<span class="mi">178</span> <span class="n">ResponsePort</span><span class="o">::~</span><span class="n">ResponsePort</span><span class="p">()</span>
<span class="mi">179</span> <span class="p">{</span>
<span class="mi">180</span> <span class="p">}</span>
<span class="mi">181</span> 
<span class="mi">182</span> <span class="kt">void</span>
<span class="mi">183</span> <span class="n">ResponsePort</span><span class="o">::</span><span class="n">responderUnbind</span><span class="p">()</span>
<span class="mi">184</span> <span class="p">{</span>
<span class="mi">185</span>     <span class="n">_requestPort</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">defaultRequestPort</span><span class="p">;</span>
<span class="mi">186</span>     <span class="n">Port</span><span class="o">::</span><span class="n">unbind</span><span class="p">();</span>
<span class="mi">187</span> <span class="p">}</span>
<span class="mi">188</span> 
<span class="mi">189</span> <span class="kt">void</span>
<span class="mi">190</span> <span class="n">ResponsePort</span><span class="o">::</span><span class="n">responderBind</span><span class="p">(</span><span class="n">RequestPort</span><span class="o">&amp;</span> <span class="n">request_port</span><span class="p">)</span>
<span class="mi">191</span> <span class="p">{</span>
<span class="mi">192</span>     <span class="n">_requestPort</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">request_port</span><span class="p">;</span>
<span class="mi">193</span>     <span class="n">Port</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">request_port</span><span class="p">);</span>
<span class="mi">194</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>ResponsePort is initialized with defaultRequestPort by default.
Because ResponsePort needs to understand who sent the request (_requestPort),
the RequestPort object reference should be passed to the 
ResponsePort at the time of construction.
Or dynamically, it can bind to another RequestPort through the responderBind method. 
When proper RequestPort is not set for the ResponsePort, 
it will generate error messages during execution of the GEM5.</p>

<h2 id="resppacketqueue"><span class="me-2">RespPacketQueue</span><a href="#resppacketqueue" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>
<p>One thing that should be maintained by the QueuedResponsePort is 
the response packets.
When the all cache accesses finished, it should pass the response packet to the processor.
However, when the processor is busy not to get the response from the cache,
then it should retry later.
For that purpose, the QueuedResponsePort contains RespPacketQueue 
which maintains all the unhandled response packets.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="rouge-code"><pre><span class="mi">300</span> <span class="k">class</span> <span class="nc">RespPacketQueue</span> <span class="o">:</span> <span class="k">public</span> <span class="n">PacketQueue</span>
<span class="mi">301</span> <span class="p">{</span>
<span class="mi">302</span> 
<span class="mi">303</span>   <span class="k">protected</span><span class="o">:</span>
<span class="mi">304</span> 
<span class="mi">305</span>     <span class="n">ResponsePort</span><span class="o">&amp;</span> <span class="n">cpuSidePort</span><span class="p">;</span>
<span class="mi">306</span> 
<span class="mi">307</span>     <span class="c1">// Static definition so it can be called when constructing the parent</span>
<span class="mi">308</span>     <span class="c1">// without us being completely initialized.</span>
<span class="mi">309</span>     <span class="k">static</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">(</span><span class="k">const</span> <span class="n">ResponsePort</span><span class="o">&amp;</span> <span class="n">cpuSidePort</span><span class="p">,</span>
<span class="mi">310</span>                                   <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">label</span><span class="p">)</span>
<span class="mi">311</span>     <span class="p">{</span> <span class="k">return</span> <span class="n">cpuSidePort</span><span class="p">.</span><span class="n">name</span><span class="p">()</span> <span class="o">+</span> <span class="s">"-"</span> <span class="o">+</span> <span class="n">label</span><span class="p">;</span> <span class="p">}</span>
<span class="mi">312</span> 
<span class="mi">313</span>   <span class="k">public</span><span class="o">:</span>
<span class="mi">314</span> 
<span class="mi">315</span>     <span class="cm">/**
316      * Create a response packet queue, linked to an event manager, a
317      * CPU-side port, and a label that will be used for functional print
318      * request packets.
319      *
320      * @param _em Event manager used for scheduling this queue
321      * @param _cpu_side_port Cpu_side port used to send the packets
322      * @param force_order Force insertion order for packets with same address
323      * @param _label Label to push on the label stack for print request packets
324      */</span>
<span class="mi">325</span>     <span class="nf">RespPacketQueue</span><span class="p">(</span><span class="n">EventManager</span><span class="o">&amp;</span> <span class="n">_em</span><span class="p">,</span> <span class="n">ResponsePort</span><span class="o">&amp;</span> <span class="n">_cpu_side_port</span><span class="p">,</span>
<span class="mi">326</span>                     <span class="kt">bool</span> <span class="n">force_order</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span>
<span class="mi">327</span>                     <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">_label</span> <span class="o">=</span> <span class="s">"RespPacketQueue"</span><span class="p">);</span>
<span class="mi">328</span> 
<span class="mi">329</span>     <span class="k">virtual</span> <span class="o">~</span><span class="n">RespPacketQueue</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="mi">330</span> 
<span class="mi">331</span>     <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="nf">name</span><span class="p">()</span> <span class="k">const</span>
<span class="mi">332</span>     <span class="p">{</span> <span class="k">return</span> <span class="n">name</span><span class="p">(</span><span class="n">cpuSidePort</span><span class="p">,</span> <span class="n">label</span><span class="p">);</span> <span class="p">}</span>
<span class="mi">333</span> 
<span class="mi">334</span>     <span class="kt">bool</span> <span class="nf">sendTiming</span><span class="p">(</span><span class="n">PacketPtr</span> <span class="n">pkt</span><span class="p">);</span>
<span class="mi">335</span> 
<span class="mi">336</span> <span class="p">};</span>
</pre></td></tr></tbody></table></code></div></div>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="rouge-code"><pre><span class="mi">266</span> <span class="n">RespPacketQueue</span><span class="o">::</span><span class="n">RespPacketQueue</span><span class="p">(</span><span class="n">EventManager</span><span class="o">&amp;</span> <span class="n">_em</span><span class="p">,</span>
<span class="mi">267</span>                                  <span class="n">ResponsePort</span><span class="o">&amp;</span> <span class="n">_cpu_side_port</span><span class="p">,</span>
<span class="mi">268</span>                                  <span class="kt">bool</span> <span class="n">force_order</span><span class="p">,</span>
<span class="mi">269</span>                                  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">_label</span><span class="p">)</span>
<span class="mi">270</span>     <span class="o">:</span> <span class="n">PacketQueue</span><span class="p">(</span><span class="n">_em</span><span class="p">,</span> <span class="n">_label</span><span class="p">,</span> <span class="n">name</span><span class="p">(</span><span class="n">_cpu_side_port</span><span class="p">,</span> <span class="n">_label</span><span class="p">),</span> <span class="n">force_order</span><span class="p">),</span>
<span class="mi">271</span>       <span class="nf">cpuSidePort</span><span class="p">(</span><span class="n">_cpu_side_port</span><span class="p">)</span>
<span class="mi">272</span> <span class="p">{</span>
<span class="mi">273</span> <span class="p">}</span>
<span class="mi">274</span> 
<span class="mi">275</span> <span class="kt">bool</span>
<span class="mi">276</span> <span class="n">RespPacketQueue</span><span class="o">::</span><span class="n">sendTiming</span><span class="p">(</span><span class="n">PacketPtr</span> <span class="n">pkt</span><span class="p">)</span>
<span class="mi">277</span> <span class="p">{</span>
<span class="mi">278</span>     <span class="k">return</span> <span class="n">cpuSidePort</span><span class="p">.</span><span class="n">sendTimingResp</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>
<span class="mi">279</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>RespPacketQueue has cpuSidePort as its member and initialized by its constructor. 
When the sendTiming function of the RespPacketQueue is invoked,
it sends the packet through the cpuSidePort using the sendTimingResp. 
Also, note that the RespPacketQueue is initialized with the EventManager object’s reference.
However, when you take a look at its initialization 
in the BaseCache::CacheResponsePort::CacheResponsePort,
the queue which is the RespPacketQueue object is initialized with 
_cache as its first operand. 
Yeah it is not the EventManager but the BaseCache!
Because the BaseCache is SimObject, it must inherit from EventManager class.
Therefore, the cache object itself can be handled as the EventManager object. 
Let’s take a look at the PacketQueue which is the parent class of RespPacketQueue.
Also, note that RespPacketQueue itself is not capable of scheduling event
because it doesn’t have any member function or field to utilize the 
passed EventManager, BaseCache.</p>

<h3 id="packetqueue"><span class="me-2">PacketQueue</span><a href="#packetqueue" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<p>Instead of the RespPacketQueue, its parent class, PacketQueue utilizes the EventManager
and organize events using the schedule method and EventFunctionWrapper.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
</pre></td><td class="rouge-code"><pre> <span class="mi">61</span> <span class="cm">/**
 62  * A packet queue is a class that holds deferred packets and later
 63  * sends them using the associated CPU-side port or memory-side port.
 64  */</span>
 <span class="mi">65</span> <span class="k">class</span> <span class="nc">PacketQueue</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Drainable</span>
 <span class="mi">66</span> <span class="p">{</span>
 <span class="mi">67</span>   <span class="k">private</span><span class="o">:</span>
 <span class="mi">68</span>     <span class="cm">/** A deferred packet, buffered to transmit later. */</span>
 <span class="mi">69</span>     <span class="k">class</span> <span class="nc">DeferredPacket</span>
 <span class="mi">70</span>     <span class="p">{</span>
 <span class="mi">71</span>       <span class="k">public</span><span class="o">:</span>
 <span class="mi">72</span>         <span class="n">Tick</span> <span class="n">tick</span><span class="p">;</span>      <span class="c1">///&lt; The tick when the packet is ready to transmit</span>
 <span class="mi">73</span>         <span class="n">PacketPtr</span> <span class="n">pkt</span><span class="p">;</span>  <span class="c1">///&lt; Pointer to the packet to transmit</span>
 <span class="mi">74</span>         <span class="n">DeferredPacket</span><span class="p">(</span><span class="n">Tick</span> <span class="n">t</span><span class="p">,</span> <span class="n">PacketPtr</span> <span class="n">p</span><span class="p">)</span>
 <span class="mi">75</span>             <span class="o">:</span> <span class="n">tick</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">pkt</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
 <span class="mi">76</span>         <span class="p">{}</span>
 <span class="mi">77</span>     <span class="p">};</span>
 <span class="mi">78</span> 
 <span class="mi">79</span>     <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">DeferredPacket</span><span class="o">&gt;</span> <span class="n">DeferredPacketList</span><span class="p">;</span>
 <span class="mi">80</span> 
 <span class="mi">81</span>     <span class="cm">/** A list of outgoing packets. */</span>
 <span class="mi">82</span>     <span class="n">DeferredPacketList</span> <span class="n">transmitList</span><span class="p">;</span>
 <span class="mi">83</span> 
 <span class="mi">84</span>     <span class="cm">/** The manager which is used for the event queue */</span>
 <span class="mi">85</span>     <span class="n">EventManager</span><span class="o">&amp;</span> <span class="n">em</span><span class="p">;</span>
 <span class="mi">86</span> 
 <span class="mi">87</span>     <span class="cm">/** Used to schedule sending of deferred packets. */</span>
 <span class="mi">88</span>     <span class="kt">void</span> <span class="nf">processSendEvent</span><span class="p">();</span>
 <span class="mi">89</span> 
 <span class="mi">90</span>     <span class="cm">/** Event used to call processSendEvent. */</span>
 <span class="mi">91</span>     <span class="n">EventFunctionWrapper</span> <span class="n">sendEvent</span><span class="p">;</span>
 <span class="mi">92</span> 
 <span class="mi">93</span>      <span class="cm">/*
 94       * Optionally disable the sanity check
 95       * on the size of the transmitList. The
 96       * sanity check will be enabled by default.
 97       */</span>
 <span class="mi">98</span>     <span class="kt">bool</span> <span class="n">_disableSanityCheck</span><span class="p">;</span>
 <span class="mi">99</span> 
<span class="mi">100</span>     <span class="cm">/**
101      * if true, inserted packets have to be unconditionally scheduled
102      * after the last packet in the queue that references the same
103      * address
104      */</span>
<span class="mi">105</span>     <span class="kt">bool</span> <span class="n">forceOrder</span><span class="p">;</span>
<span class="mi">106</span> 
<span class="mi">107</span>   <span class="k">protected</span><span class="o">:</span>
<span class="mi">108</span> 
<span class="mi">109</span>     <span class="cm">/** Label to use for print request packets label stack. */</span>
<span class="mi">110</span>     <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">label</span><span class="p">;</span>
<span class="mi">111</span> 
<span class="mi">112</span>     <span class="cm">/** Remember whether we're awaiting a retry. */</span>
<span class="mi">113</span>     <span class="kt">bool</span> <span class="n">waitingOnRetry</span><span class="p">;</span>
<span class="mi">114</span> 
<span class="mi">115</span>     <span class="cm">/** Check whether we have a packet ready to go on the transmit list. */</span>
<span class="mi">116</span>     <span class="kt">bool</span> <span class="nf">deferredPacketReady</span><span class="p">()</span> <span class="k">const</span>
<span class="mi">117</span>     <span class="p">{</span> <span class="k">return</span> <span class="o">!</span><span class="n">transmitList</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">transmitList</span><span class="p">.</span><span class="n">front</span><span class="p">().</span><span class="n">tick</span> <span class="o">&lt;=</span> <span class="n">curTick</span><span class="p">();</span> <span class="p">}</span>
<span class="mi">118</span> 
<span class="mi">119</span>     <span class="cm">/**
120      * Attempt to send a packet. Note that a subclass of the
121      * PacketQueue can override this method and thus change the
122      * behaviour (as done by the cache for the request queue). The
123      * default implementation sends the head of the transmit list. The
124      * caller must guarantee that the list is non-empty and that the
125      * head packet is scheduled for curTick() (or earlier).
126      */</span>
<span class="mi">127</span>     <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">sendDeferredPacket</span><span class="p">();</span>
<span class="mi">128</span> 
<span class="mi">129</span>     <span class="cm">/**
130      * Send a packet using the appropriate method for the specific
131      * subclass (request, response or snoop response).
132      */</span>
<span class="mi">133</span>     <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">sendTiming</span><span class="p">(</span><span class="n">PacketPtr</span> <span class="n">pkt</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="mi">134</span> 
<span class="mi">135</span>     <span class="cm">/**
136      * Create a packet queue, linked to an event manager, and a label
137      * that will be used for functional print request packets.
138      *
139      * @param _em Event manager used for scheduling this queue
140      * @param _label Label to push on the label stack for print request packets
141      * @param force_order Force insertion order for packets with same address
142      * @param disable_sanity_check Flag used to disable the sanity check
143      *        on the size of the transmitList. The check is enabled by default.
144      */</span>
<span class="mi">145</span>     <span class="nf">PacketQueue</span><span class="p">(</span><span class="n">EventManager</span><span class="o">&amp;</span> <span class="n">_em</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">_label</span><span class="p">,</span>
<span class="mi">146</span>                 <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">_sendEventName</span><span class="p">,</span>
<span class="mi">147</span>                 <span class="kt">bool</span> <span class="n">force_order</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span>
<span class="mi">148</span>                 <span class="kt">bool</span> <span class="n">disable_sanity_check</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
<span class="mi">149</span> 
<span class="mi">150</span>     <span class="cm">/**
151      * Virtual desctructor since the class may be used as a base class.
152      */</span>
<span class="mi">153</span>     <span class="k">virtual</span> <span class="o">~</span><span class="n">PacketQueue</span><span class="p">();</span>
<span class="mi">154</span> 
<span class="mi">155</span>   <span class="k">public</span><span class="o">:</span>
<span class="mi">156</span> 
<span class="mi">157</span>     <span class="cm">/**
158      * Provide a name to simplify debugging.
159      *
160      * @return A complete name, appended to module and port
161      */</span>
<span class="mi">162</span>     <span class="k">virtual</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="mi">163</span> 
<span class="mi">164</span>     <span class="cm">/**
165      * Get the size of the queue.
166      */</span>
<span class="mi">167</span>     <span class="kt">size_t</span> <span class="nf">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">transmitList</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="p">}</span>
<span class="mi">168</span> 
<span class="mi">169</span>     <span class="cm">/**
170      * Get the next packet ready time.
171      */</span>
<span class="mi">172</span>     <span class="n">Tick</span> <span class="n">deferredPacketReadyTime</span><span class="p">()</span> <span class="k">const</span>
<span class="mi">173</span>     <span class="p">{</span> <span class="k">return</span> <span class="n">transmitList</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">?</span> <span class="n">MaxTick</span> <span class="o">:</span> <span class="n">transmitList</span><span class="p">.</span><span class="n">front</span><span class="p">().</span><span class="n">tick</span><span class="p">;</span> <span class="p">}</span>
<span class="mi">174</span> 
<span class="mi">175</span>     <span class="cm">/**
176      * Check if a packet corresponding to the same address exists in the
177      * queue.
178      *
179      * @param pkt The packet to compare against.
180      * @param blk_size Block size in bytes.
181      * @return Whether a corresponding packet is found.
182      */</span>
<span class="mi">183</span>     <span class="kt">bool</span> <span class="n">checkConflict</span><span class="p">(</span><span class="k">const</span> <span class="n">PacketPtr</span> <span class="n">pkt</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">blk_size</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="mi">184</span> 
<span class="mi">185</span>     <span class="cm">/** Check the list of buffered packets against the supplied
186      * functional request. */</span>
<span class="mi">187</span>     <span class="kt">bool</span> <span class="nf">trySatisfyFunctional</span><span class="p">(</span><span class="n">PacketPtr</span> <span class="n">pkt</span><span class="p">);</span>
<span class="mi">188</span> 
<span class="mi">189</span>     <span class="cm">/**
190      * Schedule a send event if we are not already waiting for a
191      * retry. If the requested time is before an already scheduled
192      * send event, the event will be rescheduled. If MaxTick is
193      * passed, no event is scheduled. Instead, if we are idle and
194      * asked to drain then check and signal drained.
195      *
196      * @param when time to schedule an event
197      */</span>
<span class="mi">198</span>     <span class="kt">void</span> <span class="nf">schedSendEvent</span><span class="p">(</span><span class="n">Tick</span> <span class="n">when</span><span class="p">);</span>
<span class="mi">199</span> 
<span class="mi">200</span>     <span class="cm">/**
201      * Add a packet to the transmit list, and schedule a send event.
202      *
203      * @param pkt Packet to send
204      * @param when Absolute time (in ticks) to send packet
205      */</span>
<span class="mi">206</span>     <span class="kt">void</span> <span class="nf">schedSendTiming</span><span class="p">(</span><span class="n">PacketPtr</span> <span class="n">pkt</span><span class="p">,</span> <span class="n">Tick</span> <span class="n">when</span><span class="p">);</span>
<span class="mi">207</span> 
<span class="mi">208</span>     <span class="cm">/**
209      * Retry sending a packet from the queue. Note that this is not
210      * necessarily the same packet if something has been added with an
211      * earlier time stamp.
212      */</span>
<span class="mi">213</span>     <span class="kt">void</span> <span class="nf">retry</span><span class="p">();</span>
<span class="mi">214</span> 
<span class="mi">215</span>     <span class="cm">/**
216       * This allows a user to explicitly disable the sanity check
217       * on the size of the transmitList, which is enabled by default.
218       * Users must use this function to explicitly disable the sanity
219       * check.
220       */</span>
<span class="mi">221</span>     <span class="kt">void</span> <span class="nf">disableSanityCheck</span><span class="p">()</span> <span class="p">{</span> <span class="n">_disableSanityCheck</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span>
<span class="mi">222</span> 
<span class="mi">223</span>     <span class="n">DrainState</span> <span class="n">drain</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>
<span class="mi">224</span> <span class="p">};</span>
</pre></td></tr></tbody></table></code></div></div>

<h2 id="port-binding"><span class="me-2">Port binding</span><a href="#port-binding" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<div class="language-python highlighter-rouge"><div class="code-header">
        <span data-label-text="Python"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre> <span class="mi">73</span> <span class="k">class</span> <span class="nc">BaseCache</span><span class="p">(</span><span class="n">ClockedObject</span><span class="p">):</span>
 <span class="mi">74</span>     <span class="nb">type</span> <span class="o">=</span> <span class="sh">'</span><span class="s">BaseCache</span><span class="sh">'</span>
<span class="p">...</span><span class="bp">...</span>
<span class="mi">121</span>     <span class="n">cpu_side</span> <span class="o">=</span> <span class="nc">ResponsePort</span><span class="p">(</span><span class="sh">"</span><span class="s">Upstream port closer to the CPU and/or device</span><span class="sh">"</span><span class="p">)</span>
<span class="mi">122</span>     <span class="n">mem_side</span> <span class="o">=</span> <span class="nc">RequestPort</span><span class="p">(</span><span class="sh">"</span><span class="s">Downstream port closer to memory</span><span class="sh">"</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></div></div>

<p><em>gem5/src/python/m5/params.py</em></p>
<div class="language-python highlighter-rouge"><div class="code-header">
        <span data-label-text="Python"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
</pre></td><td class="rouge-code"><pre><span class="mi">2123</span> <span class="c1"># Port description object.  Like a ParamDesc object, this represents a
</span><span class="mi">2124</span> <span class="c1"># logical port in the SimObject class, not a particular port on a
</span><span class="mi">2125</span> <span class="c1"># SimObject instance.  The latter are represented by PortRef objects.
</span><span class="mi">2126</span> <span class="k">class</span> <span class="nc">Port</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="mi">2127</span>     <span class="c1"># Port("role", "description")
</span><span class="mi">2128</span> 
<span class="mi">2129</span>     <span class="n">_compat_dict</span> <span class="o">=</span> <span class="p">{</span> <span class="p">}</span>
<span class="mi">2130</span> 
<span class="mi">2131</span>     <span class="nd">@classmethod</span>
<span class="mi">2132</span>     <span class="k">def</span> <span class="nf">compat</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">role</span><span class="p">,</span> <span class="n">peer</span><span class="p">):</span>
<span class="mi">2133</span>         <span class="n">cls</span><span class="p">.</span><span class="n">_compat_dict</span><span class="p">.</span><span class="nf">setdefault</span><span class="p">(</span><span class="n">role</span><span class="p">,</span> <span class="nf">set</span><span class="p">()).</span><span class="nf">add</span><span class="p">(</span><span class="n">peer</span><span class="p">)</span>
<span class="mi">2134</span>         <span class="n">cls</span><span class="p">.</span><span class="n">_compat_dict</span><span class="p">.</span><span class="nf">setdefault</span><span class="p">(</span><span class="n">peer</span><span class="p">,</span> <span class="nf">set</span><span class="p">()).</span><span class="nf">add</span><span class="p">(</span><span class="n">role</span><span class="p">)</span>
<span class="mi">2135</span> 
<span class="mi">2136</span>     <span class="nd">@classmethod</span>
<span class="mi">2137</span>     <span class="k">def</span> <span class="nf">is_compat</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">one</span><span class="p">,</span> <span class="n">two</span><span class="p">):</span>
<span class="mi">2138</span>         <span class="k">for</span> <span class="n">port</span> <span class="ow">in</span> <span class="n">one</span><span class="p">,</span> <span class="n">two</span><span class="p">:</span>
<span class="mi">2139</span>             <span class="k">if</span> <span class="ow">not</span> <span class="n">port</span><span class="p">.</span><span class="n">role</span> <span class="ow">in</span> <span class="n">Port</span><span class="p">.</span><span class="n">_compat_dict</span><span class="p">:</span>
<span class="mi">2140</span>                 <span class="nf">fatal</span><span class="p">(</span><span class="sh">"</span><span class="s">Unrecognized role </span><span class="sh">'</span><span class="s">%s</span><span class="sh">'</span><span class="s"> for port %s</span><span class="se">\n</span><span class="sh">"</span><span class="p">,</span> <span class="n">port</span><span class="p">.</span><span class="n">role</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span>
<span class="mi">2141</span>         <span class="k">return</span> <span class="n">one</span><span class="p">.</span><span class="n">role</span> <span class="ow">in</span> <span class="n">Port</span><span class="p">.</span><span class="n">_compat_dict</span><span class="p">[</span><span class="n">two</span><span class="p">.</span><span class="n">role</span><span class="p">]</span>
<span class="mi">2142</span> 
<span class="mi">2143</span>     <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">role</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="n">is_source</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
<span class="mi">2144</span>         <span class="n">self</span><span class="p">.</span><span class="n">desc</span> <span class="o">=</span> <span class="n">desc</span>
<span class="mi">2145</span>         <span class="n">self</span><span class="p">.</span><span class="n">role</span> <span class="o">=</span> <span class="n">role</span>
<span class="mi">2146</span>         <span class="n">self</span><span class="p">.</span><span class="n">is_source</span> <span class="o">=</span> <span class="n">is_source</span>
<span class="mi">2147</span> 
<span class="mi">2148</span>     <span class="c1"># Generate a PortRef for this port on the given SimObject with the
</span><span class="mi">2149</span>     <span class="c1"># given name
</span><span class="mi">2150</span>     <span class="k">def</span> <span class="nf">makeRef</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">simobj</span><span class="p">):</span>
<span class="mi">2151</span>         <span class="k">return</span> <span class="nc">PortRef</span><span class="p">(</span><span class="n">simobj</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">role</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">is_source</span><span class="p">)</span>
<span class="mi">2152</span> 
<span class="mi">2153</span>     <span class="c1"># Connect an instance of this port (on the given SimObject with
</span><span class="mi">2154</span>     <span class="c1"># the given name) with the port described by the supplied PortRef
</span><span class="mi">2155</span>     <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">simobj</span><span class="p">,</span> <span class="n">ref</span><span class="p">):</span>
<span class="mi">2156</span>         <span class="n">self</span><span class="p">.</span><span class="nf">makeRef</span><span class="p">(</span><span class="n">simobj</span><span class="p">).</span><span class="nf">connect</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>
<span class="mi">2157</span> 
<span class="mi">2158</span>     <span class="c1"># No need for any pre-declarations at the moment as we merely rely
</span><span class="mi">2159</span>     <span class="c1"># on an unsigned int.
</span><span class="mi">2160</span>     <span class="k">def</span> <span class="nf">cxx_predecls</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">code</span><span class="p">):</span>
<span class="mi">2161</span>         <span class="k">pass</span>
<span class="mi">2162</span> 
<span class="mi">2163</span>     <span class="k">def</span> <span class="nf">pybind_predecls</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">code</span><span class="p">):</span>
<span class="mi">2164</span>         <span class="n">cls</span><span class="p">.</span><span class="nf">cxx_predecls</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">code</span><span class="p">)</span>
<span class="mi">2165</span> 
<span class="mi">2166</span>     <span class="c1"># Declare an unsigned int with the same name as the port, that
</span><span class="mi">2167</span>     <span class="c1"># will eventually hold the number of connected ports (and thus the
</span><span class="mi">2168</span>     <span class="c1"># number of elements for a VectorPort).
</span><span class="mi">2169</span>     <span class="k">def</span> <span class="nf">cxx_decl</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">code</span><span class="p">):</span>
<span class="mi">2170</span>         <span class="nf">code</span><span class="p">(</span><span class="sh">'</span><span class="s">unsigned int port_$_connection_count;</span><span class="sh">'</span><span class="p">)</span>
<span class="mi">2171</span> 
<span class="mi">2172</span> <span class="n">Port</span><span class="p">.</span><span class="nf">compat</span><span class="p">(</span><span class="sh">'</span><span class="s">GEM5 REQUESTOR</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">GEM5 RESPONDER</span><span class="sh">'</span><span class="p">)</span>
<span class="mi">2173</span> 
<span class="mi">2174</span> <span class="k">class</span> <span class="nc">RequestPort</span><span class="p">(</span><span class="n">Port</span><span class="p">):</span>
<span class="mi">2175</span>     <span class="c1"># RequestPort("description")
</span><span class="mi">2176</span>     <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">desc</span><span class="p">):</span>
<span class="mi">2177</span>         <span class="nf">super</span><span class="p">(</span><span class="n">RequestPort</span><span class="p">,</span> <span class="n">self</span><span class="p">).</span><span class="nf">__init__</span><span class="p">(</span>
<span class="mi">2178</span>                 <span class="sh">'</span><span class="s">GEM5 REQUESTOR</span><span class="sh">'</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="n">is_source</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="mi">2179</span> 
<span class="mi">2180</span> <span class="k">class</span> <span class="nc">ResponsePort</span><span class="p">(</span><span class="n">Port</span><span class="p">):</span>
<span class="mi">2181</span>     <span class="c1"># ResponsePort("description")
</span><span class="mi">2182</span>     <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">desc</span><span class="p">):</span>
<span class="mi">2183</span>         <span class="nf">super</span><span class="p">(</span><span class="n">ResponsePort</span><span class="p">,</span> <span class="n">self</span><span class="p">).</span><span class="nf">__init__</span><span class="p">(</span><span class="sh">'</span><span class="s">GEM5 RESPONDER</span><span class="sh">'</span><span class="p">,</span> <span class="n">desc</span><span class="p">)</span>
<span class="mi">2184</span> 
</pre></td></tr></tbody></table></code></div></div>

<div class="language-python highlighter-rouge"><div class="code-header">
        <span data-label-text="Python"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre></td><td class="rouge-code"><pre><span class="mi">1896</span> <span class="c1">#####################################################################
</span><span class="mi">1897</span> <span class="c1">#
</span><span class="mi">1898</span> <span class="c1"># Port objects
</span><span class="mi">1899</span> <span class="c1">#
</span><span class="mi">1900</span> <span class="c1"># Ports are used to interconnect objects in the memory system.
</span><span class="mi">1901</span> <span class="c1">#
</span><span class="mi">1902</span> <span class="c1">#####################################################################
</span><span class="mi">1903</span> 
<span class="mi">1904</span> <span class="c1"># Port reference: encapsulates a reference to a particular port on a
</span><span class="mi">1905</span> <span class="c1"># particular SimObject.
</span><span class="mi">1906</span> <span class="k">class</span> <span class="nc">PortRef</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="p">...</span><span class="bp">...</span>
<span class="mi">1941</span>     <span class="c1"># Full connection is symmetric (both ways).  Called via
</span><span class="mi">1942</span>     <span class="c1"># SimObject.__setattr__ as a result of a port assignment, e.g.,
</span><span class="mi">1943</span>     <span class="c1"># "obj1.portA = obj2.portB", or via VectorPortElementRef.__setitem__,
</span><span class="mi">1944</span>     <span class="c1"># e.g., "obj1.portA[3] = obj2.portB".
</span><span class="mi">1945</span>     <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="mi">1946</span>         <span class="k">if</span> <span class="nf">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">VectorPortRef</span><span class="p">):</span>
<span class="mi">1947</span>             <span class="c1"># reference to plain VectorPort is implicit append
</span><span class="mi">1948</span>             <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="nf">_get_next</span><span class="p">()</span>
<span class="mi">1949</span>         <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">peer</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">proxy</span><span class="p">.</span><span class="nf">isproxy</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">peer</span><span class="p">):</span>
<span class="mi">1950</span>             <span class="nf">fatal</span><span class="p">(</span><span class="sh">"</span><span class="s">Port %s is already connected to %s, cannot connect %s</span><span class="se">\n</span><span class="sh">"</span><span class="p">,</span>
<span class="mi">1951</span>                   <span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">peer</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
<span class="mi">1952</span>         <span class="n">self</span><span class="p">.</span><span class="n">peer</span> <span class="o">=</span> <span class="n">other</span>
<span class="mi">1953</span> 
<span class="mi">1954</span>         <span class="k">if</span> <span class="n">proxy</span><span class="p">.</span><span class="nf">isproxy</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
<span class="mi">1955</span>             <span class="n">other</span><span class="p">.</span><span class="nf">set_param_desc</span><span class="p">(</span><span class="nc">PortParamDesc</span><span class="p">())</span>
<span class="mi">1956</span>             <span class="k">return</span>
<span class="mi">1957</span>         <span class="k">elif</span> <span class="ow">not</span> <span class="nf">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">PortRef</span><span class="p">):</span>
<span class="mi">1958</span>             <span class="k">raise</span> <span class="nc">TypeError</span><span class="p">(</span><span class="sh">"</span><span class="s">assigning non-port reference </span><span class="sh">'</span><span class="s">%s</span><span class="sh">'</span><span class="s"> to port </span><span class="sh">'</span><span class="s">%s</span><span class="sh">'"</span> \
<span class="mi">1959</span>                   <span class="o">%</span> <span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">self</span><span class="p">))</span>
<span class="mi">1960</span> 
<span class="mi">1961</span>         <span class="k">if</span> <span class="ow">not</span> <span class="n">Port</span><span class="p">.</span><span class="nf">is_compat</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="mi">1962</span>             <span class="nf">fatal</span><span class="p">(</span><span class="sh">"</span><span class="s">Ports %s and %s with roles </span><span class="sh">'</span><span class="s">%s</span><span class="sh">'</span><span class="s"> and </span><span class="sh">'</span><span class="s">%s</span><span class="sh">'</span><span class="s"> </span><span class="sh">"</span>
<span class="mi">1963</span>                     <span class="sh">"</span><span class="s">are not compatible</span><span class="sh">"</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">role</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">role</span><span class="p">)</span>
<span class="mi">1964</span> 
<span class="mi">1965</span>         <span class="k">if</span> <span class="n">other</span><span class="p">.</span><span class="n">peer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">self</span><span class="p">:</span>
<span class="mi">1966</span>             <span class="n">other</span><span class="p">.</span><span class="nf">connect</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>
<span class="p">...</span><span class="bp">...</span>
<span class="mi">2023</span>     <span class="c1"># Call C++ to create corresponding port connection between C++ objects
</span><span class="mi">2024</span>     <span class="k">def</span> <span class="nf">ccConnect</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
<span class="mi">2025</span>         <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">ccConnected</span><span class="p">:</span> <span class="c1"># already done this
</span><span class="mi">2026</span>             <span class="k">return</span>
<span class="mi">2027</span> 
<span class="mi">2028</span>         <span class="n">peer</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">peer</span>
<span class="mi">2029</span>         <span class="k">if</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="n">peer</span><span class="p">:</span> <span class="c1"># nothing to connect to
</span><span class="mi">2030</span>             <span class="k">return</span>
<span class="mi">2031</span> 
<span class="mi">2032</span>         <span class="n">port</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">simobj</span><span class="p">.</span><span class="nf">getPort</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">index</span><span class="p">)</span>
<span class="mi">2033</span>         <span class="n">peer_port</span> <span class="o">=</span> <span class="n">peer</span><span class="p">.</span><span class="n">simobj</span><span class="p">.</span><span class="nf">getPort</span><span class="p">(</span><span class="n">peer</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">peer</span><span class="p">.</span><span class="n">index</span><span class="p">)</span>
<span class="mi">2034</span>         <span class="n">port</span><span class="p">.</span><span class="nf">bind</span><span class="p">(</span><span class="n">peer_port</span><span class="p">)</span>
<span class="mi">2035</span> 
<span class="mi">2036</span>         <span class="n">self</span><span class="p">.</span><span class="n">ccConnected</span> <span class="o">=</span> <span class="bp">True</span>
</pre></td></tr></tbody></table></code></div></div>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="rouge-code"><pre><span class="mi">127</span> <span class="kt">void</span>
<span class="mi">128</span> <span class="n">RequestPort</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">Port</span> <span class="o">&amp;</span><span class="n">peer</span><span class="p">)</span>
<span class="mi">129</span> <span class="p">{</span>
<span class="mi">130</span>     <span class="k">auto</span> <span class="o">*</span><span class="n">response_port</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">ResponsePort</span> <span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">peer</span><span class="p">);</span>
<span class="mi">131</span>     <span class="n">fatal_if</span><span class="p">(</span><span class="o">!</span><span class="n">response_port</span><span class="p">,</span> <span class="s">"Can't bind port %s to non-response port %s."</span><span class="p">,</span>
<span class="mi">132</span>              <span class="n">name</span><span class="p">(),</span> <span class="n">peer</span><span class="p">.</span><span class="n">name</span><span class="p">());</span>
<span class="mi">133</span>     <span class="c1">// request port keeps track of the response port</span>
<span class="mi">134</span>     <span class="n">_responsePort</span> <span class="o">=</span> <span class="n">response_port</span><span class="p">;</span>
<span class="mi">135</span>     <span class="n">Port</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">peer</span><span class="p">);</span>
<span class="mi">136</span>     <span class="c1">// response port also keeps track of request port</span>
<span class="mi">137</span>     <span class="n">_responsePort</span><span class="o">-&gt;</span><span class="n">responderBind</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
<span class="mi">138</span> <span class="p">}</span>

<span class="mi">189</span> <span class="kt">void</span>
<span class="mi">190</span> <span class="n">ResponsePort</span><span class="o">::</span><span class="n">responderBind</span><span class="p">(</span><span class="n">RequestPort</span><span class="o">&amp;</span> <span class="n">request_port</span><span class="p">)</span>
<span class="mi">191</span> <span class="p">{</span>
<span class="mi">192</span>     <span class="n">_requestPort</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">request_port</span><span class="p">;</span>
<span class="mi">193</span>     <span class="n">Port</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">request_port</span><span class="p">);</span>
<span class="mi">194</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre> <span class="mi">58</span> <span class="cm">/**
 59  * Ports are used to interface objects to each other.
 60  */</span>
 <span class="mi">61</span> <span class="k">class</span> <span class="nc">Port</span>
 <span class="mi">62</span> <span class="p">{</span>
<span class="mi">116</span>     <span class="cm">/** Attach to a peer port. */</span>
<span class="mi">117</span>     <span class="k">virtual</span> <span class="kt">void</span>
<span class="mi">118</span>     <span class="n">bind</span><span class="p">(</span><span class="n">Port</span> <span class="o">&amp;</span><span class="n">peer</span><span class="p">)</span>
<span class="mi">119</span>     <span class="p">{</span>
<span class="mi">120</span>         <span class="n">_peer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">peer</span><span class="p">;</span>
<span class="mi">121</span>         <span class="n">_connected</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="mi">122</span>     <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre> <span class="mi">200</span> <span class="n">Port</span> <span class="o">&amp;</span>
 <span class="mi">201</span> <span class="n">BaseCache</span><span class="o">::</span><span class="n">getPort</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">if_name</span><span class="p">,</span> <span class="n">PortID</span> <span class="n">idx</span><span class="p">)</span>
 <span class="mi">202</span> <span class="p">{</span>
 <span class="mi">203</span>     <span class="k">if</span> <span class="p">(</span><span class="n">if_name</span> <span class="o">==</span> <span class="s">"mem_side"</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">204</span>         <span class="k">return</span> <span class="n">memSidePort</span><span class="p">;</span>
 <span class="mi">205</span>     <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">if_name</span> <span class="o">==</span> <span class="s">"cpu_side"</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">206</span>         <span class="k">return</span> <span class="n">cpuSidePort</span><span class="p">;</span>
 <span class="mi">207</span>     <span class="p">}</span>  <span class="k">else</span> <span class="p">{</span>
 <span class="mi">208</span>         <span class="k">return</span> <span class="n">ClockedObject</span><span class="o">::</span><span class="n">getPort</span><span class="p">(</span><span class="n">if_name</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
 <span class="mi">209</span>     <span class="p">}</span>
 <span class="mi">210</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>#######################</p>
<h3 id="allocateblock"><span class="me-2">allocateBlock</span><a href="#allocateblock" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre></td><td class="rouge-code"><pre><span class="mi">1529</span> <span class="n">CacheBlk</span><span class="o">*</span>
<span class="mi">1530</span> <span class="n">BaseCache</span><span class="o">::</span><span class="n">allocateBlock</span><span class="p">(</span><span class="k">const</span> <span class="n">PacketPtr</span> <span class="n">pkt</span><span class="p">,</span> <span class="n">PacketList</span> <span class="o">&amp;</span><span class="n">writebacks</span><span class="p">)</span>
<span class="mi">1531</span> <span class="p">{</span>  
<span class="mi">1532</span>     <span class="c1">// Get address</span>
<span class="mi">1533</span>     <span class="k">const</span> <span class="n">Addr</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">getAddr</span><span class="p">();</span>
<span class="mi">1534</span> 
<span class="mi">1535</span>     <span class="c1">// Get secure bit</span>
<span class="mi">1536</span>     <span class="k">const</span> <span class="kt">bool</span> <span class="n">is_secure</span> <span class="o">=</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">isSecure</span><span class="p">();</span>
<span class="mi">1537</span> 
<span class="mi">1538</span>     <span class="c1">// Block size and compression related access latency. Only relevant if</span>
<span class="mi">1539</span>     <span class="c1">// using a compressor, otherwise there is no extra delay, and the block</span>
<span class="mi">1540</span>     <span class="c1">// is fully sized</span>
<span class="mi">1541</span>     <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">blk_size_bits</span> <span class="o">=</span> <span class="n">blkSize</span><span class="o">*</span><span class="mi">8</span><span class="p">;</span>
<span class="mi">1542</span>     <span class="n">Cycles</span> <span class="n">compression_lat</span> <span class="o">=</span> <span class="n">Cycles</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="mi">1543</span>     <span class="n">Cycles</span> <span class="n">decompression_lat</span> <span class="o">=</span> <span class="n">Cycles</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="mi">1544</span> 
<span class="mi">1545</span>     <span class="c1">// If a compressor is being used, it is called to compress data before</span>
<span class="mi">1546</span>     <span class="c1">// insertion. Although in Gem5 the data is stored uncompressed, even if a</span>
<span class="mi">1547</span>     <span class="c1">// compressor is used, the compression/decompression methods are called to</span>
<span class="mi">1548</span>     <span class="c1">// calculate the amount of extra cycles needed to read or write compressed</span>
<span class="mi">1549</span>     <span class="c1">// blocks.</span>
<span class="mi">1550</span>     <span class="k">if</span> <span class="p">(</span><span class="n">compressor</span> <span class="o">&amp;&amp;</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">hasData</span><span class="p">())</span> <span class="p">{</span>
<span class="mi">1551</span>         <span class="k">const</span> <span class="k">auto</span> <span class="n">comp_data</span> <span class="o">=</span> <span class="n">compressor</span><span class="o">-&gt;</span><span class="n">compress</span><span class="p">(</span>
<span class="mi">1552</span>             <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">getConstPtr</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">compression_lat</span><span class="p">,</span> <span class="n">decompression_lat</span><span class="p">);</span>
<span class="mi">1553</span>         <span class="n">blk_size_bits</span> <span class="o">=</span> <span class="n">comp_data</span><span class="o">-&gt;</span><span class="n">getSizeBits</span><span class="p">();</span>
<span class="mi">1554</span>     <span class="p">}</span>
<span class="mi">1555</span> 
<span class="mi">1556</span>     <span class="c1">// Find replacement victim</span>
<span class="mi">1557</span>     <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">CacheBlk</span><span class="o">*&gt;</span> <span class="n">evict_blks</span><span class="p">;</span>
<span class="mi">1558</span>     <span class="n">CacheBlk</span> <span class="o">*</span><span class="n">victim</span> <span class="o">=</span> <span class="n">tags</span><span class="o">-&gt;</span><span class="n">findVictim</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">is_secure</span><span class="p">,</span> <span class="n">blk_size_bits</span><span class="p">,</span>
<span class="mi">1559</span>                                         <span class="n">evict_blks</span><span class="p">);</span>
<span class="mi">1560</span>    
<span class="mi">1561</span>     <span class="c1">// It is valid to return nullptr if there is no victim</span>
<span class="mi">1562</span>     <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">victim</span><span class="p">)</span>
<span class="mi">1563</span>         <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="mi">1564</span> 
<span class="mi">1565</span>     <span class="c1">// Print victim block's information</span>
<span class="mi">1566</span>     <span class="nf">DPRINTF</span><span class="p">(</span><span class="n">CacheRepl</span><span class="p">,</span> <span class="s">"Replacement victim: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">victim</span><span class="o">-&gt;</span><span class="n">print</span><span class="p">());</span>
<span class="mi">1567</span> 
<span class="mi">1568</span>     <span class="c1">// Try to evict blocks; if it fails, give up on allocation</span>
<span class="mi">1569</span>     <span class="nf">if</span> <span class="p">(</span><span class="o">!</span><span class="n">handleEvictions</span><span class="p">(</span><span class="n">evict_blks</span><span class="p">,</span> <span class="n">writebacks</span><span class="p">))</span> <span class="p">{</span>
<span class="mi">1570</span>         <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="mi">1571</span>     <span class="p">}</span>
<span class="mi">1572</span> 
<span class="mi">1573</span>     <span class="c1">// Insert new block at victimized entry</span>
<span class="mi">1574</span>     <span class="n">tags</span><span class="o">-&gt;</span><span class="n">insertBlock</span><span class="p">(</span><span class="n">pkt</span><span class="p">,</span> <span class="n">victim</span><span class="p">);</span>
<span class="mi">1575</span> 
<span class="mi">1576</span>     <span class="c1">// If using a compressor, set compression data. This must be done after</span>
<span class="mi">1577</span>     <span class="c1">// insertion, as the compression bit may be set.</span>
<span class="mi">1578</span>     <span class="nf">if</span> <span class="p">(</span><span class="n">compressor</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1579</span>         <span class="n">compressor</span><span class="o">-&gt;</span><span class="n">setSizeBits</span><span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">blk_size_bits</span><span class="p">);</span>
<span class="mi">1580</span>         <span class="n">compressor</span><span class="o">-&gt;</span><span class="n">setDecompressionLatency</span><span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">decompression_lat</span><span class="p">);</span>
<span class="mi">1581</span>     <span class="p">}</span>
<span class="mi">1582</span> 
<span class="mi">1583</span>     <span class="k">return</span> <span class="n">victim</span><span class="p">;</span>
<span class="mi">1584</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="rouge-code"><pre><span class="mi">158</span>     <span class="cm">/**
159      * Find replacement victim based on address. The list of evicted blocks
160      * only contains the victim.
161      *
162      * @param addr Address to find a victim for.
163      * @param is_secure True if the target memory space is secure.
164      * @param size Size, in bits, of new block to allocate.
165      * @param evict_blks Cache blocks to be evicted.
166      * @return Cache block to be replaced.
167      */</span>
<span class="mi">168</span>     <span class="n">CacheBlk</span><span class="o">*</span> <span class="nf">findVictim</span><span class="p">(</span><span class="n">Addr</span> <span class="n">addr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">is_secure</span><span class="p">,</span>
<span class="mi">169</span>                          <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
<span class="mi">170</span>                          <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">CacheBlk</span><span class="o">*&gt;&amp;</span> <span class="n">evict_blks</span><span class="p">)</span> <span class="k">override</span>
<span class="mi">171</span>     <span class="p">{</span>
<span class="mi">172</span>         <span class="c1">// Get possible entries to be victimized</span>
<span class="mi">173</span>         <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ReplaceableEntry</span><span class="o">*&gt;</span> <span class="n">entries</span> <span class="o">=</span>
<span class="mi">174</span>             <span class="n">indexingPolicy</span><span class="o">-&gt;</span><span class="n">getPossibleEntries</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="mi">175</span> 
<span class="mi">176</span>         <span class="c1">// Choose replacement victim from replacement candidates</span>
<span class="mi">177</span>         <span class="n">CacheBlk</span><span class="o">*</span> <span class="n">victim</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">CacheBlk</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">replacementPolicy</span><span class="o">-&gt;</span><span class="n">getVictim</span><span class="p">(</span>
<span class="mi">178</span>                                 <span class="n">entries</span><span class="p">));</span>
<span class="mi">179</span> 
<span class="mi">180</span>         <span class="c1">// There is only one eviction for this replacement</span>
<span class="mi">181</span>         <span class="n">evict_blks</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">victim</span><span class="p">);</span>
<span class="mi">182</span> 
<span class="mi">183</span>         <span class="k">return</span> <span class="n">victim</span><span class="p">;</span>
<span class="mi">184</span>     <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>getPossibleEntries select entries of one set 
associated with the address passed to the findVictim function.
Because it returns N-ways of entries mapped to one set, 
the getVictim function should search proper entry to evict.
As a result, one entry will be selected and pushed into the eviction list.
For further memory allocation, the invalidated block is returned.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td><td class="rouge-code"><pre> <span class="mi">864</span> <span class="kt">bool</span>
 <span class="mi">865</span> <span class="n">BaseCache</span><span class="o">::</span><span class="n">handleEvictions</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">CacheBlk</span><span class="o">*&gt;</span> <span class="o">&amp;</span><span class="n">evict_blks</span><span class="p">,</span>
 <span class="mi">866</span>     <span class="n">PacketList</span> <span class="o">&amp;</span><span class="n">writebacks</span><span class="p">)</span>
 <span class="mi">867</span> <span class="p">{</span>
 <span class="mi">868</span>     <span class="kt">bool</span> <span class="n">replacement</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
 <span class="mi">869</span>     <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">blk</span> <span class="o">:</span> <span class="n">evict_blks</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">870</span>         <span class="k">if</span> <span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">isValid</span><span class="p">())</span> <span class="p">{</span>
 <span class="mi">871</span>             <span class="n">replacement</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
 <span class="mi">872</span> 
 <span class="mi">873</span>             <span class="k">const</span> <span class="n">MSHR</span><span class="o">*</span> <span class="n">mshr</span> <span class="o">=</span>
 <span class="mi">874</span>                 <span class="n">mshrQueue</span><span class="p">.</span><span class="n">findMatch</span><span class="p">(</span><span class="n">regenerateBlkAddr</span><span class="p">(</span><span class="n">blk</span><span class="p">),</span> <span class="n">blk</span><span class="o">-&gt;</span><span class="n">isSecure</span><span class="p">());</span>
 <span class="mi">875</span>             <span class="k">if</span> <span class="p">(</span><span class="n">mshr</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">876</span>                 <span class="c1">// Must be an outstanding upgrade or clean request on a block</span>
 <span class="mi">877</span>                 <span class="c1">// we're about to replace</span>
 <span class="mi">878</span>                 <span class="n">assert</span><span class="p">((</span><span class="o">!</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">isSet</span><span class="p">(</span><span class="n">CacheBlk</span><span class="o">::</span><span class="n">WritableBit</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
 <span class="mi">879</span>                     <span class="n">mshr</span><span class="o">-&gt;</span><span class="n">needsWritable</span><span class="p">())</span> <span class="o">||</span> <span class="n">mshr</span><span class="o">-&gt;</span><span class="n">isCleaning</span><span class="p">());</span>
 <span class="mi">880</span>                 <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
 <span class="mi">881</span>             <span class="p">}</span>
 <span class="mi">882</span>         <span class="p">}</span>
 <span class="mi">883</span>     <span class="p">}</span>
 <span class="mi">884</span> 
 <span class="mi">885</span>     <span class="c1">// The victim will be replaced by a new entry, so increase the replacement</span>
 <span class="mi">886</span>     <span class="c1">// counter if a valid block is being replaced</span>
 <span class="mi">887</span>     <span class="nf">if</span> <span class="p">(</span><span class="n">replacement</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">888</span>         <span class="n">stats</span><span class="p">.</span><span class="n">replacements</span><span class="o">++</span><span class="p">;</span>
 <span class="mi">889</span> 
 <span class="mi">890</span>         <span class="c1">// Evict valid blocks associated to this victim block</span>
 <span class="mi">891</span>         <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">blk</span> <span class="o">:</span> <span class="n">evict_blks</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">892</span>             <span class="k">if</span> <span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">isValid</span><span class="p">())</span> <span class="p">{</span>
 <span class="mi">893</span>                 <span class="n">evictBlock</span><span class="p">(</span><span class="n">blk</span><span class="p">,</span> <span class="n">writebacks</span><span class="p">);</span>
 <span class="mi">894</span>             <span class="p">}</span>
 <span class="mi">895</span>         <span class="p">}</span>
 <span class="mi">896</span>     <span class="p">}</span>
 <span class="mi">897</span> 
 <span class="mi">898</span>     <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
 <span class="mi">899</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="mi">1606</span> <span class="kt">void</span>
<span class="mi">1607</span> <span class="n">BaseCache</span><span class="o">::</span><span class="n">evictBlock</span><span class="p">(</span><span class="n">CacheBlk</span> <span class="o">*</span><span class="n">blk</span><span class="p">,</span> <span class="n">PacketList</span> <span class="o">&amp;</span><span class="n">writebacks</span><span class="p">)</span>
<span class="mi">1608</span> <span class="p">{</span>
<span class="mi">1609</span>     <span class="n">PacketPtr</span> <span class="n">pkt</span> <span class="o">=</span> <span class="n">evictBlock</span><span class="p">(</span><span class="n">blk</span><span class="p">);</span>
<span class="mi">1610</span>     <span class="k">if</span> <span class="p">(</span><span class="n">pkt</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1611</span>         <span class="n">writebacks</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>
<span class="mi">1612</span>     <span class="p">}</span>
<span class="mi">1613</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre> <span class="mi">899</span> <span class="n">PacketPtr</span>
 <span class="mi">900</span> <span class="n">Cache</span><span class="o">::</span><span class="n">evictBlock</span><span class="p">(</span><span class="n">CacheBlk</span> <span class="o">*</span><span class="n">blk</span><span class="p">)</span>
 <span class="mi">901</span> <span class="p">{</span>
 <span class="mi">902</span>     <span class="n">PacketPtr</span> <span class="n">pkt</span> <span class="o">=</span> <span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">isSet</span><span class="p">(</span><span class="n">CacheBlk</span><span class="o">::</span><span class="n">DirtyBit</span><span class="p">)</span> <span class="o">||</span> <span class="n">writebackClean</span><span class="p">)</span> <span class="o">?</span>
 <span class="mi">903</span>         <span class="n">writebackBlk</span><span class="p">(</span><span class="n">blk</span><span class="p">)</span> <span class="o">:</span> <span class="n">cleanEvictBlk</span><span class="p">(</span><span class="n">blk</span><span class="p">);</span>
 <span class="mi">904</span> 
 <span class="mi">905</span>     <span class="n">invalidateBlock</span><span class="p">(</span><span class="n">blk</span><span class="p">);</span>
 <span class="mi">906</span> 
 <span class="mi">907</span>     <span class="k">return</span> <span class="n">pkt</span><span class="p">;</span>
 <span class="mi">908</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="rouge-code"><pre><span class="mi">1586</span> <span class="kt">void</span>
<span class="mi">1587</span> <span class="n">BaseCache</span><span class="o">::</span><span class="n">invalidateBlock</span><span class="p">(</span><span class="n">CacheBlk</span> <span class="o">*</span><span class="n">blk</span><span class="p">)</span>
<span class="mi">1588</span> <span class="p">{</span>
<span class="mi">1589</span>     <span class="c1">// If block is still marked as prefetched, then it hasn't been used</span>
<span class="mi">1590</span>     <span class="k">if</span> <span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">wasPrefetched</span><span class="p">())</span> <span class="p">{</span>
<span class="mi">1591</span>         <span class="n">prefetcher</span><span class="o">-&gt;</span><span class="n">prefetchUnused</span><span class="p">();</span>
<span class="mi">1592</span>     <span class="p">}</span>
<span class="mi">1593</span> 
<span class="mi">1594</span>     <span class="c1">// Notify that the data contents for this address are no longer present</span>
<span class="mi">1595</span>     <span class="nf">updateBlockData</span><span class="p">(</span><span class="n">blk</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="n">blk</span><span class="o">-&gt;</span><span class="n">isValid</span><span class="p">());</span>
<span class="mi">1596</span> 
<span class="mi">1597</span>     <span class="c1">// If handling a block present in the Tags, let it do its invalidation</span>
<span class="mi">1598</span>     <span class="c1">// process, which will update stats and invalidate the block itself</span>
<span class="mi">1599</span>     <span class="nf">if</span> <span class="p">(</span><span class="n">blk</span> <span class="o">!=</span> <span class="n">tempBlock</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1600</span>         <span class="n">tags</span><span class="o">-&gt;</span><span class="n">invalidate</span><span class="p">(</span><span class="n">blk</span><span class="p">);</span>
<span class="mi">1601</span>     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="mi">1602</span>         <span class="n">tempBlock</span><span class="o">-&gt;</span><span class="n">invalidate</span><span class="p">();</span>
<span class="mi">1603</span>     <span class="p">}</span>
<span class="mi">1604</span> <span class="p">}</span>   

</pre></td></tr></tbody></table></code></div></div>

<p><em>gem5/src/mem/cache/tags/base_set_assoc.cc</em></p>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre> <span class="mi">88</span> <span class="kt">void</span>
 <span class="mi">89</span> <span class="n">BaseSetAssoc</span><span class="o">::</span><span class="n">invalidate</span><span class="p">(</span><span class="n">CacheBlk</span> <span class="o">*</span><span class="n">blk</span><span class="p">)</span>
 <span class="mi">90</span> <span class="p">{</span>
 <span class="mi">91</span>     <span class="n">BaseTags</span><span class="o">::</span><span class="n">invalidate</span><span class="p">(</span><span class="n">blk</span><span class="p">);</span>
 <span class="mi">92</span> 
 <span class="mi">93</span>     <span class="c1">// Decrease the number of tags in use</span>
 <span class="mi">94</span>     <span class="n">stats</span><span class="p">.</span><span class="n">tagsInUse</span><span class="o">--</span><span class="p">;</span>
 <span class="mi">95</span> 
 <span class="mi">96</span>     <span class="c1">// Invalidate replacement data</span>
 <span class="mi">97</span>     <span class="n">replacementPolicy</span><span class="o">-&gt;</span><span class="n">invalidate</span><span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">replacementData</span><span class="p">);</span>
 <span class="mi">98</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>Because the invalidate function of the BaseTag class is virtual function,
it should be implemented by its children class.
I utilize the base_set_assoc tags for generating cache 
in my system, so I will follow the implementation 
of the BaseSetAssoc class. 
Note that it invokes the invalidate function of the block first
and then invalidate replacement data.</p>

<p><em>gem5/src/mem/cache_blk.hh</em></p>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="rouge-code"><pre> <span class="mi">70</span> <span class="k">class</span> <span class="nc">CacheBlk</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TaggedEntry</span>
 <span class="mi">71</span> <span class="p">{</span>
 <span class="mi">72</span>   <span class="k">public</span><span class="o">:</span>
<span class="p">......</span>
<span class="mi">197</span>     <span class="cm">/**
198      * Invalidate the block and clear all state.
199      */</span>
<span class="mi">200</span>     <span class="k">virtual</span> <span class="kt">void</span> <span class="n">invalidate</span><span class="p">()</span> <span class="k">override</span>
<span class="mi">201</span>     <span class="p">{</span>
<span class="mi">202</span>         <span class="n">TaggedEntry</span><span class="o">::</span><span class="n">invalidate</span><span class="p">();</span>
<span class="mi">203</span> 
<span class="mi">204</span>         <span class="n">clearPrefetched</span><span class="p">();</span>
<span class="mi">205</span>         <span class="n">clearCoherenceBits</span><span class="p">(</span><span class="n">AllBits</span><span class="p">);</span>
<span class="mi">206</span> 
<span class="mi">207</span>         <span class="n">setTaskId</span><span class="p">(</span><span class="n">context_switch_task_id</span><span class="o">::</span><span class="n">Unknown</span><span class="p">);</span>
<span class="mi">208</span>         <span class="n">setWhenReady</span><span class="p">(</span><span class="n">MaxTick</span><span class="p">);</span>
<span class="mi">209</span>         <span class="n">setRefCount</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="mi">210</span>         <span class="n">setSrcRequestorId</span><span class="p">(</span><span class="n">Request</span><span class="o">::</span><span class="n">invldRequestorId</span><span class="p">);</span>
<span class="mi">211</span>         <span class="n">lockList</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<span class="mi">212</span>     <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>Although the invalidate function of the CacheBlk is defined 
as virtual function,
the system utilize the CahceBlk class as it is 
instead of adopting another class inheriting CacheBlk.
Therefore, the invalidate function of the CacheBlk is called.
Most importantly it inovkes the invalidate function 
of its parent class TaggedEntry. 
Also, it clears all the coherence bits and prefetched bit
if they are set.</p>

<p><em>gem5/src/mem/tags/tagged_entry</em></p>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre> <span class="mi">46</span> <span class="k">class</span> <span class="nc">TaggedEntry</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ReplaceableEntry</span>
 <span class="mi">47</span> <span class="p">{</span>
<span class="p">......</span>
<span class="mi">102</span>     <span class="cm">/** Invalidate the block. Its contents are no longer valid. */</span>
<span class="mi">103</span>     <span class="k">virtual</span> <span class="kt">void</span> <span class="n">invalidate</span><span class="p">()</span>
<span class="mi">104</span>     <span class="p">{</span>
<span class="mi">105</span>         <span class="n">_valid</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="mi">106</span>         <span class="n">setTag</span><span class="p">(</span><span class="n">MaxAddr</span><span class="p">);</span>
<span class="mi">107</span>         <span class="n">clearSecure</span><span class="p">();</span>
<span class="mi">108</span>     <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>Finally, it sets the _valid member field 
of the CacheBlk as false and clear secure flag.</p>


  </div>

  <div class="post-tail-wrapper text-muted">
    <!-- categories -->
    
      <div class="post-meta mb-3">
        <i class="far fa-folder-open fa-fw me-1"></i>
        
          <a href="/categories/gem5/">GEM5</a>,
          <a href="/categories/pipeline/">Pipeline</a>,
          <a href="/categories/o3/">O3</a>
      </div>
    

    <!-- tags -->
    

    <div
      class="
        post-tail-bottom
        d-flex justify-content-between align-items-center mt-5 pb-2
      "
    >
      <div class="license-wrapper">
        
          

          This post is licensed under 
        <a href="https://creativecommons.org/licenses/by/4.0/">
          CC BY 4.0
        </a>
         by the author.
        
      </div>

      <!-- Post sharing snippet -->

<div class="share-wrapper d-flex align-items-center">
  <span class="share-label text-muted">Share</span>
  <span class="share-icons">
    
    
    

    

      

      <a
        href="https://twitter.com/intent/tweet?text=O3%20Cpu%20Commit%20-%20Ruach&url=https%3A%2F%2Fruach.github.io%2Fposts%2FO3-CPU-commit%2F"
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="Twitter"
        target="_blank"
        rel="noopener"
        aria-label="Twitter"
      >
        <i class="fa-fw fa-brands fa-square-x-twitter"></i>
      </a>
    

      

      <a
        href="https://www.facebook.com/sharer/sharer.php?title=O3%20Cpu%20Commit%20-%20Ruach&u=https%3A%2F%2Fruach.github.io%2Fposts%2FO3-CPU-commit%2F"
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="Facebook"
        target="_blank"
        rel="noopener"
        aria-label="Facebook"
      >
        <i class="fa-fw fab fa-facebook-square"></i>
      </a>
    

      

      <a
        href="https://t.me/share/url?url=https%3A%2F%2Fruach.github.io%2Fposts%2FO3-CPU-commit%2F&text=O3%20Cpu%20Commit%20-%20Ruach"
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="Telegram"
        target="_blank"
        rel="noopener"
        aria-label="Telegram"
      >
        <i class="fa-fw fab fa-telegram"></i>
      </a>
    

      

      <a
        href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fruach.github.io%2Fposts%2FO3-CPU-commit%2F"
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="Linkedin"
        target="_blank"
        rel="noopener"
        aria-label="Linkedin"
      >
        <i class="fa-fw fab fa-linkedin"></i>
      </a>
    

    <button
      id="copy-link"
      aria-label="Copy link"
      class="btn small"
      data-bs-toggle="tooltip"
      data-bs-placement="top"
      title="Copy link"
      data-title-succeed="Link copied successfully!"
    >
      <i class="fa-fw fas fa-link pe-none fs-6"></i>
    </button>
  </span>
</div>

    </div>
    <!-- .post-tail-bottom -->
  </div>
  <!-- div.post-tail-wrapper -->
</article>


            
          </main>

          <!-- panel -->
          <aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 mb-5 text-muted">
            <div class="access">
              <!-- Get the last 5 posts from lastmod list. -->















              <!-- The trending tags list -->


















            </div>

            
              
              



  <section id="toc-wrapper" class="ps-0 pe-4">
    <h2 class="panel-heading ps-3 pt-2 mb-2">Contents</h2>
    <nav id="toc"></nav>
  </section>


            
          </aside>
        </div>

        <div class="row">
          <!-- tail -->
          <div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4">
            
              
              <!-- Recommend the other 3 posts according to the tags and categories of the current post. -->

<!-- The total size of related posts -->


<!-- An random integer that bigger than 0 -->


<!-- Equals to TAG_SCORE / {max_categories_hierarchy} -->














  

  

  

  

  

  

  

  
    
  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  











  <aside id="related-posts" aria-labelledby="related-label">
    <h3 class="mb-4" id="related-label">Further Reading</h3>
    <nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4">
      
        <article class="col">
          <a href="/posts/O3-CPU-Fetch/" class="post-preview card h-100">
            <div class="card-body">
              <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->




<time
  
  data-ts="1622088000"
  data-df="ll"
  
>
  May 27, 2021
</time>

              <h4 class="pt-0 my-2">O3 Cpu Fetch</h4>
              <div class="text-muted">
                <p>
                  





                  Fetch
 895 template &amp;lt;class Impl&amp;gt;
 896 void
 897 DefaultFetch&amp;lt;Impl&amp;gt;::tick()
 898 {
 899     list&amp;lt;ThreadID&amp;gt;::iterator threads = activeThreads-&amp;gt;begin();
 900     list&amp;lt;ThreadID&amp;...
                </p>
              </div>
            </div>
          </a>
        </article>
      
        <article class="col">
          <a href="/posts/O3-CPU-Decode/" class="post-preview card h-100">
            <div class="card-body">
              <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->




<time
  
  data-ts="1622174400"
  data-df="ll"
  
>
  May 28, 2021
</time>

              <h4 class="pt-0 my-2">O3 Cpu Decode</h4>
              <div class="text-muted">
                <p>
                  





                  Sending fetched instructions to decode stage
gem5/src/cpu/o3/fetch_impl.hh
 961 
 962     // Pick a random thread to start trying to grab instructions from
 963     auto tid_itr = activeThreads-&amp;gt...
                </p>
              </div>
            </div>
          </a>
        </article>
      
        <article class="col">
          <a href="/posts/O3-CPU-rename/" class="post-preview card h-100">
            <div class="card-body">
              <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->




<time
  
  data-ts="1622260800"
  data-df="ll"
  
>
  May 29, 2021
</time>

              <h4 class="pt-0 my-2">O3 Cpu Rename</h4>
              <div class="text-muted">
                <p>
                  





                  Rename
It maintains the rename history of all instructions 
with destination registers, storing the arch register, 
the new physical register, and the old physical register.
The information is requ...
                </p>
              </div>
            </div>
          </a>
        </article>
      
    </nav>
  </aside>
  <!-- #related-posts -->


            
              
              <!-- Navigation buttons at the bottom of the post. -->

<nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation">
  
  

  
    <a
      href="/posts/O3-CPU-commit/"
      class="btn btn-outline-primary"
      aria-label="Older"
    >
      <p>O3 Cpu Commit</p>
    </a>
  

  
    <a
      href="/posts/O3-cache-recv/"
      class="btn btn-outline-primary"
      aria-label="Newer"
    >
      <p>O3 Cache Recv</p>
    </a>
  
</nav>

            
              
              <!--  The comments switcher -->

  
  <!-- The Disqus lazy loading. -->

<div id="disqus_thread">
  <p class="text-center text-muted small">Comments powered by <a href="https://disqus.com/">Disqus</a>.</p>
</div>

<script type="text/javascript">
  var disqus_config = function () {
    this.page.url = 'https://ruach.github.io/posts/O3-CPU-commit/';
    this.page.identifier = '/posts/O3-CPU-commit/';
  };

  /* Lazy loading */
  var disqus_observer = new IntersectionObserver(
    function (entries) {
      if (entries[0].isIntersecting) {
        (function () {
          var d = document,
            s = d.createElement('script');
          s.src = 'https://ruach.disqus.com/embed.js';
          s.setAttribute('data-timestamp', +new Date());
          (d.head || d.body).appendChild(s);
        })();

        disqus_observer.disconnect();
      }
    },
    { threshold: [0] }
  );

  disqus_observer.observe(document.querySelector('#disqus_thread'));

  /* Auto switch theme */
  function reloadDisqus() {
    if (event.source === window && event.data && event.data.direction === ModeToggle.ID) {
      /* Disqus hasn't been loaded */
      if (typeof DISQUS === 'undefined') {
        return;
      }

      if (document.readyState == 'complete') {
        DISQUS.reset({ reload: true, config: disqus_config });
      }
    }
  }

  if (document.querySelector('.mode-toggle')) {
    window.addEventListener('message', reloadDisqus);
  }
</script>



            

            <!-- The Footer -->

<footer
  aria-label="Site Info"
  class="
    d-flex flex-column justify-content-center text-muted
    flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3
  "
>
  <p>
    ©
    <time>2024</time>
    <a href="https://ruach.github.io">Jaehyuk Lee</a>.
    
      <span
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author."
      >Some rights reserved.</span>
    
  </p>

  <p>Using the <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme for <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>
  </p>
</footer>

          </div>
        </div>

        <!-- The Search results -->

<div id="search-result-wrapper" class="d-flex justify-content-center unloaded">
  <div class="col-11 content">
    <div id="search-hints">
      <!-- The trending tags list -->


















    </div>
    <div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div>
  </div>
</div>

      </div>

      <aside aria-label="Scroll to Top">
        <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow">
          <i class="fas fa-angle-up"></i>
        </button>
      </aside>
    </div>

    <div id="mask"></div>

    
      <aside
  id="notification"
  class="toast"
  role="alert"
  aria-live="assertive"
  aria-atomic="true"
  data-bs-animation="true"
  data-bs-autohide="false"
>
  <div class="toast-header">
    <button
      type="button"
      class="btn-close ms-auto"
      data-bs-dismiss="toast"
      aria-label="Close"
    ></button>
  </div>
  <div class="toast-body text-center pt-0">
    <p class="px-2 mb-3">A new version of content is available.</p>
    <button type="button" class="btn btn-primary" aria-label="Update">
      Update
    </button>
  </div>
</aside>

    

    <!-- JavaScripts -->

    <!-- JS selector for site. -->

<!-- commons -->



<!-- layout specified -->


  

  
    <!-- image lazy-loading & popup & clipboard -->
    
  















  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  



  <script src="https://cdn.jsdelivr.net/combine/npm/jquery@3.7.1/dist/jquery.min.js,npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js,npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/magnific-popup@1.1.0/dist/jquery.magnific-popup.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.10/dayjs.min.js,npm/dayjs@1.11.10/locale/en.min.js,npm/dayjs@1.11.10/plugin/relativeTime.min.js,npm/dayjs@1.11.10/plugin/localizedFormat.min.js,npm/tocbot@4.21.2/dist/tocbot.min.js"></script>






<script defer src="/assets/js/dist/post.min.js"></script>






    

    <!--
  Jekyll Simple Search loader
  See: <https://github.com/christian-fei/Simple-Jekyll-Search>
-->





<script>
  /* Note: dependent library will be loaded in `js-selector.html` */
  SimpleJekyllSearch({
    searchInput: document.getElementById('search-input'),
    resultsContainer: document.getElementById('search-results'),
    json: '/assets/js/data/search.json',
    searchResultTemplate: '  <article class="px-1 px-sm-2 px-lg-4 px-xl-0">    <header>      <h2><a href="{url}">{title}</a></h2>      <div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1">        {categories}        {tags}      </div>    </header>    <p>{snippet}</p>  </article>',
    noResultsText: '<p class="mt-5"></p>',
    templateMiddleware: function(prop, value, template) {
      if (prop === 'categories') {
        if (value === '') {
          return `${value}`;
        } else {
          return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`;
        }
      }

      if (prop === 'tags') {
        if (value === '') {
          return `${value}`;
        } else {
          return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`;
        }
      }
    }
  });
</script>

  </body>
</html>

