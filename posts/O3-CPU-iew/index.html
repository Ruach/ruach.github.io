<!doctype html>














<!-- `site.alt_lang` can specify a language different from the UI -->
<html lang="en" data-mode="light">
  <!-- The Head -->

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta
    name="viewport"
    content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover"
  >

  

  

  
    <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v4.3.2" />
<meta property="og:title" content="O3 Cpu Iew" />
<meta property="og:locale" content="en" />
<meta name="description" content="IEW: Issue/Execute/Writeback GEM5 handles both execute and writeback when the execute() function is called on an instruction. Therefore, GEM5 combines Issue, Execute, and Writeback stage into one stage called IEW. This stage (IEW) handles dispatching instructions to the instruction queue, telling the instruction queue to issue instruction, and executing and writing back instructions." />
<meta property="og:description" content="IEW: Issue/Execute/Writeback GEM5 handles both execute and writeback when the execute() function is called on an instruction. Therefore, GEM5 combines Issue, Execute, and Writeback stage into one stage called IEW. This stage (IEW) handles dispatching instructions to the instruction queue, telling the instruction queue to issue instruction, and executing and writing back instructions." />
<link rel="canonical" href="http://localhost:4000/posts/O3-CPU-iew/" />
<meta property="og:url" content="http://localhost:4000/posts/O3-CPU-iew/" />
<meta property="og:site_name" content="Ruach" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-06-01T00:00:00-04:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="O3 Cpu Iew" />
<meta name="twitter:site" content="@ruach_lee" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2021-06-01T00:00:00-04:00","datePublished":"2021-06-01T00:00:00-04:00","description":"IEW: Issue/Execute/Writeback GEM5 handles both execute and writeback when the execute() function is called on an instruction. Therefore, GEM5 combines Issue, Execute, and Writeback stage into one stage called IEW. This stage (IEW) handles dispatching instructions to the instruction queue, telling the instruction queue to issue instruction, and executing and writing back instructions.","headline":"O3 Cpu Iew","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/posts/O3-CPU-iew/"},"url":"http://localhost:4000/posts/O3-CPU-iew/"}</script>
<!-- End Jekyll SEO tag -->

  

  <title>O3 Cpu Iew | Ruach
  </title>

  <!--
  The Favicons for Web, Android, Microsoft, and iOS (iPhone and iPad) Apps
  Generated by: https://realfavicongenerator.net/
-->



<link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png">
<link rel="manifest" href="/assets/img/favicons/site.webmanifest">
<link rel="shortcut icon" href="/assets/img/favicons/favicon.ico">
<meta name="apple-mobile-web-app-title" content="Ruach">
<meta name="application-name" content="Ruach">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml">
<meta name="theme-color" content="#ffffff">


  
    
      <link rel="preconnect" href="https://fonts.googleapis.com" >
      <link rel="dns-prefetch" href="https://fonts.googleapis.com" >
    
      <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
      <link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin>
    
      <link rel="preconnect" href="https://fonts.googleapis.com" >
      <link rel="dns-prefetch" href="https://fonts.googleapis.com" >
    
      <link rel="preconnect" href="https://cdn.jsdelivr.net" >
      <link rel="dns-prefetch" href="https://cdn.jsdelivr.net" >
    

    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap">
  

  <!-- GA -->
  

  <!-- Bootstrap -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css">

  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.2/css/all.min.css">

  <link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css">

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.21.2/dist/tocbot.min.css">
  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css">
  

  
    <!-- Manific Popup -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css">
  

  <!-- JavaScript -->

  

  <!-- A placeholder to allow defining custom metadata -->

</head>


  <body>
    <!-- The Side Bar -->

<aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end">
  <header class="profile-wrapper">
    <a href="/" id="avatar" class="rounded-circle">
      
        
        <img src="/assets/img/jaehyuk.png" width="112" height="112" alt="avatar" onerror="this.style.display='none'">
      
    </a>

    <h1 class="site-title">
      <a href="/">Ruach</a>
    </h1>
    <p class="site-subtitle fst-italic mb-0">Security Researcher at Gatech</p>
  </header>
  <!-- .profile-wrapper -->

  <nav class="flex-column flex-grow-1 w-100 ps-0">
    <ul class="nav">
      <!-- home -->
      <li class="nav-item">
        <a href="/" class="nav-link">
          <i class="fa-fw fas fa-home"></i>
          <span>HOME</span>
        </a>
      </li>
      <!-- the real tabs -->
      
        <li class="nav-item">
          <a href="/categories/" class="nav-link">
            <i class="fa-fw fas fa-stream"></i>
            

            <span>CATEGORIES</span>
          </a>
        </li>
        <!-- .nav-item -->
      
        <li class="nav-item">
          <a href="/tags/" class="nav-link">
            <i class="fa-fw fas fa-tags"></i>
            

            <span>TAGS</span>
          </a>
        </li>
        <!-- .nav-item -->
      
        <li class="nav-item">
          <a href="/archives/" class="nav-link">
            <i class="fa-fw fas fa-archive"></i>
            

            <span>ARCHIVES</span>
          </a>
        </li>
        <!-- .nav-item -->
      
        <li class="nav-item">
          <a href="/about/" class="nav-link">
            <i class="fa-fw fas fa-info-circle"></i>
            

            <span>ABOUT</span>
          </a>
        </li>
        <!-- .nav-item -->
      
    </ul>
  </nav>

  <div class="sidebar-bottom d-flex flex-wrap  align-items-center w-100">
    

    
      

      
        <a
          href="javascript:location.href = 'mailto:' + ['jaehyuk','gatech.edu'].join('@')"
          aria-label="email"
          

          

          

          
        >
          <i class="fas fa-envelope"></i>
        </a>
      
    
      

      
        <a
          href="https://www.linkedin.com/in/jaehyuk-lee-29b33b121/"
          aria-label="linkedin"
          

          
            target="_blank"
            
          

          

          
            rel="noopener noreferrer"
          
        >
          <i class="fab fa-linkedin"></i>
        </a>
      
    
      

      
        <a
          href="https://github.com/Ruach"
          aria-label="github"
          

          
            target="_blank"
            
          

          

          
            rel="noopener noreferrer"
          
        >
          <i class="fab fa-github"></i>
        </a>
      
    
      

      
        <a
          href="https://stackoverflow.com/users/4460514/ruach?tab=profile"
          aria-label="stack-overflow"
          

          
            target="_blank"
            
          

          

          
            rel="noopener noreferrer"
          
        >
          <i class="fab fa-stack-overflow"></i>
        </a>
      
    
  </div>
  <!-- .sidebar-bottom -->
</aside>
<!-- #sidebar -->


    <div id="main-wrapper" class="d-flex justify-content-center">
      <div class="container d-flex flex-column px-xxl-5">
        <!-- The Top Bar -->

<header id="topbar-wrapper" aria-label="Top Bar">
  <div
    id="topbar"
    class="d-flex align-items-center justify-content-between px-lg-3 h-100"
  >
    <nav id="breadcrumb" aria-label="Breadcrumb">
      

      
        
          
            <span>
              <a href="/">
                Home
              </a>
            </span>

          
        
          
        
          
            
              <span>O3 Cpu Iew</span>
            

          
        
      
    </nav>
    <!-- endof #breadcrumb -->

    <button type="button" id="sidebar-trigger" class="btn btn-link">
      <i class="fas fa-bars fa-fw"></i>
    </button>

    <div id="topbar-title">
      Post
    </div>

    <button type="button" id="search-trigger" class="btn btn-link">
      <i class="fas fa-search fa-fw"></i>
    </button>

    <search class="align-items-center ms-3 ms-lg-0">
      <i class="fas fa-search fa-fw"></i>
      <input
        class="form-control"
        id="search-input"
        type="search"
        aria-label="search"
        autocomplete="off"
        placeholder="Search..."
      >
    </search>
    <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button>
  </div>
</header>


        <div class="row flex-grow-1">
          <main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4">
            
              <!-- Refactor the HTML structure -->



<!--
  In order to allow a wide table to scroll horizontally,
  we suround the markdown table with `<div class="table-wrapper">` and `</div>`
-->



<!--
  Fixed kramdown code highlight rendering:
  https://github.com/penibelst/jekyll-compress-html/issues/101
  https://github.com/penibelst/jekyll-compress-html/issues/71#issuecomment-188144901
-->



<!-- Change the icon of checkbox -->



<!-- Handle images -->





<!-- Add header for code snippets -->



<!-- Create heading anchors -->





  
  

  
    
    

    
      
        
        
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    

    
  

  
  

  
    
    

    
      
        
        
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    

    
  

  
  

  

  
  

  




<!-- return -->




<article class="px-1">
  <header>
    <h1 data-toc-skip>O3 Cpu Iew</h1>

    <div class="post-meta text-muted">
      <!-- published date -->
      <span>
        Posted
        <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->




<time
  
  data-ts="1622520000"
  data-df="ll"
  
    data-bs-toggle="tooltip" data-bs-placement="bottom"
  
>
  Jun  1, 2021
</time>

      </span>

      <!-- lastmod date -->
      

      

      <div class="d-flex justify-content-between">
        <!-- author(s) -->
        <span>
          

          By

          <em>
            
              <a href="https://ruach.github.io">Jaehyuk Lee</a>
            
          </em>
        </span>

        <!-- read time -->
        <!-- Calculate the post's reading time, and display the word count in tooltip -->



<!-- words per minute -->










<!-- return element -->
<span
  class="readtime"
  data-bs-toggle="tooltip"
  data-bs-placement="bottom"
  title="8214 words"
>
  <em>45 min</em> read</span>

      </div>
      <!-- .d-flex -->
    </div>
    <!-- .post-meta -->
  </header>

  <div class="content">
    <h1 id="iew-issueexecutewriteback">IEW: Issue/Execute/Writeback</h1>
<blockquote>
  <p>GEM5 handles both execute and writeback when the execute() 
function is called on an instruction. Therefore, GEM5 combines 
Issue, Execute, and Writeback stage into one stage called IEW. 
This stage (IEW) handles dispatching instructions to the 
instruction queue, telling the instruction queue to issue 
instruction, and executing and writing back instructions.</p>
</blockquote>

<p>Nice description about the IEW stage provided by the <cite><a href="https://www.gem5.org/documentation/general_docs/cpu_models/O3CPU">GEM5 Documentation</a></cite>.
Also, this documentation provide which functions are mainly 
designed to achieve those three operations.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="n">Rename</span><span class="o">::</span><span class="n">tick</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Rename</span><span class="o">::</span><span class="n">RenameInsts</span><span class="p">()</span>
<span class="n">IEW</span><span class="o">::</span><span class="n">tick</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">IEW</span><span class="o">::</span><span class="n">dispatchInsts</span><span class="p">()</span>
<span class="n">IEW</span><span class="o">::</span><span class="n">tick</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">InstructionQueue</span><span class="o">::</span><span class="n">scheduleReadyInsts</span><span class="p">()</span>
<span class="n">IEW</span><span class="o">::</span><span class="n">tick</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">IEW</span><span class="o">::</span><span class="n">executeInsts</span><span class="p">()</span>
<span class="n">IEW</span><span class="o">::</span><span class="n">tick</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">IEW</span><span class="o">::</span><span class="n">writebackInsts</span><span class="p">()</span>
</pre></td></tr></tbody></table></code></div></div>

<p>In this posting, I will explain dispatch, schedule, execute, and write back in details.
The commit stage will be studied in the other posting. 
The tick function of the iew stage is the main body of execution as other stages. 
Therefore, I will explain each part of the iew stage 
following the tick implementation. 
The dispatch function tries to dispatch 
renamed instructions to the LSQ/IQ 
(Note that already the rename stage checked 
availability of the LSQ and IQ)
and actually issues instructions every cycle. 
The execute latency is actually tied to the issue latency 
to allow the IQ to be able to do back-to-back scheduling 
without having to speculatively schedule instructions. 
The IEW separates 
memory instructions from non-memory instructions.
(issuing the instruction to different queues, LSQ or IQ) 
The writeback portion of IEW completes the instructions,
wakes up any dependents, and marks the register as ready on the scoreboard.
With those information,
IQ can tell which instructions 
can be woke up and to be issued.</p>

<h2 id="dispatch"><span class="me-2">Dispatch</span><a href="#dispatch" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="rouge-code"><pre><span class="mi">1502</span> <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Impl</span><span class="p">&gt;</span>
<span class="mi">1503</span> <span class="kt">void</span>
<span class="mi">1504</span> <span class="n">DefaultIEW</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;::</span><span class="n">tick</span><span class="p">()</span>
<span class="mi">1505</span> <span class="p">{</span>
<span class="mi">1506</span>     <span class="n">wbNumInst</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="mi">1507</span>     <span class="n">wbCycle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="mi">1508</span> 
<span class="mi">1509</span>     <span class="n">wroteToTimeBuffer</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="mi">1510</span>     <span class="n">updatedQueues</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="mi">1511</span> 
<span class="mi">1512</span>     <span class="n">ldstQueue</span><span class="p">.</span><span class="n">tick</span><span class="p">();</span>
<span class="mi">1513</span> 
<span class="mi">1514</span>     <span class="n">sortInsts</span><span class="p">();</span>
<span class="mi">1515</span> 
<span class="mi">1516</span>     <span class="c1">// Free function units marked as being freed this cycle.</span>
<span class="mi">1517</span>     <span class="n">fuPool</span><span class="o">-&gt;</span><span class="n">processFreeUnits</span><span class="p">();</span>
<span class="mi">1518</span> 
<span class="mi">1519</span>     <span class="n">list</span><span class="o">&lt;</span><span class="n">ThreadID</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">threads</span> <span class="o">=</span> <span class="n">activeThreads</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">();</span>
<span class="mi">1520</span>     <span class="n">list</span><span class="o">&lt;</span><span class="n">ThreadID</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">end</span> <span class="o">=</span> <span class="n">activeThreads</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">();</span>
<span class="mi">1521</span> 
<span class="mi">1522</span>     <span class="c1">// Check stall and squash signals, dispatch any instructions.</span>
<span class="mi">1523</span>     <span class="k">while</span> <span class="p">(</span><span class="n">threads</span> <span class="o">!=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1524</span>         <span class="n">ThreadID</span> <span class="n">tid</span> <span class="o">=</span> <span class="o">*</span><span class="n">threads</span><span class="o">++</span><span class="p">;</span>
<span class="mi">1525</span> 
<span class="mi">1526</span>         <span class="n">DPRINTF</span><span class="p">(</span><span class="n">IEW</span><span class="p">,</span><span class="s">"Issue: Processing [tid:%i]</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">tid</span><span class="p">);</span>
<span class="mi">1527</span> 
<span class="mi">1528</span>         <span class="n">checkSignalsAndUpdate</span><span class="p">(</span><span class="n">tid</span><span class="p">);</span>
<span class="mi">1529</span>         <span class="n">dispatch</span><span class="p">(</span><span class="n">tid</span><span class="p">);</span>
<span class="mi">1530</span>     <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>As shown in the tick function, 
after checking signal such as block and squash, 
the first job done by the IEW is dispatching the renamed instructions. 
The main goal of the dispatch is 
inserting the renamed instruction into the IQ and LSQ
based on the instruction’s type.</p>

<h3 id="dispatch-implementation"><span class="me-2">Dispatch implementation</span><a href="#dispatch-implementation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre></td><td class="rouge-code"><pre> <span class="mi">911</span> <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Impl</span><span class="p">&gt;</span>
 <span class="mi">912</span> <span class="kt">void</span>
 <span class="mi">913</span> <span class="n">DefaultIEW</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;::</span><span class="n">dispatch</span><span class="p">(</span><span class="n">ThreadID</span> <span class="n">tid</span><span class="p">)</span>
 <span class="mi">914</span> <span class="p">{</span>
 <span class="mi">915</span>     <span class="c1">// If status is Running or idle,</span>
 <span class="mi">916</span>     <span class="c1">//     call dispatchInsts()</span>
 <span class="mi">917</span>     <span class="c1">// If status is Unblocking,</span>
 <span class="mi">918</span>     <span class="c1">//     buffer any instructions coming from rename</span>
 <span class="mi">919</span>     <span class="c1">//     continue trying to empty skid buffer</span>
 <span class="mi">920</span>     <span class="c1">//     check if stall conditions have passed</span>
 <span class="mi">921</span> 
 <span class="mi">922</span>     <span class="k">if</span> <span class="p">(</span><span class="n">dispatchStatus</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">==</span> <span class="n">Blocked</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">923</span>         <span class="o">++</span><span class="n">iewBlockCycles</span><span class="p">;</span>
 <span class="mi">924</span> 
 <span class="mi">925</span>     <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">dispatchStatus</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">==</span> <span class="n">Squashing</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">926</span>         <span class="o">++</span><span class="n">iewSquashCycles</span><span class="p">;</span>
 <span class="mi">927</span>     <span class="p">}</span>
 <span class="mi">928</span> 
 <span class="mi">929</span>     <span class="c1">// Dispatch should try to dispatch as many instructions as its bandwidth</span>
 <span class="mi">930</span>     <span class="c1">// will allow, as long as it is not currently blocked.</span>
 <span class="mi">931</span>     <span class="nf">if</span> <span class="p">(</span><span class="n">dispatchStatus</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">==</span> <span class="n">Running</span> <span class="o">||</span>
 <span class="mi">932</span>         <span class="n">dispatchStatus</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">==</span> <span class="n">Idle</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">933</span>         <span class="n">DPRINTF</span><span class="p">(</span><span class="n">IEW</span><span class="p">,</span> <span class="s">"[tid:%i] Not blocked, so attempting to run "</span>
 <span class="mi">934</span>                 <span class="s">"dispatch.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">tid</span><span class="p">);</span>
 <span class="mi">935</span> 
 <span class="mi">936</span>         <span class="n">dispatchInsts</span><span class="p">(</span><span class="n">tid</span><span class="p">);</span>
 <span class="mi">937</span>     <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">dispatchStatus</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">==</span> <span class="n">Unblocking</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">938</span>         <span class="c1">// Make sure that the skid buffer has something in it if the</span>
 <span class="mi">939</span>         <span class="c1">// status is unblocking.</span>
 <span class="mi">940</span>         <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">skidsEmpty</span><span class="p">());</span>
 <span class="mi">941</span> 
 <span class="mi">942</span>         <span class="c1">// If the status was unblocking, then instructions from the skid</span>
 <span class="mi">943</span>         <span class="c1">// buffer were used.  Remove those instructions and handle</span>
 <span class="mi">944</span>         <span class="c1">// the rest of unblocking.</span>
 <span class="mi">945</span>         <span class="n">dispatchInsts</span><span class="p">(</span><span class="n">tid</span><span class="p">);</span>
 <span class="mi">946</span> 
 <span class="mi">947</span>         <span class="o">++</span><span class="n">iewUnblockCycles</span><span class="p">;</span>
 <span class="mi">948</span> 
 <span class="mi">949</span>         <span class="k">if</span> <span class="p">(</span><span class="n">validInstsFromRename</span><span class="p">())</span> <span class="p">{</span>
 <span class="mi">950</span>             <span class="c1">// Add the current inputs to the skid buffer so they can be</span>
 <span class="mi">951</span>             <span class="c1">// reprocessed when this stage unblocks.</span>
 <span class="mi">952</span>             <span class="n">skidInsert</span><span class="p">(</span><span class="n">tid</span><span class="p">);</span>
 <span class="mi">953</span>         <span class="p">}</span>
 <span class="mi">954</span> 
 <span class="mi">955</span>         <span class="nf">unblock</span><span class="p">(</span><span class="n">tid</span><span class="p">);</span>
 <span class="mi">956</span>     <span class="p">}</span>
 <span class="mi">957</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>The dispatch function is just a wrapper function of the dispatchInsts. 
Based on the current status of the dispatch stage, 
associated operations should be executed 
in addition to the main dispatch function, dispatchInsts.
Because the dispatchInsts is fairly complex, 
I will explain one by one.</p>

<h3 id="checking-availability-of-resources-to-dispatch-instruction"><span class="me-2">Checking availability of resources to dispatch instruction</span><a href="#checking-availability-of-resources-to-dispatch-instruction" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
</pre></td><td class="rouge-code"><pre><span class="mi">959</span> <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Impl</span><span class="p">&gt;</span>
 <span class="mi">960</span> <span class="kt">void</span>
 <span class="mi">961</span> <span class="n">DefaultIEW</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;::</span><span class="n">dispatchInsts</span><span class="p">(</span><span class="n">ThreadID</span> <span class="n">tid</span><span class="p">)</span>
 <span class="mi">962</span> <span class="p">{</span>
 <span class="mi">963</span>     <span class="c1">// Obtain instructions from skid buffer if unblocking, or queue from rename</span>
 <span class="mi">964</span>     <span class="c1">// otherwise.</span>
 <span class="mi">965</span>     <span class="n">std</span><span class="o">::</span><span class="n">queue</span><span class="o">&lt;</span><span class="n">DynInstPtr</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">insts_to_dispatch</span> <span class="o">=</span>
 <span class="mi">966</span>         <span class="n">dispatchStatus</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">==</span> <span class="n">Unblocking</span> <span class="o">?</span>
 <span class="mi">967</span>         <span class="n">skidBuffer</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">:</span> <span class="n">insts</span><span class="p">[</span><span class="n">tid</span><span class="p">];</span>
 <span class="mi">968</span> 
 <span class="mi">969</span>     <span class="kt">int</span> <span class="n">insts_to_add</span> <span class="o">=</span> <span class="n">insts_to_dispatch</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
 <span class="mi">970</span> 
 <span class="mi">971</span>     <span class="n">DynInstPtr</span> <span class="n">inst</span><span class="p">;</span>
 <span class="mi">972</span>     <span class="kt">bool</span> <span class="n">add_to_iq</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
 <span class="mi">973</span>     <span class="kt">int</span> <span class="n">dis_num_inst</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="mi">974</span> 
 <span class="mi">975</span>     <span class="c1">// Loop through the instructions, putting them in the instruction</span>
 <span class="mi">976</span>     <span class="c1">// queue.</span>
 <span class="mi">977</span>     <span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="n">dis_num_inst</span> <span class="o">&lt;</span> <span class="n">insts_to_add</span> <span class="o">&amp;&amp;</span>
 <span class="mi">978</span>               <span class="n">dis_num_inst</span> <span class="o">&lt;</span> <span class="n">dispatchWidth</span><span class="p">;</span>
 <span class="mi">979</span>           <span class="o">++</span><span class="n">dis_num_inst</span><span class="p">)</span>
 <span class="mi">980</span>     <span class="p">{</span>
 <span class="mi">981</span>         <span class="n">inst</span> <span class="o">=</span> <span class="n">insts_to_dispatch</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
 <span class="mi">982</span> 
 <span class="mi">983</span>         <span class="k">if</span> <span class="p">(</span><span class="n">dispatchStatus</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">==</span> <span class="n">Unblocking</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">984</span>             <span class="n">DPRINTF</span><span class="p">(</span><span class="n">IEW</span><span class="p">,</span> <span class="s">"[tid:%i] Issue: Examining instruction from skid "</span>
 <span class="mi">985</span>                     <span class="s">"buffer</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">tid</span><span class="p">);</span>
 <span class="mi">986</span>         <span class="p">}</span>
 <span class="mi">987</span> 
 <span class="mi">988</span>         <span class="c1">// Make sure there's a valid instruction there.</span>
 <span class="mi">989</span>         <span class="nf">assert</span><span class="p">(</span><span class="n">inst</span><span class="p">);</span>
 <span class="mi">990</span> 
 <span class="mi">991</span>         <span class="nf">DPRINTF</span><span class="p">(</span><span class="n">IEW</span><span class="p">,</span> <span class="s">"[tid:%i] Issue: Adding PC %s [sn:%lli] [tid:%i] to "</span>
 <span class="mi">992</span>                 <span class="s">"IQ.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
 <span class="mi">993</span>                 <span class="n">tid</span><span class="p">,</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">pcState</span><span class="p">(),</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">seqNum</span><span class="p">,</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">threadNumber</span><span class="p">);</span>
 <span class="mi">994</span> 
 <span class="mi">995</span>         <span class="c1">// Be sure to mark these instructions as ready so that the</span>
 <span class="mi">996</span>         <span class="c1">// commit stage can go ahead and execute them, and mark</span>
 <span class="mi">997</span>         <span class="c1">// them as issued so the IQ doesn't reprocess them.</span>
 <span class="mi">998</span> 
 <span class="mi">999</span>         <span class="c1">// Check for squashed instructions.</span>
<span class="mi">1000</span>         <span class="nf">if</span> <span class="p">(</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">isSquashed</span><span class="p">())</span> <span class="p">{</span>
<span class="mi">1001</span>             <span class="n">DPRINTF</span><span class="p">(</span><span class="n">IEW</span><span class="p">,</span> <span class="s">"[tid:%i] Issue: Squashed instruction encountered, "</span>
<span class="mi">1002</span>                     <span class="s">"not adding to IQ.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">tid</span><span class="p">);</span>
<span class="mi">1003</span> 
<span class="mi">1004</span>             <span class="o">++</span><span class="n">iewDispSquashedInsts</span><span class="p">;</span>
<span class="mi">1005</span> 
<span class="mi">1006</span>             <span class="n">insts_to_dispatch</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
<span class="mi">1007</span> 
<span class="mi">1008</span>             <span class="c1">//Tell Rename That An Instruction has been processed</span>
<span class="mi">1009</span>             <span class="k">if</span> <span class="p">(</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">isLoad</span><span class="p">())</span> <span class="p">{</span>
<span class="mi">1010</span>                 <span class="n">toRename</span><span class="o">-&gt;</span><span class="n">iewInfo</span><span class="p">[</span><span class="n">tid</span><span class="p">].</span><span class="n">dispatchedToLQ</span><span class="o">++</span><span class="p">;</span>
<span class="mi">1011</span>             <span class="p">}</span>
<span class="mi">1012</span>             <span class="nf">if</span> <span class="p">(</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">isStore</span><span class="p">()</span> <span class="o">||</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">isAtomic</span><span class="p">())</span> <span class="p">{</span>
<span class="mi">1013</span>                 <span class="n">toRename</span><span class="o">-&gt;</span><span class="n">iewInfo</span><span class="p">[</span><span class="n">tid</span><span class="p">].</span><span class="n">dispatchedToSQ</span><span class="o">++</span><span class="p">;</span>
<span class="mi">1014</span>             <span class="p">}</span>
<span class="mi">1015</span> 
<span class="mi">1016</span>             <span class="n">toRename</span><span class="o">-&gt;</span><span class="n">iewInfo</span><span class="p">[</span><span class="n">tid</span><span class="p">].</span><span class="n">dispatched</span><span class="o">++</span><span class="p">;</span>
<span class="mi">1017</span>    
<span class="mi">1018</span>             <span class="k">continue</span><span class="p">;</span>
<span class="mi">1019</span>         <span class="p">}</span>
<span class="mi">1020</span>  
<span class="mi">1021</span>         <span class="c1">// Check for full conditions.</span>
<span class="mi">1022</span>         <span class="nf">if</span> <span class="p">(</span><span class="n">instQueue</span><span class="p">.</span><span class="n">isFull</span><span class="p">(</span><span class="n">tid</span><span class="p">))</span> <span class="p">{</span>
<span class="mi">1023</span>             <span class="n">DPRINTF</span><span class="p">(</span><span class="n">IEW</span><span class="p">,</span> <span class="s">"[tid:%i] Issue: IQ has become full.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">tid</span><span class="p">);</span>
<span class="mi">1024</span>    
<span class="mi">1025</span>             <span class="c1">// Call function to start blocking.</span>
<span class="mi">1026</span>             <span class="n">block</span><span class="p">(</span><span class="n">tid</span><span class="p">);</span>
<span class="mi">1027</span>    
<span class="mi">1028</span>             <span class="c1">// Set unblock to false. Special case where we are using</span>
<span class="mi">1029</span>             <span class="c1">// skidbuffer (unblocking) instructions but then we still</span>
<span class="mi">1030</span>             <span class="c1">// get full in the IQ.</span>
<span class="mi">1031</span>             <span class="n">toRename</span><span class="o">-&gt;</span><span class="n">iewUnblock</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="mi">1032</span>    
<span class="mi">1033</span>             <span class="o">++</span><span class="n">iewIQFullEvents</span><span class="p">;</span>
<span class="mi">1034</span>             <span class="k">break</span><span class="p">;</span>
<span class="mi">1035</span>         <span class="p">}</span>
<span class="mi">1036</span>    
<span class="mi">1037</span>         <span class="c1">// Check LSQ if inst is LD/ST</span>
<span class="mi">1038</span>         <span class="nf">if</span> <span class="p">((</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">isAtomic</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">ldstQueue</span><span class="p">.</span><span class="n">sqFull</span><span class="p">(</span><span class="n">tid</span><span class="p">))</span> <span class="o">||</span>
<span class="mi">1039</span>             <span class="p">(</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">isLoad</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">ldstQueue</span><span class="p">.</span><span class="n">lqFull</span><span class="p">(</span><span class="n">tid</span><span class="p">))</span> <span class="o">||</span>
<span class="mi">1040</span>             <span class="p">(</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">isStore</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">ldstQueue</span><span class="p">.</span><span class="n">sqFull</span><span class="p">(</span><span class="n">tid</span><span class="p">)))</span> <span class="p">{</span>
<span class="mi">1041</span>             <span class="n">DPRINTF</span><span class="p">(</span><span class="n">IEW</span><span class="p">,</span> <span class="s">"[tid:%i] Issue: %s has become full.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">tid</span><span class="p">,</span>
<span class="mi">1042</span>                     <span class="n">inst</span><span class="o">-&gt;</span><span class="n">isLoad</span><span class="p">()</span> <span class="o">?</span> <span class="s">"LQ"</span> <span class="o">:</span> <span class="s">"SQ"</span><span class="p">);</span>
<span class="mi">1043</span>    
<span class="mi">1044</span>             <span class="c1">// Call function to start blocking.</span>
<span class="mi">1045</span>             <span class="n">block</span><span class="p">(</span><span class="n">tid</span><span class="p">);</span>
<span class="mi">1046</span>    
<span class="mi">1047</span>             <span class="c1">// Set unblock to false. Special case where we are using</span>
<span class="mi">1048</span>             <span class="c1">// skidbuffer (unblocking) instructions but then we still</span>
<span class="mi">1049</span>             <span class="c1">// get full in the IQ.</span>
<span class="mi">1050</span>             <span class="n">toRename</span><span class="o">-&gt;</span><span class="n">iewUnblock</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="mi">1051</span> 
<span class="mi">1052</span>             <span class="o">++</span><span class="n">iewLSQFullEvents</span><span class="p">;</span>
<span class="mi">1053</span>             <span class="k">break</span><span class="p">;</span>
<span class="mi">1054</span>         <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>First, it checks whether the current instruction has been already squashed. 
If yes, then ignore the current instruction and jump to the next ones. 
If the instructions is not squashed, 
it checks the availability of resource 
required for issuing the instruction. 
Regardless of the instruction type, 
it requires one entry from the instruction queue.
Also, if it is the memory related 
instruction, it require one entry from the load queue or store queue 
based on whether it is load or store instruction.</p>

<h3 id="checking-instruction-type"><span class="me-2">Checking instruction type</span><a href="#checking-instruction-type" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
</pre></td><td class="rouge-code"><pre><span class="mi">1056</span>         <span class="c1">// Otherwise issue the instruction just fine.</span>
<span class="mi">1057</span>         <span class="nf">if</span> <span class="p">(</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">isAtomic</span><span class="p">())</span> <span class="p">{</span>
<span class="mi">1058</span>             <span class="n">DPRINTF</span><span class="p">(</span><span class="n">IEW</span><span class="p">,</span> <span class="s">"[tid:%i] Issue: Memory instruction "</span>
<span class="mi">1059</span>                     <span class="s">"encountered, adding to LSQ.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">tid</span><span class="p">);</span>
<span class="mi">1060</span> 
<span class="mi">1061</span>             <span class="n">ldstQueue</span><span class="p">.</span><span class="n">insertStore</span><span class="p">(</span><span class="n">inst</span><span class="p">);</span>
<span class="mi">1062</span> 
<span class="mi">1063</span>             <span class="o">++</span><span class="n">iewDispStoreInsts</span><span class="p">;</span>
<span class="mi">1064</span> 
<span class="mi">1065</span>             <span class="c1">// AMOs need to be set as "canCommit()"</span>
<span class="mi">1066</span>             <span class="c1">// so that commit can process them when they reach the</span>
<span class="mi">1067</span>             <span class="c1">// head of commit.</span>
<span class="mi">1068</span>             <span class="n">inst</span><span class="o">-&gt;</span><span class="n">setCanCommit</span><span class="p">();</span>
<span class="mi">1069</span>             <span class="n">instQueue</span><span class="p">.</span><span class="n">insertNonSpec</span><span class="p">(</span><span class="n">inst</span><span class="p">);</span>
<span class="mi">1070</span>             <span class="n">add_to_iq</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="mi">1071</span> 
<span class="mi">1072</span>             <span class="o">++</span><span class="n">iewDispNonSpecInsts</span><span class="p">;</span>
<span class="mi">1073</span> 
<span class="mi">1074</span>             <span class="n">toRename</span><span class="o">-&gt;</span><span class="n">iewInfo</span><span class="p">[</span><span class="n">tid</span><span class="p">].</span><span class="n">dispatchedToSQ</span><span class="o">++</span><span class="p">;</span>
<span class="mi">1075</span>         <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">isLoad</span><span class="p">())</span> <span class="p">{</span>
<span class="mi">1076</span>             <span class="n">DPRINTF</span><span class="p">(</span><span class="n">IEW</span><span class="p">,</span> <span class="s">"[tid:%i] Issue: Memory instruction "</span>
<span class="mi">1077</span>                     <span class="s">"encountered, adding to LSQ.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">tid</span><span class="p">);</span>
<span class="mi">1078</span> 
<span class="mi">1079</span>             <span class="c1">// Reserve a spot in the load store queue for this</span>
<span class="mi">1080</span>             <span class="c1">// memory access.</span>
<span class="mi">1081</span>             <span class="n">ldstQueue</span><span class="p">.</span><span class="n">insertLoad</span><span class="p">(</span><span class="n">inst</span><span class="p">);</span>
<span class="mi">1082</span> 
<span class="mi">1083</span>             <span class="o">++</span><span class="n">iewDispLoadInsts</span><span class="p">;</span>
<span class="mi">1084</span> 
<span class="mi">1085</span>             <span class="n">add_to_iq</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="mi">1086</span> 
<span class="mi">1087</span>             <span class="n">toRename</span><span class="o">-&gt;</span><span class="n">iewInfo</span><span class="p">[</span><span class="n">tid</span><span class="p">].</span><span class="n">dispatchedToLQ</span><span class="o">++</span><span class="p">;</span>
<span class="mi">1088</span>         <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">isStore</span><span class="p">())</span> <span class="p">{</span>
<span class="mi">1089</span>             <span class="n">DPRINTF</span><span class="p">(</span><span class="n">IEW</span><span class="p">,</span> <span class="s">"[tid:%i] Issue: Memory instruction "</span>
<span class="mi">1090</span>                     <span class="s">"encountered, adding to LSQ.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">tid</span><span class="p">);</span>
<span class="mi">1091</span> 
<span class="mi">1092</span>             <span class="n">ldstQueue</span><span class="p">.</span><span class="n">insertStore</span><span class="p">(</span><span class="n">inst</span><span class="p">);</span>
<span class="mi">1093</span> 
<span class="mi">1094</span>             <span class="o">++</span><span class="n">iewDispStoreInsts</span><span class="p">;</span>
<span class="mi">1095</span> 
<span class="mi">1096</span>             <span class="k">if</span> <span class="p">(</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">isStoreConditional</span><span class="p">())</span> <span class="p">{</span>
<span class="mi">1097</span>                 <span class="c1">// Store conditionals need to be set as "canCommit()"</span>
<span class="mi">1098</span>                 <span class="c1">// so that commit can process them when they reach the</span>
<span class="mi">1099</span>                 <span class="c1">// head of commit.</span>
<span class="mi">1100</span>                 <span class="c1">// @todo: This is somewhat specific to Alpha.</span>
<span class="mi">1101</span>                 <span class="n">inst</span><span class="o">-&gt;</span><span class="n">setCanCommit</span><span class="p">();</span>
<span class="mi">1102</span>                 <span class="n">instQueue</span><span class="p">.</span><span class="n">insertNonSpec</span><span class="p">(</span><span class="n">inst</span><span class="p">);</span>
<span class="mi">1103</span>                 <span class="n">add_to_iq</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="mi">1104</span> 
<span class="mi">1105</span>                 <span class="o">++</span><span class="n">iewDispNonSpecInsts</span><span class="p">;</span>
<span class="mi">1106</span>             <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="mi">1107</span>                 <span class="n">add_to_iq</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="mi">1108</span>             <span class="p">}</span>
<span class="mi">1109</span> 
<span class="mi">1110</span>             <span class="n">toRename</span><span class="o">-&gt;</span><span class="n">iewInfo</span><span class="p">[</span><span class="n">tid</span><span class="p">].</span><span class="n">dispatchedToSQ</span><span class="o">++</span><span class="p">;</span>
<span class="mi">1111</span>         <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">isMemBarrier</span><span class="p">()</span> <span class="o">||</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">isWriteBarrier</span><span class="p">())</span> <span class="p">{</span>
<span class="mi">1112</span>             <span class="c1">// Same as non-speculative stores.</span>
<span class="mi">1113</span>             <span class="n">inst</span><span class="o">-&gt;</span><span class="n">setCanCommit</span><span class="p">();</span>
<span class="mi">1114</span>             <span class="n">instQueue</span><span class="p">.</span><span class="n">insertBarrier</span><span class="p">(</span><span class="n">inst</span><span class="p">);</span>
<span class="mi">1115</span>             <span class="n">add_to_iq</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="mi">1116</span>         <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">isNop</span><span class="p">())</span> <span class="p">{</span>
<span class="mi">1117</span>             <span class="n">DPRINTF</span><span class="p">(</span><span class="n">IEW</span><span class="p">,</span> <span class="s">"[tid:%i] Issue: Nop instruction encountered, "</span>
<span class="mi">1118</span>                     <span class="s">"skipping.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">tid</span><span class="p">);</span>
<span class="mi">1119</span> 
<span class="mi">1120</span>             <span class="n">inst</span><span class="o">-&gt;</span><span class="n">setIssued</span><span class="p">();</span>
<span class="mi">1121</span>             <span class="n">inst</span><span class="o">-&gt;</span><span class="n">setExecuted</span><span class="p">();</span>
<span class="mi">1122</span>             <span class="n">inst</span><span class="o">-&gt;</span><span class="n">setCanCommit</span><span class="p">();</span>
<span class="mi">1123</span> 
<span class="mi">1124</span>             <span class="n">instQueue</span><span class="p">.</span><span class="n">recordProducer</span><span class="p">(</span><span class="n">inst</span><span class="p">);</span>
<span class="mi">1125</span> 
<span class="mi">1126</span>             <span class="n">iewExecutedNop</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
<span class="mi">1127</span> 
<span class="mi">1128</span>             <span class="n">add_to_iq</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="mi">1129</span>         <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="mi">1130</span>             <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">isExecuted</span><span class="p">());</span>
<span class="mi">1131</span>             <span class="n">add_to_iq</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="mi">1132</span>         <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>Although it is not clear 
until we understand the internal of the instQueue and ldstQueue,
but the above code pushes the instructions based on the instruction type.
For example, for the load operation, 
it pushes the instruction
to the ldstQueue with insertLoad function. 
For the write operation, 
it is inserted to the same queue 
through the insertStore function.
For the normal instructions they will be just enqueued to the instQueue.</p>

<h3 id="issuing-instruction"><span class="me-2">Issuing instruction</span><a href="#issuing-instruction" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="rouge-code"><pre><span class="mi">1134</span>         <span class="nf">if</span> <span class="p">(</span><span class="n">add_to_iq</span> <span class="o">&amp;&amp;</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">isNonSpeculative</span><span class="p">())</span> <span class="p">{</span>
<span class="mi">1135</span>             <span class="n">DPRINTF</span><span class="p">(</span><span class="n">IEW</span><span class="p">,</span> <span class="s">"[tid:%i] Issue: Nonspeculative instruction "</span>
<span class="mi">1136</span>                     <span class="s">"encountered, skipping.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">tid</span><span class="p">);</span>
<span class="mi">1137</span> 
<span class="mi">1138</span>             <span class="c1">// Same as non-speculative stores.</span>
<span class="mi">1139</span>             <span class="n">inst</span><span class="o">-&gt;</span><span class="n">setCanCommit</span><span class="p">();</span>
<span class="mi">1140</span> 
<span class="mi">1141</span>             <span class="c1">// Specifically insert it as nonspeculative.</span>
<span class="mi">1142</span>             <span class="n">instQueue</span><span class="p">.</span><span class="n">insertNonSpec</span><span class="p">(</span><span class="n">inst</span><span class="p">);</span>
<span class="mi">1143</span> 
<span class="mi">1144</span>             <span class="o">++</span><span class="n">iewDispNonSpecInsts</span><span class="p">;</span>
<span class="mi">1145</span> 
<span class="mi">1146</span>             <span class="n">add_to_iq</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="mi">1147</span>         <span class="p">}</span>
<span class="mi">1148</span> 
<span class="mi">1149</span>         <span class="c1">// If the instruction queue is not full, then add the</span>
<span class="mi">1150</span>         <span class="c1">// instruction.</span>
<span class="mi">1151</span>         <span class="nf">if</span> <span class="p">(</span><span class="n">add_to_iq</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1152</span>             <span class="n">instQueue</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">inst</span><span class="p">);</span>
<span class="mi">1153</span>         <span class="p">}</span>
<span class="mi">1154</span> 
<span class="mi">1155</span>         <span class="n">insts_to_dispatch</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
<span class="mi">1156</span> 
<span class="mi">1157</span>         <span class="n">toRename</span><span class="o">-&gt;</span><span class="n">iewInfo</span><span class="p">[</span><span class="n">tid</span><span class="p">].</span><span class="n">dispatched</span><span class="o">++</span><span class="p">;</span>
<span class="mi">1158</span> 
<span class="mi">1159</span>         <span class="o">++</span><span class="n">iewDispatchedInsts</span><span class="p">;</span>
<span class="mi">1160</span> 
<span class="mi">1161</span> <span class="err">#</span><span class="k">if</span> <span class="n">TRACING_ON</span>
<span class="mi">1162</span>         <span class="n">inst</span><span class="o">-&gt;</span><span class="n">dispatchTick</span> <span class="o">=</span> <span class="n">curTick</span><span class="p">()</span> <span class="o">-</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">fetchTick</span><span class="p">;</span>
<span class="mi">1163</span> <span class="err">#</span><span class="n">endif</span>
<span class="mi">1164</span>         <span class="n">ppDispatch</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">(</span><span class="n">inst</span><span class="p">);</span>
<span class="mi">1165</span>     <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>After each instructions are handled 
by inserting them to the corresponding queues 
with the associated method provided by the queues, 
some of them should also be inserted to the instruction queue. 
Note that add_to_iq flag is set
based on the instruction type, 
When this flag is set, the instruction should be added to the instQueue (line 1151-1153).</p>

<h3 id="end-of-the-dispatching"><span class="me-2">End of the dispatching</span><a href="#end-of-the-dispatching" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="rouge-code"><pre><span class="mi">1167</span>     <span class="nf">if</span> <span class="p">(</span><span class="o">!</span><span class="n">insts_to_dispatch</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
<span class="mi">1168</span>         <span class="n">DPRINTF</span><span class="p">(</span><span class="n">IEW</span><span class="p">,</span><span class="s">"[tid:%i] Issue: Bandwidth Full. Blocking.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">tid</span><span class="p">);</span>
<span class="mi">1169</span>         <span class="n">block</span><span class="p">(</span><span class="n">tid</span><span class="p">);</span>
<span class="mi">1170</span>         <span class="n">toRename</span><span class="o">-&gt;</span><span class="n">iewUnblock</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="mi">1171</span>     <span class="p">}</span>
<span class="mi">1172</span> 
<span class="mi">1173</span>     <span class="nf">if</span> <span class="p">(</span><span class="n">dispatchStatus</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">==</span> <span class="n">Idle</span> <span class="o">&amp;&amp;</span> <span class="n">dis_num_inst</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1174</span>         <span class="n">dispatchStatus</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">=</span> <span class="n">Running</span><span class="p">;</span>
<span class="mi">1175</span> 
<span class="mi">1176</span>         <span class="n">updatedQueues</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="mi">1177</span>     <span class="p">}</span>
<span class="mi">1178</span> 
<span class="mi">1179</span>     <span class="n">dis_num_inst</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="mi">1180</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>After dispatching all renamed instructions, 
it should check whether it still has some instructions in the queue. 
When the instruction cannot be processed further because of throttling,
it should block and handle rest of the instructions at the next cycle.</p>

<h2 id="instruction-queue-and-loadstore-queue"><span class="me-2">Instruction Queue and Load/Store queue</span><a href="#instruction-queue-and-loadstore-queue" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>
<p>Before moving on to the next stage, I’d like to cover some part of the IQ and LSQ.</p>

<h3 id="instruction-queue-has-several-lists-to-keep-issued-instructions"><span class="me-2">Instruction queue has several lists to keep issued instructions</span><a href="#instruction-queue-has-several-lists-to-keep-issued-instructions" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<p>Mainly the job of the queue is managing instructions 
and providing some interfaces to process the enqueued instructions.</p>

<p><em>gem5/src/cpu/o3/inst_queue.hh</em></p>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="rouge-code"><pre><span class="mi">311</span>     <span class="c1">//////////////////////////////////////</span>
<span class="mi">312</span>     <span class="c1">// Instruction lists, ready queues, and ordering</span>
<span class="mi">313</span>     <span class="c1">//////////////////////////////////////</span>
<span class="mi">314</span> 
<span class="mi">315</span>     <span class="cm">/** List of all the instructions in the IQ (some of which may be issued). */</span>
<span class="mi">316</span>     <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">DynInstPtr</span><span class="o">&gt;</span> <span class="n">instList</span><span class="p">[</span><span class="n">Impl</span><span class="o">::</span><span class="n">MaxThreads</span><span class="p">];</span>
<span class="mi">317</span> 
<span class="mi">318</span>     <span class="cm">/** List of instructions that are ready to be executed. */</span>
<span class="mi">319</span>     <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">DynInstPtr</span><span class="o">&gt;</span> <span class="n">instsToExecute</span><span class="p">;</span>
<span class="mi">320</span> 
<span class="mi">321</span>     <span class="cm">/** List of instructions waiting for their DTB translation to
322      *  complete (hw page table walk in progress).
323      */</span>
<span class="mi">324</span>     <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">DynInstPtr</span><span class="o">&gt;</span> <span class="n">deferredMemInsts</span><span class="p">;</span>
<span class="mi">325</span> 
<span class="mi">326</span>     <span class="cm">/** List of instructions that have been cache blocked. */</span>
<span class="mi">327</span>     <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">DynInstPtr</span><span class="o">&gt;</span> <span class="n">blockedMemInsts</span><span class="p">;</span>
<span class="mi">328</span> 
<span class="mi">329</span>     <span class="cm">/** List of instructions that were cache blocked, but a retry has been seen
330      * since, so they can now be retried. May fail again go on the blocked list.
331      */</span>
<span class="mi">332</span>     <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">DynInstPtr</span><span class="o">&gt;</span> <span class="n">retryMemInsts</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></div></div>

<h3 id="insert-new-entries-to-the-instruction-queue"><span class="me-2">Insert new entries to the instruction queue</span><a href="#insert-new-entries-to-the-instruction-queue" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<p>The insert function is the essential example of the interface.
It inserts new entries to the instruction list 
managed by the instruction queue.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre></td><td class="rouge-code"><pre> <span class="mi">578</span> <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Impl</span><span class="p">&gt;</span>
 <span class="mi">579</span> <span class="kt">void</span>
 <span class="mi">580</span> <span class="n">InstructionQueue</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;::</span><span class="n">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">DynInstPtr</span> <span class="o">&amp;</span><span class="n">new_inst</span><span class="p">)</span>
 <span class="mi">581</span> <span class="p">{</span>
 <span class="mi">582</span>     <span class="k">if</span> <span class="p">(</span><span class="n">new_inst</span><span class="o">-&gt;</span><span class="n">isFloating</span><span class="p">())</span> <span class="p">{</span>
 <span class="mi">583</span>         <span class="n">fpInstQueueWrites</span><span class="o">++</span><span class="p">;</span>
 <span class="mi">584</span>     <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">new_inst</span><span class="o">-&gt;</span><span class="n">isVector</span><span class="p">())</span> <span class="p">{</span>
 <span class="mi">585</span>         <span class="n">vecInstQueueWrites</span><span class="o">++</span><span class="p">;</span>
 <span class="mi">586</span>     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
 <span class="mi">587</span>         <span class="n">intInstQueueWrites</span><span class="o">++</span><span class="p">;</span>
 <span class="mi">588</span>     <span class="p">}</span>
 <span class="mi">589</span>     <span class="c1">// Make sure the instruction is valid</span>
 <span class="mi">590</span>     <span class="nf">assert</span><span class="p">(</span><span class="n">new_inst</span><span class="p">);</span>
 <span class="mi">591</span> 
 <span class="mi">592</span>     <span class="nf">DPRINTF</span><span class="p">(</span><span class="n">IQ</span><span class="p">,</span> <span class="s">"Adding instruction [sn:%llu] PC %s to the IQ.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
 <span class="mi">593</span>             <span class="n">new_inst</span><span class="o">-&gt;</span><span class="n">seqNum</span><span class="p">,</span> <span class="n">new_inst</span><span class="o">-&gt;</span><span class="n">pcState</span><span class="p">());</span>
 <span class="mi">594</span> 
 <span class="mi">595</span>     <span class="nf">assert</span><span class="p">(</span><span class="n">freeEntries</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
 <span class="mi">596</span> 
 <span class="mi">597</span>     <span class="n">instList</span><span class="p">[</span><span class="n">new_inst</span><span class="o">-&gt;</span><span class="n">threadNumber</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">new_inst</span><span class="p">);</span>
 <span class="mi">598</span> 
 <span class="mi">599</span>     <span class="o">--</span><span class="n">freeEntries</span><span class="p">;</span>
 <span class="mi">600</span> 
 <span class="mi">601</span>     <span class="n">new_inst</span><span class="o">-&gt;</span><span class="n">setInIQ</span><span class="p">();</span>
 <span class="mi">602</span> 
 <span class="mi">603</span>     <span class="c1">// Look through its source registers (physical regs), and mark any</span>
 <span class="mi">604</span>     <span class="c1">// dependencies.</span>
 <span class="mi">605</span>     <span class="nf">addToDependents</span><span class="p">(</span><span class="n">new_inst</span><span class="p">);</span>
 <span class="mi">606</span> 
 <span class="mi">607</span>     <span class="c1">// Have this instruction set itself as the producer of its destination</span>
 <span class="mi">608</span>     <span class="c1">// register(s).</span>
 <span class="mi">609</span>     <span class="nf">addToProducers</span><span class="p">(</span><span class="n">new_inst</span><span class="p">);</span>
 <span class="mi">610</span> 
 <span class="mi">611</span>     <span class="nf">if</span> <span class="p">(</span><span class="n">new_inst</span><span class="o">-&gt;</span><span class="n">isMemRef</span><span class="p">())</span> <span class="p">{</span>
 <span class="mi">612</span>         <span class="n">memDepUnit</span><span class="p">[</span><span class="n">new_inst</span><span class="o">-&gt;</span><span class="n">threadNumber</span><span class="p">].</span><span class="n">insert</span><span class="p">(</span><span class="n">new_inst</span><span class="p">);</span>
 <span class="mi">613</span>     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
 <span class="mi">614</span>         <span class="n">addIfReady</span><span class="p">(</span><span class="n">new_inst</span><span class="p">);</span>
 <span class="mi">615</span>     <span class="p">}</span>
 <span class="mi">616</span> 
 <span class="mi">617</span>     <span class="o">++</span><span class="n">iqInstsAdded</span><span class="p">;</span>
 <span class="mi">618</span> 
 <span class="mi">619</span>     <span class="n">count</span><span class="p">[</span><span class="n">new_inst</span><span class="o">-&gt;</span><span class="n">threadNumber</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
 <span class="mi">620</span> 
 <span class="mi">621</span>     <span class="nf">assert</span><span class="p">(</span><span class="n">freeEntries</span> <span class="o">==</span> <span class="p">(</span><span class="n">numEntries</span> <span class="o">-</span> <span class="n">countInsts</span><span class="p">()));</span>
 <span class="mi">622</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>Inserting the instruction to the list is done 
by simple push_back operation of the list.
However, it invokes two important functions: 
addToProducers and addToDependents.
These two functions generates producer and consumer dependency 
among instructions’s operands, registers. 
When one instruction waits until the specific register’s value become ready (consumer),
it should be tracked by some hardware component. 
Also, when the data becomes ready 
as a result of execution of one instruction (producer), 
it should be forwarded to the consumers waiting for the value. 
For that purpose, GEM5 utilize the DependencyGraph. 
After producing dependency for the unavailable registers, 
if the instruction references memory while its execution,
it should be specially handled by the memory dependency unit. 
The details will be explained together with the DependencyGraph later.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="rouge-code"><pre><span class="mi">1450</span> <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Impl</span><span class="p">&gt;</span>
<span class="mi">1451</span> <span class="kt">void</span>
<span class="mi">1452</span> <span class="n">InstructionQueue</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;::</span><span class="n">addIfReady</span><span class="p">(</span><span class="k">const</span> <span class="n">DynInstPtr</span> <span class="o">&amp;</span><span class="n">inst</span><span class="p">)</span>
<span class="mi">1453</span> <span class="p">{</span>
<span class="mi">1454</span>     <span class="c1">// If the instruction now has all of its source registers</span>
<span class="mi">1455</span>     <span class="c1">// available, then add it to the list of ready instructions.</span>
<span class="mi">1456</span>     <span class="k">if</span> <span class="p">(</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">readyToIssue</span><span class="p">())</span> <span class="p">{</span>
<span class="mi">1457</span> 
<span class="mi">1458</span>         <span class="c1">//Add the instruction to the proper ready list.</span>
<span class="mi">1459</span>         <span class="k">if</span> <span class="p">(</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">isMemRef</span><span class="p">())</span> <span class="p">{</span>
<span class="mi">1460</span> 
<span class="mi">1461</span>             <span class="n">DPRINTF</span><span class="p">(</span><span class="n">IQ</span><span class="p">,</span> <span class="s">"Checking if memory instruction can issue.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="mi">1462</span> 
<span class="mi">1463</span>             <span class="c1">// Message to the mem dependence unit that this instruction has</span>
<span class="mi">1464</span>             <span class="c1">// its registers ready.</span>
<span class="mi">1465</span>             <span class="n">memDepUnit</span><span class="p">[</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">threadNumber</span><span class="p">].</span><span class="n">regsReady</span><span class="p">(</span><span class="n">inst</span><span class="p">);</span>
<span class="mi">1466</span> 
<span class="mi">1467</span>             <span class="k">return</span><span class="p">;</span>
<span class="mi">1468</span>         <span class="p">}</span>
<span class="mi">1469</span> 
<span class="mi">1470</span>         <span class="n">OpClass</span> <span class="n">op_class</span> <span class="o">=</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">opClass</span><span class="p">();</span>
<span class="mi">1471</span> 
<span class="mi">1472</span>         <span class="nf">DPRINTF</span><span class="p">(</span><span class="n">IQ</span><span class="p">,</span> <span class="s">"Instruction is ready to issue, putting it onto "</span>
<span class="mi">1473</span>                 <span class="s">"the ready list, PC %s opclass:%i [sn:%llu].</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
<span class="mi">1474</span>                 <span class="n">inst</span><span class="o">-&gt;</span><span class="n">pcState</span><span class="p">(),</span> <span class="n">op_class</span><span class="p">,</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">seqNum</span><span class="p">);</span>
<span class="mi">1475</span> 
<span class="mi">1476</span>         <span class="n">readyInsts</span><span class="p">[</span><span class="n">op_class</span><span class="p">].</span><span class="n">push</span><span class="p">(</span><span class="n">inst</span><span class="p">);</span>
<span class="mi">1477</span> 
<span class="mi">1478</span>         <span class="c1">// Will need to reorder the list if either a queue is not on the list,</span>
<span class="mi">1479</span>         <span class="c1">// or it has an older instruction than last time.</span>
<span class="mi">1480</span>         <span class="nf">if</span> <span class="p">(</span><span class="o">!</span><span class="n">queueOnList</span><span class="p">[</span><span class="n">op_class</span><span class="p">])</span> <span class="p">{</span>
<span class="mi">1481</span>             <span class="n">addToOrderList</span><span class="p">(</span><span class="n">op_class</span><span class="p">);</span>
<span class="mi">1482</span>         <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">readyInsts</span><span class="p">[</span><span class="n">op_class</span><span class="p">].</span><span class="n">top</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">seqNum</span>  <span class="o">&lt;</span>
<span class="mi">1483</span>                    <span class="p">(</span><span class="o">*</span><span class="n">readyIt</span><span class="p">[</span><span class="n">op_class</span><span class="p">]).</span><span class="n">oldestInst</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1484</span>             <span class="n">listOrder</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">readyIt</span><span class="p">[</span><span class="n">op_class</span><span class="p">]);</span>
<span class="mi">1485</span>             <span class="n">addToOrderList</span><span class="p">(</span><span class="n">op_class</span><span class="p">);</span>
<span class="mi">1486</span>         <span class="p">}</span>
<span class="mi">1487</span>     <span class="p">}</span>
<span class="mi">1488</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>At the end of the insert function, it adds instruction 
to the <strong>readyInsts</strong> buffer 
if all the registers are available (line 1476).
If the instruction is not ready, 
which means the source registers are not available, 
the instruction should not be inqueued to the readyInsts buffer.
The instructions waiting for the source register to become available 
will be added to the readyInsts buffer 
when other dependent instructions complete.</p>

<h2 id="execute"><span class="me-2">Execute</span><a href="#execute" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>
<p>To understand what should be done after dispatching the instructions,
let’s go back to the tick function of the iew stage.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="rouge-code"><pre><span class="mi">1532</span>     <span class="nf">if</span> <span class="p">(</span><span class="n">exeStatus</span> <span class="o">!=</span> <span class="n">Squashing</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1533</span>         <span class="n">executeInsts</span><span class="p">();</span>
<span class="mi">1534</span> 
<span class="mi">1535</span>         <span class="n">writebackInsts</span><span class="p">();</span>
<span class="mi">1536</span> 
<span class="mi">1537</span>         <span class="c1">// Have the instruction queue try to schedule any ready instructions.</span>
<span class="mi">1538</span>         <span class="c1">// (In actuality, this scheduling is for instructions that will</span>
<span class="mi">1539</span>         <span class="c1">// be executed next cycle.)</span>
<span class="mi">1540</span>         <span class="n">instQueue</span><span class="p">.</span><span class="n">scheduleReadyInsts</span><span class="p">();</span>
<span class="mi">1541</span> 
<span class="mi">1542</span>         <span class="c1">// Also should advance its own time buffers if the stage ran.</span>
<span class="mi">1543</span>         <span class="c1">// Not the best place for it, but this works (hopefully).</span>
<span class="mi">1544</span>         <span class="n">issueToExecQueue</span><span class="p">.</span><span class="n">advance</span><span class="p">();</span>
<span class="mi">1545</span>     <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>If the execution stage is not in the squashing state, 
it will execute instructions stored in the instQueue, particularly readyInsts queue. 
Here execute() function of the compute instruction is invoked and sent to commit. 
Please note execute() will write results to the destination registers.
Therefore, after executeInsts is invoked, 
writebackInsts is called to write the result to destination registers.
Furthermore, when there are dependent instructions to the currently executed one,
those instructions will be added to the ready list for scheduling.</p>

<h3 id="executeinsts"><span class="me-2">executeInsts</span><a href="#executeinsts" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
</pre></td><td class="rouge-code"><pre><span class="mi">1205</span> <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Impl</span><span class="p">&gt;</span>
<span class="mi">1206</span> <span class="kt">void</span>
<span class="mi">1207</span> <span class="n">DefaultIEW</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;::</span><span class="n">executeInsts</span><span class="p">()</span>
<span class="mi">1208</span> <span class="p">{</span>
<span class="mi">1209</span>     <span class="n">wbNumInst</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="mi">1210</span>     <span class="n">wbCycle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="mi">1211</span> 
<span class="mi">1212</span>     <span class="n">list</span><span class="o">&lt;</span><span class="n">ThreadID</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">threads</span> <span class="o">=</span> <span class="n">activeThreads</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">();</span>
<span class="mi">1213</span>     <span class="n">list</span><span class="o">&lt;</span><span class="n">ThreadID</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">end</span> <span class="o">=</span> <span class="n">activeThreads</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">();</span>
<span class="mi">1214</span> 
<span class="mi">1215</span>     <span class="k">while</span> <span class="p">(</span><span class="n">threads</span> <span class="o">!=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1216</span>         <span class="n">ThreadID</span> <span class="n">tid</span> <span class="o">=</span> <span class="o">*</span><span class="n">threads</span><span class="o">++</span><span class="p">;</span>
<span class="mi">1217</span>         <span class="n">fetchRedirect</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="mi">1218</span>     <span class="p">}</span>
<span class="mi">1219</span> 
<span class="mi">1220</span>     <span class="c1">// Uncomment this if you want to see all available instructions.</span>
<span class="mi">1221</span>     <span class="c1">// @todo This doesn't actually work anymore, we should fix it.</span>
<span class="mi">1222</span>     <span class="c1">// printAvailableInsts();</span>
<span class="mi">1223</span> 
<span class="mi">1224</span>     <span class="c1">// Execute/writeback any instructions that are available.</span>
<span class="mi">1225</span>     <span class="kt">int</span> <span class="n">insts_to_execute</span> <span class="o">=</span> <span class="n">fromIssue</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
<span class="mi">1226</span>     <span class="kt">int</span> <span class="n">inst_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="mi">1227</span>     <span class="k">for</span> <span class="p">(;</span> <span class="n">inst_num</span> <span class="o">&lt;</span> <span class="n">insts_to_execute</span><span class="p">;</span>
<span class="mi">1228</span>           <span class="o">++</span><span class="n">inst_num</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1229</span> 
<span class="mi">1230</span>         <span class="n">DPRINTF</span><span class="p">(</span><span class="n">IEW</span><span class="p">,</span> <span class="s">"Execute: Executing instructions from IQ.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="mi">1231</span> 
<span class="mi">1232</span>         <span class="n">DynInstPtr</span> <span class="n">inst</span> <span class="o">=</span> <span class="n">instQueue</span><span class="p">.</span><span class="n">getInstToExecute</span><span class="p">();</span>
<span class="mi">1233</span> 
<span class="mi">1234</span>         <span class="n">DPRINTF</span><span class="p">(</span><span class="n">IEW</span><span class="p">,</span> <span class="s">"Execute: Processing PC %s, [tid:%i] [sn:%llu].</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
<span class="mi">1235</span>                 <span class="n">inst</span><span class="o">-&gt;</span><span class="n">pcState</span><span class="p">(),</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">threadNumber</span><span class="p">,</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">seqNum</span><span class="p">);</span>
<span class="mi">1236</span> 
<span class="mi">1237</span>         <span class="c1">// Notify potential listeners that this instruction has started</span>
<span class="mi">1238</span>         <span class="c1">// executing</span>
<span class="mi">1239</span>         <span class="n">ppExecute</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">(</span><span class="n">inst</span><span class="p">);</span>
<span class="mi">1240</span> 
<span class="mi">1241</span>         <span class="c1">// Check if the instruction is squashed; if so then skip it</span>
<span class="mi">1242</span>         <span class="k">if</span> <span class="p">(</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">isSquashed</span><span class="p">())</span> <span class="p">{</span>
<span class="mi">1243</span>             <span class="n">DPRINTF</span><span class="p">(</span><span class="n">IEW</span><span class="p">,</span> <span class="s">"Execute: Instruction was squashed. PC: %s, [tid:%i]"</span>
<span class="mi">1244</span>                          <span class="s">" [sn:%llu]</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">pcState</span><span class="p">(),</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">threadNumber</span><span class="p">,</span>
<span class="mi">1245</span>                          <span class="n">inst</span><span class="o">-&gt;</span><span class="n">seqNum</span><span class="p">);</span>
<span class="mi">1246</span> 
<span class="mi">1247</span>             <span class="c1">// Consider this instruction executed so that commit can go</span>
<span class="mi">1248</span>             <span class="c1">// ahead and retire the instruction.</span>
<span class="mi">1249</span>             <span class="n">inst</span><span class="o">-&gt;</span><span class="n">setExecuted</span><span class="p">();</span>
<span class="mi">1250</span> 
<span class="mi">1251</span>             <span class="c1">// Not sure if I should set this here or just let commit try to</span>
<span class="mi">1252</span>             <span class="c1">// commit any squashed instructions.  I like the latter a bit more.</span>
<span class="mi">1253</span>             <span class="n">inst</span><span class="o">-&gt;</span><span class="n">setCanCommit</span><span class="p">();</span>
<span class="mi">1254</span> 
<span class="mi">1255</span>             <span class="o">++</span><span class="n">iewExecSquashedInsts</span><span class="p">;</span>
<span class="mi">1256</span> 
<span class="mi">1257</span>             <span class="k">continue</span><span class="p">;</span>
<span class="mi">1258</span>         <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>The executeInsts function execute an many instruction as it can afford,
which is implemented as the loop in the line 1227 and after. 
First it retrieves instruction that can be executed by invoking
getInstToExecute function of the instQueue. 
After one instruction is retrieved, it checks if the instruction
should be squashed. 
Although the squashed instructions are not really executed,
but it should be treated as executed because it should be committed. 
After this condition is checked, depending on the type of the instruction,
it will process the instruction separately.</p>

<h2 id="execute-memory-instruction"><span class="me-2">execute memory instruction</span><a href="#execute-memory-instruction" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>
<p>1259 
1260         Fault fault = NoFault;
1261 
1262         // Execute instruction.
1263         // Note that if the instruction faults, it will be handled
1264         // at the commit stage.
1265         if (inst-&gt;isMemRef()) {
1266             DPRINTF(IEW, “Execute: Calculating address for memory “
1267                     “reference.\n”);
1268 
1269             // Tell the LDSTQ to execute this instruction (if it is a load).
1270             if (inst-&gt;isAtomic()) {
1271                 // AMOs are treated like store requests
1272                 fault = ldstQueue.executeStore(inst);
1273 
1274                 if (inst-&gt;isTranslationDelayed() &amp;&amp;
1275                     fault == NoFault) {
1276                     // A hw page table walk is currently going on; the
1277                     // instruction must be deferred.
1278                     DPRINTF(IEW, “Execute: Delayed translation, deferring “
1279                             “store.\n”);
1280                     instQueue.deferMemInst(inst);
1281                     continue;
1282                 }
1283             } else if (inst-&gt;isLoad()) {
1284                 // Loads will mark themselves as executed, and their writeback
1285                 // event adds the instruction to the queue to commit
1286                 fault = ldstQueue.executeLoad(inst);
1287 
1288                 if (inst-&gt;isTranslationDelayed() &amp;&amp;
1289                     fault == NoFault) {
1290                     // A hw page table walk is currently going on; the
1291                     // instruction must be deferred.
1292                     DPRINTF(IEW, “Execute: Delayed translation, deferring “
1293                             “load.\n”);
1294                     instQueue.deferMemInst(inst);
1295                     continue;
1296                 }
1297 
1298                 if (inst-&gt;isDataPrefetch() || inst-&gt;isInstPrefetch()) {
1299                     inst-&gt;fault = NoFault;
1300                 }
1301             } else if (inst-&gt;isStore()) {
1302                 fault = ldstQueue.executeStore(inst);
1303 
1304                 if (inst-&gt;isTranslationDelayed() &amp;&amp;
1305                     fault == NoFault) {
1306                     // A hw page table walk is currently going on; the
1307                     // instruction must be deferred.
1308                     DPRINTF(IEW, “Execute: Delayed translation, deferring “
1309                             “store.\n”);
1310                     instQueue.deferMemInst(inst);
1311                     continue;
1312                 }
1313 
1314                 // If the store had a fault then it may not have a mem req
1315                 if (fault != NoFault || !inst-&gt;readPredicate() ||
1316                         !inst-&gt;isStoreConditional()) {
1317                     // If the instruction faulted, then we need to send it along
1318                     // to commit without the instruction completing.
1319                     // Send this instruction to commit, also make sure iew stage
1320                     // realizes there is activity.
1321                     inst-&gt;setExecuted();
1322                     instToCommit(inst);
1323                     activityThisCycle();
1324                 }
1325 
1326                 // Store conditionals will mark themselves as
1327                 // executed, and their writeback event will add the
1328                 // instruction to the queue to commit.
1329             } else {
1330                 panic(“Unexpected memory type!\n”);
1331             }
1332 
1333         } else {</p>
<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="rouge-code"><pre>
For the memory operation, it can be one of three instruction type:
atomic, load, store. 
Basically, the loadstore queue in charge of executing memory instructions,
but based on the type of memory operation, it needs to handle 
instruction differently. 
Let's take a look at how the load and store instruction will be processed.

### Execute load instruction
```cpp
1283             } else if (inst-&gt;isLoad()) {
1284                 // Loads will mark themselves as executed, and their writeback
1285                 // event adds the instruction to the queue to commit
1286                 fault = ldstQueue.executeLoad(inst);
1287
1288                 if (inst-&gt;isTranslationDelayed() &amp;&amp;
1289                     fault == NoFault) {
1290                     // A hw page table walk is currently going on; the
1291                     // instruction must be deferred.
1292                     DPRINTF(IEW, "Execute: Delayed translation, deferring "
1293                             "load.\n");
1294                     instQueue.deferMemInst(inst);
1295                     continue;
1296                 }
1297
1298                 if (inst-&gt;isDataPrefetch() || inst-&gt;isInstPrefetch()) {
1299                     inst-&gt;fault = NoFault;
1300                 }
</pre></td></tr></tbody></table></code></div></div>
<p>The main execution of the load instruction is done by the executeLoad function of the ldstQueue. 
After the execution, it needs to check whether the translation is the 
bottleneck of making progress on the load operation.
Note that when the virtual to physical address resolution is delayed 
because of long TLB latency, 
it should be executed at the next or later clock cycle 
when the TLB is ready. 
Therefore, when the instruction cannot be executed at this moment,
it should set the current load instruction is deferred (deferMemInst).
Also, when the load operation was just prefetch,
then any fault generated by this operation should be ignored 
(line 1298-1299). Let’s take our important function executeLoad in detail!</p>

<p><em>gem5/src/o3/cpu/lsq_impl.hh</em></p>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre> <span class="mi">251</span> <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Impl</span><span class="p">&gt;</span>
 <span class="mi">252</span> <span class="n">Fault</span>
 <span class="mi">253</span> <span class="n">LSQ</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;::</span><span class="n">executeLoad</span><span class="p">(</span><span class="k">const</span> <span class="n">DynInstPtr</span> <span class="o">&amp;</span><span class="n">inst</span><span class="p">)</span>
 <span class="mi">254</span> <span class="p">{</span>
 <span class="mi">255</span>     <span class="n">ThreadID</span> <span class="n">tid</span> <span class="o">=</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">threadNumber</span><span class="p">;</span>
 <span class="mi">256</span>
 <span class="mi">257</span>     <span class="k">return</span> <span class="kr">thread</span><span class="p">[</span><span class="n">tid</span><span class="p">].</span><span class="n">executeLoad</span><span class="p">(</span><span class="n">inst</span><span class="p">);</span>
 <span class="mi">258</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p><em>gem5/src/o3/cpu/lsq.hh</em></p>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="rouge-code"><pre>  <span class="mi">63</span> <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Impl</span><span class="p">&gt;</span>
  <span class="mi">64</span> <span class="k">class</span> <span class="nc">LSQ</span>
  <span class="mi">65</span> 
  <span class="mi">66</span> <span class="p">{</span>
<span class="p">......</span>
<span class="mi">1104</span>     <span class="cm">/** Total Size of LQ Entries. */</span>
<span class="mi">1105</span>     <span class="kt">unsigned</span> <span class="n">LQEntries</span><span class="p">;</span>
<span class="mi">1106</span>     <span class="cm">/** Total Size of SQ Entries. */</span>
<span class="mi">1107</span>     <span class="kt">unsigned</span> <span class="n">SQEntries</span><span class="p">;</span>
<span class="mi">1108</span> 
<span class="mi">1109</span>     <span class="cm">/** Max LQ Size - Used to Enforce Sharing Policies. */</span>
<span class="mi">1110</span>     <span class="kt">unsigned</span> <span class="n">maxLQEntries</span><span class="p">;</span>
<span class="mi">1111</span> 
<span class="mi">1112</span>     <span class="cm">/** Max SQ Size - Used to Enforce Sharing Policies. */</span>
<span class="mi">1113</span>     <span class="kt">unsigned</span> <span class="n">maxSQEntries</span><span class="p">;</span>
<span class="mi">1114</span> 
<span class="mi">1115</span>     <span class="cm">/** Data port. */</span>
<span class="mi">1116</span>     <span class="n">DcachePort</span> <span class="n">dcachePort</span><span class="p">;</span>
<span class="mi">1117</span> 
<span class="mi">1118</span>     <span class="cm">/** The LSQ units for individual threads. */</span>
<span class="mi">1119</span>     <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">LSQUnit</span><span class="o">&gt;</span> <span class="kr">thread</span><span class="p">;</span>
<span class="mi">1120</span> 
<span class="mi">1121</span>     <span class="cm">/** Number of Threads. */</span>
<span class="mi">1122</span>     <span class="n">ThreadID</span> <span class="n">numThreads</span><span class="p">;</span>
<span class="mi">1123</span> <span class="p">};</span>
</pre></td></tr></tbody></table></code></div></div>

<p><em>gem5/src/o3/cpu/lsq_unit_impl.hh</em></p>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
</pre></td><td class="rouge-code"><pre> <span class="mi">558</span> <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Impl</span><span class="p">&gt;</span>
 <span class="mi">559</span> <span class="n">Fault</span>
 <span class="mi">560</span> <span class="n">LSQUnit</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;::</span><span class="n">executeLoad</span><span class="p">(</span><span class="k">const</span> <span class="n">DynInstPtr</span> <span class="o">&amp;</span><span class="n">inst</span><span class="p">)</span>
 <span class="mi">561</span> <span class="p">{</span>  
 <span class="mi">562</span>     <span class="k">using</span> <span class="k">namespace</span> <span class="n">TheISA</span><span class="p">;</span>
 <span class="mi">563</span>     <span class="c1">// Execute a specific load.</span>
 <span class="mi">564</span>     <span class="n">Fault</span> <span class="n">load_fault</span> <span class="o">=</span> <span class="n">NoFault</span><span class="p">;</span>
 <span class="mi">565</span>    
 <span class="mi">566</span>     <span class="n">DPRINTF</span><span class="p">(</span><span class="n">LSQUnit</span><span class="p">,</span> <span class="s">"Executing load PC %s, [sn:%lli]</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
 <span class="mi">567</span>             <span class="n">inst</span><span class="o">-&gt;</span><span class="n">pcState</span><span class="p">(),</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">seqNum</span><span class="p">);</span>
 <span class="mi">568</span>    
 <span class="mi">569</span>     <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">isSquashed</span><span class="p">());</span>
 <span class="mi">570</span>    
 <span class="mi">571</span>     <span class="n">load_fault</span> <span class="o">=</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">initiateAcc</span><span class="p">();</span>
 <span class="mi">572</span> 
 <span class="mi">573</span>     <span class="k">if</span> <span class="p">(</span><span class="n">load_fault</span> <span class="o">==</span> <span class="n">NoFault</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">readMemAccPredicate</span><span class="p">())</span> <span class="p">{</span>
 <span class="mi">574</span>         <span class="n">assert</span><span class="p">(</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">readPredicate</span><span class="p">());</span>
 <span class="mi">575</span>         <span class="n">inst</span><span class="o">-&gt;</span><span class="n">setExecuted</span><span class="p">();</span>
 <span class="mi">576</span>         <span class="n">inst</span><span class="o">-&gt;</span><span class="n">completeAcc</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">);</span>
 <span class="mi">577</span>         <span class="n">iewStage</span><span class="o">-&gt;</span><span class="n">instToCommit</span><span class="p">(</span><span class="n">inst</span><span class="p">);</span>
 <span class="mi">578</span>         <span class="n">iewStage</span><span class="o">-&gt;</span><span class="n">activityThisCycle</span><span class="p">();</span>
 <span class="mi">579</span>         <span class="k">return</span> <span class="n">NoFault</span><span class="p">;</span>
 <span class="mi">580</span>     <span class="p">}</span>
 <span class="mi">581</span>        
 <span class="mi">582</span>     <span class="k">if</span> <span class="p">(</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">isTranslationDelayed</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">load_fault</span> <span class="o">==</span> <span class="n">NoFault</span><span class="p">)</span>
 <span class="mi">583</span>         <span class="k">return</span> <span class="n">load_fault</span><span class="p">;</span>
 <span class="mi">584</span>            
 <span class="mi">585</span>     <span class="nf">if</span> <span class="p">(</span><span class="n">load_fault</span> <span class="o">!=</span> <span class="n">NoFault</span> <span class="o">&amp;&amp;</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">translationCompleted</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
 <span class="mi">586</span>         <span class="n">inst</span><span class="o">-&gt;</span><span class="n">savedReq</span><span class="o">-&gt;</span><span class="n">isPartialFault</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">savedReq</span><span class="o">-&gt;</span><span class="n">isComplete</span><span class="p">())</span> <span class="p">{</span>
 <span class="mi">587</span>         <span class="n">assert</span><span class="p">(</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">savedReq</span><span class="o">-&gt;</span><span class="n">isSplit</span><span class="p">());</span>
 <span class="mi">588</span>         <span class="c1">// If we have a partial fault where the mem access is not complete yet</span>
 <span class="mi">589</span>         <span class="c1">// then the cache must have been blocked. This load will be re-executed</span>
 <span class="mi">590</span>         <span class="c1">// when the cache gets unblocked. We will handle the fault when the</span>
 <span class="mi">591</span>         <span class="c1">// mem access is complete.</span>
 <span class="mi">592</span>         <span class="k">return</span> <span class="n">NoFault</span><span class="p">;</span>
 <span class="mi">593</span>     <span class="p">}</span>  
 <span class="mi">594</span>        
 <span class="mi">595</span>     <span class="c1">// If the instruction faulted or predicated false, then we need to send it</span>
 <span class="mi">596</span>     <span class="c1">// along to commit without the instruction completing.</span>
 <span class="mi">597</span>     <span class="nf">if</span> <span class="p">(</span><span class="n">load_fault</span> <span class="o">!=</span> <span class="n">NoFault</span> <span class="o">||</span> <span class="o">!</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">readPredicate</span><span class="p">())</span> <span class="p">{</span>
 <span class="mi">598</span>         <span class="c1">// Send this instruction to commit, also make sure iew stage</span>
 <span class="mi">599</span>         <span class="c1">// realizes there is activity.  Mark it as executed unless it</span>
 <span class="mi">600</span>         <span class="c1">// is a strictly ordered load that needs to hit the head of</span>
 <span class="mi">601</span>         <span class="c1">// commit.</span>
 <span class="mi">602</span>         <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">readPredicate</span><span class="p">())</span>
 <span class="mi">603</span>             <span class="n">inst</span><span class="o">-&gt;</span><span class="n">forwardOldRegs</span><span class="p">();</span>
 <span class="mi">604</span>         <span class="n">DPRINTF</span><span class="p">(</span><span class="n">LSQUnit</span><span class="p">,</span> <span class="s">"Load [sn:%lli] not executed from %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
 <span class="mi">605</span>                 <span class="n">inst</span><span class="o">-&gt;</span><span class="n">seqNum</span><span class="p">,</span>
 <span class="mi">606</span>                 <span class="p">(</span><span class="n">load_fault</span> <span class="o">!=</span> <span class="n">NoFault</span> <span class="o">?</span> <span class="s">"fault"</span> <span class="o">:</span> <span class="s">"predication"</span><span class="p">));</span>
 <span class="mi">607</span>         <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">hasRequest</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">strictlyOrdered</span><span class="p">())</span> <span class="o">||</span>
 <span class="mi">608</span>             <span class="n">inst</span><span class="o">-&gt;</span><span class="n">isAtCommit</span><span class="p">())</span> <span class="p">{</span>
 <span class="mi">609</span>             <span class="n">inst</span><span class="o">-&gt;</span><span class="n">setExecuted</span><span class="p">();</span>
 <span class="mi">610</span>         <span class="p">}</span>
 <span class="mi">611</span>         <span class="n">iewStage</span><span class="o">-&gt;</span><span class="n">instToCommit</span><span class="p">(</span><span class="n">inst</span><span class="p">);</span>
 <span class="mi">612</span>         <span class="n">iewStage</span><span class="o">-&gt;</span><span class="n">activityThisCycle</span><span class="p">();</span>
 <span class="mi">613</span>     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
 <span class="mi">614</span>         <span class="k">if</span> <span class="p">(</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">effAddrValid</span><span class="p">())</span> <span class="p">{</span>
 <span class="mi">615</span>             <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">lqIt</span><span class="p">;</span>
 <span class="mi">616</span>             <span class="o">++</span><span class="n">it</span><span class="p">;</span>
 <span class="mi">617</span> 
 <span class="mi">618</span>             <span class="k">if</span> <span class="p">(</span><span class="n">checkLoads</span><span class="p">)</span>
 <span class="mi">619</span>                 <span class="k">return</span> <span class="n">checkViolations</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">inst</span><span class="p">);</span>
 <span class="mi">620</span>         <span class="p">}</span>
 <span class="mi">621</span>     <span class="p">}</span>
 <span class="mi">622</span> 
 <span class="mi">623</span>     <span class="k">return</span> <span class="n">load_fault</span><span class="p">;</span>
 <span class="mi">624</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<h3 id="initiateacc-handling-tlb-request"><span class="me-2">initiateAcc: handling TLB request</span><a href="#initiateacc-handling-tlb-request" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<p>I already covered InitiateAcc of the memory instructions before. 
However, compared to simple processors, the O3 cpu have different way to 
process the initateAcc.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre><span class="mi">147</span> <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Impl</span><span class="p">&gt;</span>
<span class="mi">148</span> <span class="n">Fault</span>
<span class="mi">149</span> <span class="n">BaseO3DynInst</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;::</span><span class="n">initiateAcc</span><span class="p">()</span>
<span class="mi">150</span> <span class="p">{</span>    
<span class="mi">151</span>     <span class="c1">// @todo: Pretty convoluted way to avoid squashing from happening</span>
<span class="mi">152</span>     <span class="c1">// when using the TC during an instruction's execution</span>
<span class="mi">153</span>     <span class="c1">// (specifically for instructions that have side-effects that use</span>
<span class="mi">154</span>     <span class="c1">// the TC).  Fix this.</span>
<span class="mi">155</span>     <span class="kt">bool</span> <span class="n">no_squash_from_TC</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="o">-&gt;</span><span class="n">noSquashFromTC</span><span class="p">;</span>
<span class="mi">156</span>     <span class="k">this</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="o">-&gt;</span><span class="n">noSquashFromTC</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="mi">157</span> 
<span class="mi">158</span>     <span class="k">this</span><span class="o">-&gt;</span><span class="n">fault</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">staticInst</span><span class="o">-&gt;</span><span class="n">initiateAcc</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">traceData</span><span class="p">);</span>
<span class="mi">159</span> 
<span class="mi">160</span>     <span class="k">this</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="o">-&gt;</span><span class="n">noSquashFromTC</span> <span class="o">=</span> <span class="n">no_squash_from_TC</span><span class="p">;</span>
<span class="mi">161</span> 
<span class="mi">162</span>     <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">fault</span><span class="p">;</span>
<span class="mi">163</span> <span class="p">}</span>    
</pre></td></tr></tbody></table></code></div></div>
<p>Because the staticInst stored in the dynamic instruction is the 
class object of a specific microoperation, 
it will invokes the initiateAcc function of that micro-load/store operation. 
For the memory read operation case, it invokes initiateMemRead function of architecture side.
This will end up invoking initiateMemRead function of the CPU side.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre> <span class="mi">42</span> <span class="k">namespace</span> <span class="n">X86ISA</span>
 <span class="mi">43</span> <span class="p">{</span>
 <span class="mi">44</span> 
 <span class="mi">45</span> <span class="c1">/// Initiate a read from memory in timing mode.</span>
 <span class="mi">46</span> <span class="k">static</span> <span class="n">Fault</span>
 <span class="mi">47</span> <span class="n">initiateMemRead</span><span class="p">(</span><span class="n">ExecContext</span> <span class="o">*</span><span class="n">xc</span><span class="p">,</span> <span class="n">Trace</span><span class="o">::</span><span class="n">InstRecord</span> <span class="o">*</span><span class="n">traceData</span><span class="p">,</span> <span class="n">Addr</span> <span class="n">addr</span><span class="p">,</span>
 <span class="mi">48</span>                 <span class="kt">unsigned</span> <span class="n">dataSize</span><span class="p">,</span> <span class="n">Request</span><span class="o">::</span><span class="n">Flags</span> <span class="n">flags</span><span class="p">)</span>
 <span class="mi">49</span> <span class="p">{</span>
 <span class="mi">50</span>     <span class="k">return</span> <span class="n">xc</span><span class="o">-&gt;</span><span class="n">initiateMemRead</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">dataSize</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
 <span class="mi">51</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre> <span class="mi">962</span> <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Impl</span><span class="p">&gt;</span>
 <span class="mi">963</span> <span class="n">Fault</span>
 <span class="mi">964</span> <span class="n">BaseDynInst</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;::</span><span class="n">initiateMemRead</span><span class="p">(</span><span class="n">Addr</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">size</span><span class="p">,</span>
 <span class="mi">965</span>                                    <span class="n">Request</span><span class="o">::</span><span class="n">Flags</span> <span class="n">flags</span><span class="p">,</span>
 <span class="mi">966</span>                                    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&amp;</span> <span class="n">byte_enable</span><span class="p">)</span>
 <span class="mi">967</span> <span class="p">{</span>
 <span class="mi">968</span>     <span class="n">assert</span><span class="p">(</span><span class="n">byte_enable</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">||</span> <span class="n">byte_enable</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">size</span><span class="p">);</span>
 <span class="mi">969</span>     <span class="k">return</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">pushRequest</span><span class="p">(</span>
 <span class="mi">970</span>             <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">DynInstPtr</span><span class="o">::</span><span class="n">PtrType</span><span class="o">&gt;</span><span class="p">(</span><span class="k">this</span><span class="p">),</span>
 <span class="mi">971</span>             <span class="cm">/* ld */</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">,</span>
 <span class="mi">972</span>             <span class="n">byte_enable</span><span class="p">);</span>
 <span class="mi">973</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>Because the instruction of the O3 CPU is instance of BaseO3DynInst
inheriting the BaseDynInst, when the instruction implementation invokes 
initateMemRead (invoked through the InitateAcc implementation of the instruction),
it invokes the corresponding method implemented in the BaseDynInst class.</p>

<h3 id="pushrequest"><span class="me-2">pushRequest</span><a href="#pushrequest" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre><span class="mi">713</span>     <span class="cm">/** CPU pushRequest function, forwards request to LSQ. */</span>
<span class="mi">714</span>     <span class="n">Fault</span> <span class="nf">pushRequest</span><span class="p">(</span><span class="k">const</span> <span class="n">DynInstPtr</span><span class="o">&amp;</span> <span class="n">inst</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">isLoad</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
<span class="mi">715</span>                       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">Addr</span> <span class="n">addr</span><span class="p">,</span> <span class="n">Request</span><span class="o">::</span><span class="n">Flags</span> <span class="n">flags</span><span class="p">,</span>
<span class="mi">716</span>                       <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="n">AtomicOpFunctorPtr</span> <span class="n">amo_op</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span>
<span class="mi">717</span>                       <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&amp;</span> <span class="n">byte_enable</span> <span class="o">=</span>
<span class="mi">718</span>                           <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">())</span>
<span class="mi">719</span> 
<span class="mi">720</span>     <span class="p">{</span>
<span class="mi">721</span>         <span class="k">return</span> <span class="n">iew</span><span class="p">.</span><span class="n">ldstQueue</span><span class="p">.</span><span class="n">pushRequest</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="n">isLoad</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span>
<span class="mi">722</span>                 <span class="n">flags</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">amo_op</span><span class="p">),</span> <span class="n">byte_enable</span><span class="p">);</span>
<span class="mi">723</span>     <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>Instead of directly handling the load operation, 
initiateMemRead pushes the request to the load queue through the pushRequest function. 
This design seems to be odd because the initateAcc function has been invoked 
by the lsq at the first place, and the instruction forward the request 
to the loadstore queue once again. It might have been just implemented 
as simple function that handles the request directly without going through
multiple different units. Anyway, initiateMemRead invokes the pushRequest of the CPU side
and it will end up invoking pushRequest of the LSQ.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
</pre></td><td class="rouge-code"><pre> <span class="mi">693</span> <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Impl</span><span class="p">&gt;</span>
 <span class="mi">694</span> <span class="n">Fault</span>
 <span class="mi">695</span> <span class="n">LSQ</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;::</span><span class="n">pushRequest</span><span class="p">(</span><span class="k">const</span> <span class="n">DynInstPtr</span><span class="o">&amp;</span> <span class="n">inst</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">isLoad</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
 <span class="mi">696</span>                        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">Addr</span> <span class="n">addr</span><span class="p">,</span> <span class="n">Request</span><span class="o">::</span><span class="n">Flags</span> <span class="n">flags</span><span class="p">,</span>
 <span class="mi">697</span>                        <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="n">AtomicOpFunctorPtr</span> <span class="n">amo_op</span><span class="p">,</span>
 <span class="mi">698</span>                        <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&amp;</span> <span class="n">byte_enable</span><span class="p">)</span>
 <span class="mi">699</span> <span class="p">{</span>
 <span class="mi">700</span>     <span class="c1">// This comming request can be either load, store or atomic.</span>
 <span class="mi">701</span>     <span class="c1">// Atomic request has a corresponding pointer to its atomic memory</span>
 <span class="mi">702</span>     <span class="c1">// operation</span>
 <span class="mi">703</span>     <span class="kt">bool</span> <span class="n">isAtomic</span> <span class="n">M5_VAR_USED</span> <span class="o">=</span> <span class="o">!</span><span class="n">isLoad</span> <span class="o">&amp;&amp;</span> <span class="n">amo_op</span><span class="p">;</span>
 <span class="mi">704</span> 
 <span class="mi">705</span>     <span class="n">ThreadID</span> <span class="n">tid</span> <span class="o">=</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">contextToThread</span><span class="p">(</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">contextId</span><span class="p">());</span>
 <span class="mi">706</span>     <span class="k">auto</span> <span class="n">cacheLineSize</span> <span class="o">=</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">cacheLineSize</span><span class="p">();</span>
 <span class="mi">707</span>     <span class="kt">bool</span> <span class="n">needs_burst</span> <span class="o">=</span> <span class="n">transferNeedsBurst</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">cacheLineSize</span><span class="p">);</span>
 <span class="mi">708</span>     <span class="n">LSQRequest</span><span class="o">*</span> <span class="n">req</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
 <span class="mi">709</span> 
 <span class="mi">710</span>     <span class="c1">// Atomic requests that access data across cache line boundary are</span>
 <span class="mi">711</span>     <span class="c1">// currently not allowed since the cache does not guarantee corresponding</span>
 <span class="mi">712</span>     <span class="c1">// atomic memory operations to be executed atomically across a cache line.</span>
 <span class="mi">713</span>     <span class="c1">// For ISAs such as x86 that supports cross-cache-line atomic instructions,</span>
 <span class="mi">714</span>     <span class="c1">// the cache needs to be modified to perform atomic update to both cache</span>
 <span class="mi">715</span>     <span class="c1">// lines. For now, such cross-line update is not supported.</span>
 <span class="mi">716</span>     <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">isAtomic</span> <span class="o">||</span> <span class="p">(</span><span class="n">isAtomic</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">needs_burst</span><span class="p">));</span>
 <span class="mi">717</span> 
 <span class="mi">718</span>     <span class="k">if</span> <span class="p">(</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">translationStarted</span><span class="p">())</span> <span class="p">{</span>
 <span class="mi">719</span>         <span class="n">req</span> <span class="o">=</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">savedReq</span><span class="p">;</span>
 <span class="mi">720</span>         <span class="n">assert</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
 <span class="mi">721</span>     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
 <span class="mi">722</span>         <span class="k">if</span> <span class="p">(</span><span class="n">needs_burst</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">723</span>             <span class="n">req</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SplitDataRequest</span><span class="p">(</span><span class="o">&amp;</span><span class="kr">thread</span><span class="p">[</span><span class="n">tid</span><span class="p">],</span> <span class="n">inst</span><span class="p">,</span> <span class="n">isLoad</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span>
 <span class="mi">724</span>                     <span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
 <span class="mi">725</span>         <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
 <span class="mi">726</span>             <span class="n">req</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SingleDataRequest</span><span class="p">(</span><span class="o">&amp;</span><span class="kr">thread</span><span class="p">[</span><span class="n">tid</span><span class="p">],</span> <span class="n">inst</span><span class="p">,</span> <span class="n">isLoad</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span>
 <span class="mi">727</span>                     <span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">amo_op</span><span class="p">));</span>
 <span class="mi">728</span>         <span class="p">}</span>
 <span class="mi">729</span>         <span class="nf">assert</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
 <span class="mi">730</span>         <span class="nf">if</span> <span class="p">(</span><span class="o">!</span><span class="n">byte_enable</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
 <span class="mi">731</span>             <span class="n">req</span><span class="o">-&gt;</span><span class="n">_byteEnable</span> <span class="o">=</span> <span class="n">byte_enable</span><span class="p">;</span>
 <span class="mi">732</span>         <span class="p">}</span>
 <span class="mi">733</span>         <span class="n">inst</span><span class="o">-&gt;</span><span class="n">setRequest</span><span class="p">();</span>
 <span class="mi">734</span>         <span class="n">req</span><span class="o">-&gt;</span><span class="n">taskId</span><span class="p">(</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">taskId</span><span class="p">());</span>
 <span class="mi">735</span> 
 <span class="mi">736</span>         <span class="c1">// There might be fault from a previous execution attempt if this is</span>
 <span class="mi">737</span>         <span class="c1">// a strictly ordered load</span>
 <span class="mi">738</span>         <span class="n">inst</span><span class="o">-&gt;</span><span class="n">getFault</span><span class="p">()</span> <span class="o">=</span> <span class="n">NoFault</span><span class="p">;</span>
 <span class="mi">739</span> 
 <span class="mi">740</span>         <span class="n">req</span><span class="o">-&gt;</span><span class="n">initiateTranslation</span><span class="p">();</span>
 <span class="mi">741</span>     <span class="p">}</span>
 <span class="mi">742</span> 
 <span class="mi">743</span>     <span class="cm">/* This is the place were instructions get the effAddr. */</span>
 <span class="mi">744</span>     <span class="nf">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">isTranslationComplete</span><span class="p">())</span> <span class="p">{</span>
 <span class="mi">745</span>         <span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">isMemAccessRequired</span><span class="p">())</span> <span class="p">{</span>
 <span class="mi">746</span>             <span class="n">inst</span><span class="o">-&gt;</span><span class="n">effAddr</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">getVaddr</span><span class="p">();</span>
 <span class="mi">747</span>             <span class="n">inst</span><span class="o">-&gt;</span><span class="n">effSize</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
 <span class="mi">748</span>             <span class="n">inst</span><span class="o">-&gt;</span><span class="n">effAddrValid</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
 <span class="mi">749</span> 
 <span class="mi">750</span>             <span class="k">if</span> <span class="p">(</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">checker</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">751</span>                 <span class="n">inst</span><span class="o">-&gt;</span><span class="n">reqToVerify</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Request</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">());</span>
 <span class="mi">752</span>             <span class="p">}</span>
 <span class="mi">753</span>             <span class="n">Fault</span> <span class="n">fault</span><span class="p">;</span>
 <span class="mi">754</span>             <span class="nf">if</span> <span class="p">(</span><span class="n">isLoad</span><span class="p">)</span>
 <span class="mi">755</span>                 <span class="n">fault</span> <span class="o">=</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">lqIdx</span><span class="p">);</span>
 <span class="mi">756</span>             <span class="k">else</span>
 <span class="mi">757</span>                 <span class="n">fault</span> <span class="o">=</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">sqIdx</span><span class="p">);</span>
 <span class="mi">758</span>             <span class="c1">// inst-&gt;getFault() may have the first-fault of a</span>
 <span class="mi">759</span>             <span class="c1">// multi-access split request at this point.</span>
 <span class="mi">760</span>             <span class="c1">// Overwrite that only if we got another type of fault</span>
 <span class="mi">761</span>             <span class="c1">// (e.g. re-exec).</span>
 <span class="mi">762</span>             <span class="k">if</span> <span class="p">(</span><span class="n">fault</span> <span class="o">!=</span> <span class="n">NoFault</span><span class="p">)</span>
 <span class="mi">763</span>                 <span class="n">inst</span><span class="o">-&gt;</span><span class="n">getFault</span><span class="p">()</span> <span class="o">=</span> <span class="n">fault</span><span class="p">;</span>
 <span class="mi">764</span>         <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">isLoad</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">765</span>             <span class="n">inst</span><span class="o">-&gt;</span><span class="n">setMemAccPredicate</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
 <span class="mi">766</span>             <span class="c1">// Commit will have to clean up whatever happened.  Set this</span>
 <span class="mi">767</span>             <span class="c1">// instruction as executed.</span>
 <span class="mi">768</span>             <span class="n">inst</span><span class="o">-&gt;</span><span class="n">setExecuted</span><span class="p">();</span>
 <span class="mi">769</span>         <span class="p">}</span>
 <span class="mi">770</span>     <span class="p">}</span>
 <span class="mi">771</span> 
 <span class="mi">772</span>     <span class="nf">if</span> <span class="p">(</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">traceData</span><span class="p">)</span>
 <span class="mi">773</span>         <span class="n">inst</span><span class="o">-&gt;</span><span class="n">traceData</span><span class="o">-&gt;</span><span class="n">setMem</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
 <span class="mi">774</span> 
 <span class="mi">775</span>     <span class="k">return</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">getFault</span><span class="p">();</span>
 <span class="mi">776</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>The dynamic instruction can track whether the current instruction has started 
TLB translation by checking the flag stored in the instruction.
It provide the interface to access that information, called 
<strong>translationStarted</strong>
When the instruction set that flag, 
it means that the instruction already started the TLB access but waiting response.
In the delayed TLB response case, the instruction stores the request information 
in its instruction object. 
Therefore, it can retrieve the request that has sent to TLB before. 
However, if it is the first time of execution, then 
it should generate new request.
As shown in line 722-728, 
if the request should access two separate cache blocks,
it generates <strong>SplitDataRequest</strong> request object. 
However, if it only access one block, then 
<strong>SingleDataRequest</strong> request object is generated instead. 
After the request has been produced, 
it should set proper flags of the instruction object to indicate 
the instruction initiated the TLB access (line 733). 
After that, the <strong>initiateTranslation</strong> function provided by the request object is invoked 
to actually generate accesses to the TLBs.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="rouge-code"><pre> <span class="mi">860</span> <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Impl</span><span class="p">&gt;</span>
 <span class="mi">861</span> <span class="kt">void</span>
 <span class="mi">862</span> <span class="n">LSQ</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;::</span><span class="n">SingleDataRequest</span><span class="o">::</span><span class="n">initiateTranslation</span><span class="p">()</span>
 <span class="mi">863</span> <span class="p">{</span>
 <span class="mi">864</span>     <span class="n">assert</span><span class="p">(</span><span class="n">_requests</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
 <span class="mi">865</span> 
 <span class="mi">866</span>     <span class="k">this</span><span class="o">-&gt;</span><span class="n">addRequest</span><span class="p">(</span><span class="n">_addr</span><span class="p">,</span> <span class="n">_size</span><span class="p">,</span> <span class="n">_byteEnable</span><span class="p">);</span>
 <span class="mi">867</span> 
 <span class="mi">868</span>     <span class="k">if</span> <span class="p">(</span><span class="n">_requests</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">869</span>         <span class="n">_requests</span><span class="p">.</span><span class="n">back</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">setReqInstSeqNum</span><span class="p">(</span><span class="n">_inst</span><span class="o">-&gt;</span><span class="n">seqNum</span><span class="p">);</span>
 <span class="mi">870</span>         <span class="n">_requests</span><span class="p">.</span><span class="n">back</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">taskId</span><span class="p">(</span><span class="n">_taskId</span><span class="p">);</span>
 <span class="mi">871</span>         <span class="n">_inst</span><span class="o">-&gt;</span><span class="n">translationStarted</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
 <span class="mi">872</span>         <span class="n">setState</span><span class="p">(</span><span class="n">State</span><span class="o">::</span><span class="n">Translation</span><span class="p">);</span>
 <span class="mi">873</span>         <span class="n">flags</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="n">Flag</span><span class="o">::</span><span class="n">TranslationStarted</span><span class="p">);</span>
 <span class="mi">874</span> 
 <span class="mi">875</span>         <span class="n">_inst</span><span class="o">-&gt;</span><span class="n">savedReq</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
 <span class="mi">876</span>         <span class="n">sendFragmentToTranslation</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
 <span class="mi">877</span>     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
 <span class="mi">878</span>         <span class="n">_inst</span><span class="o">-&gt;</span><span class="n">setMemAccPredicate</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
 <span class="mi">879</span>     <span class="p">}</span>
 <span class="mi">880</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>The <strong>addRequest</strong> just generates packet need to be sent to the TLB unit.
Although the current object can be interpreted as just an request itself 
that can be directly sent to the TLB unit, but it is a wrapper for 
all the required interface and data structures to resolve TLB access.
For example, it includes the ports connected with the TLB unit so that 
the generated request and its response can be communicated through that port.
Anyway, the addRequest function just generates the real packet 
understandable by the TLB unit.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre> <span class="mi">407</span>         <span class="kt">void</span>
 <span class="mi">408</span>         <span class="nf">addRequest</span><span class="p">(</span><span class="n">Addr</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">size</span><span class="p">,</span>
 <span class="mi">409</span>                    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&amp;</span> <span class="n">byte_enable</span><span class="p">)</span>
 <span class="mi">410</span>         <span class="p">{</span>
 <span class="mi">411</span>             <span class="k">if</span> <span class="p">(</span><span class="n">byte_enable</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">||</span>
 <span class="mi">412</span>                 <span class="n">isAnyActiveElement</span><span class="p">(</span><span class="n">byte_enable</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">byte_enable</span><span class="p">.</span><span class="n">end</span><span class="p">()))</span> <span class="p">{</span>
 <span class="mi">413</span>                 <span class="k">auto</span> <span class="n">request</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Request</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_inst</span><span class="o">-&gt;</span><span class="n">getASID</span><span class="p">(),</span>
 <span class="mi">414</span>                         <span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">_flags</span><span class="p">,</span> <span class="n">_inst</span><span class="o">-&gt;</span><span class="n">masterId</span><span class="p">(),</span>
 <span class="mi">415</span>                         <span class="n">_inst</span><span class="o">-&gt;</span><span class="n">instAddr</span><span class="p">(),</span> <span class="n">_inst</span><span class="o">-&gt;</span><span class="n">contextId</span><span class="p">(),</span>
 <span class="mi">416</span>                         <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">_amo_op</span><span class="p">));</span>
 <span class="mi">417</span>                 <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">byte_enable</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
 <span class="mi">418</span>                     <span class="n">request</span><span class="o">-&gt;</span><span class="n">setByteEnable</span><span class="p">(</span><span class="n">byte_enable</span><span class="p">);</span>
 <span class="mi">419</span>                 <span class="p">}</span>
 <span class="mi">420</span>                 <span class="n">_requests</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">request</span><span class="p">);</span>                                                                                                                                                                  
 <span class="mi">421</span>             <span class="p">}</span>
 <span class="mi">422</span>         <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>The addRequest function of the LSQRquest class
just generates the request and save it to the <strong>_requests</strong> vector 
to send them later. 
After the request packets are generated, 
initiateTranslation invokes <strong>sendFragmentToTranslation</strong> to 
send the generated packet(s) to the TLB.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre> <span class="mi">980</span> <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Impl</span><span class="p">&gt;</span>
 <span class="mi">981</span> <span class="kt">void</span>
 <span class="mi">982</span> <span class="n">LSQ</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;::</span><span class="n">LSQRequest</span><span class="o">::</span><span class="n">sendFragmentToTranslation</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
 <span class="mi">983</span> <span class="p">{</span>
 <span class="mi">984</span>     <span class="n">numInTranslationFragments</span><span class="o">++</span><span class="p">;</span>
 <span class="mi">985</span>     <span class="n">_port</span><span class="p">.</span><span class="n">dTLB</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">translateTiming</span><span class="p">(</span>
 <span class="mi">986</span>             <span class="k">this</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">(</span><span class="n">i</span><span class="p">),</span>
 <span class="mi">987</span>             <span class="k">this</span><span class="o">-&gt;</span><span class="n">_inst</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="o">-&gt;</span><span class="n">getTC</span><span class="p">(),</span> <span class="k">this</span><span class="p">,</span>
 <span class="mi">988</span>             <span class="k">this</span><span class="o">-&gt;</span><span class="n">isLoad</span><span class="p">()</span> <span class="o">?</span> <span class="n">BaseTLB</span><span class="o">::</span><span class="n">Read</span> <span class="o">:</span> <span class="n">BaseTLB</span><span class="o">::</span><span class="n">Write</span><span class="p">);</span>
 <span class="mi">989</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>Remember that the <strong>SingleDataRequest</strong> has only one request packet.
Therefore, it has only one entry in the _requests vector. 
This function sends the request stored in the _requests vector to the TLB.
Note that the argument is used to index the entry stored in the _requests vector. 
You can see that it invokes the translateTiming of the dTLB connected to the LSQ.
The details of the translateTiming function of the TLB is explained in the previous posting.
Also, note that it passes the <strong>this</strong> as the translation object parameter. 
Because the translation object is used to invoke the finish function when the TLB access is resolved.</p>

<h3 id="response-of-lsq-for-the-tlb-resolution"><span class="me-2">Response of LSQ for the TLB resolution</span><a href="#response-of-lsq-for-the-tlb-resolution" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="rouge-code"><pre> <span class="mi">778</span> <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Impl</span><span class="p">&gt;</span>
 <span class="mi">779</span> <span class="kt">void</span>
 <span class="mi">780</span> <span class="n">LSQ</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;::</span><span class="n">SingleDataRequest</span><span class="o">::</span><span class="n">finish</span><span class="p">(</span><span class="k">const</span> <span class="n">Fault</span> <span class="o">&amp;</span><span class="n">fault</span><span class="p">,</span> <span class="k">const</span> <span class="n">RequestPtr</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">,</span>
 <span class="mi">781</span>         <span class="n">ThreadContext</span><span class="o">*</span> <span class="n">tc</span><span class="p">,</span> <span class="n">BaseTLB</span><span class="o">::</span><span class="n">Mode</span> <span class="n">mode</span><span class="p">)</span>
 <span class="mi">782</span> <span class="p">{</span>
 <span class="mi">783</span>     <span class="n">_fault</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">fault</span><span class="p">);</span>
 <span class="mi">784</span>     <span class="n">numInTranslationFragments</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="mi">785</span>     <span class="n">numTranslatedFragments</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
 <span class="mi">786</span>     <span class="cm">/* If the instruction has been squahsed, let the request know
 787      * as it may have to self-destruct. */</span>
 <span class="mi">788</span>     <span class="k">if</span> <span class="p">(</span><span class="n">_inst</span><span class="o">-&gt;</span><span class="n">isSquashed</span><span class="p">())</span> <span class="p">{</span>
 <span class="mi">789</span>         <span class="k">this</span><span class="o">-&gt;</span><span class="n">squashTranslation</span><span class="p">();</span>
 <span class="mi">790</span>     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
 <span class="mi">791</span>         <span class="n">_inst</span><span class="o">-&gt;</span><span class="n">strictlyOrdered</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">isStrictlyOrdered</span><span class="p">());</span>
 <span class="mi">792</span> 
 <span class="mi">793</span>         <span class="n">flags</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="n">Flag</span><span class="o">::</span><span class="n">TranslationFinished</span><span class="p">);</span>
 <span class="mi">794</span>         <span class="k">if</span> <span class="p">(</span><span class="n">fault</span> <span class="o">==</span> <span class="n">NoFault</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">795</span>             <span class="n">_inst</span><span class="o">-&gt;</span><span class="n">physEffAddr</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">getPaddr</span><span class="p">();</span>
 <span class="mi">796</span>             <span class="n">_inst</span><span class="o">-&gt;</span><span class="n">memReqFlags</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">getFlags</span><span class="p">();</span>
 <span class="mi">797</span>             <span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">isCondSwap</span><span class="p">())</span> <span class="p">{</span>
 <span class="mi">798</span>                 <span class="n">assert</span><span class="p">(</span><span class="n">_res</span><span class="p">);</span>
 <span class="mi">799</span>                 <span class="n">req</span><span class="o">-&gt;</span><span class="n">setExtraData</span><span class="p">(</span><span class="o">*</span><span class="n">_res</span><span class="p">);</span>
 <span class="mi">800</span>             <span class="p">}</span>
 <span class="mi">801</span>             <span class="nf">setState</span><span class="p">(</span><span class="n">State</span><span class="o">::</span><span class="n">Request</span><span class="p">);</span>
 <span class="mi">802</span>         <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
 <span class="mi">803</span>             <span class="n">setState</span><span class="p">(</span><span class="n">State</span><span class="o">::</span><span class="n">Fault</span><span class="p">);</span>
 <span class="mi">804</span>         <span class="p">}</span>
 <span class="mi">805</span> 
 <span class="mi">806</span>         <span class="n">LSQRequest</span><span class="o">::</span><span class="n">_inst</span><span class="o">-&gt;</span><span class="n">fault</span> <span class="o">=</span> <span class="n">fault</span><span class="p">;</span>
 <span class="mi">807</span>         <span class="n">LSQRequest</span><span class="o">::</span><span class="n">_inst</span><span class="o">-&gt;</span><span class="n">translationCompleted</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
 <span class="mi">808</span>     <span class="p">}</span>
 <span class="mi">809</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>When the translation is completed, the finish function provided by the Request 
generated by the LSQ will be invoked at the end of the translation. 
As shwon in the above code, 
it first checks whether the instruction has been squashed 
while the TLB process the request. 
If it has not been squashed, it will set required flags 
indicating the translation is completed for specific instruction.
Note that it sets various fields of the instruction that has initiated the 
TLB request (_inst in the line 790-808). 
One of the most important field changed by the finish function is <strong>_state</strong> field of the request.
This field indicates current status of the TLB request and can be set to other state 
by using the setState function. 
Remind that how the simpleCPU starts memory access after the TLB is resolved. 
It initiates memory operation at the end of the finish function.
However, O3 cpu does not invoke any related functions to generate 
actual memory request when the TLB is resolved. Then when and where the O3,
especially the LSQ initiates the memory operation?
The answer is in the pushRequest!</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre></td><td class="rouge-code"><pre> <span class="mi">693</span> <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Impl</span><span class="p">&gt;</span>
 <span class="mi">694</span> <span class="n">Fault</span>
 <span class="mi">695</span> <span class="n">LSQ</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;::</span><span class="n">pushRequest</span><span class="p">(</span><span class="k">const</span> <span class="n">DynInstPtr</span><span class="o">&amp;</span> <span class="n">inst</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">isLoad</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
 <span class="mi">696</span>                        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">Addr</span> <span class="n">addr</span><span class="p">,</span> <span class="n">Request</span><span class="o">::</span><span class="n">Flags</span> <span class="n">flags</span><span class="p">,</span>
 <span class="mi">697</span>                        <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="n">AtomicOpFunctorPtr</span> <span class="n">amo_op</span><span class="p">,</span>
 <span class="mi">698</span>                        <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&amp;</span> <span class="n">byte_enable</span><span class="p">)</span>
 <span class="mi">699</span> <span class="p">{</span>
 <span class="p">......</span>
 <span class="mi">743</span>     <span class="cm">/* This is the place were instructions get the effAddr. */</span>
 <span class="mi">744</span>     <span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">isTranslationComplete</span><span class="p">())</span> <span class="p">{</span>
 <span class="mi">745</span>         <span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">isMemAccessRequired</span><span class="p">())</span> <span class="p">{</span>
 <span class="mi">746</span>             <span class="n">inst</span><span class="o">-&gt;</span><span class="n">effAddr</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">getVaddr</span><span class="p">();</span>
 <span class="mi">747</span>             <span class="n">inst</span><span class="o">-&gt;</span><span class="n">effSize</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
 <span class="mi">748</span>             <span class="n">inst</span><span class="o">-&gt;</span><span class="n">effAddrValid</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
 <span class="mi">749</span>
 <span class="mi">750</span>             <span class="k">if</span> <span class="p">(</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">checker</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">751</span>                 <span class="n">inst</span><span class="o">-&gt;</span><span class="n">reqToVerify</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Request</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">());</span>
 <span class="mi">752</span>             <span class="p">}</span>
 <span class="mi">753</span>             <span class="n">Fault</span> <span class="n">fault</span><span class="p">;</span>
 <span class="mi">754</span>             <span class="nf">if</span> <span class="p">(</span><span class="n">isLoad</span><span class="p">)</span>
 <span class="mi">755</span>                 <span class="n">fault</span> <span class="o">=</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">lqIdx</span><span class="p">);</span>
 <span class="mi">756</span>             <span class="k">else</span>
 <span class="mi">757</span>                 <span class="n">fault</span> <span class="o">=</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">sqIdx</span><span class="p">);</span>
 <span class="mi">758</span>             <span class="c1">// inst-&gt;getFault() may have the first-fault of a</span>
 <span class="mi">759</span>             <span class="c1">// multi-access split request at this point.</span>
 <span class="mi">760</span>             <span class="c1">// Overwrite that only if we got another type of fault</span>
 <span class="mi">761</span>             <span class="c1">// (e.g. re-exec).</span>
 <span class="mi">762</span>             <span class="k">if</span> <span class="p">(</span><span class="n">fault</span> <span class="o">!=</span> <span class="n">NoFault</span><span class="p">)</span>
 <span class="mi">763</span>                 <span class="n">inst</span><span class="o">-&gt;</span><span class="n">getFault</span><span class="p">()</span> <span class="o">=</span> <span class="n">fault</span><span class="p">;</span>
 <span class="mi">764</span>         <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">isLoad</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">765</span>             <span class="n">inst</span><span class="o">-&gt;</span><span class="n">setMemAccPredicate</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
 <span class="mi">766</span>             <span class="c1">// Commit will have to clean up whatever happened.  Set this</span>
 <span class="mi">767</span>             <span class="c1">// instruction as executed.</span>
 <span class="mi">768</span>             <span class="n">inst</span><span class="o">-&gt;</span><span class="n">setExecuted</span><span class="p">();</span>
 <span class="mi">769</span>         <span class="p">}</span>
 <span class="mi">770</span>     <span class="p">}</span>
 <span class="mi">771</span>
 <span class="mi">772</span>     <span class="nf">if</span> <span class="p">(</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">traceData</span><span class="p">)</span>
 <span class="mi">773</span>         <span class="n">inst</span><span class="o">-&gt;</span><span class="n">traceData</span><span class="o">-&gt;</span><span class="n">setMem</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
 <span class="mi">774</span>
 <span class="mi">775</span>     <span class="k">return</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">getFault</span><span class="p">();</span>
 <span class="mi">776</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>It first checks the TLB translation is finished by invoking isTranslationComplete.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre> <span class="mi">586</span>         <span class="kt">bool</span>
 <span class="mi">587</span>         <span class="n">isInTranslation</span><span class="p">()</span>
 <span class="mi">588</span>         <span class="p">{</span>
 <span class="mi">589</span>             <span class="k">return</span> <span class="n">_state</span> <span class="o">==</span> <span class="n">State</span><span class="o">::</span><span class="n">Translation</span><span class="p">;</span>
 <span class="mi">590</span>         <span class="p">}</span>
 <span class="mi">591</span> 
 <span class="mi">592</span>         <span class="kt">bool</span>
 <span class="mi">593</span>         <span class="nf">isTranslationComplete</span><span class="p">()</span>
 <span class="mi">594</span>         <span class="p">{</span>
 <span class="mi">595</span>             <span class="k">return</span> <span class="n">flags</span><span class="p">.</span><span class="n">isSet</span><span class="p">(</span><span class="n">Flag</span><span class="o">::</span><span class="n">TranslationStarted</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
 <span class="mi">596</span>                    <span class="o">!</span><span class="n">isInTranslation</span><span class="p">();</span>
 <span class="mi">597</span>         <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>You might remember that the _state field was changed 
when the finish function of the TLB request packet is invoked. 
Therefore, if the TLB request is already resolved, 
the isTranslationComplete function will return true.
And then the actual memory read or write operation is made based on the instruction type. 
Because the translation packet <strong>req</strong> has translated physical address 
from the virtual address, it should also be passed to the operation because 
memory operation should target the physical address not the virtual address.
Because we care currently dealing with the read operation, let’s take a look at 
how the O3 access the real memory.</p>

<h3 id="cpu-read-lsqread-lsqunitread"><span class="me-2">CPU-&gt;read-&gt;LSQ::read-&gt;LSQUnit::read</span><a href="#cpu-read-lsqread-lsqunitread" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="mi">725</span>     <span class="cm">/** CPU read function, forwards read to LSQ. */</span>
<span class="mi">726</span>     <span class="n">Fault</span> <span class="nf">read</span><span class="p">(</span><span class="n">LSQRequest</span><span class="o">*</span> <span class="n">req</span><span class="p">,</span> <span class="kt">int</span> <span class="n">load_idx</span><span class="p">)</span>
<span class="mi">727</span>     <span class="p">{</span>
<span class="mi">728</span>         <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">iew</span><span class="p">.</span><span class="n">ldstQueue</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">load_idx</span><span class="p">);</span>
<span class="mi">729</span>     <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="mi">1125</span> <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Impl</span><span class="p">&gt;</span>
<span class="mi">1126</span> <span class="n">Fault</span>
<span class="mi">1127</span> <span class="n">LSQ</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;::</span><span class="n">read</span><span class="p">(</span><span class="n">LSQRequest</span><span class="o">*</span> <span class="n">req</span><span class="p">,</span> <span class="kt">int</span> <span class="n">load_idx</span><span class="p">)</span>
<span class="mi">1128</span> <span class="p">{</span>
<span class="mi">1129</span>     <span class="n">ThreadID</span> <span class="n">tid</span> <span class="o">=</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">contextToThread</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">contextId</span><span class="p">());</span>
<span class="mi">1130</span> 
<span class="mi">1131</span>     <span class="k">return</span> <span class="kr">thread</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">tid</span><span class="p">).</span><span class="n">read</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">load_idx</span><span class="p">);</span>
<span class="mi">1132</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>The processor load function handles four different memory load operations:
LLSC (locked load/store), MappedIPR (memory mapped register), 
store forwarding, and just memory load operation. 
I will cover the plain memory load operation that will try to access the data
from the cache and memory. The store forwarding case will be handled 
in the other posting.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
</pre></td><td class="rouge-code"><pre><span class="mi">621</span> <span class="n">LSQUnit</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;::</span><span class="n">read</span><span class="p">(</span><span class="n">LSQRequest</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="kt">int</span> <span class="n">load_idx</span><span class="p">)</span>
<span class="mi">622</span> <span class="p">{</span>
<span class="mi">623</span>     <span class="n">LQEntry</span><span class="o">&amp;</span> <span class="n">load_req</span> <span class="o">=</span> <span class="n">loadQueue</span><span class="p">[</span><span class="n">load_idx</span><span class="p">];</span>
<span class="mi">624</span>     <span class="k">const</span> <span class="n">DynInstPtr</span><span class="o">&amp;</span> <span class="n">load_inst</span> <span class="o">=</span> <span class="n">load_req</span><span class="p">.</span><span class="n">instruction</span><span class="p">();</span>
<span class="mi">625</span> 
<span class="mi">626</span>     <span class="n">load_req</span><span class="p">.</span><span class="n">setRequest</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
<span class="mi">627</span>     <span class="n">assert</span><span class="p">(</span><span class="n">load_inst</span><span class="p">);</span>
<span class="mi">628</span> 
<span class="mi">629</span>     <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">load_inst</span><span class="o">-&gt;</span><span class="n">isExecuted</span><span class="p">());</span>
<span class="mi">630</span> 
<span class="mi">631</span>     <span class="c1">// Make sure this isn't a strictly ordered load</span>
<span class="mi">632</span>     <span class="c1">// A bit of a hackish way to get strictly ordered accesses to work</span>
<span class="mi">633</span>     <span class="c1">// only if they're at the head of the LSQ and are ready to commit</span>
<span class="mi">634</span>     <span class="c1">// (at the head of the ROB too).</span>
<span class="mi">635</span> 
<span class="mi">636</span>     <span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">mainRequest</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">isStrictlyOrdered</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
<span class="mi">637</span>         <span class="p">(</span><span class="n">load_idx</span> <span class="o">!=</span> <span class="n">loadQueue</span><span class="p">.</span><span class="n">head</span><span class="p">()</span> <span class="o">||</span> <span class="o">!</span><span class="n">load_inst</span><span class="o">-&gt;</span><span class="n">isAtCommit</span><span class="p">()))</span> <span class="p">{</span>
<span class="mi">638</span>         <span class="c1">// Tell IQ/mem dep unit that this instruction will need to be</span>
<span class="mi">639</span>         <span class="c1">// rescheduled eventually</span>
<span class="mi">640</span>         <span class="n">iewStage</span><span class="o">-&gt;</span><span class="n">rescheduleMemInst</span><span class="p">(</span><span class="n">load_inst</span><span class="p">);</span>
<span class="mi">641</span>         <span class="n">load_inst</span><span class="o">-&gt;</span><span class="n">clearIssued</span><span class="p">();</span>
<span class="mi">642</span>         <span class="n">load_inst</span><span class="o">-&gt;</span><span class="n">effAddrValid</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
<span class="mi">643</span>         <span class="o">++</span><span class="n">lsqRescheduledLoads</span><span class="p">;</span>
<span class="mi">644</span>         <span class="n">DPRINTF</span><span class="p">(</span><span class="n">LSQUnit</span><span class="p">,</span> <span class="s">"Strictly ordered load [sn:%lli] PC %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
<span class="mi">645</span>                 <span class="n">load_inst</span><span class="o">-&gt;</span><span class="n">seqNum</span><span class="p">,</span> <span class="n">load_inst</span><span class="o">-&gt;</span><span class="n">pcState</span><span class="p">());</span>
<span class="mi">646</span> 
<span class="mi">647</span>         <span class="c1">// Must delete request now that it wasn't handed off to</span>
<span class="mi">648</span>         <span class="c1">// memory.  This is quite ugly.  @todo: Figure out the proper</span>
<span class="mi">649</span>         <span class="c1">// place to really handle request deletes.</span>
<span class="mi">650</span>         <span class="n">load_req</span><span class="p">.</span><span class="n">setRequest</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">);</span>
<span class="mi">651</span>         <span class="n">req</span><span class="o">-&gt;</span><span class="n">discard</span><span class="p">();</span>
<span class="mi">652</span>         <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">GenericISA</span><span class="o">::</span><span class="n">M5PanicFault</span><span class="o">&gt;</span><span class="p">(</span>
<span class="mi">653</span>             <span class="s">"Strictly ordered load [sn:%llx] PC %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
<span class="mi">654</span>             <span class="n">load_inst</span><span class="o">-&gt;</span><span class="n">seqNum</span><span class="p">,</span> <span class="n">load_inst</span><span class="o">-&gt;</span><span class="n">pcState</span><span class="p">());</span>
<span class="mi">655</span>     <span class="p">}</span>
<span class="mi">656</span> 
<span class="mi">657</span>     <span class="nf">DPRINTF</span><span class="p">(</span><span class="n">LSQUnit</span><span class="p">,</span> <span class="s">"Read called, load idx: %i, store idx: %i, "</span>
<span class="mi">658</span>             <span class="s">"storeHead: %i addr: %#x%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
<span class="mi">659</span>             <span class="n">load_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">load_inst</span><span class="o">-&gt;</span><span class="n">sqIt</span><span class="p">.</span><span class="n">_idx</span><span class="p">,</span> <span class="n">storeQueue</span><span class="p">.</span><span class="n">head</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
<span class="mi">660</span>             <span class="n">req</span><span class="o">-&gt;</span><span class="n">mainRequest</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getPaddr</span><span class="p">(),</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">isSplit</span><span class="p">()</span> <span class="o">?</span> <span class="s">" split"</span> <span class="o">:</span> <span class="s">""</span><span class="p">);</span>
<span class="mi">661</span> 
<span class="mi">662</span>     <span class="nf">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">mainRequest</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">isLLSC</span><span class="p">())</span> <span class="p">{</span>
<span class="mi">663</span>         <span class="c1">// Disable recording the result temporarily.  Writing to misc</span>
<span class="mi">664</span>         <span class="c1">// regs normally updates the result, but this is not the</span>
<span class="mi">665</span>         <span class="c1">// desired behavior when handling store conditionals.</span>
<span class="mi">666</span>         <span class="n">load_inst</span><span class="o">-&gt;</span><span class="n">recordResult</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
<span class="mi">667</span>         <span class="n">TheISA</span><span class="o">::</span><span class="n">handleLockedRead</span><span class="p">(</span><span class="n">load_inst</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">mainRequest</span><span class="p">());</span>
<span class="mi">668</span>         <span class="n">load_inst</span><span class="o">-&gt;</span><span class="n">recordResult</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
<span class="mi">669</span>     <span class="p">}</span>
<span class="mi">670</span> 
<span class="mi">671</span>     <span class="nf">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">mainRequest</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">isMmappedIpr</span><span class="p">())</span> <span class="p">{</span>
<span class="mi">672</span>         <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">load_inst</span><span class="o">-&gt;</span><span class="n">memData</span><span class="p">);</span>
<span class="mi">673</span>         <span class="n">load_inst</span><span class="o">-&gt;</span><span class="n">memData</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">uint8_t</span><span class="p">[</span><span class="n">MaxDataBytes</span><span class="p">];</span>
<span class="mi">674</span> 
<span class="mi">675</span>         <span class="n">ThreadContext</span> <span class="o">*</span><span class="kr">thread</span> <span class="o">=</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">tcBase</span><span class="p">(</span><span class="n">lsqID</span><span class="p">);</span>
<span class="mi">676</span>         <span class="n">PacketPtr</span> <span class="n">main_pkt</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Packet</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">mainRequest</span><span class="p">(),</span> <span class="n">MemCmd</span><span class="o">::</span><span class="n">ReadReq</span><span class="p">);</span>
<span class="mi">677</span> 
<span class="mi">678</span>         <span class="n">main_pkt</span><span class="o">-&gt;</span><span class="n">dataStatic</span><span class="p">(</span><span class="n">load_inst</span><span class="o">-&gt;</span><span class="n">memData</span><span class="p">);</span>
<span class="mi">679</span> 
<span class="mi">680</span>         <span class="n">Cycles</span> <span class="n">delay</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">handleIprRead</span><span class="p">(</span><span class="kr">thread</span><span class="p">,</span> <span class="n">main_pkt</span><span class="p">);</span>
<span class="mi">681</span> 
<span class="mi">682</span>         <span class="n">WritebackEvent</span> <span class="o">*</span><span class="n">wb</span> <span class="o">=</span> <span class="k">new</span> <span class="n">WritebackEvent</span><span class="p">(</span><span class="n">load_inst</span><span class="p">,</span> <span class="n">main_pkt</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
<span class="mi">683</span>         <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">schedule</span><span class="p">(</span><span class="n">wb</span><span class="p">,</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">clockEdge</span><span class="p">(</span><span class="n">delay</span><span class="p">));</span>
<span class="mi">684</span>         <span class="k">return</span> <span class="n">NoFault</span><span class="p">;</span>
<span class="mi">685</span>     <span class="p">}</span>
<span class="mi">686</span> 
<span class="mi">687</span>     <span class="c1">// Check the SQ for any previous stores that might lead to forwarding</span>
<span class="p">......</span>
<span class="mi">840</span>     <span class="c1">// If there's no forwarding case, then go access memory</span>
<span class="mi">841</span>     <span class="nf">DPRINTF</span><span class="p">(</span><span class="n">LSQUnit</span><span class="p">,</span> <span class="s">"Doing memory access for inst [sn:%lli] PC %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
<span class="mi">842</span>             <span class="n">load_inst</span><span class="o">-&gt;</span><span class="n">seqNum</span><span class="p">,</span> <span class="n">load_inst</span><span class="o">-&gt;</span><span class="n">pcState</span><span class="p">());</span>
<span class="mi">843</span> 
<span class="mi">844</span>     <span class="c1">// Allocate memory if this is the first time a load is issued.</span>
<span class="mi">845</span>     <span class="nf">if</span> <span class="p">(</span><span class="o">!</span><span class="n">load_inst</span><span class="o">-&gt;</span><span class="n">memData</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">846</span>         <span class="n">load_inst</span><span class="o">-&gt;</span><span class="n">memData</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">uint8_t</span><span class="p">[</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">mainRequest</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getSize</span><span class="p">()];</span>
<span class="mi">847</span>     <span class="p">}</span>
<span class="mi">848</span> 
<span class="mi">849</span>     <span class="c1">// For now, load throughput is constrained by the number of</span>
<span class="mi">850</span>     <span class="c1">// load FUs only, and loads do not consume a cache port (only</span>
<span class="mi">851</span>     <span class="c1">// stores do).</span>
<span class="mi">852</span>     <span class="c1">// @todo We should account for cache port contention</span>
<span class="mi">853</span>     <span class="c1">// and arbitrate between loads and stores.</span>
<span class="mi">854</span> 
<span class="mi">855</span>     <span class="c1">// if we the cache is not blocked, do cache access</span>
<span class="mi">856</span>     <span class="nf">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">senderState</span><span class="p">()</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">857</span>         <span class="n">LQSenderState</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LQSenderState</span><span class="p">(</span>
<span class="mi">858</span>                 <span class="n">loadQueue</span><span class="p">.</span><span class="n">getIterator</span><span class="p">(</span><span class="n">load_idx</span><span class="p">));</span>
<span class="mi">859</span>         <span class="n">state</span><span class="o">-&gt;</span><span class="n">isLoad</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="mi">860</span>         <span class="n">state</span><span class="o">-&gt;</span><span class="n">inst</span> <span class="o">=</span> <span class="n">load_inst</span><span class="p">;</span>
<span class="mi">861</span>         <span class="n">state</span><span class="o">-&gt;</span><span class="n">isSplit</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">isSplit</span><span class="p">();</span>
<span class="mi">862</span>         <span class="n">req</span><span class="o">-&gt;</span><span class="n">senderState</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
<span class="mi">863</span>     <span class="p">}</span>
<span class="mi">864</span>     <span class="n">req</span><span class="o">-&gt;</span><span class="n">buildPackets</span><span class="p">();</span>
<span class="mi">865</span>     <span class="n">req</span><span class="o">-&gt;</span><span class="n">sendPacketToCache</span><span class="p">();</span>
<span class="mi">866</span>     <span class="nf">if</span> <span class="p">(</span><span class="o">!</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">isSent</span><span class="p">())</span>
<span class="mi">867</span>         <span class="n">iewStage</span><span class="o">-&gt;</span><span class="n">blockMemInst</span><span class="p">(</span><span class="n">load_inst</span><span class="p">);</span>
<span class="mi">868</span> 
<span class="mi">869</span>     <span class="k">return</span> <span class="n">NoFault</span><span class="p">;</span>
<span class="mi">870</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<h3 id="execute-store-instruction"><span class="me-2">Execute store instruction</span><a href="#execute-store-instruction" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<h3 id="execute-non-memory-instruction"><span class="me-2">Execute non-memory instruction</span><a href="#execute-non-memory-instruction" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre><span class="mi">1333</span>         <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="mi">1334</span>             <span class="c1">// If the instruction has already faulted, then skip executing it.</span>
<span class="mi">1335</span>             <span class="c1">// Such case can happen when it faulted during ITLB translation.</span>
<span class="mi">1336</span>             <span class="c1">// If we execute the instruction (even if it's a nop) the fault</span>
<span class="mi">1337</span>             <span class="c1">// will be replaced and we will lose it.</span>
<span class="mi">1338</span>             <span class="k">if</span> <span class="p">(</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">getFault</span><span class="p">()</span> <span class="o">==</span> <span class="n">NoFault</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1339</span>                 <span class="n">inst</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">();</span>
<span class="mi">1340</span>                 <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">readPredicate</span><span class="p">())</span>
<span class="mi">1341</span>                     <span class="n">inst</span><span class="o">-&gt;</span><span class="n">forwardOldRegs</span><span class="p">();</span>
<span class="mi">1342</span>             <span class="p">}</span>
<span class="mi">1343</span> 
<span class="mi">1344</span>             <span class="n">inst</span><span class="o">-&gt;</span><span class="n">setExecuted</span><span class="p">();</span>
<span class="mi">1345</span> 
<span class="mi">1346</span>             <span class="nf">instToCommit</span><span class="p">(</span><span class="n">inst</span><span class="p">);</span>
<span class="mi">1347</span>         <span class="p">}</span>
<span class="mi">1348</span> 
<span class="mi">1349</span>         <span class="nf">updateExeInstStats</span><span class="p">(</span><span class="n">inst</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></div></div>

<p>1351         // Check if branch prediction was correct, if not then we need
1352         // to tell commit to squash in flight instructions.  Only
1353         // handle this if there hasn’t already been something that
1354         // redirects fetch in this group of instructions.
1355 
1356         // This probably needs to prioritize the redirects if a different
1357         // scheduler is used.  Currently the scheduler schedules the oldest
1358         // instruction first, so the branch resolution order will be correct.
1359         ThreadID tid = inst-&gt;threadNumber;
1360 
1361         if (!fetchRedirect[tid] ||
1362             !toCommit-&gt;squash[tid] ||
1363             toCommit-&gt;squashedSeqNum[tid] &gt; inst-&gt;seqNum) {
1364 
1365             // Prevent testing for misprediction on load instructions,
1366             // that have not been executed.
1367             bool loadNotExecuted = !inst-&gt;isExecuted() &amp;&amp; inst-&gt;isLoad();
1368 
1369             if (inst-&gt;mispredicted() &amp;&amp; !loadNotExecuted) {
1370                 fetchRedirect[tid] = true;
1371 
1372                 DPRINTF(IEW, “[tid:%i] [sn:%llu] Execute: “
1373                         “Branch mispredict detected.\n”,
1374                         tid,inst-&gt;seqNum);
1375                 DPRINTF(IEW, “[tid:%i] [sn:%llu] “
1376                         “Predicted target was PC: %s\n”,
1377                         tid,inst-&gt;seqNum,inst-&gt;readPredTarg());
1378                 DPRINTF(IEW, “[tid:%i] [sn:%llu] Execute: “
1379                         “Redirecting fetch to PC: %s\n”,
1380                         tid,inst-&gt;seqNum,inst-&gt;pcState());
1381                 // If incorrect, then signal the ROB that it must be squashed.
1382                 squashDueToBranch(inst, tid);
1383 
1384                 ppMispredict-&gt;notify(inst);
1385 
1386                 if (inst-&gt;readPredTaken()) {
1387                     predictedTakenIncorrect++;
1388                 } else {
1389                     predictedNotTakenIncorrect++;
1390                 }
1391             } else if (ldstQueue.violation(tid)) {
1392                 assert(inst-&gt;isMemRef());
1393                 // If there was an ordering violation, then get the
1394                 // DynInst that caused the violation.  Note that this
1395                 // clears the violation signal.
1396                 DynInstPtr violator;
1397                 violator = ldstQueue.getMemDepViolator(tid);
1398 
1399                 DPRINTF(IEW, “LDSTQ detected a violation. Violator PC: %s “
1400                         “[sn:%lli], inst PC: %s [sn:%lli]. Addr is: %#x.\n”,
1401                         violator-&gt;pcState(), violator-&gt;seqNum,
1402                         inst-&gt;pcState(), inst-&gt;seqNum, inst-&gt;physEffAddr);
1403 
1404                 fetchRedirect[tid] = true;
1405 
1406                 // Tell the instruction queue that a violation has occured.
1407                 instQueue.violation(inst, violator);
1408 
1409                 // Squash.
1410                 squashDueToMemOrder(violator, tid);
1411 
1412                 ++memOrderViolationEvents;
1413             }
1414         } else {
1415             // Reset any state associated with redirects that will not
1416             // be used.
1417             if (ldstQueue.violation(tid)) {
1418                 assert(inst-&gt;isMemRef());
1419 
1420                 DynInstPtr violator = ldstQueue.getMemDepViolator(tid);
1421 
1422                 DPRINTF(IEW, “LDSTQ detected a violation.  Violator PC: “
1423                         “%s, inst PC: %s.  Addr is: %#x.\n”,
1424                         violator-&gt;pcState(), inst-&gt;pcState(),
1425                         inst-&gt;physEffAddr);
1426                 DPRINTF(IEW, “Violation will not be handled because “
1427                         “already squashing\n”);
1428 
1429                 ++memOrderViolationEvents;
1430             }
1431         }
1432     }
1433 
1434     // Update and record activity if we processed any instructions.
1435     if (inst_num) {
1436         if (exeStatus == Idle) {
1437             exeStatus = Running;
1438         }
1439 
1440         updatedQueues = true;
1441 
1442         cpu-&gt;activityThisCycle();
1443     }
1444 
1445     // Need to reset this in case a writeback event needs to write into the
1446     // iew queue.  That way the writeback event will write into the correct
1447     // spot in the queue.
1448     wbNumInst = 0;
1449 
1450 }
```</p>

<h2 id="schedule"><span class="me-2">Schedule</span><a href="#schedule" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>
<p>Schedule (InstructionQueue::scheduleReadyInsts()) The IQ manages the ready instructions (operands ready) in a ready list, and schedules them to an available FU. The latency of the FU is set here, and instructions are sent to execution when the FU done.</p>


  </div>

  <div class="post-tail-wrapper text-muted">
    <!-- categories -->
    
      <div class="post-meta mb-3">
        <i class="far fa-folder-open fa-fw me-1"></i>
        
          <a href="/categories/gem5/">GEM5</a>,
          <a href="/categories/pipeline/">Pipeline</a>,
          <a href="/categories/o3/">O3</a>
      </div>
    

    <!-- tags -->
    

    <div
      class="
        post-tail-bottom
        d-flex justify-content-between align-items-center mt-5 pb-2
      "
    >
      <div class="license-wrapper">
        
          

          This post is licensed under 
        <a href="https://creativecommons.org/licenses/by/4.0/">
          CC BY 4.0
        </a>
         by the author.
        
      </div>

      <!-- Post sharing snippet -->

<div class="share-wrapper d-flex align-items-center">
  <span class="share-label text-muted">Share</span>
  <span class="share-icons">
    
    
    

    

      

      <a
        href="https://twitter.com/intent/tweet?text=O3%20Cpu%20Iew%20-%20Ruach&url=http%3A%2F%2Flocalhost%3A4000%2Fposts%2FO3-CPU-iew%2F"
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="Twitter"
        target="_blank"
        rel="noopener"
        aria-label="Twitter"
      >
        <i class="fa-fw fa-brands fa-square-x-twitter"></i>
      </a>
    

      

      <a
        href="https://www.facebook.com/sharer/sharer.php?title=O3%20Cpu%20Iew%20-%20Ruach&u=http%3A%2F%2Flocalhost%3A4000%2Fposts%2FO3-CPU-iew%2F"
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="Facebook"
        target="_blank"
        rel="noopener"
        aria-label="Facebook"
      >
        <i class="fa-fw fab fa-facebook-square"></i>
      </a>
    

      

      <a
        href="https://t.me/share/url?url=http%3A%2F%2Flocalhost%3A4000%2Fposts%2FO3-CPU-iew%2F&text=O3%20Cpu%20Iew%20-%20Ruach"
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="Telegram"
        target="_blank"
        rel="noopener"
        aria-label="Telegram"
      >
        <i class="fa-fw fab fa-telegram"></i>
      </a>
    

      

      <a
        href="https://www.linkedin.com/sharing/share-offsite/?url=http%3A%2F%2Flocalhost%3A4000%2Fposts%2FO3-CPU-iew%2F"
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="Linkedin"
        target="_blank"
        rel="noopener"
        aria-label="Linkedin"
      >
        <i class="fa-fw fab fa-linkedin"></i>
      </a>
    

    <button
      id="copy-link"
      aria-label="Copy link"
      class="btn small"
      data-bs-toggle="tooltip"
      data-bs-placement="top"
      title="Copy link"
      data-title-succeed="Link copied successfully!"
    >
      <i class="fa-fw fas fa-link pe-none fs-6"></i>
    </button>
  </span>
</div>

    </div>
    <!-- .post-tail-bottom -->
  </div>
  <!-- div.post-tail-wrapper -->
</article>


            
          </main>

          <!-- panel -->
          <aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 mb-5 text-muted">
            <div class="access">
              <!-- Get the last 5 posts from lastmod list. -->















              <!-- The trending tags list -->


















            </div>

            
              
              



  <section id="toc-wrapper" class="ps-0 pe-4">
    <h2 class="panel-heading ps-3 pt-2 mb-2">Contents</h2>
    <nav id="toc"></nav>
  </section>


            
          </aside>
        </div>

        <div class="row">
          <!-- tail -->
          <div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4">
            
              
              <!-- Recommend the other 3 posts according to the tags and categories of the current post. -->

<!-- The total size of related posts -->


<!-- An random integer that bigger than 0 -->


<!-- Equals to TAG_SCORE / {max_categories_hierarchy} -->














  

  

  

  

  

  

  

  

  

  

  

  

  

  
    
  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  











  <aside id="related-posts" aria-labelledby="related-label">
    <h3 class="mb-4" id="related-label">Further Reading</h3>
    <nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4">
      
        <article class="col">
          <a href="/posts/O3-CPU-Fetch/" class="post-preview card h-100">
            <div class="card-body">
              <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->




<time
  
  data-ts="1622088000"
  data-df="ll"
  
>
  May 27, 2021
</time>

              <h4 class="pt-0 my-2">O3 Cpu Fetch</h4>
              <div class="text-muted">
                <p>
                  





                  Fetch
 895 template &amp;lt;class Impl&amp;gt;
 896 void
 897 DefaultFetch&amp;lt;Impl&amp;gt;::tick()
 898 {
 899     list&amp;lt;ThreadID&amp;gt;::iterator threads = activeThreads-&amp;gt;begin();
 900     list&amp;lt;ThreadID&amp;...
                </p>
              </div>
            </div>
          </a>
        </article>
      
        <article class="col">
          <a href="/posts/O3-CPU-Decode/" class="post-preview card h-100">
            <div class="card-body">
              <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->




<time
  
  data-ts="1622174400"
  data-df="ll"
  
>
  May 28, 2021
</time>

              <h4 class="pt-0 my-2">O3 Cpu Decode</h4>
              <div class="text-muted">
                <p>
                  





                  Sending fetched instructions to decode stage
gem5/src/cpu/o3/fetch_impl.hh
 961 
 962     // Pick a random thread to start trying to grab instructions from
 963     auto tid_itr = activeThreads-&amp;gt...
                </p>
              </div>
            </div>
          </a>
        </article>
      
        <article class="col">
          <a href="/posts/O3-CPU-rename/" class="post-preview card h-100">
            <div class="card-body">
              <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->




<time
  
  data-ts="1622260800"
  data-df="ll"
  
>
  May 29, 2021
</time>

              <h4 class="pt-0 my-2">O3 Cpu Rename</h4>
              <div class="text-muted">
                <p>
                  





                  Rename
It maintains the rename history of all instructions 
with destination registers, storing the arch register, 
the new physical register, and the old physical register.
The information is requ...
                </p>
              </div>
            </div>
          </a>
        </article>
      
    </nav>
  </aside>
  <!-- #related-posts -->


            
              
              <!-- Navigation buttons at the bottom of the post. -->

<nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation">
  
  

  
    <a
      href="/posts/O3-CPU-rename/"
      class="btn btn-outline-primary"
      aria-label="Older"
    >
      <p>O3 Cpu Rename</p>
    </a>
  

  
    <a
      href="/posts/O3-CPU-commit/"
      class="btn btn-outline-primary"
      aria-label="Newer"
    >
      <p>O3 Cpu Commit</p>
    </a>
  
</nav>

            
              
              <!--  The comments switcher -->

  
  <!-- https://giscus.app/ -->
<script type="text/javascript">
  (function () {
    const origin = 'https://giscus.app';
    const iframe = 'iframe.giscus-frame';
    const lightTheme = 'light';
    const darkTheme = 'dark_dimmed';

    let initTheme = lightTheme;
    const html = document.documentElement;

    if (
      (html.hasAttribute('data-mode') &&
        html.getAttribute('data-mode') === 'dark') ||
      (!html.hasAttribute('data-mode') &&
        window.matchMedia('(prefers-color-scheme: dark)').matches)
    ) {
      initTheme = darkTheme;
    }

    let giscusAttributes = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'Ruach/ruach.github.io',
      'data-repo-id': '',
      'data-category': '',
      'data-category-id': '',
      'data-mapping': 'pathname',
      'data-reactions-enabled': '1',
      'data-emit-metadata': '0',
      'data-theme': initTheme,
      'data-input-position': 'bottom',
      'data-lang': 'en',
      'data-loading': 'lazy',
      crossorigin: 'anonymous',
      async: ''
    };

    let giscusScript = document.createElement('script');
    Object.entries(giscusAttributes).forEach(([key, value]) =>
      giscusScript.setAttribute(key, value)
    );
    document.getElementById('tail-wrapper').appendChild(giscusScript);

    addEventListener('message', (event) => {
      if (
        event.source === window &&
        event.data &&
        event.data.direction === ModeToggle.ID
      ) {
        /* global theme mode changed */
        const mode = event.data.message;
        const theme = mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme;

        const message = {
          setConfig: {
            theme: theme
          }
        };

        const giscus = document.querySelector(iframe).contentWindow;
        giscus.postMessage({ giscus: message }, origin);
      }
    });
  })();
</script>



            

            <!-- The Footer -->

<footer
  aria-label="Site Info"
  class="
    d-flex flex-column justify-content-center text-muted
    flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3
  "
>
  <p>
    ©
    <time>2023</time>
    <a href="https://ruach.github.io">Jaehyuk Lee</a>.
    
      <span
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author."
      >Some rights reserved.</span>
    
  </p>

  <p>Using the <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme for <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>
  </p>
</footer>

          </div>
        </div>

        <!-- The Search results -->

<div id="search-result-wrapper" class="d-flex justify-content-center unloaded">
  <div class="col-11 content">
    <div id="search-hints">
      <!-- The trending tags list -->


















    </div>
    <div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div>
  </div>
</div>

      </div>

      <aside aria-label="Scroll to Top">
        <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow">
          <i class="fas fa-angle-up"></i>
        </button>
      </aside>
    </div>

    <div id="mask"></div>

    
      <aside
  id="notification"
  class="toast"
  role="alert"
  aria-live="assertive"
  aria-atomic="true"
  data-bs-animation="true"
  data-bs-autohide="false"
>
  <div class="toast-header">
    <button
      type="button"
      class="btn-close ms-auto"
      data-bs-dismiss="toast"
      aria-label="Close"
    ></button>
  </div>
  <div class="toast-body text-center pt-0">
    <p class="px-2 mb-3">A new version of content is available.</p>
    <button type="button" class="btn btn-primary" aria-label="Update">
      Update
    </button>
  </div>
</aside>

    

    <!-- JavaScripts -->

    <!-- JS selector for site. -->

<!-- commons -->



<!-- layout specified -->


  

  
    <!-- image lazy-loading & popup & clipboard -->
    
  















  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  



  <script src="https://cdn.jsdelivr.net/combine/npm/jquery@3.7.1/dist/jquery.min.js,npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js,npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/magnific-popup@1.1.0/dist/jquery.magnific-popup.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.10/dayjs.min.js,npm/dayjs@1.11.10/locale/en.min.js,npm/dayjs@1.11.10/plugin/relativeTime.min.js,npm/dayjs@1.11.10/plugin/localizedFormat.min.js,npm/tocbot@4.21.2/dist/tocbot.min.js"></script>






<script defer src="/assets/js/dist/post.min.js"></script>






    

    <!--
  Jekyll Simple Search loader
  See: <https://github.com/christian-fei/Simple-Jekyll-Search>
-->





<script>
  /* Note: dependent library will be loaded in `js-selector.html` */
  SimpleJekyllSearch({
    searchInput: document.getElementById('search-input'),
    resultsContainer: document.getElementById('search-results'),
    json: '/assets/js/data/search.json',
    searchResultTemplate: '  <article class="px-1 px-sm-2 px-lg-4 px-xl-0">    <header>      <h2><a href="{url}">{title}</a></h2>      <div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1">        {categories}        {tags}      </div>    </header>    <p>{snippet}</p>  </article>',
    noResultsText: '<p class="mt-5"></p>',
    templateMiddleware: function(prop, value, template) {
      if (prop === 'categories') {
        if (value === '') {
          return `${value}`;
        } else {
          return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`;
        }
      }

      if (prop === 'tags') {
        if (value === '') {
          return `${value}`;
        } else {
          return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`;
        }
      }
    }
  });
</script>

  </body>
</html>

