<!doctype html>














<!-- `site.alt_lang` can specify a language different from the UI -->
<html lang="en" data-mode="light">
  <!-- The Head -->

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta
    name="viewport"
    content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover"
  >

  

  

  
    <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v4.3.3" />
<meta property="og:title" content="KVM page-fault handling for TDX" />
<meta property="og:locale" content="en" />
<meta name="description" content="Basic idea to implement private page Because shared EPT is the same as the existing EPT, use the existing logic for shared EPT. On the other hand, secure EPT requires additional operations instead of directly reading/writing of the EPT entry. On EPT violation, The KVM mmu walks down the EPT tree from the root, determines the EPT entry to operate, and updates the entry. If necessary, a TLB shootdown is done. Because it’s very slow to directly walk secure EPT by TDX SEAMCALL, TDH.MEM.SEPT.RD(), the mirror of secure EPT is created and maintained. Add hooks to KVM MMU to reuse the existing code." />
<meta property="og:description" content="Basic idea to implement private page Because shared EPT is the same as the existing EPT, use the existing logic for shared EPT. On the other hand, secure EPT requires additional operations instead of directly reading/writing of the EPT entry. On EPT violation, The KVM mmu walks down the EPT tree from the root, determines the EPT entry to operate, and updates the entry. If necessary, a TLB shootdown is done. Because it’s very slow to directly walk secure EPT by TDX SEAMCALL, TDH.MEM.SEPT.RD(), the mirror of secure EPT is created and maintained. Add hooks to KVM MMU to reuse the existing code." />
<link rel="canonical" href="https://ruach.github.io/posts/PAGEFAULT-HANDLING-KVM-TDX/" />
<meta property="og:url" content="https://ruach.github.io/posts/PAGEFAULT-HANDLING-KVM-TDX/" />
<meta property="og:site_name" content="Ruach" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-04-15T00:00:00-04:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="KVM page-fault handling for TDX" />
<meta name="twitter:site" content="@ruach_lee" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-04-15T00:00:00-04:00","datePublished":"2023-04-15T00:00:00-04:00","description":"Basic idea to implement private page Because shared EPT is the same as the existing EPT, use the existing logic for shared EPT. On the other hand, secure EPT requires additional operations instead of directly reading/writing of the EPT entry. On EPT violation, The KVM mmu walks down the EPT tree from the root, determines the EPT entry to operate, and updates the entry. If necessary, a TLB shootdown is done. Because it’s very slow to directly walk secure EPT by TDX SEAMCALL, TDH.MEM.SEPT.RD(), the mirror of secure EPT is created and maintained. Add hooks to KVM MMU to reuse the existing code.","headline":"KVM page-fault handling for TDX","mainEntityOfPage":{"@type":"WebPage","@id":"https://ruach.github.io/posts/PAGEFAULT-HANDLING-KVM-TDX/"},"url":"https://ruach.github.io/posts/PAGEFAULT-HANDLING-KVM-TDX/"}</script>
<!-- End Jekyll SEO tag -->

  

  <title>KVM page-fault handling for TDX | Ruach
  </title>

  <!--
  The Favicons for Web, Android, Microsoft, and iOS (iPhone and iPad) Apps
  Generated by: https://realfavicongenerator.net/
-->



<link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png">
<link rel="manifest" href="/assets/img/favicons/site.webmanifest">
<link rel="shortcut icon" href="/assets/img/favicons/favicon.ico">
<meta name="apple-mobile-web-app-title" content="Ruach">
<meta name="application-name" content="Ruach">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml">
<meta name="theme-color" content="#ffffff">


  
    
      <link rel="preconnect" href="https://fonts.googleapis.com" >
      <link rel="dns-prefetch" href="https://fonts.googleapis.com" >
    
      <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
      <link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin>
    
      <link rel="preconnect" href="https://fonts.googleapis.com" >
      <link rel="dns-prefetch" href="https://fonts.googleapis.com" >
    
      <link rel="preconnect" href="https://cdn.jsdelivr.net" >
      <link rel="dns-prefetch" href="https://cdn.jsdelivr.net" >
    

    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap">
  

  <!-- GA -->
  

  <!-- Bootstrap -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css">

  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.2/css/all.min.css">

  <link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css">

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.21.2/dist/tocbot.min.css">
  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css">
  

  
    <!-- Manific Popup -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css">
  

  <!-- JavaScript -->

  

  <!-- A placeholder to allow defining custom metadata -->

</head>


  <body>
    <!-- The Side Bar -->

<aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end">
  <header class="profile-wrapper">
    <a href="/" id="avatar" class="rounded-circle">
      
        
        <img src="/assets/img/jaehyuk.png" width="112" height="112" alt="avatar" onerror="this.style.display='none'">
      
    </a>

    <h1 class="site-title">
      <a href="/">Ruach</a>
    </h1>
    <p class="site-subtitle fst-italic mb-0">Jaehyuk Lee</p>
  </header>
  <!-- .profile-wrapper -->

  <nav class="flex-column flex-grow-1 w-100 ps-0">
    <ul class="nav">
      <!-- home -->
      <li class="nav-item">
        <a href="/" class="nav-link">
          <i class="fa-fw fas fa-home"></i>
          <span>HOME</span>
        </a>
      </li>
      <!-- the real tabs -->
      
        <li class="nav-item">
          <a href="/categories/" class="nav-link">
            <i class="fa-fw fas fa-stream"></i>
            

            <span>CATEGORIES</span>
          </a>
        </li>
        <!-- .nav-item -->
      
        <li class="nav-item">
          <a href="/archives/" class="nav-link">
            <i class="fa-fw fas fa-archive"></i>
            

            <span>ARCHIVES</span>
          </a>
        </li>
        <!-- .nav-item -->
      
        <li class="nav-item">
          <a href="/about/" class="nav-link">
            <i class="fa-fw fas fa-info-circle"></i>
            

            <span>ABOUT</span>
          </a>
        </li>
        <!-- .nav-item -->
      
    </ul>
  </nav>

  <div class="sidebar-bottom d-flex flex-wrap  align-items-center w-100">
    

    
      

      
        <a
          href="javascript:location.href = 'mailto:' + ['jaehyuk','gatech.edu'].join('@')"
          aria-label="email"
          

          

          

          
        >
          <i class="fas fa-envelope"></i>
        </a>
      
    
      

      
        <a
          href="https://www.linkedin.com/in/jaehyuk-lee-29b33b121/"
          aria-label="linkedin"
          

          
            target="_blank"
            
          

          

          
            rel="noopener noreferrer"
          
        >
          <i class="fab fa-linkedin"></i>
        </a>
      
    
      

      
        <a
          href="https://github.com/Ruach"
          aria-label="github"
          

          
            target="_blank"
            
          

          

          
            rel="noopener noreferrer"
          
        >
          <i class="fab fa-github"></i>
        </a>
      
    
      

      
        <a
          href="https://stackoverflow.com/users/4460514/ruach?tab=profile"
          aria-label="stack-overflow"
          

          
            target="_blank"
            
          

          

          
            rel="noopener noreferrer"
          
        >
          <i class="fab fa-stack-overflow"></i>
        </a>
      
    
  </div>
  <!-- .sidebar-bottom -->
</aside>
<!-- #sidebar -->


    <div id="main-wrapper" class="d-flex justify-content-center">
      <div class="container d-flex flex-column px-xxl-5">
        <!-- The Top Bar -->

<header id="topbar-wrapper" aria-label="Top Bar">
  <div
    id="topbar"
    class="d-flex align-items-center justify-content-between px-lg-3 h-100"
  >
    <nav id="breadcrumb" aria-label="Breadcrumb">
      

      
        
          
            <span>
              <a href="/">
                Home
              </a>
            </span>

          
        
          
        
          
            
              <span>KVM page-fault handling for TDX</span>
            

          
        
      
    </nav>
    <!-- endof #breadcrumb -->

    <button type="button" id="sidebar-trigger" class="btn btn-link">
      <i class="fas fa-bars fa-fw"></i>
    </button>

    <div id="topbar-title">
      Post
    </div>

    <button type="button" id="search-trigger" class="btn btn-link">
      <i class="fas fa-search fa-fw"></i>
    </button>

    <search class="align-items-center ms-3 ms-lg-0">
      <i class="fas fa-search fa-fw"></i>
      <input
        class="form-control"
        id="search-input"
        type="search"
        aria-label="search"
        autocomplete="off"
        placeholder="Search..."
      >
    </search>
    <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button>
  </div>
</header>


        <div class="row flex-grow-1">
          <main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4">
            
              <!-- Refactor the HTML structure -->



<!--
  In order to allow a wide table to scroll horizontally,
  we suround the markdown table with `<div class="table-wrapper">` and `</div>`
-->



<!--
  Fixed kramdown code highlight rendering:
  https://github.com/penibelst/jekyll-compress-html/issues/101
  https://github.com/penibelst/jekyll-compress-html/issues/71#issuecomment-188144901
-->



<!-- Change the icon of checkbox -->



<!-- Handle images -->





<!-- Add header for code snippets -->



<!-- Create heading anchors -->





  
  

  
    
    

    
      
        
        
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    

    
  

  
  

  
    
    

    
      
        
        
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    

    
  

  
  

  

  
  

  




<!-- return -->




<article class="px-1">
  <header>
    <h1 data-toc-skip>KVM page-fault handling for TDX</h1>

    <div class="post-meta text-muted">
      <!-- published date -->
      <span>
        Posted
        <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->




<time
  
  data-ts="1681531200"
  data-df="ll"
  
    data-bs-toggle="tooltip" data-bs-placement="bottom"
  
>
  Apr 15, 2023
</time>

      </span>

      <!-- lastmod date -->
      

      

      <div class="d-flex justify-content-between">
        <!-- author(s) -->
        <span>
          

          By

          <em>
            
              <a href="https://ruach.github.io">Jaehyuk Lee</a>
            
          </em>
        </span>

        <!-- read time -->
        <!-- Calculate the post's reading time, and display the word count in tooltip -->



<!-- words per minute -->










<!-- return element -->
<span
  class="readtime"
  data-bs-toggle="tooltip"
  data-bs-placement="bottom"
  title="5983 words"
>
  <em>33 min</em> read</span>

      </div>
      <!-- .d-flex -->
    </div>
    <!-- .post-meta -->
  </header>

  <div class="content">
    <h3 id="basic-idea-to-implement-private-page"><span class="me-2">Basic idea to implement private page</span><a href="#basic-idea-to-implement-private-page" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<blockquote>
  <p>Because shared EPT is the same as the existing EPT, use the existing logic for
shared EPT.  On the other hand, secure EPT requires additional operations
instead of directly reading/writing of the EPT entry.</p>

  <p>On EPT violation, The KVM mmu walks down the EPT tree from the root, determines
the EPT entry to operate, and updates the entry. If necessary, a TLB shootdown
is done.  Because it’s very slow to directly walk secure EPT by TDX SEAMCALL,
TDH.MEM.SEPT.RD(), the mirror of secure EPT is created and maintained.  Add
hooks to KVM MMU to reuse the existing code.</p>
</blockquote>

<h3 id="kernel-log-from-vmexit-to-aug"><span class="me-2">Kernel log from VMExit to AUG</span><a href="#kernel-log-from-vmexit-to-aug" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre><span class="p">[</span><span class="mf">190678.041238</span><span class="p">]</span>  <span class="n">__tdx_sept_set_private_spte</span><span class="p">.</span><span class="n">cold</span><span class="o">+</span><span class="mh">0x6c</span><span class="o">/</span><span class="mh">0x26e</span> <span class="p">[</span><span class="n">kvm_intel</span><span class="p">]</span>
<span class="p">[</span><span class="mf">190678.041248</span><span class="p">]</span>  <span class="o">?</span> <span class="n">do_huge_pmd_anonymous_page</span><span class="o">+</span><span class="mh">0xf1</span><span class="o">/</span><span class="mh">0x370</span>
<span class="p">[</span><span class="mf">190678.041251</span><span class="p">]</span>  <span class="n">tdx_handle_changed_private_spte</span><span class="o">+</span><span class="mh">0xee</span><span class="o">/</span><span class="mh">0x270</span> <span class="p">[</span><span class="n">kvm_intel</span><span class="p">]</span>
<span class="p">[</span><span class="mf">190678.041259</span><span class="p">]</span>  <span class="n">__handle_changed_spte</span><span class="o">+</span><span class="mh">0x564</span><span class="o">/</span><span class="mh">0x710</span> <span class="p">[</span><span class="n">kvm</span><span class="p">]</span>
<span class="p">[</span><span class="mf">190678.041297</span><span class="p">]</span>  <span class="o">?</span> <span class="n">follow_pud_mask</span><span class="p">.</span><span class="n">isra</span><span class="mf">.0</span><span class="o">+</span><span class="mh">0x11e</span><span class="o">/</span><span class="mh">0x1b0</span>    
<span class="p">[</span><span class="mf">190678.041299</span><span class="p">]</span>  <span class="n">tdp_mmu_set_spte_atomic</span><span class="o">+</span><span class="mh">0x117</span><span class="o">/</span><span class="mh">0x190</span> <span class="p">[</span><span class="n">kvm</span><span class="p">]</span>
<span class="p">[</span><span class="mf">190678.041332</span><span class="p">]</span>  <span class="n">tdp_mmu_map_handle_target_level</span><span class="o">+</span><span class="mh">0x275</span><span class="o">/</span><span class="mh">0x420</span> <span class="p">[</span><span class="n">kvm</span><span class="p">]</span>
<span class="p">[</span><span class="mf">190678.041363</span><span class="p">]</span>  <span class="n">kvm_tdp_mmu_map</span><span class="o">+</span><span class="mh">0x46b</span><span class="o">/</span><span class="mh">0x7a0</span> <span class="p">[</span><span class="n">kvm</span><span class="p">]</span>
<span class="p">[</span><span class="mf">190678.041394</span><span class="p">]</span>  <span class="o">?</span> <span class="n">get_user_pages_fast</span><span class="o">+</span><span class="mh">0x24</span><span class="o">/</span><span class="mh">0x50</span> 
<span class="p">[</span><span class="mf">190678.041397</span><span class="p">]</span>  <span class="n">direct_page_fault</span><span class="o">+</span><span class="mh">0x27a</span><span class="o">/</span><span class="mh">0x340</span> <span class="p">[</span><span class="n">kvm</span><span class="p">]</span>
<span class="p">[</span><span class="mf">190678.041428</span><span class="p">]</span>  <span class="n">kvm_tdp_page_fault</span><span class="o">+</span><span class="mh">0x83</span><span class="o">/</span><span class="mh">0xa0</span> <span class="p">[</span><span class="n">kvm</span><span class="p">]</span>
<span class="p">[</span><span class="mf">190678.041459</span><span class="p">]</span>  <span class="o">?</span> <span class="n">x86_pmu_enable</span><span class="o">+</span><span class="mh">0x1ab</span><span class="o">/</span><span class="mh">0x490</span>
<span class="p">[</span><span class="mf">190678.041461</span><span class="p">]</span>  <span class="n">kvm_mmu_page_fault</span><span class="o">+</span><span class="mh">0x247</span><span class="o">/</span><span class="mh">0x2c0</span> <span class="p">[</span><span class="n">kvm</span><span class="p">]</span>
<span class="p">[</span><span class="mf">190678.041491</span><span class="p">]</span>  <span class="n">tdx_handle_ept_violation</span><span class="o">+</span><span class="mh">0xe1</span><span class="o">/</span><span class="mh">0x1a0</span> <span class="p">[</span><span class="n">kvm_intel</span><span class="p">]</span>
<span class="p">[</span><span class="mf">190678.041500</span><span class="p">]</span>  <span class="n">__tdx_handle_exit</span><span class="o">+</span><span class="mh">0x15e</span><span class="o">/</span><span class="mh">0x220</span> <span class="p">[</span><span class="n">kvm_intel</span><span class="p">]</span>
<span class="p">[</span><span class="mf">190678.041507</span><span class="p">]</span>  <span class="n">tdx_handle_exit</span><span class="o">+</span><span class="mh">0x12</span><span class="o">/</span><span class="mh">0x60</span> <span class="p">[</span><span class="n">kvm_intel</span><span class="p">]</span>
<span class="p">[</span><span class="mf">190678.041513</span><span class="p">]</span>  <span class="n">vt_handle_exit</span><span class="o">+</span><span class="mh">0x26</span><span class="o">/</span><span class="mh">0x30</span> <span class="p">[</span><span class="n">kvm_intel</span><span class="p">]</span>
<span class="p">[</span><span class="mf">190678.041519</span><span class="p">]</span>  <span class="n">vcpu_enter_guest</span><span class="o">+</span><span class="mh">0x7ef</span><span class="o">/</span><span class="mh">0x1000</span> <span class="p">[</span><span class="n">kvm</span><span class="p">]</span>
</pre></td></tr></tbody></table></code></div></div>

<h3 id="tdx_handle_ept_violation"><span class="me-2">tdx_handle_ept_violation</span><a href="#tdx_handle_ept_violation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<p>When guest TD exits, it goes through below functions to handle TD exit events: 
vt_handle_exit -&gt; __tdx_handle_exit. Based on the exit type of the TD, it jumps
to the different functions to handle the exit (refer to [[]]).</p>

<p>In this posting, we will follow the EXIT_REASON_EPT_VIOLATION exit reason, so it
jumps to tdx_handle_ept_violation.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">int</span> <span class="nf">tdx_handle_ept_violation</span><span class="p">(</span><span class="k">struct</span> <span class="nc">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">union</span> <span class="n">tdx_ext_exit_qualification</span> <span class="n">ext_exit_qual</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">exit_qual</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">err_page_level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="n">ext_exit_qual</span><span class="p">.</span><span class="n">full</span> <span class="o">=</span> <span class="n">tdexit_ext_exit_qual</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">ext_exit_qual</span><span class="p">.</span><span class="n">type</span> <span class="o">&gt;=</span> <span class="n">NUM_EXT_EXIT_QUAL</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">pr_err</span><span class="p">(</span><span class="s">"EPT violation at gpa 0x%lx, with invalid ext exit qualification type 0x%x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                        <span class="n">tdexit_gpa</span><span class="p">(</span><span class="n">vcpu</span><span class="p">),</span> <span class="n">ext_exit_qual</span><span class="p">.</span><span class="n">type</span><span class="p">);</span>
                <span class="n">kvm_vm_bugged</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">);</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">ext_exit_qual</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">EXT_EXIT_QUAL_ACCEPT</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">err_page_level</span> <span class="o">=</span> <span class="n">ext_exit_qual</span><span class="p">.</span><span class="n">req_sept_level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">kvm_is_private_gpa</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">tdexit_gpa</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)))</span> <span class="p">{</span>
                <span class="cm">/*
                 * Always treat SEPT violations as write faults.  Ignore the
                 * EXIT_QUALIFICATION reported by TDX-SEAM for SEPT violations.
                 * TD private pages are always RWX in the SEPT tables,
                 * i.e. they're always mapped writable.  Just as importantly,
                 * treating SEPT violations as write faults is necessary to
                 * avoid COW allocations, which will cause TDAUGPAGE failures
                 * due to aliasing a single HPA to multiple GPAs.
                 */</span>
<span class="cp">#define TDX_SEPT_VIOLATION_EXIT_QUAL    EPT_VIOLATION_ACC_WRITE
</span>                <span class="n">exit_qual</span> <span class="o">=</span> <span class="n">TDX_SEPT_VIOLATION_EXIT_QUAL</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">exit_qual</span> <span class="o">=</span> <span class="n">tdexit_exit_qual</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">exit_qual</span> <span class="o">&amp;</span> <span class="n">EPT_VIOLATION_ACC_INSTR</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">pr_warn</span><span class="p">(</span><span class="s">"kvm: TDX instr fetch to shared GPA = 0x%lx @ RIP = 0x%lx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                                <span class="n">tdexit_gpa</span><span class="p">(</span><span class="n">vcpu</span><span class="p">),</span> <span class="n">kvm_rip_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">));</span>
                        <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">exit_reason</span> <span class="o">=</span> <span class="n">KVM_EXIT_EXCEPTION</span><span class="p">;</span>
                        <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">ex</span><span class="p">.</span><span class="n">exception</span> <span class="o">=</span> <span class="n">PF_VECTOR</span><span class="p">;</span>
                        <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">ex</span><span class="p">.</span><span class="n">error_code</span> <span class="o">=</span> <span class="n">exit_qual</span><span class="p">;</span>
                        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
                <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">trace_kvm_page_fault</span><span class="p">(</span><span class="n">tdexit_gpa</span><span class="p">(</span><span class="n">vcpu</span><span class="p">),</span> <span class="n">exit_qual</span><span class="p">);</span>
        <span class="k">return</span> <span class="nf">__vmx_handle_ept_violation</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">tdexit_gpa</span><span class="p">(</span><span class="n">vcpu</span><span class="p">),</span> <span class="n">exit_qual</span><span class="p">,</span> <span class="n">err_page_level</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">tdexit_gpa</span><span class="p">(</span><span class="k">struct</span> <span class="nc">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">return</span> <span class="n">kvm_r8_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">kvm_is_private_gpa</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="nc">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gpa_t</span> <span class="n">gpa</span><span class="p">)</span>
<span class="p">{</span>               
        <span class="n">gfn_t</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">kvm_gfn_shared_mask</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">mask</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">gpa_to_gfn</span><span class="p">(</span><span class="n">gpa</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>       
</pre></td></tr></tbody></table></code></div></div>

<p>When TD exits because of the EPT violation, it passes the faultin GPA address 
through the r8 register to the VMM. Therefore, the tdx_handle_ept_violation 
function checks if the faultin address is private. If it is not a private, then 
TD exit happens while it tries to fetch instructions from non-private memory, 
which doesn’t need further handling operations. If it is private, then it should 
be handled by the VMM layer to resolve fault.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">tdexit_ext_exit_qual</span><span class="p">(</span><span class="k">struct</span> <span class="nc">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">return</span> <span class="n">kvm_rdx_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
<span class="p">}</span>

</pre></td></tr></tbody></table></code></div></div>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__vmx_handle_ept_violation</span><span class="p">(</span><span class="k">struct</span> <span class="nc">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gpa_t</span> <span class="n">gpa</span><span class="p">,</span>
                                             <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">exit_qualification</span><span class="p">,</span>
                                             <span class="kt">int</span> <span class="n">err_page_level</span><span class="p">)</span>
<span class="p">{</span>                       
        <span class="n">u64</span> <span class="n">error_code</span><span class="p">;</span> 
                
        <span class="cm">/* Is it a read fault? */</span>
        <span class="n">error_code</span> <span class="o">=</span> <span class="p">(</span><span class="n">exit_qualification</span> <span class="o">&amp;</span> <span class="n">EPT_VIOLATION_ACC_READ</span><span class="p">)</span>
                     <span class="o">?</span> <span class="n">PFERR_USER_MASK</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
        <span class="cm">/* Is it a write fault? */</span>
        <span class="n">error_code</span> <span class="o">|=</span> <span class="p">(</span><span class="n">exit_qualification</span> <span class="o">&amp;</span> <span class="n">EPT_VIOLATION_ACC_WRITE</span><span class="p">)</span>
                      <span class="o">?</span> <span class="n">PFERR_WRITE_MASK</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
        <span class="cm">/* Is it a fetch fault? */</span>
        <span class="n">error_code</span> <span class="o">|=</span> <span class="p">(</span><span class="n">exit_qualification</span> <span class="o">&amp;</span> <span class="n">EPT_VIOLATION_ACC_INSTR</span><span class="p">)</span>
                      <span class="o">?</span> <span class="n">PFERR_FETCH_MASK</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
        <span class="cm">/* ept page table entry is present? */</span>
        <span class="n">error_code</span> <span class="o">|=</span> <span class="p">(</span><span class="n">exit_qualification</span> <span class="o">&amp;</span> <span class="n">EPT_VIOLATION_RWX_MASK</span><span class="p">)</span>
                      <span class="o">?</span> <span class="n">PFERR_PRESENT_MASK</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

        <span class="n">error_code</span> <span class="o">|=</span> <span class="p">(</span><span class="n">exit_qualification</span> <span class="o">&amp;</span> <span class="n">EPT_VIOLATION_GVA_TRANSLATED</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">?</span>
               <span class="n">PFERR_GUEST_FINAL_MASK</span> <span class="o">:</span> <span class="n">PFERR_GUEST_PAGE_MASK</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">err_page_level</span> <span class="o">&gt;</span> <span class="n">PG_LEVEL_NONE</span><span class="p">)</span>
                <span class="n">error_code</span> <span class="o">|=</span> <span class="p">(</span><span class="n">err_page_level</span> <span class="o">&lt;&lt;</span> <span class="n">PFERR_LEVEL_START_BIT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PFERR_LEVEL_MASK</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">kvm_mmu_page_fault</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gpa</span><span class="p">,</span> <span class="n">error_code</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>If the faultin GPA belongs to the private memory, VMM can retrieves the exit
qualification through the rdx register. Above function parses the qualification 
and passes the error_code to the kvm_mmu_page_fault function. Note that TDX 
private page fault is treated as write fault (\XXX is it true?).</p>

<h3 id="handling-page-fault"><span class="me-2">Handling page fault</span><a href="#handling-page-fault" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<p>Now we have most of the information about the fault. Let’s handle page fault!</p>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
</pre></td><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">noinline</span> <span class="nf">kvm_mmu_page_fault</span><span class="p">(</span><span class="k">struct</span> <span class="nc">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gpa_t</span> <span class="n">cr2_or_gpa</span><span class="p">,</span> <span class="n">u64</span> <span class="n">error_code</span><span class="p">,</span>
                       <span class="kt">void</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">insn_len</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="n">emulation_type</span> <span class="o">=</span> <span class="n">EMULTYPE_PF</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">direct</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="o">-&gt;</span><span class="n">root_role</span><span class="p">.</span><span class="n">direct</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">VALID_PAGE</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">.</span><span class="n">hpa</span><span class="p">)))</span>
                <span class="k">return</span> <span class="n">RET_PF_RETRY</span><span class="p">;</span>

        <span class="n">r</span> <span class="o">=</span> <span class="n">RET_PF_INVALID</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error_code</span> <span class="o">&amp;</span> <span class="n">PFERR_RSVD_MASK</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">handle_mmio_page_fault</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">cr2_or_gpa</span><span class="p">,</span> <span class="n">direct</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="n">RET_PF_EMULATE</span><span class="p">)</span>
                        <span class="k">goto</span> <span class="n">emulate</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="n">RET_PF_INVALID</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">kvm_mmu_do_page_fault</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">cr2_or_gpa</span><span class="p">,</span>
                                          <span class="n">lower_32_bits</span><span class="p">(</span><span class="n">error_code</span><span class="p">),</span> <span class="nb">false</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">KVM_BUG_ON</span><span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="n">RET_PF_INVALID</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">))</span>
                        <span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="n">RET_PF_USER</span><span class="p">)</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">!=</span> <span class="n">RET_PF_EMULATE</span><span class="p">)</span>
                <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

        <span class="cm">/*
         * Before emulating the instruction, check if the error code
         * was due to a RO violation while translating the guest page.
         * This can occur when using nested virtualization with nested
         * paging in both guests. If true, we simply unprotect the page
	 * and resume the guest.
         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="o">-&gt;</span><span class="n">root_role</span><span class="p">.</span><span class="n">direct</span> <span class="o">&amp;&amp;</span>
            <span class="p">(</span><span class="n">error_code</span> <span class="o">&amp;</span> <span class="n">PFERR_NESTED_GUEST_PAGE</span><span class="p">)</span> <span class="o">==</span> <span class="n">PFERR_NESTED_GUEST_PAGE</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">kvm_mmu_unprotect_page</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gpa_to_gfn</span><span class="p">(</span><span class="n">cr2_or_gpa</span><span class="p">));</span>
                <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/*
         * vcpu-&gt;arch.mmu.page_fault returned RET_PF_EMULATE, but we can still
         * optimistically try to just unprotect the page and let the processor
         * re-execute the instruction that caused the page fault.  Do not allow
         * retrying MMIO emulation, as it's not only pointless but could also
         * cause us to enter an infinite loop because the processor will keep
         * faulting on the non-existent MMIO address.  Retrying an instruction
         * from a nested guest is also pointless and dangerous as we are only
         * explicitly shadowing L1's page tables, i.e. unprotecting something
         * for L1 isn't going to magically fix whatever issue cause L2 to fail.
         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mmio_info_in_cache</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">cr2_or_gpa</span><span class="p">,</span> <span class="n">direct</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_guest_mode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>
                <span class="n">emulation_type</span> <span class="o">|=</span> <span class="n">EMULTYPE_ALLOW_RETRY_PF</span><span class="p">;</span>
<span class="n">emulate</span><span class="o">:</span>
        <span class="k">return</span> <span class="nf">x86_emulate_instruction</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">cr2_or_gpa</span><span class="p">,</span> <span class="n">emulation_type</span><span class="p">,</span> <span class="n">insn</span><span class="p">,</span>
                                       <span class="n">insn_len</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">kvm_mmu_do_page_fault</span><span class="p">(</span><span class="k">struct</span> <span class="nc">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gpa_t</span> <span class="n">cr2_or_gpa</span><span class="p">,</span>
                                        <span class="n">u32</span> <span class="n">err</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">prefetch</span><span class="p">)</span>
<span class="p">{</span>                       
        <span class="k">struct</span> <span class="nc">kvm_page_fault</span> <span class="n">fault</span> <span class="o">=</span> <span class="p">{</span>
                <span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">cr2_or_gpa</span><span class="p">,</span>
                <span class="p">.</span><span class="n">error_code</span> <span class="o">=</span> <span class="n">err</span><span class="p">,</span>
                <span class="p">.</span><span class="n">exec</span> <span class="o">=</span> <span class="n">err</span> <span class="o">&amp;</span> <span class="n">PFERR_FETCH_MASK</span><span class="p">,</span> 
                <span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">err</span> <span class="o">&amp;</span> <span class="n">PFERR_WRITE_MASK</span><span class="p">,</span>
                <span class="p">.</span><span class="n">present</span> <span class="o">=</span> <span class="n">err</span> <span class="o">&amp;</span> <span class="n">PFERR_PRESENT_MASK</span><span class="p">,</span>
                <span class="p">.</span><span class="n">rsvd</span> <span class="o">=</span> <span class="n">err</span> <span class="o">&amp;</span> <span class="n">PFERR_RSVD_MASK</span><span class="p">,</span>
                <span class="p">.</span><span class="n">user</span> <span class="o">=</span> <span class="n">err</span> <span class="o">&amp;</span> <span class="n">PFERR_USER_MASK</span><span class="p">,</span>
                <span class="p">.</span><span class="n">prefetch</span> <span class="o">=</span> <span class="n">prefetch</span><span class="p">,</span>
                <span class="p">.</span><span class="n">is_tdp</span> <span class="o">=</span> <span class="n">likely</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="o">-&gt;</span><span class="n">page_fault</span> <span class="o">==</span> <span class="n">kvm_tdp_page_fault</span><span class="p">),</span>
                <span class="p">.</span><span class="n">nx_huge_page_workaround_enabled</span> <span class="o">=</span> <span class="n">is_nx_huge_page_enabled</span><span class="p">(),</span>
                <span class="p">.</span><span class="n">is_private</span> <span class="o">=</span> <span class="n">kvm_is_private_gpa</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">cr2_or_gpa</span><span class="p">),</span>
        
                <span class="p">.</span><span class="n">max_level</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">tdp_max_page_level</span><span class="p">,</span>
                <span class="p">.</span><span class="n">req_level</span> <span class="o">=</span> <span class="n">PG_LEVEL_4K</span><span class="p">,</span>
                <span class="p">.</span><span class="n">goal_level</span> <span class="o">=</span> <span class="n">PG_LEVEL_4K</span><span class="p">,</span>
        <span class="p">};</span>
        <span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

        <span class="cm">/*
         * Async #PF "faults", a.k.a. prefetch faults, are not faults from the
         * guest perspective and have already been counted at the time of the
         * original fault.
         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prefetch</span><span class="p">)</span>
                <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">pf_taken</span><span class="o">++</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">IS_ENABLED</span><span class="p">(</span><span class="n">CONFIG_RETPOLINE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">fault</span><span class="p">.</span><span class="n">is_tdp</span><span class="p">)</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">kvm_tdp_page_fault</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fault</span><span class="p">);</span>
        <span class="k">else</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="o">-&gt;</span><span class="n">page_fault</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fault</span><span class="p">);</span>
        <span class="cm">/*
         * Similar to above, prefetch faults aren't truly spurious, and the
         * async #PF path doesn't do emulation.  Do count faults that are fixed
         * by the async #PF handler though, otherwise they'll never be counted.
         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="n">RET_PF_FIXED</span><span class="p">)</span>
                <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">pf_fixed</span><span class="o">++</span><span class="p">;</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">prefetch</span><span class="p">)</span>
                <span class="p">;</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="n">RET_PF_EMULATE</span><span class="p">)</span>
                <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">pf_emulate</span><span class="o">++</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="n">RET_PF_SPURIOUS</span><span class="p">)</span>
                <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">pf_spurious</span><span class="o">++</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>It injects the fault to the page fault handler. It is highly likely that the 
TDX utilize the tdp, so it will invoke kvm_tdp_page_fault function.</p>

<h3 id="fault-handling-for-tdx"><span class="me-2">Fault handling (for TDX)</span><a href="#fault-handling-for-tdx" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<blockquote>
  <p>The <strong>kvm_faultin_pfn</strong> function resolves GPA -&gt; HVA mapping and pin the HVA.
To translate GPA to HVA, the memslot instance associated with the faultin GPA
is required.</p>
</blockquote>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_faultin_pfn</span><span class="p">(</span><span class="k">struct</span> <span class="nc">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">kvm_page_fault</span> <span class="o">*</span><span class="n">fault</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="nc">kvm_memory_slot</span> <span class="o">*</span><span class="n">slot</span> <span class="o">=</span> <span class="n">fault</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">async</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

        <span class="cm">/*
         * Retry the page fault if the gfn hit a memslot that is being deleted
         * or moved.  This ensures any existing SPTEs for the old memslot will
         * be zapped before KVM inserts a new MMIO SPTE for the gfn.
         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">slot</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">KVM_MEMSLOT_INVALID</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">RET_PF_RETRY</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kvm_is_visible_memslot</span><span class="p">(</span><span class="n">slot</span><span class="p">))</span> <span class="p">{</span>
                <span class="cm">/* Don't expose private memslots to L2. */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">is_guest_mode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
                        <span class="n">fault</span><span class="o">-&gt;</span><span class="n">slot</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
                        <span class="n">fault</span><span class="o">-&gt;</span><span class="n">pfn</span> <span class="o">=</span> <span class="n">KVM_PFN_NOSLOT</span><span class="p">;</span>
                        <span class="n">fault</span><span class="o">-&gt;</span><span class="n">map_writable</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                        <span class="k">return</span> <span class="n">RET_PF_CONTINUE</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="cm">/*
                 * If the APIC access page exists but is disabled, go directly
                 * to emulation without caching the MMIO access or creating a
                 * MMIO SPTE.  That way the cache doesn't need to be purged
                 * when the AVIC is re-enabled.
                 */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">&amp;&amp;</span> <span class="n">slot</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">==</span> <span class="n">APIC_ACCESS_PAGE_PRIVATE_MEMSLOT</span> <span class="o">&amp;&amp;</span>
                    <span class="o">!</span><span class="n">kvm_apicv_activated</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">))</span>
                        <span class="k">return</span> <span class="n">RET_PF_EMULATE</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">kvm_slot_is_private</span><span class="p">(</span><span class="n">slot</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">kvm_faultin_pfn_private</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">fault</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">!=</span> <span class="n">RET_PF_CONTINUE</span><span class="p">)</span>
                        <span class="k">return</span> <span class="n">r</span> <span class="o">==</span> <span class="n">RET_PF_FIXED</span> <span class="o">?</span> <span class="n">RET_PF_CONTINUE</span> <span class="o">:</span> <span class="n">r</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">fault</span><span class="o">-&gt;</span><span class="n">is_private</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">kvm_faultin_pfn_private_mapped</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">fault</span><span class="p">);</span>
        <span class="n">async</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">fault</span><span class="o">-&gt;</span><span class="n">pfn</span> <span class="o">=</span> <span class="n">__gfn_to_pfn_memslot</span><span class="p">(</span><span class="n">slot</span><span class="p">,</span> <span class="n">fault</span><span class="o">-&gt;</span><span class="n">gfn</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">async</span><span class="p">,</span>
                                          <span class="n">fault</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fault</span><span class="o">-&gt;</span><span class="n">map_writable</span><span class="p">,</span>
                                          <span class="o">&amp;</span><span class="n">fault</span><span class="o">-&gt;</span><span class="n">hva</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></div></div>
<p>When the faultin address does not belong to private memory space for TD, then 
__gfn_to_pfn_memslot function translate gfn to pfn. Otherwise (TDX private), 
it invokes kvm_faultin_pfn_private function when private_file has been assigned 
or kvm_faultin_pfn_private_mapped without private_fd (most of the cases).</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="rouge-code"><pre><span class="cm">/*
 * Private page can't be release on mmu_notifier without losing page contents.
 * The help, callback, from backing store is needed to allow page migration.
 * For now, pin the page.
 */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_faultin_pfn_private_mapped</span><span class="p">(</span><span class="k">struct</span> <span class="nc">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
                                           <span class="k">struct</span> <span class="nc">kvm_page_fault</span> <span class="o">*</span><span class="n">fault</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">hva_t</span> <span class="n">hva</span> <span class="o">=</span> <span class="n">gfn_to_hva_memslot</span><span class="p">(</span><span class="n">fault</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">,</span> <span class="n">fault</span><span class="o">-&gt;</span><span class="n">gfn</span><span class="p">);</span>
        <span class="k">struct</span> <span class="nc">page</span> <span class="o">*</span><span class="n">page</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

        <span class="n">fault</span><span class="o">-&gt;</span><span class="n">map_writable</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">fault</span><span class="o">-&gt;</span><span class="n">pfn</span> <span class="o">=</span> <span class="n">KVM_PFN_ERR_FAULT</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">hva</span> <span class="o">==</span> <span class="n">KVM_HVA_ERR_RO_BAD</span> <span class="o">||</span> <span class="n">hva</span> <span class="o">==</span> <span class="n">KVM_HVA_ERR_BAD</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">RET_PF_INVALID</span><span class="p">;</span>

        <span class="cm">/* TDX allows only RWX.  Read-only isn't supported. */</span>
        <span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">fault</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">get_user_pages_fast</span><span class="p">(</span><span class="n">hva</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">FOLL_WRITE</span><span class="p">,</span> <span class="n">page</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">RET_PF_INVALID</span><span class="p">;</span>

        <span class="n">fault</span><span class="o">-&gt;</span><span class="n">map_writable</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="n">fault</span><span class="o">-&gt;</span><span class="n">pfn</span> <span class="o">=</span> <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">page</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="k">return</span> <span class="n">RET_PF_CONTINUE</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>It invokes get_user_pages_fast function to walk page table to find HPA mapping
for hva and pin it. Also it assigns the pfn to the injected fault so that it can
be handled later to generate mapping in the private EPT (GPA -&gt; HPA).</p>

<h3 id="handling-the-fault-setting-ept"><span class="me-2">Handling the fault (setting EPT)</span><a href="#handling-the-fault-setting-ept" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
</pre></td><td class="rouge-code"><pre><span class="cm">/*
 * Handle a TDP page fault (NPT/EPT violation/misconfiguration) by installing
 * page tables and SPTEs to translate the faulting guest physical address.
 */</span>
<span class="kt">int</span> <span class="nf">kvm_tdp_mmu_map</span><span class="p">(</span><span class="k">struct</span> <span class="nc">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">kvm_page_fault</span> <span class="o">*</span><span class="n">fault</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="nc">kvm_mmu</span> <span class="o">*</span><span class="n">mmu</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">;</span>
        <span class="k">struct</span> <span class="nc">tdp_iter</span> <span class="n">iter</span><span class="p">;</span>
        <span class="n">gfn_t</span> <span class="n">raw_gfn</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">is_private</span> <span class="o">=</span> <span class="n">fault</span><span class="o">-&gt;</span><span class="n">is_private</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

        <span class="n">kvm_mmu_hugepage_adjust</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">fault</span><span class="p">);</span>

        <span class="n">trace_kvm_mmu_spte_requested</span><span class="p">(</span><span class="n">fault</span><span class="p">);</span>

        <span class="n">rcu_read_lock</span><span class="p">();</span>

        <span class="n">raw_gfn</span> <span class="o">=</span> <span class="n">gpa_to_gfn</span><span class="p">(</span><span class="n">fault</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">is_error_noslot_pfn</span><span class="p">(</span><span class="n">fault</span><span class="o">-&gt;</span><span class="n">pfn</span><span class="p">)</span> <span class="o">||</span> <span class="n">kvm_is_reserved_pfn</span><span class="p">(</span><span class="n">fault</span><span class="o">-&gt;</span><span class="n">pfn</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">is_private</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">rcu_read_unlock</span><span class="p">();</span>
                        <span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
                <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">tdp_mmu_for_each_pte</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">mmu</span><span class="p">,</span> <span class="n">is_private</span><span class="p">,</span> <span class="n">raw_gfn</span><span class="p">,</span> <span class="n">raw_gfn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">WARN_ON</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">is_private</span> <span class="o">!=</span> <span class="n">is_private</span><span class="p">);</span>
                <span class="n">WARN_ON</span><span class="p">(</span><span class="n">is_private_sptep</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">sptep</span><span class="p">)</span> <span class="o">!=</span> <span class="n">is_private</span><span class="p">);</span>

                <span class="cm">/*
                 * In private GPA case, cannot map a private page to higher
                 * level if smaller level mapping exists.  It can be promoted to
                 * larger mapping later when all the smaller mapping are there.
                 */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">fault</span><span class="o">-&gt;</span><span class="n">nx_huge_page_workaround_enabled</span> <span class="o">||</span> <span class="n">is_private</span><span class="p">)</span>
                        <span class="n">disallowed_hugepage_adjust</span><span class="p">(</span><span class="n">fault</span><span class="p">,</span> <span class="n">iter</span><span class="p">.</span><span class="n">old_spte</span><span class="p">,</span> <span class="n">iter</span><span class="p">.</span><span class="n">level</span><span class="p">);</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">level</span> <span class="o">==</span> <span class="n">fault</span><span class="o">-&gt;</span><span class="n">goal_level</span><span class="p">)</span>
                        <span class="k">break</span><span class="p">;</span>

                <span class="cm">/*
                 * Check zapped large page firstly, this allows us continue to
                 * split the large private page after unzap the pte back.
                 */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">is_private_zapped_spte</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">old_spte</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
                    <span class="n">is_large_pte</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">old_spte</span><span class="p">))</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">tdp_mmu_unzap_large_spte</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">fault</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iter</span><span class="p">)</span> <span class="o">!=</span>
                            <span class="n">RET_PF_CONTINUE</span><span class="p">)</span>
                                <span class="k">break</span><span class="p">;</span>
                        <span class="n">iter</span><span class="p">.</span><span class="n">old_spte</span> <span class="o">=</span> <span class="n">kvm_tdp_mmu_read_spte</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">sptep</span><span class="p">);</span>
                <span class="p">}</span>

                <span class="cm">/*
                 * If there is an SPTE mapping a large page at a higher level
                 * than the target, that SPTE must be cleared and replaced
                 * with a non-leaf SPTE.
                 */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">is_shadow_present_pte</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">old_spte</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
                    <span class="n">is_large_pte</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">old_spte</span><span class="p">))</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">is_private</span><span class="p">)</span> <span class="p">{</span>
                                <span class="n">tdp_mmu_split_pivate_huge_page</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iter</span><span class="p">,</span>
                                                               <span class="n">fault</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
                                <span class="k">break</span><span class="p">;</span>
                        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                                <span class="k">if</span> <span class="p">(</span><span class="n">tdp_mmu_zap_spte_atomic</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iter</span><span class="p">))</span>
                                        <span class="k">break</span><span class="p">;</span>
                        <span class="p">}</span>
                        <span class="n">WARN_ON</span><span class="p">(</span><span class="n">is_private_sptep</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">sptep</span><span class="p">));</span>

                        <span class="cm">/*
                         * The iter must explicitly re-read the spte here
                         * because the new value informs the !present
                         * path below.
                         */</span>
                        <span class="n">iter</span><span class="p">.</span><span class="n">old_spte</span> <span class="o">=</span> <span class="n">kvm_tdp_mmu_read_spte</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">sptep</span><span class="p">);</span>
                <span class="p">}</span>

                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_shadow_present_pte</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">old_spte</span><span class="p">))</span> <span class="p">{</span>
                        <span class="kt">bool</span> <span class="n">account_nx</span> <span class="o">=</span> <span class="n">fault</span><span class="o">-&gt;</span><span class="n">huge_page_disallowed</span> <span class="o">&amp;&amp;</span>
                                <span class="n">fault</span><span class="o">-&gt;</span><span class="n">req_level</span> <span class="o">&gt;=</span> <span class="n">iter</span><span class="p">.</span><span class="n">level</span><span class="p">;</span>

                        <span class="cm">/*
                         * If SPTE has been frozen by another thread, just
                         * give up and retry, avoiding unnecessary page table
                         * allocation and free.
                         */</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">is_removed_spte</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">old_spte</span><span class="p">))</span>
                                <span class="k">break</span><span class="p">;</span>

                        <span class="k">if</span> <span class="p">(</span><span class="n">tdp_mmu_populate_nonleaf</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iter</span><span class="p">,</span> <span class="n">account_nx</span><span class="p">))</span>
                                <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
        <span class="p">}</span>

        <span class="cm">/*
         * Force the guest to retry the access if the upper level SPTEs aren't
         * in place, or if the target leaf SPTE is frozen by another CPU.
         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">level</span> <span class="o">!=</span> <span class="n">fault</span><span class="o">-&gt;</span><span class="n">goal_level</span> <span class="o">||</span> <span class="n">is_removed_spte</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">old_spte</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">rcu_read_unlock</span><span class="p">();</span>
                <span class="k">return</span> <span class="n">RET_PF_RETRY</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="n">tdp_mmu_map_handle_target_level</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">fault</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iter</span><span class="p">);</span>
        <span class="n">rcu_read_unlock</span><span class="p">();</span>

        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="cp">#define tdp_mmu_for_each_pte(_iter, _mmu, _private, _start, _end)       \
        for_each_tdp_pte(_iter,                                         \
                 to_shadow_page((_private) ? _mmu-&gt;private_root_hpa :   \
                                _mmu-&gt;root.hpa),                        \
                _start, _end)
</span></pre></td></tr></tbody></table></code></div></div>

<h3 id="set-new-spte-entry"><span class="me-2">Set new SPTE entry</span><a href="#set-new-spte-entry" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<p>When a guest VM makes a memory access, the TDP MMU checks the guest’s page 
tables and translates the virtual address to a physical address. If the guest’s
page tables are not present in the TDP MMU’s cache, the hypervisor intercepts 
the page fault and updates the <strong>TDP MMU cache</strong> with the appropriate guest page
table entries. <strong>tdp_mmu_set_spte_atomic</strong> is used to set the PTE for a specific
guest virtual address in the TDP MMU. It is called when the hypervisor needs to 
modify a guest PTE, such as when adding or removing a mapping from a guest’s 
virtual address space. Because we are handling the page fault, it needs to map 
new entry in the SPT, and the atomic function properly inserts new entry to the
SPT. Note that make_spte function in the tdp_mmu_map_handle_target_level 
generates the new spte entry to be inserted. For the details please refer to 
[[]]. Also note that tdp_mmu_set_spte_atomic is called instaed of the 
tdp_mmu_map_set_spte_atomic.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
</pre></td><td class="rouge-code"><pre><span class="cm">/*
 * tdp_mmu_set_spte_atomic - Set a TDP MMU SPTE atomically
 * and handle the associated bookkeeping.  Do not mark the page dirty
 * in KVM's dirty bitmaps.
 *
 * If setting the SPTE fails because it has changed, iter-&gt;old_spte will be
 * refreshed to the current value of the spte.
 *
 * @kvm: kvm instance
 * @iter: a tdp_iter instance currently on the SPTE that should be set
 * @new_spte: The value the SPTE should be set to
 * Return:
 * * 0      - If the SPTE was set.
 * * -EBUSY - If the SPTE cannot be set. In this case this function will have
 *            no side-effects other than setting iter-&gt;old_spte to the last
 *            known value of the spte.
 */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">tdp_mmu_set_spte_atomic</span><span class="p">(</span><span class="k">struct</span> <span class="nc">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span>
                                          <span class="k">struct</span> <span class="nc">tdp_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">,</span>
                                          <span class="n">u64</span> <span class="n">new_spte</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">bool</span> <span class="n">freeze_spte</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">is_private</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_removed_spte</span><span class="p">(</span><span class="n">new_spte</span><span class="p">);</span>
        <span class="n">u64</span> <span class="n">tmp_spte</span> <span class="o">=</span> <span class="n">freeze_spte</span> <span class="o">?</span> <span class="n">REMOVED_SPTE</span> <span class="o">:</span> <span class="n">new_spte</span><span class="p">;</span>
        <span class="n">u64</span> <span class="o">*</span><span class="n">sptep</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">sptep</span><span class="p">);</span>
        <span class="n">u64</span> <span class="n">old_spte</span><span class="p">;</span>

        <span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">yielded</span><span class="p">);</span>
        <span class="n">WARN_ON</span><span class="p">(</span><span class="n">is_private_sptep</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">sptep</span><span class="p">)</span> <span class="o">!=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">is_private</span><span class="p">);</span>

        <span class="cm">/*
         * The caller is responsible for ensuring the old SPTE is not a REMOVED
         * SPTE.  KVM should never attempt to zap or manipulate a REMOVED SPTE,
         * and pre-checking before inserting a new SPTE is advantageous as it
         * avoids unnecessary work.
         */</span>
        <span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">yielded</span> <span class="o">||</span> <span class="n">is_removed_spte</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">old_spte</span><span class="p">));</span>

        <span class="n">lockdep_assert_held_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>

        <span class="cm">/*
         * Note, fast_pf_fix_direct_spte() can also modify TDP MMU SPTEs and
         * does not hold the mmu_lock.
         */</span>
        <span class="n">old_spte</span> <span class="o">=</span> <span class="n">cmpxchg64</span><span class="p">(</span><span class="n">sptep</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">old_spte</span><span class="p">,</span> <span class="n">tmp_spte</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">old_spte</span> <span class="o">!=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">old_spte</span><span class="p">)</span> <span class="p">{</span>
                <span class="cm">/*
                 * The page table entry was modified by a different logical
                 * CPU. Refresh iter-&gt;old_spte with the current value so the
                 * caller operates on fresh data, e.g. if it retries
                 * tdp_mmu_set_spte_atomic().
                 */</span>
                <span class="n">iter</span><span class="o">-&gt;</span><span class="n">old_spte</span> <span class="o">=</span> <span class="n">old_spte</span><span class="p">;</span>
                <span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">__handle_changed_spte</span><span class="p">(</span>
                <span class="n">kvm</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">as_id</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">gfn</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">is_private</span><span class="p">,</span>
                <span class="n">iter</span><span class="o">-&gt;</span><span class="n">old_spte</span><span class="p">,</span> <span class="n">new_spte</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
        <span class="n">handle_changed_spte_acc_track</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">old_spte</span><span class="p">,</span> <span class="n">new_spte</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">freeze_spte</span><span class="p">)</span>
                <span class="n">__kvm_tdp_mmu_write_spte</span><span class="p">(</span><span class="n">sptep</span><span class="p">,</span> <span class="n">new_spte</span><span class="p">);</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>The function takes an argument for the new PTE value and performs an atomic swap
operation to set the new PTE in the TDP MMU cache. The function also performs 
various checks and updates to ensure that the new PTE is valid and that the TDP 
MMU cache is consistent with the guest’s page tables.</p>

<h2 id="handling-architecture-specific-page-table-changes"><span class="me-2">Handling (architecture specific) page table changes</span><a href="#handling-architecture-specific-page-table-changes" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>
<p>The purpose of __handle_changed_spte is to update the virtual memory mappings in
response to changes in the SPTE. For example, if the SPTE’s permissions were 
changed to disallow write access, the function may need to update the 
corresponding page table entry to indicate that the page is read-only. The 
function may also need to perform other operations, such as updating the dirty 
bit, clearing the accessed bit, or invalidating TLB entries. Just updating the 
SPTE doesn’t change the page table related hardware registers automatically.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
</pre></td><td class="rouge-code"><pre><span class="cm">/**
 * __handle_changed_spte - handle bookkeeping associated with an SPTE change
 * @kvm: kvm instance
 * @as_id: the address space of the paging structure the SPTE was a part of
 * @gfn: the base GFN that was mapped by the SPTE
 * @private_spte: the SPTE is private or not
 * @old_spte: The value of the SPTE before the change
 * @new_spte: The value of the SPTE after the change
 * @level: the level of the PT the SPTE is part of in the paging structure
 * @shared: This operation may not be running under the exclusive use of
 *          the MMU lock and the operation must synchronize with other
 *          threads that might be modifying SPTEs.
 *
 * Handle bookkeeping that might result from the modification of a SPTE.
 * This function must be called for all TDP SPTE modifications.
 */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__handle_changed_spte</span><span class="p">(</span><span class="k">struct</span> <span class="nc">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">int</span> <span class="n">as_id</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">,</span>
                                  <span class="kt">bool</span> <span class="n">private_spte</span><span class="p">,</span> <span class="n">u64</span> <span class="n">old_spte</span><span class="p">,</span>
                                  <span class="n">u64</span> <span class="n">new_spte</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">shared</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">bool</span> <span class="n">was_present</span> <span class="o">=</span> <span class="n">is_shadow_present_pte</span><span class="p">(</span><span class="n">old_spte</span><span class="p">);</span>
        <span class="kt">bool</span> <span class="n">is_present</span> <span class="o">=</span> <span class="n">is_shadow_present_pte</span><span class="p">(</span><span class="n">new_spte</span><span class="p">);</span>
        <span class="kt">bool</span> <span class="n">was_last</span> <span class="o">=</span> <span class="n">is_last_spte</span><span class="p">(</span><span class="n">old_spte</span><span class="p">,</span> <span class="n">level</span><span class="p">);</span>
        <span class="kt">bool</span> <span class="n">is_last</span> <span class="o">=</span> <span class="n">is_last_spte</span><span class="p">(</span><span class="n">new_spte</span><span class="p">,</span> <span class="n">level</span><span class="p">);</span>
        <span class="kt">bool</span> <span class="n">was_leaf</span> <span class="o">=</span> <span class="n">was_present</span> <span class="o">&amp;&amp;</span> <span class="n">was_last</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">is_leaf</span> <span class="o">=</span> <span class="n">is_present</span> <span class="o">&amp;&amp;</span> <span class="n">is_last</span><span class="p">;</span>
        <span class="n">kvm_pfn_t</span> <span class="n">old_pfn</span> <span class="o">=</span> <span class="n">spte_to_pfn</span><span class="p">(</span><span class="n">old_spte</span><span class="p">);</span>
        <span class="n">kvm_pfn_t</span> <span class="n">new_pfn</span> <span class="o">=</span> <span class="n">spte_to_pfn</span><span class="p">(</span><span class="n">new_spte</span><span class="p">);</span>
        <span class="kt">bool</span> <span class="n">pfn_changed</span> <span class="o">=</span> <span class="n">old_pfn</span> <span class="o">!=</span> <span class="n">new_pfn</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">was_private_zapped</span> <span class="o">=</span> <span class="n">is_private_zapped_spte</span><span class="p">(</span><span class="n">old_spte</span><span class="p">);</span>
        <span class="kt">bool</span> <span class="n">is_private_zapped</span> <span class="o">=</span> <span class="n">is_private_zapped_spte</span><span class="p">(</span><span class="n">new_spte</span><span class="p">);</span>
        <span class="k">struct</span> <span class="nc">kvm_spte_change</span> <span class="n">change</span> <span class="o">=</span> <span class="p">{</span>
                <span class="p">.</span><span class="n">gfn</span> <span class="o">=</span> <span class="n">gfn</span><span class="p">,</span>
                <span class="p">.</span><span class="n">level</span> <span class="o">=</span> <span class="n">level</span><span class="p">,</span>
		<span class="p">.</span><span class="n">old</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="p">.</span><span class="n">pfn</span> <span class="o">=</span> <span class="n">old_pfn</span><span class="p">,</span>
                        <span class="p">.</span><span class="n">is_present</span> <span class="o">=</span> <span class="n">was_present</span><span class="p">,</span>
                        <span class="p">.</span><span class="n">is_last</span> <span class="o">=</span> <span class="n">was_last</span><span class="p">,</span>
                        <span class="p">.</span><span class="n">is_private_zapped</span> <span class="o">=</span> <span class="n">was_private_zapped</span><span class="p">,</span>
                <span class="p">},</span>
                <span class="p">.</span><span class="k">new</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="p">.</span><span class="n">pfn</span> <span class="o">=</span> <span class="n">new_pfn</span><span class="p">,</span>
                        <span class="p">.</span><span class="n">is_present</span> <span class="o">=</span> <span class="n">is_present</span><span class="p">,</span>
                        <span class="p">.</span><span class="n">is_last</span> <span class="o">=</span> <span class="n">is_last</span><span class="p">,</span>
                        <span class="p">.</span><span class="n">is_private_zapped</span> <span class="o">=</span> <span class="n">is_private_zapped</span><span class="p">,</span>
                <span class="p">},</span>
        <span class="p">};</span>

        <span class="n">WARN_ON</span><span class="p">(</span><span class="n">level</span> <span class="o">&gt;</span> <span class="n">PT64_ROOT_MAX_LEVEL</span><span class="p">);</span>
        <span class="n">WARN_ON</span><span class="p">(</span><span class="n">level</span> <span class="o">&lt;</span> <span class="n">PG_LEVEL_4K</span><span class="p">);</span>
        <span class="n">WARN_ON</span><span class="p">(</span><span class="n">gfn</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">KVM_PAGES_PER_HPAGE</span><span class="p">(</span><span class="n">level</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
        <span class="n">WARN_ON</span><span class="p">(</span><span class="n">kvm_is_private_gpa</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn_to_gpa</span><span class="p">(</span><span class="n">gfn</span><span class="p">))</span> <span class="o">!=</span> <span class="n">private_spte</span><span class="p">);</span>
        <span class="n">WARN_ON</span><span class="p">(</span><span class="n">was_private_zapped</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">private_spte</span><span class="p">);</span>

        <span class="cm">/*
         * If this warning were to trigger it would indicate that there was a
         * missing MMU notifier or a race with some notifier handler.
         * A present, leaf SPTE should never be directly replaced with another
         * present leaf SPTE pointing to a different PFN. A notifier handler
         * should be zapping the SPTE before the main MM's page table is
         * changed, or the SPTE should be zeroed, and the TLBs flushed by the
         * thread before replacement.
         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">was_leaf</span> <span class="o">&amp;&amp;</span> <span class="n">is_leaf</span> <span class="o">&amp;&amp;</span> <span class="n">pfn_changed</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">pr_err</span><span class="p">(</span><span class="s">"Invalid SPTE change: cannot replace a present leaf</span><span class="se">\n</span><span class="s">"</span>
                       <span class="s">"SPTE with another present leaf SPTE mapping a</span><span class="se">\n</span><span class="s">"</span>
                       <span class="s">"different PFN!</span><span class="se">\n</span><span class="s">"</span>
                       <span class="s">"as_id: %d gfn: %llx old_spte: %llx new_spte: %llx level: %d"</span><span class="p">,</span>
                       <span class="n">as_id</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">old_spte</span><span class="p">,</span> <span class="n">new_spte</span><span class="p">,</span> <span class="n">level</span><span class="p">);</span>

                <span class="cm">/*
                 * Crash the host to prevent error propagation and guest data
                 * corruption.
                 */</span>
                <span class="n">BUG</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">old_spte</span> <span class="o">==</span> <span class="n">new_spte</span><span class="p">)</span>
                <span class="k">return</span><span class="p">;</span>

        <span class="n">trace_kvm_tdp_mmu_spte_changed</span><span class="p">(</span><span class="n">as_id</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">old_spte</span><span class="p">,</span> <span class="n">new_spte</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">is_leaf</span><span class="p">)</span>
                <span class="n">check_spte_writable_invariants</span><span class="p">(</span><span class="n">new_spte</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">was_private_zapped</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">change</span><span class="p">.</span><span class="n">sept_page</span> <span class="o">=</span> <span class="n">tdx_get_sept_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">change</span><span class="p">);</span>
                <span class="n">WARN_ON</span><span class="p">(</span><span class="n">is_private_zapped</span><span class="p">);</span>
                <span class="n">static_call</span><span class="p">(</span><span class="n">kvm_x86_handle_private_zapped_spte</span><span class="p">)(</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">change</span><span class="p">);</span>
                <span class="cm">/* Temporarily blocked private SPTE can only be leaf. */</span>
                <span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">is_last_spte</span><span class="p">(</span><span class="n">old_spte</span><span class="p">,</span> <span class="n">level</span><span class="p">));</span>
                <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/*
         * The only times a SPTE should be changed from a non-present to
         * non-present state is when an MMIO entry is installed/modified/
         * removed. In that case, there is nothing to do here.
         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">was_present</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_present</span><span class="p">)</span> <span class="p">{</span>
                <span class="cm">/*
                 * If this change does not involve a MMIO SPTE or removed SPTE,
                 * it is unexpected. Log the change, though it should not
                 * impact the guest since both the former and current SPTEs
                 * are nonpresent.
                 */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">is_mmio_spte</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">old_spte</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
                            <span class="o">!</span><span class="n">is_mmio_spte</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">new_spte</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
                            <span class="o">!</span><span class="n">is_removed_spte</span><span class="p">(</span><span class="n">new_spte</span><span class="p">)))</span>
                        <span class="n">pr_err</span><span class="p">(</span><span class="s">"Unexpected SPTE change! Nonpresent SPTEs</span><span class="se">\n</span><span class="s">"</span>
                               <span class="s">"should not be replaced with another,</span><span class="se">\n</span><span class="s">"</span>
                               <span class="s">"different nonpresent SPTE, unless one or both</span><span class="se">\n</span><span class="s">"</span>
                               <span class="s">"are MMIO SPTEs, or the new SPTE is</span><span class="se">\n</span><span class="s">"</span>
                               <span class="s">"a temporary removed SPTE.</span><span class="se">\n</span><span class="s">"</span>
                               <span class="s">"as_id: %d gfn: %llx old_spte: %llx new_spte: %llx level: %d"</span><span class="p">,</span>
                               <span class="n">as_id</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">old_spte</span><span class="p">,</span> <span class="n">new_spte</span><span class="p">,</span> <span class="n">level</span><span class="p">);</span>
                <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">is_leaf</span> <span class="o">!=</span> <span class="n">was_leaf</span><span class="p">)</span>
                <span class="n">kvm_update_page_stats</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">is_leaf</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">was_leaf</span> <span class="o">&amp;&amp;</span> <span class="n">is_dirty_spte</span><span class="p">(</span><span class="n">old_spte</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
            <span class="p">(</span><span class="o">!</span><span class="n">is_present</span> <span class="o">||</span> <span class="o">!</span><span class="n">is_dirty_spte</span><span class="p">(</span><span class="n">new_spte</span><span class="p">)</span> <span class="o">||</span> <span class="n">pfn_changed</span><span class="p">))</span>
                <span class="n">kvm_set_pfn_dirty</span><span class="p">(</span><span class="n">old_pfn</span><span class="p">);</span>

        <span class="cm">/*
         * Recursively handle child PTs if the change removed a subtree from
         * the paging structure.  Note the WARN on the PFN changing without the
         * SPTE being converted to a hugepage (leaf) or being zapped.  Shadow
         * pages are kernel allocations and should never be migrated.
         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">was_present</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">was_last</span> <span class="o">&amp;&amp;</span>
            <span class="p">(</span><span class="n">is_leaf</span> <span class="o">||</span> <span class="o">!</span><span class="n">is_present</span> <span class="o">||</span> <span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">pfn_changed</span><span class="p">)))</span> <span class="p">{</span>
                <span class="n">WARN_ON</span><span class="p">(</span><span class="n">private_spte</span> <span class="o">!=</span>
                        <span class="n">is_private_sptep</span><span class="p">(</span><span class="n">spte_to_child_pt</span><span class="p">(</span><span class="n">old_spte</span><span class="p">,</span> <span class="n">level</span><span class="p">)));</span>
                <span class="n">handle_removed_pt</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">spte_to_child_pt</span><span class="p">(</span><span class="n">old_spte</span><span class="p">,</span> <span class="n">level</span><span class="p">),</span>
                                  <span class="n">private_spte</span><span class="p">,</span> <span class="n">shared</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="cm">/*
         * Special handling for the private mapping.  We are either
         * setting up new mapping at middle level page table, or leaf,
         * or tearing down existing mapping.
         *
         * This is after handling lower page table by above
         * handle_remove_tdp_mmu_page().  S-EPT requires to remove S-EPT tables
         * after removing childrens.
         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">private_spte</span> <span class="o">&amp;&amp;</span>
            <span class="cm">/* Ignore change of software only bits. e.g. host_writable */</span>
            <span class="p">(</span><span class="n">was_leaf</span> <span class="o">!=</span> <span class="n">is_leaf</span> <span class="o">||</span> <span class="n">was_present</span> <span class="o">!=</span> <span class="n">is_present</span> <span class="o">||</span> <span class="n">pfn_changed</span> <span class="o">||</span>
             <span class="n">was_private_zapped</span> <span class="o">!=</span> <span class="n">is_private_zapped</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">change</span><span class="p">.</span><span class="n">sept_page</span> <span class="o">=</span> <span class="n">tdx_get_sept_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">change</span><span class="p">);</span>
                <span class="n">WARN_ON</span><span class="p">(</span><span class="n">was_private_zapped</span> <span class="o">&amp;&amp;</span> <span class="n">is_private_zapped</span><span class="p">);</span>
                <span class="cm">/*
                 * When write lock is held, leaf pte should be zapping or
                 * prohibiting.  Not directly was_present=1 -&gt; zero EPT entry.
                 */</span>
                <span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">shared</span> <span class="o">&amp;&amp;</span> <span class="n">is_leaf</span> <span class="o">&amp;&amp;</span>
                        <span class="o">!</span><span class="n">is_private_zapped</span><span class="p">);</span>
                <span class="n">static_call</span><span class="p">(</span><span class="n">kvm_x86_handle_changed_private_spte</span><span class="p">)(</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">change</span><span class="p">);</span>
        <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<blockquote>
  <p>Allocate protected page table for private page table, and add hooks to
operate on protected page table.  This patch adds allocation/free of
protected page tables and hooks.  When calling hooks to update SPTE entry,
freeze the entry, call hooks and unfreeze the entry to allow concurrent
updates on page tables.  Which is the advantage of TDP MMU.  As
kvm_gfn_shared_mask() returns false always, those hooks aren’t called yet
with this patch.</p>

  <p>When the faulting GPA is private, the KVM fault is called private.  When
resolving private KVM fault, allocate protected page table and call hooks
to operate on protected page table. On the change of the private PTE entry,
invoke kvm_x86_ops hook in __handle_changed_spte() to propagate the change
to protected page table. The following depicts the relationship.</p>

  <p>For protected page table, hooks are called to update protected page table
in addition to direct access to the private SPTE. For the zapping case, it
works to freeze the SPTE. It can call hooks in addition to TLB shootdown.
For populating the private SPTE entry, there can be a race condition
without further protection</p>

  <p>vcpu 1: populating 2M private SPTE
 vcpu 2: populating 4K private SPTE
 vcpu 2: TDX SEAMCALL to update 4K protected SPTE =&gt; error
 vcpu 1: TDX SEAMCALL to update 2M protected SPTE</p>

  <p>To avoid the race, the frozen SPTE is utilized.  Instead of atomic update
of the private entry, freeze the entry, call the hook that update protected
SPTE, set the entry to the final value.</p>

  <p>Support 4K page only at this stage.  2M page support can be done in future
patches.</p>
</blockquote>

<h2 id="hooks-for-tdx-private-page-update-__handle_changed_spte"><span class="me-2">Hooks for TDX private page update (__handle_changed_spte)</span><a href="#hooks-for-tdx-private-page-update-__handle_changed_spte" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<h3 id="kvm_x86_handle_private_zapped_spte"><span class="me-2">kvm_x86_handle_private_zapped_spte</span><a href="#kvm_x86_handle_private_zapped_spte" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<blockquote>
  <p>The existing KVM TDP MMU code uses atomic update of SPTE.  On populating
the EPT entry, atomically set the entry.  However, it requires TLB
shootdown to zap SPTE.  To address it, the entry is frozen with the special
SPTE value that clears the present bit. After the TLB shootdown, the entry
is set to the eventual value (unfreeze).</p>
</blockquote>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre>        <span class="k">if</span> <span class="p">(</span><span class="n">was_private_zapped</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">change</span><span class="p">.</span><span class="n">sept_page</span> <span class="o">=</span> <span class="n">tdx_get_sept_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">change</span><span class="p">);</span>
                <span class="n">WARN_ON</span><span class="p">(</span><span class="n">is_private_zapped</span><span class="p">);</span>
                <span class="n">static_call</span><span class="p">(</span><span class="n">kvm_x86_handle_private_zapped_spte</span><span class="p">)(</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">change</span><span class="p">);</span>
                <span class="cm">/* Temporarily blocked private SPTE can only be leaf. */</span>
                <span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">is_last_spte</span><span class="p">(</span><span class="n">old_spte</span><span class="p">,</span> <span class="n">level</span><span class="p">));</span>
                <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>For shadow page (sp) covering private memories, each spte (kvm_mmu_page) has
private_sp memory field to point to page address used as S-EPT page by the TDX
module. Note that the spte is mirror of the S-EPT in the KVM module side. To 
let TDX module know which S-EPT page should be modified based on VMM decisions, 
it should passes the S-EPT page address to proper SEAMCALL.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">tdx_get_sept_page</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="nc">kvm_spte_change</span> <span class="o">*</span><span class="n">change</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">change</span><span class="o">-&gt;</span><span class="k">new</span><span class="p">.</span><span class="n">is_present</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">change</span><span class="o">-&gt;</span><span class="k">new</span><span class="p">.</span><span class="n">is_last</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">struct</span> <span class="nc">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="n">to_shadow_page</span><span class="p">(</span><span class="n">pfn_to_hpa</span><span class="p">(</span><span class="n">change</span><span class="o">-&gt;</span><span class="k">new</span><span class="p">.</span><span class="n">pfn</span><span class="p">));</span>
                <span class="kt">void</span> <span class="o">*</span><span class="n">sept_page</span> <span class="o">=</span> <span class="n">kvm_mmu_private_sp</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>
        
                <span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">sept_page</span><span class="p">);</span>
                <span class="n">WARN_ON</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">.</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">!=</span> <span class="n">change</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">);</span>
                <span class="n">WARN_ON</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">gfn</span> <span class="o">!=</span> <span class="n">change</span><span class="o">-&gt;</span><span class="n">gfn</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">kvm_mmu_private_sp</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>
        <span class="p">}</span>
        
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>               
</pre></td></tr></tbody></table></code></div></div>

<p>The tdx_get_sept_page function retrieves this S-EPT physical address extracted 
from the new sp. Because the change only contains the pfn of the new spt, it 
first retrieves the sp (kvm_mmu_page) through the to_shadow_page function. Note
that the kvm_mmu_page bound to one spt can be retrieved from the private field 
of the spt physical address (please refer to [[]]). The kvm_mmu_private_sp 
simply returns private_sp field of the sp. The returned private_sp field is 
stored in sept_page field of the change variable. The private_sp field of sp 
points to the memory allocated at the time of sp initialization, prepared for 
S-EPT uses. Now the change variable can provide all required information to 
update the S-EPT in the TDX module side. Only the left operation is invoking 
proper SEAMCALL with provided parameters so that VMM makes the TDX module change
the S-EPT on behalf of the VMM.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">void</span> <span class="nf">tdx_handle_private_zapped_spte</span><span class="p">(</span>
        <span class="k">struct</span> <span class="nc">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="nc">kvm_spte_change</span> <span class="o">*</span><span class="n">change</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="nc">kvm_tdx</span> <span class="o">*</span><span class="n">kvm_tdx</span> <span class="o">=</span> <span class="n">to_kvm_tdx</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>

        <span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">is_td</span><span class="p">(</span><span class="n">kvm</span><span class="p">));</span>
        <span class="n">WARN_ON</span><span class="p">(</span><span class="n">change</span><span class="o">-&gt;</span><span class="n">old</span><span class="p">.</span><span class="n">is_present</span><span class="p">);</span>
        <span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">change</span><span class="o">-&gt;</span><span class="n">old</span><span class="p">.</span><span class="n">is_private_zapped</span><span class="p">);</span>
        <span class="n">WARN_ON</span><span class="p">(</span><span class="n">change</span><span class="o">-&gt;</span><span class="k">new</span><span class="p">.</span><span class="n">is_private_zapped</span><span class="p">);</span>

        <span class="cm">/*
         * Handle special case of old_spte being temporarily blocked private
         * SPTE.  There are two cases: 1) Need to restore the original mapping
         * (unblock) when guest accesses the private page; 2) Need to truly
         * zap the SPTE because of zapping aliasing in fault handler, or when
         * VM is being destroyed.
         *
         * Do this before handling "!was_present &amp;&amp; !is_present" case below,
         * because blocked private SPTE is also non-present.
         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">change</span><span class="o">-&gt;</span><span class="k">new</span><span class="p">.</span><span class="n">is_present</span><span class="p">)</span> <span class="p">{</span>
                <span class="cm">/* map_gpa holds write lock. */</span>
                <span class="n">lockdep_assert_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">change</span><span class="o">-&gt;</span><span class="n">old</span><span class="p">.</span><span class="n">pfn</span> <span class="o">==</span> <span class="n">change</span><span class="o">-&gt;</span><span class="k">new</span><span class="p">.</span><span class="n">pfn</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">tdx_sept_unzap_private_spte</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">change</span><span class="o">-&gt;</span><span class="n">gfn</span><span class="p">,</span> <span class="n">change</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">);</span>
                <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">change</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">&gt;</span> <span class="n">PG_LEVEL_4K</span> <span class="o">&amp;&amp;</span>
                           <span class="n">change</span><span class="o">-&gt;</span><span class="n">old</span><span class="p">.</span><span class="n">is_last</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">change</span><span class="o">-&gt;</span><span class="k">new</span><span class="p">.</span><span class="n">is_last</span><span class="p">)</span> <span class="p">{</span>
                        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

                        <span class="cm">/* This large SPTE is blocked already. */</span>
                        <span class="n">tdx_sept_split_private_spte</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">change</span><span class="o">-&gt;</span><span class="n">gfn</span><span class="p">,</span> <span class="n">change</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">,</span> <span class="n">change</span><span class="o">-&gt;</span><span class="n">sept_page</span><span class="p">);</span>
                        <span class="cm">/* Block on newly splited SPTEs as parent SPTE as blocked. */</span>
                        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PT64_ENT_PER_PAGE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                                <span class="n">tdx_sept_zap_private_spte</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">change</span><span class="o">-&gt;</span><span class="n">gfn</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">change</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
                        <span class="n">tdx_sept_tlb_remote_flush</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="cm">/*
                         * Because page is pined (refer to
                         * kvm_faultin_pfn_private()), page migration shouldn't
                         * be triggered for private page.  kvm private memory
                         * slot case should also prevent page migration.
                         */</span>
                        <span class="n">pr_err</span><span class="p">(</span><span class="s">"gfn 0x%llx level %d "</span>
                               <span class="s">"old_pfn 0x%llx was_present %d was_last %d was_priavte_zapped %d "</span>
                               <span class="s">"new_pfn 0x%llx is_present %d is_last %d is_priavte_zapped %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                               <span class="n">change</span><span class="o">-&gt;</span><span class="n">gfn</span><span class="p">,</span> <span class="n">change</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">,</span>
                               <span class="n">change</span><span class="o">-&gt;</span><span class="n">old</span><span class="p">.</span><span class="n">pfn</span><span class="p">,</span> <span class="n">change</span><span class="o">-&gt;</span><span class="n">old</span><span class="p">.</span><span class="n">is_present</span><span class="p">,</span>
                               <span class="n">change</span><span class="o">-&gt;</span><span class="n">old</span><span class="p">.</span><span class="n">is_last</span><span class="p">,</span> <span class="n">change</span><span class="o">-&gt;</span><span class="n">old</span><span class="p">.</span><span class="n">is_private_zapped</span><span class="p">,</span>
                               <span class="n">change</span><span class="o">-&gt;</span><span class="k">new</span><span class="p">.</span><span class="n">pfn</span><span class="p">,</span> <span class="n">change</span><span class="o">-&gt;</span><span class="k">new</span><span class="p">.</span><span class="n">is_present</span><span class="p">,</span>
                               <span class="n">change</span><span class="o">-&gt;</span><span class="k">new</span><span class="p">.</span><span class="n">is_last</span><span class="p">,</span> <span class="n">change</span><span class="o">-&gt;</span><span class="k">new</span><span class="p">.</span><span class="n">is_private_zapped</span><span class="p">);</span>
                        <span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
                <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">lockdep_assert_held_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">is_hkid_assigned</span><span class="p">(</span><span class="n">kvm_tdx</span><span class="p">))</span>
                        <span class="n">tdx_track</span><span class="p">(</span><span class="n">kvm_tdx</span><span class="p">);</span>
                <span class="n">tdx_sept_drop_private_spte</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">change</span><span class="o">-&gt;</span><span class="n">gfn</span><span class="p">,</span> <span class="n">change</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">,</span>
                                        <span class="n">change</span><span class="o">-&gt;</span><span class="n">old</span><span class="p">.</span><span class="n">pfn</span><span class="p">);</span>
        <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<h3 id="kvm_x86_handle_changed_private_spte"><span class="me-2">kvm_x86_handle_changed_private_spte</span><a href="#kvm_x86_handle_changed_private_spte" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="rouge-code"><pre>        <span class="cm">/*
         * Special handling for the private mapping.  We are either
         * setting up new mapping at middle level page table, or leaf,
         * or tearing down existing mapping.
         *
         * This is after handling lower page table by above
         * handle_remove_tdp_mmu_page().  S-EPT requires to remove S-EPT tables
         * after removing childrens.
         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">private_spte</span> <span class="o">&amp;&amp;</span>
            <span class="cm">/* Ignore change of software only bits. e.g. host_writable */</span>
            <span class="p">(</span><span class="n">was_leaf</span> <span class="o">!=</span> <span class="n">is_leaf</span> <span class="o">||</span> <span class="n">was_present</span> <span class="o">!=</span> <span class="n">is_present</span> <span class="o">||</span> <span class="n">pfn_changed</span> <span class="o">||</span>
             <span class="n">was_private_zapped</span> <span class="o">!=</span> <span class="n">is_private_zapped</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">change</span><span class="p">.</span><span class="n">sept_page</span> <span class="o">=</span> <span class="n">tdx_get_sept_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">change</span><span class="p">);</span>
                <span class="n">WARN_ON</span><span class="p">(</span><span class="n">was_private_zapped</span> <span class="o">&amp;&amp;</span> <span class="n">is_private_zapped</span><span class="p">);</span>
                <span class="cm">/*
                 * When write lock is held, leaf pte should be zapping or
                 * prohibiting.  Not directly was_present=1 -&gt; zero EPT entry.
                 */</span>
                <span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">shared</span> <span class="o">&amp;&amp;</span> <span class="n">is_leaf</span> <span class="o">&amp;&amp;</span>
                        <span class="o">!</span><span class="n">is_private_zapped</span><span class="p">);</span>
                <span class="n">static_call</span><span class="p">(</span><span class="n">kvm_x86_handle_changed_private_spte</span><span class="p">)(</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">change</span><span class="p">);</span>
        <span class="p">}</span>

</pre></td></tr></tbody></table></code></div></div>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">void</span> <span class="nf">tdx_handle_changed_private_spte</span><span class="p">(</span>
        <span class="k">struct</span> <span class="nc">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="nc">kvm_spte_change</span> <span class="o">*</span><span class="n">change</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">bool</span> <span class="n">was_leaf</span> <span class="o">=</span> <span class="n">change</span><span class="o">-&gt;</span><span class="n">old</span><span class="p">.</span><span class="n">is_present</span> <span class="o">&amp;&amp;</span> <span class="n">change</span><span class="o">-&gt;</span><span class="n">old</span><span class="p">.</span><span class="n">is_last</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">is_leaf</span> <span class="o">=</span> <span class="n">change</span><span class="o">-&gt;</span><span class="k">new</span><span class="p">.</span><span class="n">is_present</span> <span class="o">&amp;&amp;</span> <span class="n">change</span><span class="o">-&gt;</span><span class="k">new</span><span class="p">.</span><span class="n">is_last</span><span class="p">;</span>
        <span class="k">struct</span> <span class="nc">kvm_tdx</span> <span class="o">*</span><span class="n">kvm_tdx</span> <span class="o">=</span> <span class="n">to_kvm_tdx</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
        <span class="k">const</span> <span class="n">gfn_t</span> <span class="n">gfn</span> <span class="o">=</span> <span class="n">change</span><span class="o">-&gt;</span><span class="n">gfn</span><span class="p">;</span>
        <span class="k">const</span> <span class="k">enum</span> <span class="n">pg_level</span> <span class="n">level</span> <span class="o">=</span> <span class="n">change</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">;</span>

        <span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">is_td</span><span class="p">(</span><span class="n">kvm</span><span class="p">));</span>
        <span class="n">lockdep_assert_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">change</span><span class="o">-&gt;</span><span class="k">new</span><span class="p">.</span><span class="n">is_present</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">&gt;</span> <span class="n">PG_LEVEL_4K</span> <span class="o">&amp;&amp;</span> <span class="n">was_leaf</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_leaf</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">tdx_sept_zap_private_spte</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">level</span><span class="p">);</span>
                        <span class="n">tdx_sept_tlb_remote_flush</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
                        <span class="n">tdx_sept_split_private_spte</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">change</span><span class="o">-&gt;</span><span class="n">sept_page</span><span class="p">);</span>
                <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">is_leaf</span><span class="p">)</span>
                        <span class="n">tdx_sept_set_private_spte</span><span class="p">(</span>
                                <span class="n">kvm</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">change</span><span class="o">-&gt;</span><span class="k">new</span><span class="p">.</span><span class="n">pfn</span><span class="p">);</span>
                <span class="k">else</span> <span class="p">{</span>
                        <span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">change</span><span class="o">-&gt;</span><span class="n">sept_page</span><span class="p">);</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">tdx_sept_link_private_sp</span><span class="p">(</span>
                                    <span class="n">kvm</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">change</span><span class="o">-&gt;</span><span class="n">sept_page</span><span class="p">))</span>
                                <span class="cm">/* failed to update Secure-EPT.  */</span>
                                <span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
                <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">was_leaf</span><span class="p">)</span> <span class="p">{</span>
                <span class="cm">/* non-present -&gt; non-present doesn't make sense. */</span>
                <span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">change</span><span class="o">-&gt;</span><span class="n">old</span><span class="p">.</span><span class="n">is_present</span><span class="p">);</span>

                <span class="cm">/*
                 * Zap private leaf SPTE.  Zapping private table is done
                 * below in handle_removed_tdp_mmu_page().
                 */</span>
                <span class="n">tdx_sept_zap_private_spte</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">level</span><span class="p">);</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">change</span><span class="o">-&gt;</span><span class="k">new</span><span class="p">.</span><span class="n">is_private_zapped</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">lockdep_assert_held_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>
                        <span class="n">WARN_ON</span><span class="p">(</span><span class="n">change</span><span class="o">-&gt;</span><span class="k">new</span><span class="p">.</span><span class="n">pfn</span> <span class="o">!=</span> <span class="n">change</span><span class="o">-&gt;</span><span class="n">old</span><span class="p">.</span><span class="n">pfn</span><span class="p">);</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="n">lockdep_assert_held_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>
                        <span class="n">WARN_ON</span><span class="p">(</span><span class="n">change</span><span class="o">-&gt;</span><span class="k">new</span><span class="p">.</span><span class="n">pfn</span><span class="p">);</span>

                        <span class="cm">/*
                         * TDX requires TLB tracking before dropping private
                         * page.
                         */</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">is_hkid_assigned</span><span class="p">(</span><span class="n">kvm_tdx</span><span class="p">))</span>
                                <span class="n">tdx_track</span><span class="p">(</span><span class="n">kvm_tdx</span><span class="p">);</span>

                        <span class="n">tdx_sept_drop_private_spte</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">change</span><span class="o">-&gt;</span><span class="n">old</span><span class="p">.</span><span class="n">pfn</span><span class="p">);</span>
                <span class="p">}</span>
        <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<h3 id="kvm_x86_free_private_sp-handle_removed_pt"><span class="me-2">kvm_x86_free_private_sp (handle_removed_pt)</span><a href="#kvm_x86_free_private_sp-handle_removed_pt" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre>        <span class="cm">/*
         * Recursively handle child PTs if the change removed a subtree from
         * the paging structure.  Note the WARN on the PFN changing without the
         * SPTE being converted to a hugepage (leaf) or being zapped.  Shadow
         * pages are kernel allocations and should never be migrated.
         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">was_present</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">was_last</span> <span class="o">&amp;&amp;</span>
            <span class="p">(</span><span class="n">is_leaf</span> <span class="o">||</span> <span class="o">!</span><span class="n">is_present</span> <span class="o">||</span> <span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">pfn_changed</span><span class="p">)))</span> <span class="p">{</span>
                <span class="n">WARN_ON</span><span class="p">(</span><span class="n">private_spte</span> <span class="o">!=</span>
                        <span class="n">is_private_sptep</span><span class="p">(</span><span class="n">spte_to_child_pt</span><span class="p">(</span><span class="n">old_spte</span><span class="p">,</span> <span class="n">level</span><span class="p">)));</span>
                <span class="n">handle_removed_pt</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">spte_to_child_pt</span><span class="p">(</span><span class="n">old_spte</span><span class="p">,</span> <span class="n">level</span><span class="p">),</span>
                                  <span class="n">private_spte</span><span class="p">,</span> <span class="n">shared</span><span class="p">);</span>
        <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>This condition indicates that</p>
<ol>
  <li>previous page is split into the leaf page</li>
  <li>previous page is removed</li>
  <li>physical page for the spte is changed</li>
</ol>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_removed_pt</span><span class="p">(</span><span class="k">struct</span> <span class="nc">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">tdp_ptep_t</span> <span class="n">pt</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">is_private</span><span class="p">,</span>
                              <span class="kt">bool</span> <span class="n">shared</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="nc">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="n">sptep_to_sp</span><span class="p">(</span><span class="n">rcu_dereference</span><span class="p">(</span><span class="n">pt</span><span class="p">));</span>
        <span class="kt">int</span> <span class="n">level</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">.</span><span class="n">level</span><span class="p">;</span>
        <span class="n">gfn_t</span> <span class="n">base_gfn</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">gfn</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

        <span class="n">trace_kvm_mmu_prepare_zap_page</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>

        <span class="n">tdp_mmu_unlink_sp</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">shared</span><span class="p">);</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PT64_ENT_PER_PAGE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">tdp_ptep_t</span> <span class="n">sptep</span> <span class="o">=</span> <span class="n">pt</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
                <span class="n">gfn_t</span> <span class="n">gfn</span> <span class="o">=</span> <span class="n">base_gfn</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">KVM_PAGES_PER_HPAGE</span><span class="p">(</span><span class="n">level</span><span class="p">);</span>
                <span class="n">u64</span> <span class="n">old_spte</span><span class="p">;</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">shared</span><span class="p">)</span> <span class="p">{</span>
                        <span class="cm">/*
                         * Set the SPTE to a nonpresent value that other
                         * threads will not overwrite. If the SPTE was
                         * already marked as removed then another thread
                         * handling a page fault could overwrite it, so
                         * set the SPTE until it is set from some other
                         * value to the removed SPTE value.
                         */</span>
                        <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
                                <span class="n">old_spte</span> <span class="o">=</span> <span class="n">kvm_tdp_mmu_write_spte_atomic</span><span class="p">(</span><span class="n">sptep</span><span class="p">,</span> <span class="n">REMOVED_SPTE</span><span class="p">);</span>
                                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_removed_spte</span><span class="p">(</span><span class="n">old_spte</span><span class="p">))</span>
                                        <span class="k">break</span><span class="p">;</span>
                                <span class="n">cpu_relax</span><span class="p">();</span>
                        <span class="p">}</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="cm">/*
                         * If the SPTE is not MMU-present, there is no backing
                         * page associated with the SPTE and so no side effects
                         * that need to be recorded, and exclusive ownership of
                         * mmu_lock ensures the SPTE can't be made present.
                         * Note, zapping MMIO SPTEs is also unnecessary as they
                         * are guarded by the memslots generation, not by being
                         * unreachable.
                         */</span>
                        <span class="n">old_spte</span> <span class="o">=</span> <span class="n">kvm_tdp_mmu_read_spte</span><span class="p">(</span><span class="n">sptep</span><span class="p">);</span>
                        <span class="cm">/*
                         * It comes here when zapping all pages when destroying
                         * vm.  It means TLB shootdown optimization doesn't make
                         * sense.  Zap private_zapped entry.
                         */</span>
                        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_shadow_present_pte</span><span class="p">(</span><span class="n">old_spte</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
                            <span class="o">!</span><span class="n">is_private_zapped_spte</span><span class="p">(</span><span class="n">old_spte</span><span class="p">))</span>
                                <span class="k">continue</span><span class="p">;</span>

                        <span class="cm">/*
                         * Use the common helper instead of a raw WRITE_ONCE as
                         * the SPTE needs to be updated atomically if it can be
                         * modified by a different vCPU outside of mmu_lock.
                         * Even though the parent SPTE is !PRESENT, the TLB
                         * hasn't yet been flushed, and both Intel and AMD
                         * document that A/D assists can use upper-level PxE
                         * entries that are cached in the TLB, i.e. the CPU can
                         * still access the page and mark it dirty.
                         *
                         * No retry is needed in the atomic update path as the
                         * sole concern is dropping a Dirty bit, i.e. no other
                         * task can zap/remove the SPTE as mmu_lock is held for
                         * write.  Marking the SPTE as a removed SPTE is not
                         * strictly necessary for the same reason, but using
                         * the remove SPTE value keeps the shared/exclusive
                         * paths consistent and allows the handle_changed_spte()
                         * call below to hardcode the new value to REMOVED_SPTE.
                         *
                         * Note, even though dropping a Dirty bit is the only
                         * scenario where a non-atomic update could result in a
                         * functional bug, simply checking the Dirty bit isn't
                         * sufficient as a fast page fault could read the upper
                         * level SPTE before it is zapped, and then make this
                         * target SPTE writable, resume the guest, and set the
                         * Dirty bit between reading the SPTE above and writing
                         * it here.
                         */</span>
                        <span class="n">old_spte</span> <span class="o">=</span> <span class="n">kvm_tdp_mmu_write_spte</span><span class="p">(</span><span class="n">sptep</span><span class="p">,</span> <span class="n">old_spte</span><span class="p">,</span>
                                                          <span class="n">REMOVED_SPTE</span><span class="p">,</span> <span class="n">level</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="n">handle_changed_spte</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">kvm_mmu_page_as_id</span><span class="p">(</span><span class="n">sp</span><span class="p">),</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">is_private</span><span class="p">,</span>
                                    <span class="n">old_spte</span><span class="p">,</span> <span class="n">REMOVED_SPTE</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span>
                                    <span class="n">shared</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">WARN_ON</span><span class="p">(</span><span class="n">is_private</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">kvm_mmu_private_sp</span><span class="p">(</span><span class="n">sp</span><span class="p">));</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">is_private</span> <span class="o">&amp;&amp;</span> <span class="n">WARN_ON</span><span class="p">(</span><span class="n">static_call</span><span class="p">(</span><span class="n">kvm_x86_free_private_sp</span><span class="p">)(</span>
                                          <span class="n">kvm</span><span class="p">,</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">gfn</span><span class="p">,</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">.</span><span class="n">level</span><span class="p">,</span>
                                          <span class="n">kvm_mmu_private_sp</span><span class="p">(</span><span class="n">sp</span><span class="p">))))</span> <span class="p">{</span>
                <span class="cm">/*
                 * Failed to unlink Secure EPT page and there is nothing to do
                 * further.  Intentionally leak the page to prevent the kernel
                 * from accessing the encrypted page.
                 */</span>
                <span class="n">kvm_mmu_init_private_sp</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">call_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">rcu_head</span><span class="p">,</span> <span class="n">tdp_mmu_free_sp_rcu_callback</span><span class="p">);</span>
<span class="p">}</span>


</pre></td></tr></tbody></table></code></div></div>


  </div>

  <div class="post-tail-wrapper text-muted">
    <!-- categories -->
    
      <div class="post-meta mb-3">
        <i class="far fa-folder-open fa-fw me-1"></i>
        
          <a href="/categories/confidential-computing/">Confidential Computing</a>,
          <a href="/categories/intel-tdx/">Intel TDX</a>,
          <a href="/categories/kvm/">KVM</a>
      </div>
    

    <!-- tags -->
    

    <div
      class="
        post-tail-bottom
        d-flex justify-content-between align-items-center mt-5 pb-2
      "
    >
      <div class="license-wrapper">
        
          

          This post is licensed under 
        <a href="https://creativecommons.org/licenses/by/4.0/">
          CC BY 4.0
        </a>
         by the author.
        
      </div>

      <!-- Post sharing snippet -->

<div class="share-wrapper d-flex align-items-center">
  <span class="share-label text-muted">Share</span>
  <span class="share-icons">
    
    
    

    

      

      <a
        href="https://twitter.com/intent/tweet?text=KVM%20page-fault%20handling%20for%20TDX%20-%20Ruach&url=https%3A%2F%2Fruach.github.io%2Fposts%2FPAGEFAULT-HANDLING-KVM-TDX%2F"
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="Twitter"
        target="_blank"
        rel="noopener"
        aria-label="Twitter"
      >
        <i class="fa-fw fa-brands fa-square-x-twitter"></i>
      </a>
    

      

      <a
        href="https://www.facebook.com/sharer/sharer.php?title=KVM%20page-fault%20handling%20for%20TDX%20-%20Ruach&u=https%3A%2F%2Fruach.github.io%2Fposts%2FPAGEFAULT-HANDLING-KVM-TDX%2F"
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="Facebook"
        target="_blank"
        rel="noopener"
        aria-label="Facebook"
      >
        <i class="fa-fw fab fa-facebook-square"></i>
      </a>
    

      

      <a
        href="https://t.me/share/url?url=https%3A%2F%2Fruach.github.io%2Fposts%2FPAGEFAULT-HANDLING-KVM-TDX%2F&text=KVM%20page-fault%20handling%20for%20TDX%20-%20Ruach"
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="Telegram"
        target="_blank"
        rel="noopener"
        aria-label="Telegram"
      >
        <i class="fa-fw fab fa-telegram"></i>
      </a>
    

      

      <a
        href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fruach.github.io%2Fposts%2FPAGEFAULT-HANDLING-KVM-TDX%2F"
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="Linkedin"
        target="_blank"
        rel="noopener"
        aria-label="Linkedin"
      >
        <i class="fa-fw fab fa-linkedin"></i>
      </a>
    

    <button
      id="copy-link"
      aria-label="Copy link"
      class="btn small"
      data-bs-toggle="tooltip"
      data-bs-placement="top"
      title="Copy link"
      data-title-succeed="Link copied successfully!"
    >
      <i class="fa-fw fas fa-link pe-none fs-6"></i>
    </button>
  </span>
</div>

    </div>
    <!-- .post-tail-bottom -->
  </div>
  <!-- div.post-tail-wrapper -->
</article>


            
          </main>

          <!-- panel -->
          <aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 mb-5 text-muted">
            <div class="access">
              <!-- Get the last 5 posts from lastmod list. -->















              <!-- The trending tags list -->


















            </div>

            
              
              



  <section id="toc-wrapper" class="ps-0 pe-4">
    <h2 class="panel-heading ps-3 pt-2 mb-2">Contents</h2>
    <nav id="toc"></nav>
  </section>


            
          </aside>
        </div>

        <div class="row">
          <!-- tail -->
          <div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4">
            
              
              <!-- Recommend the other 3 posts according to the tags and categories of the current post. -->

<!-- The total size of related posts -->


<!-- An random integer that bigger than 0 -->


<!-- Equals to TAG_SCORE / {max_categories_hierarchy} -->














  

  

  

  

  

  

  

  
    
  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  











  <aside id="related-posts" aria-labelledby="related-label">
    <h3 class="mb-4" id="related-label">Further Reading</h3>
    <nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4">
      
        <article class="col">
          <a href="/posts/TDX-MODULE-LIFECYCLE-2/" class="post-preview card h-100">
            <div class="card-body">
              <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->




<time
  
  data-ts="1679544000"
  data-df="ll"
  
>
  Mar 23, 2023
</time>

              <h4 class="pt-0 my-2">TDX Module Life Cycle Part 2</h4>
              <div class="text-muted">
                <p>
                  





                  In previous posts, I discussed the initialization of the TDX module using 
TDH_SYS_INIT SEAMCALL. As depicted in the image below, several additional 
configuration steps are necessary for the TDX m...
                </p>
              </div>
            </div>
          </a>
        </article>
      
        <article class="col">
          <a href="/posts/SPT-AND-MEMSLOT/" class="post-preview card h-100">
            <div class="card-body">
              <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->




<time
  
  data-ts="1681099200"
  data-df="ll"
  
>
  Apr 10, 2023
</time>

              <h4 class="pt-0 my-2">Shadow Page Table (SPT) and MEMSLOT</h4>
              <div class="text-muted">
                <p>
                  





                  Shadow Page Table (SPT)
Before the introduction of TDP, shadow paging has been utilized to translate
GPA to HPA. The KVM module utilize a unified concept to abstract the 
structure managing this tr...
                </p>
              </div>
            </div>
          </a>
        </article>
      
        <article class="col">
          <a href="/posts/TDX-SEAMLDR/" class="post-preview card h-100">
            <div class="card-body">
              <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->




<time
  
  data-ts="1678424400"
  data-df="ll"
  
>
  Mar 10, 2023
</time>

              <h4 class="pt-0 my-2">TDX Module Life Cycle Part 0 (SEAMLDR)</h4>
              <div class="text-muted">
                <p>
                  





                  New CPU privileges and software layer for Intel TDX
Secure Arbitration Mode (SEAM) is an extension of Virtual Machines Extension 
(VMX). It introduces new VMX root mode called SEAM root. The primar...
                </p>
              </div>
            </div>
          </a>
        </article>
      
    </nav>
  </aside>
  <!-- #related-posts -->


            
              
              <!-- Navigation buttons at the bottom of the post. -->

<nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation">
  
  

  
    <a
      href="/posts/PAGEFAULT-HANDLING-KVM/"
      class="btn btn-outline-primary"
      aria-label="Older"
    >
      <p>KVM page-fault handling</p>
    </a>
  

  
    <a
      href="/posts/tdx-intro/"
      class="btn btn-outline-primary"
      aria-label="Newer"
    >
      <p>TDX Architecture Introduction</p>
    </a>
  
</nav>

            
              
              <!--  The comments switcher -->

  
  <!-- The Disqus lazy loading. -->

<div id="disqus_thread">
  <p class="text-center text-muted small">Comments powered by <a href="https://disqus.com/">Disqus</a>.</p>
</div>

<script type="text/javascript">
  var disqus_config = function () {
    this.page.url = 'https://ruach.github.io/posts/PAGEFAULT-HANDLING-KVM-TDX/';
    this.page.identifier = '/posts/PAGEFAULT-HANDLING-KVM-TDX/';
  };

  /* Lazy loading */
  var disqus_observer = new IntersectionObserver(
    function (entries) {
      if (entries[0].isIntersecting) {
        (function () {
          var d = document,
            s = d.createElement('script');
          s.src = 'https://ruach.disqus.com/embed.js';
          s.setAttribute('data-timestamp', +new Date());
          (d.head || d.body).appendChild(s);
        })();

        disqus_observer.disconnect();
      }
    },
    { threshold: [0] }
  );

  disqus_observer.observe(document.querySelector('#disqus_thread'));

  /* Auto switch theme */
  function reloadDisqus() {
    if (event.source === window && event.data && event.data.direction === ModeToggle.ID) {
      /* Disqus hasn't been loaded */
      if (typeof DISQUS === 'undefined') {
        return;
      }

      if (document.readyState == 'complete') {
        DISQUS.reset({ reload: true, config: disqus_config });
      }
    }
  }

  if (document.querySelector('.mode-toggle')) {
    window.addEventListener('message', reloadDisqus);
  }
</script>



            

            <!-- The Footer -->

<footer
  aria-label="Site Info"
  class="
    d-flex flex-column justify-content-center text-muted
    flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3
  "
>
  <p>
    ©
    <time>2024</time>
    <a href="https://ruach.github.io">Jaehyuk Lee</a>.
    
      <span
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author."
      >Some rights reserved.</span>
    
  </p>

  <p>Using the <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme for <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>
  </p>
</footer>

          </div>
        </div>

        <!-- The Search results -->

<div id="search-result-wrapper" class="d-flex justify-content-center unloaded">
  <div class="col-11 content">
    <div id="search-hints">
      <!-- The trending tags list -->


















    </div>
    <div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div>
  </div>
</div>

      </div>

      <aside aria-label="Scroll to Top">
        <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow">
          <i class="fas fa-angle-up"></i>
        </button>
      </aside>
    </div>

    <div id="mask"></div>

    
      <aside
  id="notification"
  class="toast"
  role="alert"
  aria-live="assertive"
  aria-atomic="true"
  data-bs-animation="true"
  data-bs-autohide="false"
>
  <div class="toast-header">
    <button
      type="button"
      class="btn-close ms-auto"
      data-bs-dismiss="toast"
      aria-label="Close"
    ></button>
  </div>
  <div class="toast-body text-center pt-0">
    <p class="px-2 mb-3">A new version of content is available.</p>
    <button type="button" class="btn btn-primary" aria-label="Update">
      Update
    </button>
  </div>
</aside>

    

    <!-- JavaScripts -->

    <!-- JS selector for site. -->

<!-- commons -->



<!-- layout specified -->


  

  
    <!-- image lazy-loading & popup & clipboard -->
    
  















  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  



  <script src="https://cdn.jsdelivr.net/combine/npm/jquery@3.7.1/dist/jquery.min.js,npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js,npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/magnific-popup@1.1.0/dist/jquery.magnific-popup.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.10/dayjs.min.js,npm/dayjs@1.11.10/locale/en.min.js,npm/dayjs@1.11.10/plugin/relativeTime.min.js,npm/dayjs@1.11.10/plugin/localizedFormat.min.js,npm/tocbot@4.21.2/dist/tocbot.min.js"></script>






<script defer src="/assets/js/dist/post.min.js"></script>






    

    <!--
  Jekyll Simple Search loader
  See: <https://github.com/christian-fei/Simple-Jekyll-Search>
-->





<script>
  /* Note: dependent library will be loaded in `js-selector.html` */
  SimpleJekyllSearch({
    searchInput: document.getElementById('search-input'),
    resultsContainer: document.getElementById('search-results'),
    json: '/assets/js/data/search.json',
    searchResultTemplate: '  <article class="px-1 px-sm-2 px-lg-4 px-xl-0">    <header>      <h2><a href="{url}">{title}</a></h2>      <div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1">        {categories}        {tags}      </div>    </header>    <p>{snippet}</p>  </article>',
    noResultsText: '<p class="mt-5"></p>',
    templateMiddleware: function(prop, value, template) {
      if (prop === 'categories') {
        if (value === '') {
          return `${value}`;
        } else {
          return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`;
        }
      }

      if (prop === 'tags') {
        if (value === '') {
          return `${value}`;
        } else {
          return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`;
        }
      }
    }
  });
</script>

  </body>
</html>

