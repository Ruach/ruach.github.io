<!doctype html>














<!-- `site.alt_lang` can specify a language different from the UI -->
<html lang="en" data-mode="light">
  <!-- The Head -->

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta
    name="viewport"
    content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover"
  >

  

  

  
    <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v4.3.3" />
<meta property="og:title" content="KVM page-fault handling" />
<meta property="og:locale" content="en" />
<meta name="description" content="EPT violation exit and handle The logistics of KVM’s page fault handling is like below: __vmx_handle_exit -&gt; handle_ept_violation -&gt; __vmx_handle_ept_violation -&gt; kvm_mmu_page_fault -&gt; kvm_mmu_do_page_fault -&gt; mmu.page_fault(), kvm_tdp_page_fault (when tdp is enabled) -&gt; direct_page_fault" />
<meta property="og:description" content="EPT violation exit and handle The logistics of KVM’s page fault handling is like below: __vmx_handle_exit -&gt; handle_ept_violation -&gt; __vmx_handle_ept_violation -&gt; kvm_mmu_page_fault -&gt; kvm_mmu_do_page_fault -&gt; mmu.page_fault(), kvm_tdp_page_fault (when tdp is enabled) -&gt; direct_page_fault" />
<link rel="canonical" href="https://ruach.github.io/posts/PAGEFAULT-HANDLING-KVM/" />
<meta property="og:url" content="https://ruach.github.io/posts/PAGEFAULT-HANDLING-KVM/" />
<meta property="og:site_name" content="Ruach" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-04-12T00:00:00-04:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="KVM page-fault handling" />
<meta name="twitter:site" content="@ruach_lee" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-04-12T00:00:00-04:00","datePublished":"2023-04-12T00:00:00-04:00","description":"EPT violation exit and handle The logistics of KVM’s page fault handling is like below: __vmx_handle_exit -&gt; handle_ept_violation -&gt; __vmx_handle_ept_violation -&gt; kvm_mmu_page_fault -&gt; kvm_mmu_do_page_fault -&gt; mmu.page_fault(), kvm_tdp_page_fault (when tdp is enabled) -&gt; direct_page_fault","headline":"KVM page-fault handling","mainEntityOfPage":{"@type":"WebPage","@id":"https://ruach.github.io/posts/PAGEFAULT-HANDLING-KVM/"},"url":"https://ruach.github.io/posts/PAGEFAULT-HANDLING-KVM/"}</script>
<!-- End Jekyll SEO tag -->

  

  <title>KVM page-fault handling | Ruach
  </title>

  <!--
  The Favicons for Web, Android, Microsoft, and iOS (iPhone and iPad) Apps
  Generated by: https://realfavicongenerator.net/
-->



<link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png">
<link rel="manifest" href="/assets/img/favicons/site.webmanifest">
<link rel="shortcut icon" href="/assets/img/favicons/favicon.ico">
<meta name="apple-mobile-web-app-title" content="Ruach">
<meta name="application-name" content="Ruach">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml">
<meta name="theme-color" content="#ffffff">


  
    
      <link rel="preconnect" href="https://fonts.googleapis.com" >
      <link rel="dns-prefetch" href="https://fonts.googleapis.com" >
    
      <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
      <link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin>
    
      <link rel="preconnect" href="https://fonts.googleapis.com" >
      <link rel="dns-prefetch" href="https://fonts.googleapis.com" >
    
      <link rel="preconnect" href="https://cdn.jsdelivr.net" >
      <link rel="dns-prefetch" href="https://cdn.jsdelivr.net" >
    

    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap">
  

  <!-- GA -->
  

  <!-- Bootstrap -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css">

  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.2/css/all.min.css">

  <link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css">

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.21.2/dist/tocbot.min.css">
  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css">
  

  
    <!-- Manific Popup -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css">
  

  <!-- JavaScript -->

  

  <!-- A placeholder to allow defining custom metadata -->

</head>


  <body>
    <!-- The Side Bar -->

<aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end">
  <header class="profile-wrapper">
    <a href="/" id="avatar" class="rounded-circle">
      
        
        <img src="/assets/img/jaehyuk.png" width="112" height="112" alt="avatar" onerror="this.style.display='none'">
      
    </a>

    <h1 class="site-title">
      <a href="/">Ruach</a>
    </h1>
    <p class="site-subtitle fst-italic mb-0">Jaehyuk Lee</p>
  </header>
  <!-- .profile-wrapper -->

  <nav class="flex-column flex-grow-1 w-100 ps-0">
    <ul class="nav">
      <!-- home -->
      <li class="nav-item">
        <a href="/" class="nav-link">
          <i class="fa-fw fas fa-home"></i>
          <span>HOME</span>
        </a>
      </li>
      <!-- the real tabs -->
      
        <li class="nav-item">
          <a href="/categories/" class="nav-link">
            <i class="fa-fw fas fa-stream"></i>
            

            <span>CATEGORIES</span>
          </a>
        </li>
        <!-- .nav-item -->
      
        <li class="nav-item">
          <a href="/archives/" class="nav-link">
            <i class="fa-fw fas fa-archive"></i>
            

            <span>ARCHIVES</span>
          </a>
        </li>
        <!-- .nav-item -->
      
        <li class="nav-item">
          <a href="/about/" class="nav-link">
            <i class="fa-fw fas fa-info-circle"></i>
            

            <span>ABOUT</span>
          </a>
        </li>
        <!-- .nav-item -->
      
    </ul>
  </nav>

  <div class="sidebar-bottom d-flex flex-wrap  align-items-center w-100">
    

    
      

      
        <a
          href="javascript:location.href = 'mailto:' + ['jaehyuk','gatech.edu'].join('@')"
          aria-label="email"
          

          

          

          
        >
          <i class="fas fa-envelope"></i>
        </a>
      
    
      

      
        <a
          href="https://www.linkedin.com/in/jaehyuk-lee-29b33b121/"
          aria-label="linkedin"
          

          
            target="_blank"
            
          

          

          
            rel="noopener noreferrer"
          
        >
          <i class="fab fa-linkedin"></i>
        </a>
      
    
      

      
        <a
          href="https://github.com/Ruach"
          aria-label="github"
          

          
            target="_blank"
            
          

          

          
            rel="noopener noreferrer"
          
        >
          <i class="fab fa-github"></i>
        </a>
      
    
      

      
        <a
          href="https://stackoverflow.com/users/4460514/ruach?tab=profile"
          aria-label="stack-overflow"
          

          
            target="_blank"
            
          

          

          
            rel="noopener noreferrer"
          
        >
          <i class="fab fa-stack-overflow"></i>
        </a>
      
    
  </div>
  <!-- .sidebar-bottom -->
</aside>
<!-- #sidebar -->


    <div id="main-wrapper" class="d-flex justify-content-center">
      <div class="container d-flex flex-column px-xxl-5">
        <!-- The Top Bar -->

<header id="topbar-wrapper" aria-label="Top Bar">
  <div
    id="topbar"
    class="d-flex align-items-center justify-content-between px-lg-3 h-100"
  >
    <nav id="breadcrumb" aria-label="Breadcrumb">
      

      
        
          
            <span>
              <a href="/">
                Home
              </a>
            </span>

          
        
          
        
          
            
              <span>KVM page-fault handling</span>
            

          
        
      
    </nav>
    <!-- endof #breadcrumb -->

    <button type="button" id="sidebar-trigger" class="btn btn-link">
      <i class="fas fa-bars fa-fw"></i>
    </button>

    <div id="topbar-title">
      Post
    </div>

    <button type="button" id="search-trigger" class="btn btn-link">
      <i class="fas fa-search fa-fw"></i>
    </button>

    <search class="align-items-center ms-3 ms-lg-0">
      <i class="fas fa-search fa-fw"></i>
      <input
        class="form-control"
        id="search-input"
        type="search"
        aria-label="search"
        autocomplete="off"
        placeholder="Search..."
      >
    </search>
    <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button>
  </div>
</header>


        <div class="row flex-grow-1">
          <main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4">
            
              <!-- Refactor the HTML structure -->



<!--
  In order to allow a wide table to scroll horizontally,
  we suround the markdown table with `<div class="table-wrapper">` and `</div>`
-->



<!--
  Fixed kramdown code highlight rendering:
  https://github.com/penibelst/jekyll-compress-html/issues/101
  https://github.com/penibelst/jekyll-compress-html/issues/71#issuecomment-188144901
-->



<!-- Change the icon of checkbox -->



<!-- Handle images -->





<!-- Add header for code snippets -->



<!-- Create heading anchors -->





  
  

  
    
    

    
      
        
        
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    

    
  

  
  

  
    
    

    
      
        
        
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    

    
  

  
  

  

  
  

  




<!-- return -->




<article class="px-1">
  <header>
    <h1 data-toc-skip>KVM page-fault handling</h1>

    <div class="post-meta text-muted">
      <!-- published date -->
      <span>
        Posted
        <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->




<time
  
  data-ts="1681272000"
  data-df="ll"
  
    data-bs-toggle="tooltip" data-bs-placement="bottom"
  
>
  Apr 12, 2023
</time>

      </span>

      <!-- lastmod date -->
      

      

      <div class="d-flex justify-content-between">
        <!-- author(s) -->
        <span>
          

          By

          <em>
            
              <a href="https://ruach.github.io">Jaehyuk Lee</a>
            
          </em>
        </span>

        <!-- read time -->
        <!-- Calculate the post's reading time, and display the word count in tooltip -->



<!-- words per minute -->










<!-- return element -->
<span
  class="readtime"
  data-bs-toggle="tooltip"
  data-bs-placement="bottom"
  title="7503 words"
>
  <em>41 min</em> read</span>

      </div>
      <!-- .d-flex -->
    </div>
    <!-- .post-meta -->
  </header>

  <div class="content">
    <h1 id="ept-violation-exit-and-handle">EPT violation exit and handle</h1>
<p>The logistics of KVM’s page fault handling is like below: 
__vmx_handle_exit -&gt; handle_ept_violation -&gt; __vmx_handle_ept_violation -&gt;
kvm_mmu_page_fault -&gt; kvm_mmu_do_page_fault -&gt; mmu.page_fault(), 
kvm_tdp_page_fault (when tdp is enabled) -&gt; direct_page_fault</p>

<h2 id="ept-violation-exit-reason-interpretation"><span class="me-2">EPT violation exit reason interpretation</span><a href="#ept-violation-exit-reason-interpretation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__vmx_handle_ept_violation</span><span class="p">(</span><span class="k">struct</span> <span class="nc">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gpa_t</span> <span class="n">gpa</span><span class="p">,</span>
                                             <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">exit_qualification</span><span class="p">,</span>
                                             <span class="kt">int</span> <span class="n">err_page_level</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">u64</span> <span class="n">error_code</span><span class="p">;</span>
        
        <span class="cm">/* Is it a read fault? */</span>
        <span class="n">error_code</span> <span class="o">=</span> <span class="p">(</span><span class="n">exit_qualification</span> <span class="o">&amp;</span> <span class="n">EPT_VIOLATION_ACC_READ</span><span class="p">)</span>
                     <span class="o">?</span> <span class="n">PFERR_USER_MASK</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
        <span class="cm">/* Is it a write fault? */</span>
        <span class="n">error_code</span> <span class="o">|=</span> <span class="p">(</span><span class="n">exit_qualification</span> <span class="o">&amp;</span> <span class="n">EPT_VIOLATION_ACC_WRITE</span><span class="p">)</span>
                      <span class="o">?</span> <span class="n">PFERR_WRITE_MASK</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
        <span class="cm">/* Is it a fetch fault? */</span>
        <span class="n">error_code</span> <span class="o">|=</span> <span class="p">(</span><span class="n">exit_qualification</span> <span class="o">&amp;</span> <span class="n">EPT_VIOLATION_ACC_INSTR</span><span class="p">)</span>
                      <span class="o">?</span> <span class="n">PFERR_FETCH_MASK</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
        <span class="cm">/* ept page table entry is present? */</span>
        <span class="n">error_code</span> <span class="o">|=</span> <span class="p">(</span><span class="n">exit_qualification</span> <span class="o">&amp;</span>
                       <span class="p">(</span><span class="n">EPT_VIOLATION_READABLE</span> <span class="o">|</span> <span class="n">EPT_VIOLATION_WRITABLE</span> <span class="o">|</span>
                        <span class="n">EPT_VIOLATION_EXECUTABLE</span><span class="p">))</span>
                      <span class="o">?</span> <span class="n">PFERR_PRESENT_MASK</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
        
        <span class="n">error_code</span> <span class="o">|=</span> <span class="p">(</span><span class="n">exit_qualification</span> <span class="o">&amp;</span> <span class="n">EPT_VIOLATION_GVA_TRANSLATED</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">?</span>
               <span class="n">PFERR_GUEST_FINAL_MASK</span> <span class="o">:</span> <span class="n">PFERR_GUEST_PAGE_MASK</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">err_page_level</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">error_code</span> <span class="o">|=</span> <span class="p">(</span><span class="n">err_page_level</span> <span class="o">&lt;&lt;</span> <span class="n">PFERR_LEVEL_START_BIT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PFERR_LEVEL_MASK</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">kvm_mmu_page_fault</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gpa</span><span class="p">,</span> <span class="n">error_code</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>exit_qualification can be retrieved from the VMCS structure. Based on the exit
reasons, different bits are set, so they should be interpreted by the VMM side 
to handle EPT violation properly.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">int</span> <span class="nf">direct_page_fault</span><span class="p">(</span><span class="k">struct</span> <span class="nc">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gpa_t</span> <span class="n">gpa</span><span class="p">,</span> <span class="n">u32</span> <span class="n">error_code</span><span class="p">,</span>
                             <span class="kt">bool</span> <span class="n">prefault</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_level</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">is_tdp</span><span class="p">,</span>
                             <span class="n">kvm_pfn_t</span> <span class="o">*</span><span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">bool</span> <span class="n">is_tdp_mmu_fault</span> <span class="o">=</span> <span class="n">is_tdp_mmu</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">);</span>
        <span class="kt">bool</span> <span class="n">write</span> <span class="o">=</span> <span class="n">error_code</span> <span class="o">&amp;</span> <span class="n">PFERR_WRITE_MASK</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">map_writable</span><span class="p">;</span>

        <span class="n">gfn_t</span> <span class="n">gfn</span> <span class="o">=</span> <span class="n">vcpu_gpa_to_gfn_unalias</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gpa</span><span class="p">);</span>
<span class="p">......</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">fast_page_fault</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gpa</span><span class="p">,</span> <span class="n">error_code</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">!=</span> <span class="n">RET_PF_INVALID</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">......</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">kvm_faultin_pfn</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">prefault</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">gpa</span><span class="p">,</span> <span class="n">pfn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hva</span><span class="p">,</span>
                         <span class="n">write</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">map_writable</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">))</span>
<span class="p">......</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">is_tdp_mmu_fault</span><span class="p">)</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">kvm_tdp_mmu_map</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gpa</span><span class="p">,</span> <span class="n">error_code</span><span class="p">,</span> <span class="n">map_writable</span><span class="p">,</span> <span class="n">max_level</span><span class="p">,</span>
                                    <span class="o">*</span><span class="n">pfn</span><span class="p">,</span> <span class="n">prefault</span><span class="p">);</span>
        <span class="k">else</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">__direct_map</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gpa</span><span class="p">,</span> <span class="n">error_code</span><span class="p">,</span> <span class="n">map_writable</span><span class="p">,</span> <span class="n">max_level</span><span class="p">,</span>
                                 <span class="o">*</span><span class="n">pfn</span><span class="p">,</span> <span class="n">prefault</span><span class="p">,</span> <span class="n">is_tdp</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>direct_page_fault consists of two main parts: 1. Translate faultin gpa -&gt; hva 
-&gt; hpa 2. Resolve page fault. gpa is the address that cause EPT fault, and 
error_code describe the reason of EPT fault such as read/write fault. pfn param
is the address that caused the VM EXIT, due to EPT violation. The max_level is 
vcpu-&gt;kvm-&gt;arch.tdp_max_page_level which means the maximum level of SPT.</p>

<h1 id="faultin-gpa--memslot---hva---host-page-table---hpa">Faultin GPA -&gt;(<strong><em>memslot</em></strong>) -&gt; HVA -&gt; (<strong><em>host page table</em></strong>) -&gt; HPA</h1>
<p>When EPT fault happens, only information we have is faultin GPT address. 
Remember that the GPT is not 1:1 mapped to host virtual address. Therefore, we 
need to translate GPT to HVA and walk host page table to get HPA mapped to HVA.
After retrieving the HPA, we can set the EPT table so that the faulting GPA can 
be translated into HPA that we find as a result of host page table walk.</p>

<h2 id="gpa---hva"><span class="me-2">GPA -&gt; HVA</span><a href="#gpa---hva" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>
<h3 id="memslot-translates-gpa---hva"><span class="me-2">Memslot translates GPA -&gt; HVA</span><a href="#memslot-translates-gpa---hva" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<p>The <strong>kvm_faultin_pfn</strong> function resolves GPA -&gt; HVA mapping and pin the HVA.
To translate GPA to HVA, the memslot instance associated with the faultin GPA
is required. To retrieve associated memslot, <strong>kvm_faultin_pfn</strong> function 
invokes kvm_vcpu_gfn_to_memslot.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">kvm_memory_slot</span> <span class="o">*</span><span class="nf">kvm_vcpu_gfn_to_memslot</span><span class="p">(</span><span class="k">struct</span> <span class="nc">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="nc">kvm_memslots</span> <span class="o">*</span><span class="n">slots</span> <span class="o">=</span> <span class="n">kvm_vcpu_memslots</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
        <span class="k">struct</span> <span class="nc">kvm_memory_slot</span> <span class="o">*</span><span class="n">slot</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">slot_index</span><span class="p">;</span>

        <span class="n">slot</span> <span class="o">=</span> <span class="n">try_get_memslot</span><span class="p">(</span><span class="n">slots</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">last_used_slot</span><span class="p">,</span> <span class="n">gfn</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">slot</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">slot</span><span class="p">;</span>

        <span class="cm">/*
         * Fall back to searching all memslots. We purposely use
         * search_memslots() instead of __gfn_to_memslot() to avoid
         * thrashing the VM-wide last_used_index in kvm_memslots.
         */</span>
        <span class="n">slot</span> <span class="o">=</span> <span class="n">search_memslots</span><span class="p">(</span><span class="n">slots</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">slot_index</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">slot</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">last_used_slot</span> <span class="o">=</span> <span class="n">slot_index</span><span class="p">;</span>
                <span class="k">return</span> <span class="n">slot</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>kvm_vcpu_gfn_to_memslot retrieves the memslot associated with the faulted gfn.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">bool</span> <span class="nf">kvm_faultin_pfn</span><span class="p">(</span><span class="k">struct</span> <span class="nc">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">prefault</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">,</span>
                         <span class="n">gpa_t</span> <span class="n">cr2_or_gpa</span><span class="p">,</span> <span class="n">kvm_pfn_t</span> <span class="o">*</span><span class="n">pfn</span><span class="p">,</span> <span class="n">hva_t</span> <span class="o">*</span><span class="n">hva</span><span class="p">,</span>
                         <span class="kt">bool</span> <span class="n">write</span><span class="p">,</span> <span class="kt">bool</span> <span class="o">*</span><span class="n">writable</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="nc">kvm_memory_slot</span> <span class="o">*</span><span class="n">slot</span> <span class="o">=</span> <span class="n">kvm_vcpu_gfn_to_memslot</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gfn</span><span class="p">);</span>
<span class="p">......</span>
        <span class="n">async</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="o">*</span><span class="n">pfn</span> <span class="o">=</span> <span class="n">__gfn_to_pfn_memslot</span><span class="p">(</span><span class="n">slot</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">async</span><span class="p">,</span>
                                    <span class="n">write</span><span class="p">,</span> <span class="n">writable</span><span class="p">,</span> <span class="n">hva</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">async</span><span class="p">)</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="cm">/* *pfn has correct page already */</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prefault</span> <span class="o">&amp;&amp;</span> <span class="n">kvm_can_do_async_pf</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">trace_kvm_try_async_get_page</span><span class="p">(</span><span class="n">cr2_or_gpa</span><span class="p">,</span> <span class="n">gfn</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">kvm_find_async_pf_gfn</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gfn</span><span class="p">))</span> <span class="p">{</span>
                        <span class="n">trace_kvm_async_pf_doublefault</span><span class="p">(</span><span class="n">cr2_or_gpa</span><span class="p">,</span> <span class="n">gfn</span><span class="p">);</span>
                        <span class="n">kvm_make_request</span><span class="p">(</span><span class="n">KVM_REQ_APF_HALT</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>
                        <span class="k">goto</span> <span class="n">out_retry</span><span class="p">;</span>
                <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">kvm_arch_setup_async_pf</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">cr2_or_gpa</span><span class="p">,</span> <span class="n">gfn</span><span class="p">))</span>
                        <span class="k">goto</span> <span class="n">out_retry</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="o">*</span><span class="n">pfn</span> <span class="o">=</span> <span class="n">__gfn_to_pfn_memslot</span><span class="p">(</span><span class="n">slot</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
                                    <span class="n">write</span><span class="p">,</span> <span class="n">writable</span><span class="p">,</span> <span class="n">hva</span><span class="p">);</span>

<span class="n">out_retry</span><span class="o">:</span>
        <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="n">RET_PF_RETRY</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>After retrieving the memslot, it invokes __gfn_to_pfn_memslot function to 
translate the gfn -&gt; hva -&gt; pfn.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="rouge-code"><pre><span class="n">kvm_pfn_t</span> <span class="nf">__gfn_to_pfn_memslot</span><span class="p">(</span><span class="k">struct</span> <span class="nc">kvm_memory_slot</span> <span class="o">*</span><span class="n">slot</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">,</span>
                               <span class="kt">bool</span> <span class="n">atomic</span><span class="p">,</span> <span class="kt">bool</span> <span class="o">*</span><span class="n">async</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">write_fault</span><span class="p">,</span>
                               <span class="kt">bool</span> <span class="o">*</span><span class="n">writable</span><span class="p">,</span> <span class="n">hva_t</span> <span class="o">*</span><span class="n">hva</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">__gfn_to_hva_many</span><span class="p">(</span><span class="n">slot</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">write_fault</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">hva</span><span class="p">)</span>
                <span class="o">*</span><span class="n">hva</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">==</span> <span class="n">KVM_HVA_ERR_RO_BAD</span><span class="p">)</span> <span class="p">{</span> 
                <span class="k">if</span> <span class="p">(</span><span class="n">writable</span><span class="p">)</span>      
                        <span class="o">*</span><span class="n">writable</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                <span class="k">return</span> <span class="n">KVM_PFN_ERR_RO_FAULT</span><span class="p">;</span>
        <span class="p">}</span>                   

        <span class="k">if</span> <span class="p">(</span><span class="n">kvm_is_error_hva</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">writable</span><span class="p">)</span>
                        <span class="o">*</span><span class="n">writable</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                <span class="k">return</span> <span class="n">KVM_PFN_NOSLOT</span><span class="p">;</span>
        <span class="p">}</span>
                                      
        <span class="cm">/* Do not map writable pfn in the readonly memslot. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">writable</span> <span class="o">&amp;&amp;</span> <span class="n">memslot_is_readonly</span><span class="p">(</span><span class="n">slot</span><span class="p">))</span> <span class="p">{</span>
                <span class="o">*</span><span class="n">writable</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                <span class="n">writable</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span> 

        <span class="k">return</span> <span class="nf">hva_to_pfn</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">atomic</span><span class="p">,</span> <span class="n">async</span><span class="p">,</span> <span class="n">write_fault</span><span class="p">,</span>
                          <span class="n">writable</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>Using memslot, __gfn_to_hva_many function returns the hva address mapped to 
faulted gfn. Also, hva_to_pfn function pins the hva and returns the pfn mapped 
to the hva. Note that the HVA belongs to user process, so it should be pinned 
by the kernel not to allow kernel switch HPA mapped to HVA.</p>

<h2 id="hva---hpa"><span class="me-2">HVA -&gt; HPA</span><a href="#hva---hpa" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>
<h3 id="walking-host-page-table-to-pin-hva-and-locate-hpa"><span class="me-2">Walking host page table to pin HVA and locate HPA</span><a href="#walking-host-page-table-to-pin-hva-and-locate-hpa" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<p>Currently, we have information about faultin GPA and its HVA. We need HPA
mapped to the HVA.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="n">kvm_pfn_t</span> <span class="nf">hva_to_pfn</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">atomic</span><span class="p">,</span> <span class="kt">bool</span> <span class="o">*</span><span class="n">async</span><span class="p">,</span>
                        <span class="kt">bool</span> <span class="n">write_fault</span><span class="p">,</span> <span class="kt">bool</span> <span class="o">*</span><span class="n">writable</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="nc">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>
        <span class="n">kvm_pfn_t</span> <span class="n">pfn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">npages</span><span class="p">,</span> <span class="n">r</span><span class="p">;</span>

        <span class="cm">/* we can do it either atomically or asynchronously, not both */</span>
        <span class="n">BUG_ON</span><span class="p">(</span><span class="n">atomic</span> <span class="o">&amp;&amp;</span> <span class="n">async</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">hva_to_pfn_fast</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">write_fault</span><span class="p">,</span> <span class="n">writable</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pfn</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">pfn</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">atomic</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">KVM_PFN_ERR_FAULT</span><span class="p">;</span>

        <span class="n">npages</span> <span class="o">=</span> <span class="n">hva_to_pfn_slow</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">async</span><span class="p">,</span> <span class="n">write_fault</span><span class="p">,</span> <span class="n">writable</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pfn</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">npages</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">pfn</span><span class="p">;</span>

        <span class="n">mmap_read_lock</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">npages</span> <span class="o">==</span> <span class="o">-</span><span class="n">EHWPOISON</span> <span class="o">||</span>
              <span class="p">(</span><span class="o">!</span><span class="n">async</span> <span class="o">&amp;&amp;</span> <span class="n">check_user_page_hwpoison</span><span class="p">(</span><span class="n">addr</span><span class="p">)))</span> <span class="p">{</span>
                <span class="n">pfn</span> <span class="o">=</span> <span class="n">KVM_PFN_ERR_HWPOISON</span><span class="p">;</span>
                <span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
        <span class="p">}</span>

<span class="n">retry</span><span class="o">:</span>
        <span class="n">vma</span> <span class="o">=</span> <span class="n">vma_lookup</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">vma</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
                <span class="n">pfn</span> <span class="o">=</span> <span class="n">KVM_PFN_ERR_FAULT</span><span class="p">;</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VM_IO</span> <span class="o">|</span> <span class="n">VM_PFNMAP</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">hva_to_pfn_remapped</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">async</span><span class="p">,</span> <span class="n">write_fault</span><span class="p">,</span> <span class="n">writable</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pfn</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
                        <span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
                        <span class="n">pfn</span> <span class="o">=</span> <span class="n">KVM_PFN_ERR_FAULT</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">async</span> <span class="o">&amp;&amp;</span> <span class="n">vma_is_valid</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">write_fault</span><span class="p">))</span>
                        <span class="o">*</span><span class="n">async</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="n">pfn</span> <span class="o">=</span> <span class="n">KVM_PFN_ERR_FAULT</span><span class="p">;</span>
        <span class="p">}</span>
<span class="n">exit</span><span class="o">:</span>
        <span class="n">mmap_read_unlock</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">pfn</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">The</span> <span class="n">addr</span> <span class="n">parameter</span> <span class="n">is</span> <span class="n">host</span> <span class="k">virtual</span> <span class="n">address</span> <span class="n">which</span> <span class="n">maps</span> <span class="n">memory</span> <span class="n">to</span> <span class="n">the</span> <span class="n">guest</span><span class="p">.</span> <span class="n">The</span> 
<span class="n">async</span> <span class="n">indicates</span> <span class="n">whether</span> <span class="n">it</span> <span class="n">needs</span> <span class="n">to</span> <span class="n">wait</span> <span class="n">IO</span> <span class="n">complete</span> <span class="k">if</span> <span class="n">the</span> <span class="n">host</span> <span class="n">page</span> <span class="n">is</span> <span class="n">not</span> 
<span class="n">in</span> <span class="n">the</span> <span class="n">memory</span><span class="p">.</span> <span class="n">The</span> <span class="n">write_fault</span> <span class="n">means</span> <span class="n">whether</span> <span class="n">it</span> <span class="k">requires</span> <span class="n">a</span> <span class="n">writable</span> <span class="n">host</span> <span class="n">page</span><span class="p">.</span>
<span class="n">The</span> <span class="n">writable</span> <span class="n">means</span> <span class="n">whether</span> <span class="n">it</span> <span class="n">allows</span> <span class="n">to</span> <span class="n">map</span> <span class="n">a</span> <span class="n">writable</span> <span class="n">host</span> <span class="n">page</span> <span class="n">when</span> <span class="n">the</span> 
<span class="n">write_fault</span> <span class="n">is</span> <span class="n">set</span> <span class="n">as</span> <span class="nb">false</span><span class="p">.</span> 

<span class="err">```</span><span class="n">cpp</span>
<span class="k">static</span> <span class="kt">bool</span> <span class="nf">hva_to_pfn_fast</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">write_fault</span><span class="p">,</span>
                            <span class="kt">bool</span> <span class="o">*</span><span class="n">writable</span><span class="p">,</span> <span class="n">kvm_pfn_t</span> <span class="o">*</span><span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="nc">page</span> <span class="o">*</span><span class="n">page</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

        <span class="cm">/*
         * Fast pin a writable pfn only if it is a write fault request
         * or the caller allows to map a writable pfn for a read fault
         * request.
         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">write_fault</span> <span class="o">||</span> <span class="n">writable</span><span class="p">))</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">get_user_page_fast_only</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">FOLL_WRITE</span><span class="p">,</span> <span class="n">page</span><span class="p">))</span> <span class="p">{</span>
                <span class="o">*</span><span class="n">pfn</span> <span class="o">=</span> <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">page</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">writable</span><span class="p">)</span>
                        <span class="o">*</span><span class="n">writable</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">int</span> <span class="nf">hva_to_pfn_slow</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">bool</span> <span class="o">*</span><span class="n">async</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">write_fault</span><span class="p">,</span>
                           <span class="kt">bool</span> <span class="o">*</span><span class="n">writable</span><span class="p">,</span> <span class="n">kvm_pfn_t</span> <span class="o">*</span><span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">FOLL_HWPOISON</span><span class="p">;</span>
        <span class="k">struct</span> <span class="nc">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">npages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="n">might_sleep</span><span class="p">();</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">writable</span><span class="p">)</span>
                <span class="o">*</span><span class="n">writable</span> <span class="o">=</span> <span class="n">write_fault</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">write_fault</span><span class="p">)</span>
                <span class="n">flags</span> <span class="o">|=</span> <span class="n">FOLL_WRITE</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">async</span><span class="p">)</span>
                <span class="n">flags</span> <span class="o">|=</span> <span class="n">FOLL_NOWAIT</span><span class="p">;</span>

        <span class="n">npages</span> <span class="o">=</span> <span class="n">get_user_pages_unlocked</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">npages</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">npages</span><span class="p">;</span>

        <span class="cm">/* map read fault as writable if possible */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">write_fault</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">writable</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">struct</span> <span class="nc">page</span> <span class="o">*</span><span class="n">wpage</span><span class="p">;</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">get_user_page_fast_only</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">FOLL_WRITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wpage</span><span class="p">))</span> <span class="p">{</span>
                        <span class="o">*</span><span class="n">writable</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                        <span class="n">put_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
                        <span class="n">page</span> <span class="o">=</span> <span class="n">wpage</span><span class="p">;</span>
                <span class="p">}</span>
        <span class="p">}</span>
        <span class="o">*</span><span class="n">pfn</span> <span class="o">=</span> <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">npages</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>There are two variations of hva_to_pfn: hva_to_pfn_fast and hva_to_pfn_slow. The
fast version is invoked first and the slow version will be invoked only when the 
fast fails to translate hva to pfn, mostly due to absence of non-leaf page table
entries during the translation. The only noticeable difference is the assumption,
the fast version assumes that all non-leaf entries required for translations are 
already built, but the slow version does not. The slow version generates
non-leaf page table entries if they are not present.</p>

<p>The core functionality of two functions, translating hva to pfn, is implemented
by the get_user_page_fast_only function. When the pfn associated with faulting 
GPA is found, page_to_pfn function will return the physical frame of the last 
level page frame.</p>

<h3 id="pinning-gpa-through-get_user_pages"><span class="me-2">Pinning GPA through get_user_pages</span><a href="#pinning-gpa-through-get_user_pages" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<blockquote>
  <p>get_user_pages() is a way to map user-space memory into the kernel’s address 
space; it will ensure that all of the requested pages have been faulted into 
RAM (and locked there) and provide a kernel mapping that, in turn, can be used
for direct access by the kernel or (more often) to set up zero-copy I/O 
operations. There are a number of variants of get_user_pages(), most notably 
get_user_pages_fast(), which trades off some flexibility for the ability to 
avoid acquiring the contended mmap_sem lock before doing its work. The ability
to avoid copying data between kernel and user space makes get_user_pages() the 
key to high-performance I/O. get_user_page_fast_only attempts to pin user page
by walking the page tables without taking a lock.</p>
</blockquote>

<p>hva_to_pfn_* functions actually invokes <strong>get_user_page_fast_only</strong> function 
to **pin the HVA. Remember that the HVA belongs to address space of guest 
process hosting KVM. The logistics of hva_to_pfn_ is like below:</p>

<blockquote>
  <p>hva_to_pfn -&gt; get_user_page_fast_only -&gt; internal_get_user_pages_fast -&gt; 
lockless_pages_from_mm -&gt; gup_pgd_range</p>
</blockquote>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">get_user_page_fast_only</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
                        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gup_flags</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">page</span> <span class="o">**</span><span class="n">pagep</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">return</span> <span class="n">get_user_pages_fast_only</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">gup_flags</span><span class="p">,</span> <span class="n">pagep</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">get_user_pages_fast_only</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr_pages</span><span class="p">,</span>
                             <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gup_flags</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">nr_pinned</span><span class="p">;</span>
        <span class="cm">/*
         * Internally (within mm/gup.c), gup fast variants must set FOLL_GET,
         * because gup fast is always a "pin with a +1 page refcount" request.
         *
         * FOLL_FAST_ONLY is required in order to match the API description of
         * this routine: no fall back to regular ("slow") GUP.
         */</span>
        <span class="n">gup_flags</span> <span class="o">|=</span> <span class="n">FOLL_GET</span> <span class="o">|</span> <span class="n">FOLL_FAST_ONLY</span><span class="p">;</span>

        <span class="n">nr_pinned</span> <span class="o">=</span> <span class="n">internal_get_user_pages_fast</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="n">gup_flags</span><span class="p">,</span>
                                                 <span class="n">pages</span><span class="p">);</span>

        <span class="cm">/*
         * As specified in the API description above, this routine is not
         * allowed to return negative values. However, the common core
         * routine internal_get_user_pages_fast() *can* return -errno.
         * Therefore, correct for that here:
         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nr_pinned</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">nr_pinned</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">nr_pinned</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">int</span> <span class="nf">internal_get_user_pages_fast</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span>
                                        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_pages</span><span class="p">,</span>
                                        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gup_flags</span><span class="p">,</span>
                                        <span class="k">struct</span> <span class="nc">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_pinned</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">gup_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">FOLL_WRITE</span> <span class="o">|</span> <span class="n">FOLL_LONGTERM</span> <span class="o">|</span>
                                       <span class="n">FOLL_FORCE</span> <span class="o">|</span> <span class="n">FOLL_PIN</span> <span class="o">|</span> <span class="n">FOLL_GET</span> <span class="o">|</span>
                                       <span class="n">FOLL_FAST_ONLY</span><span class="p">)))</span>
                <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">gup_flags</span> <span class="o">&amp;</span> <span class="n">FOLL_PIN</span><span class="p">)</span>
                <span class="n">mm_set_has_pinned_flag</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">gup_flags</span> <span class="o">&amp;</span> <span class="n">FOLL_FAST_ONLY</span><span class="p">))</span>
                <span class="n">might_lock_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_lock</span><span class="p">);</span>

        <span class="n">start</span> <span class="o">=</span> <span class="n">untagged_addr</span><span class="p">(</span><span class="n">start</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">;</span>
        <span class="n">len</span> <span class="o">=</span> <span class="n">nr_pages</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">check_add_overflow</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end</span><span class="p">))</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">((</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">start</span><span class="p">,</span> <span class="n">len</span><span class="p">)))</span>
                <span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

        <span class="n">nr_pinned</span> <span class="o">=</span> <span class="n">lockless_pages_from_mm</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">gup_flags</span><span class="p">,</span> <span class="n">pages</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nr_pinned</span> <span class="o">==</span> <span class="n">nr_pages</span> <span class="o">||</span> <span class="n">gup_flags</span> <span class="o">&amp;</span> <span class="n">FOLL_FAST_ONLY</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">nr_pinned</span><span class="p">;</span>

        <span class="cm">/* Slow path: try to get the remaining pages with get_user_pages */</span>
        <span class="n">start</span> <span class="o">+=</span> <span class="n">nr_pinned</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
        <span class="n">pages</span> <span class="o">+=</span> <span class="n">nr_pinned</span><span class="p">;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">__gup_longterm_unlocked</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">nr_pages</span> <span class="o">-</span> <span class="n">nr_pinned</span><span class="p">,</span> <span class="n">gup_flags</span><span class="p">,</span>
                                      <span class="n">pages</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="cm">/*
                 * The caller has to unpin the pages we already pinned so
                 * returning -errno is not an option
                 */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">nr_pinned</span><span class="p">)</span>
                        <span class="k">return</span> <span class="n">nr_pinned</span><span class="p">;</span>
                <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">ret</span> <span class="o">+</span> <span class="n">nr_pinned</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">lockless_pages_from_mm</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span>
                                            <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span>
                                            <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gup_flags</span><span class="p">,</span>
                                            <span class="k">struct</span> <span class="nc">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">nr_pinned</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="n">seq</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ENABLED</span><span class="p">(</span><span class="n">CONFIG_HAVE_FAST_GUP</span><span class="p">)</span> <span class="o">||</span>
            <span class="o">!</span><span class="n">gup_fast_permitted</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">gup_flags</span> <span class="o">&amp;</span> <span class="n">FOLL_PIN</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">seq</span> <span class="o">=</span> <span class="n">raw_read_seqcount</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">write_protect_seq</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">seq</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
        <span class="n">gup_pgd_range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">gup_flags</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr_pinned</span><span class="p">);</span>
        <span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">gup_flags</span> <span class="o">&amp;</span> <span class="n">FOLL_PIN</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">read_seqcount_retry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">write_protect_seq</span><span class="p">,</span> <span class="n">seq</span><span class="p">))</span> <span class="p">{</span>
                        <span class="n">unpin_user_pages</span><span class="p">(</span><span class="n">pages</span><span class="p">,</span> <span class="n">nr_pinned</span><span class="p">);</span>
                        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
                <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">nr_pinned</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<h3 id="software-pagetable-walking"><span class="me-2">Software pagetable walking</span><a href="#software-pagetable-walking" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<p>The <strong>gup_pgd_range</strong> does software based page table walking to locate PTE (host
physical address) mapped to the faulting GPA. If the PTE exists, it pins the PTE.
Note that it walks user process page table not the EPT. 
[[]]</p>

<blockquote>
  <p>gup_pgd_range -&gt; gup_p4d_range -&gt; gup_pud_range -&gt; gup_pmd_range -&gt;
gup_pte_range</p>
</blockquote>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">void</span> <span class="nf">gup_pgd_range</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span>
                <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">nr</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next</span><span class="p">;</span>
        <span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgdp</span><span class="p">;</span>

        <span class="n">pgdp</span> <span class="o">=</span> <span class="n">pgd_offset</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
        <span class="k">do</span> <span class="p">{</span>
                <span class="n">pgd_t</span> <span class="n">pgd</span> <span class="o">=</span> <span class="n">READ_ONCE</span><span class="p">(</span><span class="o">*</span><span class="n">pgdp</span><span class="p">);</span>

                <span class="n">next</span> <span class="o">=</span> <span class="n">pgd_addr_end</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">pgd_none</span><span class="p">(</span><span class="n">pgd</span><span class="p">))</span>
                        <span class="k">return</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pgd_huge</span><span class="p">(</span><span class="n">pgd</span><span class="p">)))</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gup_huge_pgd</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="n">pgdp</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span>
                                          <span class="n">pages</span><span class="p">,</span> <span class="n">nr</span><span class="p">))</span>
                                <span class="k">return</span><span class="p">;</span>
                <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">is_hugepd</span><span class="p">(</span><span class="n">__hugepd</span><span class="p">(</span><span class="n">pgd_val</span><span class="p">(</span><span class="n">pgd</span><span class="p">)))))</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gup_huge_pd</span><span class="p">(</span><span class="n">__hugepd</span><span class="p">(</span><span class="n">pgd_val</span><span class="p">(</span><span class="n">pgd</span><span class="p">)),</span> <span class="n">addr</span><span class="p">,</span>
                                         <span class="n">PGDIR_SHIFT</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span> <span class="n">nr</span><span class="p">))</span>
                                <span class="k">return</span><span class="p">;</span>
                <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gup_p4d_range</span><span class="p">(</span><span class="n">pgdp</span><span class="p">,</span> <span class="n">pgd</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span> <span class="n">nr</span><span class="p">))</span>
                        <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">pgdp</span><span class="o">++</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">next</span><span class="p">,</span> <span class="n">addr</span> <span class="o">!=</span> <span class="n">end</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre><span class="cp">#define pgd_offset(mm, address)         pgd_offset_pgd((mm)-&gt;pgd, (address))
</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pgd_t</span> <span class="o">*</span><span class="nf">pgd_offset_pgd</span><span class="p">(</span><span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">pgd</span> <span class="o">+</span> <span class="n">pgd_index</span><span class="p">(</span><span class="n">address</span><span class="p">));</span>
<span class="p">};</span>

<span class="cp">#define pgd_index(a)  (((a) &gt;&gt; PGDIR_SHIFT) &amp; (PTRS_PER_PGD - 1))
#define PGDIR_SHIFT             39
#define PTRS_PER_PGD            512
</span>
<span class="cp">#define PGDIR_SIZE      (_AC(1, UL) &lt;&lt; PGDIR_SHIFT)
#define PGDIR_MASK      (~(PGDIR_SIZE - 1))
</span>
<span class="cp">#define pgd_addr_end(addr, end)                                         \
({      unsigned long __boundary = ((addr) + PGDIR_SIZE) &amp; PGDIR_MASK;  \
        (__boundary - 1 &lt; (end) - 1)? __boundary: (end);                \
})
</span></pre></td></tr></tbody></table></code></div></div>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">int</span> <span class="nf">gup_p4d_range</span><span class="p">(</span><span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgdp</span><span class="p">,</span> <span class="n">pgd_t</span> <span class="n">pgd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span>
                         <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">nr</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next</span><span class="p">;</span>
        <span class="n">p4d_t</span> <span class="o">*</span><span class="n">p4dp</span><span class="p">;</span>

        <span class="n">p4dp</span> <span class="o">=</span> <span class="n">p4d_offset_lockless</span><span class="p">(</span><span class="n">pgdp</span><span class="p">,</span> <span class="n">pgd</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
        <span class="k">do</span> <span class="p">{</span>
                <span class="n">p4d_t</span> <span class="n">p4d</span> <span class="o">=</span> <span class="n">READ_ONCE</span><span class="p">(</span><span class="o">*</span><span class="n">p4dp</span><span class="p">);</span>

                <span class="n">next</span> <span class="o">=</span> <span class="n">p4d_addr_end</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">p4d_none</span><span class="p">(</span><span class="n">p4d</span><span class="p">))</span>
                        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">p4d_huge</span><span class="p">(</span><span class="n">p4d</span><span class="p">));</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">is_hugepd</span><span class="p">(</span><span class="n">__hugepd</span><span class="p">(</span><span class="n">p4d_val</span><span class="p">(</span><span class="n">p4d</span><span class="p">)))))</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gup_huge_pd</span><span class="p">(</span><span class="n">__hugepd</span><span class="p">(</span><span class="n">p4d_val</span><span class="p">(</span><span class="n">p4d</span><span class="p">)),</span> <span class="n">addr</span><span class="p">,</span>
                                         <span class="n">P4D_SHIFT</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span> <span class="n">nr</span><span class="p">))</span>
                                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
                <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gup_pud_range</span><span class="p">(</span><span class="n">p4dp</span><span class="p">,</span> <span class="n">p4d</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span> <span class="n">nr</span><span class="p">))</span>
                        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">p4dp</span><span class="o">++</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">next</span><span class="p">,</span> <span class="n">addr</span> <span class="o">!=</span> <span class="n">end</span><span class="p">);</span>

        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>When p4d_none(p4d) returns true, then it returns 0 all the way up to 
hva_to_pfn_fast and fall through the hva_to_pfn_slow function. Remember that 
hva_to_pfn_fast function works only when the all associated page table entries 
present, which are required in translating faultin gpa -&gt; hpa.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">int</span> <span class="nf">gup_pte_range</span><span class="p">(</span><span class="n">pmd_t</span> <span class="n">pmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span>
                         <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">nr</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="nc">dev_pagemap</span> <span class="o">*</span><span class="n">pgmap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">nr_start</span> <span class="o">=</span> <span class="o">*</span><span class="n">nr</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span> <span class="o">*</span><span class="n">ptem</span><span class="p">;</span>

        <span class="n">ptem</span> <span class="o">=</span> <span class="n">ptep</span> <span class="o">=</span> <span class="n">pte_offset_map</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmd</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
        <span class="k">do</span> <span class="p">{</span>
                <span class="n">pte_t</span> <span class="n">pte</span> <span class="o">=</span> <span class="n">ptep_get_lockless</span><span class="p">(</span><span class="n">ptep</span><span class="p">);</span>
                <span class="k">struct</span> <span class="nc">page</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

                <span class="cm">/*
                 * Similar to the PMD case below, NUMA hinting must take slow
                 * path using the pte_protnone check.
                 */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">pte_protnone</span><span class="p">(</span><span class="n">pte</span><span class="p">))</span>
                        <span class="k">goto</span> <span class="n">pte_unmap</span><span class="p">;</span>

                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte_access_permitted</span><span class="p">(</span><span class="n">pte</span><span class="p">,</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FOLL_WRITE</span><span class="p">))</span>
                        <span class="k">goto</span> <span class="n">pte_unmap</span><span class="p">;</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">pte_devmap</span><span class="p">(</span><span class="n">pte</span><span class="p">))</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FOLL_LONGTERM</span><span class="p">))</span>
                                <span class="k">goto</span> <span class="n">pte_unmap</span><span class="p">;</span>

                        <span class="n">pgmap</span> <span class="o">=</span> <span class="n">get_dev_pagemap</span><span class="p">(</span><span class="n">pte_pfn</span><span class="p">(</span><span class="n">pte</span><span class="p">),</span> <span class="n">pgmap</span><span class="p">);</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">pgmap</span><span class="p">))</span> <span class="p">{</span>
                                <span class="n">undo_dev_pagemap</span><span class="p">(</span><span class="n">nr</span><span class="p">,</span> <span class="n">nr_start</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">pages</span><span class="p">);</span>
                                <span class="k">goto</span> <span class="n">pte_unmap</span><span class="p">;</span>
                        <span class="p">}</span>
                <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pte_special</span><span class="p">(</span><span class="n">pte</span><span class="p">))</span>
                        <span class="k">goto</span> <span class="n">pte_unmap</span><span class="p">;</span>

                <span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">pfn_valid</span><span class="p">(</span><span class="n">pte_pfn</span><span class="p">(</span><span class="n">pte</span><span class="p">)));</span>
                <span class="n">page</span> <span class="o">=</span> <span class="n">pte_page</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>

                <span class="n">head</span> <span class="o">=</span> <span class="n">try_grab_compound_head</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">head</span><span class="p">)</span>
                        <span class="k">goto</span> <span class="n">pte_unmap</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">page_is_secretmem</span><span class="p">(</span><span class="n">page</span><span class="p">)))</span> <span class="p">{</span>
                        <span class="n">put_compound_head</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
                        <span class="k">goto</span> <span class="n">pte_unmap</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">!=</span> <span class="n">pte_val</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">)))</span> <span class="p">{</span>
                        <span class="n">put_compound_head</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
                        <span class="k">goto</span> <span class="n">pte_unmap</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="n">VM_BUG_ON_PAGE</span><span class="p">(</span><span class="n">compound_head</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">!=</span> <span class="n">head</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>

                <span class="cm">/*
                 * We need to make the page accessible if and only if we are
                 * going to access its content (the FOLL_PIN case).  Please
                 * see Documentation/core-api/pin_user_pages.rst for
                 * details.
                 */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FOLL_PIN</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">ret</span> <span class="o">=</span> <span class="n">arch_make_page_accessible</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
                                <span class="n">unpin_user_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
                                <span class="k">goto</span> <span class="n">pte_unmap</span><span class="p">;</span>
                        <span class="p">}</span>
                <span class="p">}</span>
                <span class="n">SetPageReferenced</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
                <span class="n">pages</span><span class="p">[</span><span class="o">*</span><span class="n">nr</span><span class="p">]</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
                <span class="p">(</span><span class="o">*</span><span class="n">nr</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>

        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">ptep</span><span class="o">++</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">addr</span> <span class="o">!=</span> <span class="n">end</span><span class="p">);</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="n">pte_unmap</span><span class="o">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pgmap</span><span class="p">)</span>
                <span class="n">put_dev_pagemap</span><span class="p">(</span><span class="n">pgmap</span><span class="p">);</span>
        <span class="n">pte_unmap</span><span class="p">(</span><span class="n">ptem</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>As a result of page table walking, all the pages mapped to faulting GPA will be
returned through pages parameter.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre>        <span class="k">if</span> <span class="p">(</span><span class="n">get_user_page_fast_only</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">FOLL_WRITE</span><span class="p">,</span> <span class="n">page</span><span class="p">))</span> <span class="p">{</span>                  
                <span class="o">*</span><span class="n">pfn</span> <span class="o">=</span> <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">page</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>                                    
                                                                                
                <span class="k">if</span> <span class="p">(</span><span class="n">writable</span><span class="p">)</span>                                                   
                        <span class="o">*</span><span class="n">writable</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>                                       
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>                                                    
        <span class="p">}</span>             
</pre></td></tr></tbody></table></code></div></div>

<p>Also the returned page is used to retrieve the HPA mapped to HVA and faulting 
GPA.</p>

<h1 id="resolve-page-fault-2nd-part">Resolve page fault (2nd part)</h1>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre><span class="mi">4597</span> <span class="k">static</span> <span class="kt">int</span> <span class="nf">direct_page_fault</span><span class="p">(</span><span class="k">struct</span> <span class="nc">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gpa_t</span> <span class="n">gpa</span><span class="p">,</span> <span class="n">u32</span> <span class="n">error_code</span><span class="p">,</span>
<span class="mi">4598</span>                              <span class="kt">bool</span> <span class="n">prefault</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_level</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">is_tdp</span><span class="p">,</span>
<span class="mi">4599</span>                              <span class="n">kvm_pfn_t</span> <span class="o">*</span><span class="n">pfn</span><span class="p">)</span>
<span class="mi">4600</span> <span class="p">{</span>
<span class="p">......</span>
<span class="mi">4645</span>         <span class="k">if</span> <span class="p">(</span><span class="n">is_tdp_mmu_fault</span><span class="p">)</span>
<span class="mi">4646</span>                 <span class="n">r</span> <span class="o">=</span> <span class="n">kvm_tdp_mmu_map</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gpa</span><span class="p">,</span> <span class="n">error_code</span><span class="p">,</span> <span class="n">map_writable</span><span class="p">,</span> <span class="n">max_level</span><span class="p">,</span>
<span class="mi">4647</span>                                     <span class="o">*</span><span class="n">pfn</span><span class="p">,</span> <span class="n">prefault</span><span class="p">);</span>
<span class="mi">4648</span>         <span class="k">else</span>
<span class="mi">4649</span>                 <span class="n">r</span> <span class="o">=</span> <span class="n">__direct_map</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gpa</span><span class="p">,</span> <span class="n">error_code</span><span class="p">,</span> <span class="n">map_writable</span><span class="p">,</span> <span class="n">max_level</span><span class="p">,</span>
<span class="mi">4650</span>                                  <span class="o">*</span><span class="n">pfn</span><span class="p">,</span> <span class="n">prefault</span><span class="p">,</span> <span class="n">is_tdp</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></div></div>

<p>After the kvm_faultin_pfn function is returned, the faulting GPA is translated 
into pfn as a result of software based host page table walking. The retrieved 
page frame entry, <strong>pfn</strong>, is passed to kvm_tdp_mmu_map or __direct_map based on
the platform configuration.</p>

<h2 id="setup-spt-corresponding-to-the-retrieved-gpa-hpa-mapping"><span class="me-2">Setup SPT corresponding to the retrieved GPA-&gt;HPA mapping</span><a href="#setup-spt-corresponding-to-the-retrieved-gpa-hpa-mapping" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>
<p>If the TDP is enabled, kvm_tdp_mmu_map function is invoked to handle a TDP page 
fault (NPT/EPT violation/misconfiguration) by installing page tables and SPTEs 
to translate the faulting guest physical address. Note that previously it walked
<strong>host process page table</strong> not EPT. As a result of host process page table walk,
we retrieved the GVA-&gt;HVA-&gt;HPA mapping, so EPT page table entries should be 
properly installed to resolve VMEXIT caused by EPT violation.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre></td><td class="rouge-code"><pre> <span class="mi">994</span> <span class="kt">int</span> <span class="nf">kvm_tdp_mmu_map</span><span class="p">(</span><span class="k">struct</span> <span class="nc">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gpa_t</span> <span class="n">gpa</span><span class="p">,</span> <span class="n">u32</span> <span class="n">error_code</span><span class="p">,</span>
 <span class="mi">995</span>                     <span class="kt">int</span> <span class="n">map_writable</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_level</span><span class="p">,</span> <span class="n">kvm_pfn_t</span> <span class="n">pfn</span><span class="p">,</span>
 <span class="mi">996</span>                     <span class="kt">bool</span> <span class="n">prefault</span><span class="p">)</span>
 <span class="mi">997</span> <span class="p">{</span>
 <span class="mi">998</span>         <span class="kt">bool</span> <span class="n">nx_huge_page_workaround_enabled</span> <span class="o">=</span> <span class="n">is_nx_huge_page_enabled</span><span class="p">();</span>
 <span class="mi">999</span>         <span class="kt">bool</span> <span class="n">write</span> <span class="o">=</span> <span class="n">error_code</span> <span class="o">&amp;</span> <span class="n">PFERR_WRITE_MASK</span><span class="p">;</span>
<span class="mi">1000</span>         <span class="kt">bool</span> <span class="n">exec</span> <span class="o">=</span> <span class="n">error_code</span> <span class="o">&amp;</span> <span class="n">PFERR_FETCH_MASK</span><span class="p">;</span>
<span class="mi">1001</span>         <span class="kt">bool</span> <span class="n">huge_page_disallowed</span> <span class="o">=</span> <span class="n">exec</span> <span class="o">&amp;&amp;</span> <span class="n">nx_huge_page_workaround_enabled</span><span class="p">;</span>
<span class="mi">1002</span>         <span class="k">struct</span> <span class="nc">kvm_mmu</span> <span class="o">*</span><span class="n">mmu</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">;</span>
<span class="mi">1003</span>         <span class="k">struct</span> <span class="nc">tdp_iter</span> <span class="n">iter</span><span class="p">;</span>
<span class="mi">1004</span>         <span class="k">struct</span> <span class="nc">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
<span class="mi">1005</span>         <span class="n">u64</span> <span class="o">*</span><span class="n">child_pt</span><span class="p">;</span>
<span class="mi">1006</span>         <span class="n">u64</span> <span class="n">new_spte</span><span class="p">;</span>
<span class="mi">1007</span>         <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
<span class="mi">1008</span>         <span class="n">gfn_t</span> <span class="n">gfn</span> <span class="o">=</span> <span class="n">gpa</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
<span class="mi">1009</span>         <span class="kt">int</span> <span class="n">level</span><span class="p">;</span>
<span class="mi">1010</span>         <span class="kt">int</span> <span class="n">req_level</span><span class="p">;</span>
<span class="mi">1011</span> 
<span class="mi">1012</span>         <span class="n">level</span> <span class="o">=</span> <span class="n">kvm_mmu_hugepage_adjust</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">max_level</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pfn</span><span class="p">,</span>
<span class="mi">1013</span>                                         <span class="n">huge_page_disallowed</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req_level</span><span class="p">);</span>
<span class="mi">1014</span> 
<span class="mi">1015</span>         <span class="nf">trace_kvm_mmu_spte_requested</span><span class="p">(</span><span class="n">gpa</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">pfn</span><span class="p">);</span>
<span class="mi">1016</span> 
<span class="mi">1017</span>         <span class="nf">rcu_read_lock</span><span class="p">();</span>
<span class="mi">1018</span> 
<span class="mi">1019</span>         <span class="nf">tdp_mmu_for_each_pte</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">mmu</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">gfn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="p">......</span>
<span class="mi">1071</span>         <span class="p">}</span>
<span class="mi">1072</span> 
<span class="mi">1073</span>         <span class="nf">if</span> <span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">level</span> <span class="o">!=</span> <span class="n">level</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1074</span>                 <span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="mi">1075</span>                 <span class="k">return</span> <span class="n">RET_PF_RETRY</span><span class="p">;</span>
<span class="mi">1076</span>         <span class="p">}</span>
<span class="mi">1077</span> 
<span class="mi">1078</span>         <span class="n">ret</span> <span class="o">=</span> <span class="n">tdp_mmu_map_handle_target_level</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">write</span><span class="p">,</span> <span class="n">map_writable</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iter</span><span class="p">,</span>
<span class="mi">1079</span>                                               <span class="n">pfn</span><span class="p">,</span> <span class="n">prefault</span><span class="p">);</span>
<span class="mi">1080</span>         <span class="nf">rcu_read_unlock</span><span class="p">();</span>
<span class="mi">1081</span> 
<span class="mi">1082</span>         <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="mi">1083</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<h3 id="iterating-spte-to-locate-page-frame-mapping-gfn---hfn"><span class="me-2">Iterating SPTE to locate page frame mapping GFN -&gt; HFN</span><a href="#iterating-spte-to-locate-page-frame-mapping-gfn---hfn" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p>Recall that we are working on to set up EPT entries associated with faultin 
GPA (gfn), so that MMU can smoothly walks the EPT page tables and translate 
VM’s access on the faultin accessa to the HPA. To this end, we need to walk the 
EPT page tables to locate the entries associated with faultin GPA. Note that the
mmu-&gt;root_hpa holds the root address of the SPT, realized as EPT.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre><span class="cp">#define tdp_mmu_for_each_pte(_iter, _mmu, _start, _end)         \
        for_each_tdp_pte(_iter, __va(_mmu-&gt;root_hpa),           \
                         _mmu-&gt;shadow_root_level, _start, _end)
</span>        
<span class="cp">#define for_each_tdp_pte(iter, root, root_level, start, end) \
        for_each_tdp_pte_min_level(iter, root, root_level, PG_LEVEL_4K, start, end)
</span>
<span class="cm">/*
 * Iterates over every SPTE mapping the GFN range [start, end) in a
 * preorder traversal.
 */</span>
<span class="cp">#define for_each_tdp_pte_min_level(iter, root, root_level, min_level, start, end) \
        for (tdp_iter_start(&amp;iter, root, root_level, min_level, start); \
             iter.valid &amp;&amp; iter.gfn &lt; end;                   \
             tdp_iter_next(&amp;iter))
</span></pre></td></tr></tbody></table></code></div></div>

<h3 id="initialize-the-spt-iterator"><span class="me-2">Initialize the SPT iterator</span><a href="#initialize-the-spt-iterator" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">tdp_iter</span> <span class="p">{</span>
        <span class="cm">/*
         * The iterator will traverse the paging structure towards the mapping
         * for this GFN.
         */</span>
        <span class="n">gfn_t</span> <span class="n">next_last_level_gfn</span><span class="p">;</span>
        <span class="cm">/*
         * The next_last_level_gfn at the time when the thread last
         * yielded. Only yielding when the next_last_level_gfn !=
         * yielded_gfn helps ensure forward progress.
         */</span>
        <span class="n">gfn_t</span> <span class="n">yielded_gfn</span><span class="p">;</span>
        <span class="cm">/* Pointers to the page tables traversed to reach the current SPTE */</span>
        <span class="n">tdp_ptep_t</span> <span class="n">pt_path</span><span class="p">[</span><span class="n">PT64_ROOT_MAX_LEVEL</span><span class="p">];</span>
        <span class="cm">/* A pointer to the current SPTE */</span>
        <span class="n">tdp_ptep_t</span> <span class="n">sptep</span><span class="p">;</span>
        <span class="cm">/* The lowest GFN mapped by the current SPTE */</span>
        <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">;</span>
        <span class="cm">/* The level of the root page given to the iterator */</span>
        <span class="kt">int</span> <span class="n">root_level</span><span class="p">;</span>
        <span class="cm">/* The lowest level the iterator should traverse to */</span>
        <span class="kt">int</span> <span class="n">min_level</span><span class="p">;</span>
        <span class="cm">/* The iterator's current level within the paging structure */</span>
        <span class="kt">int</span> <span class="n">level</span><span class="p">;</span>
        <span class="cm">/* The address space ID, i.e. SMM vs. regular. */</span>
        <span class="kt">int</span> <span class="n">as_id</span><span class="p">;</span> 
        <span class="cm">/* A snapshot of the value at sptep */</span>
        <span class="n">u64</span> <span class="n">old_spte</span><span class="p">;</span>
        <span class="cm">/*
         * Whether the iterator has a valid state. This will be false if the
         * iterator walks off the end of the paging structure.
         */</span>
        <span class="kt">bool</span> <span class="n">valid</span><span class="p">;</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></div></div>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre><span class="cm">/*
 * Sets a TDP iterator to walk a pre-order traversal of the paging structure
 * rooted at root_pt, starting with the walk to translate next_last_level_gfn.
 */</span>
<span class="kt">void</span> <span class="nf">tdp_iter_start</span><span class="p">(</span><span class="k">struct</span> <span class="nc">tdp_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">root_pt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">root_level</span><span class="p">,</span>
                    <span class="kt">int</span> <span class="n">min_level</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">next_last_level_gfn</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">WARN_ON</span><span class="p">(</span><span class="n">root_level</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">WARN_ON</span><span class="p">(</span><span class="n">root_level</span> <span class="o">&gt;</span> <span class="n">PT64_ROOT_MAX_LEVEL</span><span class="p">);</span>

        <span class="n">iter</span><span class="o">-&gt;</span><span class="n">next_last_level_gfn</span> <span class="o">=</span> <span class="n">next_last_level_gfn</span><span class="p">;</span>
        <span class="n">iter</span><span class="o">-&gt;</span><span class="n">root_level</span> <span class="o">=</span> <span class="n">root_level</span><span class="p">;</span>
        <span class="n">iter</span><span class="o">-&gt;</span><span class="n">min_level</span> <span class="o">=</span> <span class="n">min_level</span><span class="p">;</span>
        <span class="n">iter</span><span class="o">-&gt;</span><span class="n">pt_path</span><span class="p">[</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">root_level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">tdp_ptep_t</span><span class="p">)</span><span class="n">root_pt</span><span class="p">;</span>
        <span class="n">iter</span><span class="o">-&gt;</span><span class="n">as_id</span> <span class="o">=</span> <span class="n">kvm_mmu_page_as_id</span><span class="p">(</span><span class="n">sptep_to_sp</span><span class="p">(</span><span class="n">root_pt</span><span class="p">));</span>

        <span class="n">tdp_iter_restart</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>Note that <strong>next_last_level_gfn is the faultin gfn</strong>. And root_pt is the virtual 
address of <strong>mmu-&gt;root_hpa which is the root address of the SPT</strong>.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">tdp_iter_restart</span><span class="p">(</span><span class="k">struct</span> <span class="nc">tdp_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">iter</span><span class="o">-&gt;</span><span class="n">yielded_gfn</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">next_last_level_gfn</span><span class="p">;</span>
        <span class="n">iter</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">root_level</span><span class="p">;</span> 

        <span class="n">iter</span><span class="o">-&gt;</span><span class="n">gfn</span> <span class="o">=</span> <span class="n">round_gfn_for_level</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">next_last_level_gfn</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">);</span>
        <span class="n">tdp_iter_refresh_sptep</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
        
        <span class="n">iter</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>tdp_iter_restart return the TDP iterator to the root PT and allow it to continue 
its traversal over the paging structure from there. Note that gfn field of the
iter returns the gfn masked with table index bits of current level. It also 
retrieves the next level page table entry (sptep) based on the gfn (from faultin
addr) and previous spte (from pt_path[cur_level-1]). Note that pt_path memorizes
spte of different level that were traversed while resolving the fault. Remember
that the next page table entry of the next level is calculated by adding the 
bits extracted from the faultin addr (as an index) and the root address of the 
page table of that level.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre><span class="cp">#define PAGE_SHIFT              12
#define PAGE_SIZE               (_AC(1,UL) &lt;&lt; PAGE_SHIFT)
</span><span class="cm">/* KVM Hugepage definitions for x86 */</span>
<span class="cp">#define KVM_MAX_HUGEPAGE_LEVEL  PG_LEVEL_1G
#define KVM_NR_PAGE_SIZES       (KVM_MAX_HUGEPAGE_LEVEL - PG_LEVEL_4K + 1)
#define KVM_HPAGE_GFN_SHIFT(x)  (((x) - 1) * 9)
#define KVM_HPAGE_SHIFT(x)      (PAGE_SHIFT + KVM_HPAGE_GFN_SHIFT(x))
#define KVM_HPAGE_SIZE(x)       (1UL &lt;&lt; KVM_HPAGE_SHIFT(x))
#define KVM_HPAGE_MASK(x)       (~(KVM_HPAGE_SIZE(x) - 1))
#define KVM_PAGES_PER_HPAGE(x)  (KVM_HPAGE_SIZE(x) / PAGE_SIZE)
</span>
<span class="k">static</span> <span class="n">gfn_t</span> <span class="nf">round_gfn_for_level</span><span class="p">(</span><span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>                       
        <span class="k">return</span> <span class="n">gfn</span> <span class="o">&amp;</span> <span class="o">-</span><span class="n">KVM_PAGES_PER_HPAGE</span><span class="p">(</span><span class="n">level</span><span class="p">);</span>
<span class="p">}</span>    
</pre></td></tr></tbody></table></code></div></div>

<p>-KVM_PAGES_PER_HPAGE is equal to ~(KVM_PAGES_PER_HPAGE(level) - 1). Assuming 
that the root_level is 4 (shadow_root_level), the number will be</p>
<blockquote>
  <p>gfn &amp; ~(KVM_PAGES_PER_HPAGE(4)-1)
gfn &amp; ~((KVM_HPAGE_SIZE(4) / 2^12) -1)
gfn &amp; ~(((1UL « KVM_HPAGE_SHIFT(4)) / 2^12) -1)<br />
gfn &amp; ~(((1UL « 39) / 2^12) -1)<br />
gfn &amp; ~(2^27 -1)</p>
</blockquote>

<p>Note that the 2^39 is the start address of the PML4 in x86 architecture. Also
remember that the gfn is the page frame which is from faultin GPA » PAGE_SHIFT.
That is the reason why 2^39 is divided by 2^12. Therefore gfn &amp; ~(2^27-1) 
retrieves the all above bits starting from the start bits of the PML4. Under the
assumption of 48 bits of physical address, it extracts the bits located at 47 
(MSB) to 39(PML4).</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="rouge-code"><pre><span class="cp">#define PT64_LEVEL_BITS 9
</span>
<span class="cp">#define PT64_LEVEL_SHIFT(level) \ 
</span>                <span class="p">(</span><span class="n">PAGE_SHIFT</span> <span class="o">+</span> <span class="p">(</span><span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">PT64_LEVEL_BITS</span><span class="p">)</span>
        
<span class="cp">#define PT64_INDEX(address, level)\
        (((address) &gt;&gt; PT64_LEVEL_SHIFT(level)) &amp; ((1 &lt;&lt; PT64_LEVEL_BITS) - 1))
#define SHADOW_PT_INDEX(addr, level) PT64_INDEX(addr, level)
</span>
<span class="cm">/* Bits 9 and 10 are ignored by all non-EPT PTEs. */</span>
<span class="cp">#define DEFAULT_SPTE_HOST_WRITEABLE     BIT_ULL(9)
#define DEFAULT_SPTE_MMU_WRITEABLE      BIT_ULL(10)
</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tdp_iter_refresh_sptep</span><span class="p">(</span><span class="k">struct</span> <span class="nc">tdp_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">iter</span><span class="o">-&gt;</span><span class="n">sptep</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">pt_path</span><span class="p">[</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
                <span class="n">SHADOW_PT_INDEX</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">gfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">);</span>
        <span class="n">iter</span><span class="o">-&gt;</span><span class="n">old_spte</span> <span class="o">=</span> <span class="n">READ_ONCE</span><span class="p">(</span><span class="o">*</span><span class="n">rcu_dereference</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">sptep</span><span class="p">));</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>sptep field points to current SPTE address. Calculating its address is very 
similar to software based host page table walking, which selects specific bits 
from the GFN indicating the index of the SPT at that level. Also, the pth_path 
contains the root SPTE of different levels, so adding the two value retrieves
the next SPTE that iterator move on.</p>

<blockquote>
  <p>iter-&gt;pt_path[iter-&gt;level - 1] + SHADOW_PT_INDEX(iter-&gt;gfn « PAGE_SHIFT, 
iter-&gt;level);
root_hpa + SHADOW_PT_INDEX((iter-&gt;gfn) « 12, 4)
root_hpa + ((iter-&gt;gfn « 12) » 39) &amp; ((1 « 9) - 1)
root_hpa + (INDEX_OF_PML4) &amp; (1 1111 1111)</p>
</blockquote>

<p>This macro masks out the 9 bits from the gfn and retrieves actual index of PML4.
Note that each table index of different levels are generated with 9 bits of the 
faultin address, and this address location is determined based on the level. By
masking 9 LSB bits from the gfn left shifted with 12 and right shifted 39 again,
it can extract only the bits used for indexing PML4 table. Anyway the most 
important thing is sptep of the iter points to the SPTE derived from faultin
address and its PML4 index, which points to the next level SPT table, PDPT base
address in physical address. Also, old_spte is set with the same address.</p>

<h2 id="walking-spt-inside-iteration"><span class="me-2">Walking SPT (Inside Iteration)</span><a href="#walking-spt-inside-iteration" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
</pre></td><td class="rouge-code"><pre><span class="mi">1019</span>         <span class="nf">tdp_mmu_for_each_pte</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">mmu</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">gfn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1020</span>                 <span class="k">if</span> <span class="p">(</span><span class="n">nx_huge_page_workaround_enabled</span><span class="p">)</span>
<span class="mi">1021</span>                         <span class="n">disallowed_hugepage_adjust</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">old_spte</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span>
<span class="mi">1022</span>                                                    <span class="n">iter</span><span class="p">.</span><span class="n">level</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pfn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">level</span><span class="p">);</span>
<span class="mi">1023</span> 
<span class="mi">1024</span>                 <span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">level</span> <span class="o">==</span> <span class="n">level</span><span class="p">)</span>
<span class="mi">1025</span>                         <span class="k">break</span><span class="p">;</span>
<span class="mi">1026</span> 
<span class="mi">1027</span>                 <span class="cm">/*
1028                  * If there is an SPTE mapping a large page at a higher level
1029                  * than the target, that SPTE must be cleared and replaced
1030                  * with a non-leaf SPTE.
1031                  */</span>
<span class="mi">1032</span>                 <span class="k">if</span> <span class="p">(</span><span class="n">is_shadow_present_pte</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">old_spte</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
<span class="mi">1033</span>                     <span class="n">is_large_pte</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">old_spte</span><span class="p">))</span> <span class="p">{</span>
<span class="mi">1034</span>                         <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tdp_mmu_zap_spte_atomic</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iter</span><span class="p">))</span>
<span class="mi">1035</span>                                 <span class="k">break</span><span class="p">;</span>
<span class="mi">1036</span> 
<span class="mi">1037</span>                         <span class="cm">/*
1038                          * The iter must explicitly re-read the spte here
1039                          * because the new value informs the !present
1040                          * path below.
1041                          */</span>
<span class="mi">1042</span>                         <span class="n">iter</span><span class="p">.</span><span class="n">old_spte</span> <span class="o">=</span> <span class="n">READ_ONCE</span><span class="p">(</span><span class="o">*</span><span class="n">rcu_dereference</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">sptep</span><span class="p">));</span>
<span class="mi">1043</span>                 <span class="p">}</span>
<span class="mi">1044</span> 
<span class="mi">1045</span>                 <span class="nf">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_shadow_present_pte</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">old_spte</span><span class="p">))</span> <span class="p">{</span>
<span class="mi">1046</span>                         <span class="cm">/*
1047                          * If SPTE has been frozen by another thread, just
1048                          * give up and retry, avoiding unnecessary page table
1049                          * allocation and free.
1050                          */</span>
<span class="mi">1051</span>                         <span class="k">if</span> <span class="p">(</span><span class="n">is_removed_spte</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">old_spte</span><span class="p">))</span>
<span class="mi">1052</span>                                 <span class="k">break</span><span class="p">;</span>
<span class="mi">1053</span> 
<span class="mi">1054</span>                         <span class="n">sp</span> <span class="o">=</span> <span class="n">alloc_tdp_mmu_page</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">iter</span><span class="p">.</span><span class="n">gfn</span><span class="p">,</span> <span class="n">iter</span><span class="p">.</span><span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="mi">1055</span>                         <span class="n">child_pt</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">spt</span><span class="p">;</span>
<span class="mi">1056</span> 
<span class="mi">1057</span>                         <span class="n">new_spte</span> <span class="o">=</span> <span class="n">make_nonleaf_spte</span><span class="p">(</span><span class="n">child_pt</span><span class="p">,</span>
<span class="mi">1058</span>                                                      <span class="o">!</span><span class="n">shadow_accessed_mask</span><span class="p">);</span>
<span class="mi">1059</span> 
<span class="mi">1060</span>                         <span class="k">if</span> <span class="p">(</span><span class="n">tdp_mmu_set_spte_atomic_no_dirty_log</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iter</span><span class="p">,</span> <span class="n">new_spte</span><span class="p">))</span> <span class="p">{</span>
<span class="mi">1061</span>                                 <span class="n">tdp_mmu_link_page</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span>
<span class="mi">1062</span>                                                   <span class="n">huge_page_disallowed</span> <span class="o">&amp;&amp;</span>
<span class="mi">1063</span>                                                   <span class="n">req_level</span> <span class="o">&gt;=</span> <span class="n">iter</span><span class="p">.</span><span class="n">level</span><span class="p">);</span>
<span class="mi">1064</span> 
<span class="mi">1065</span>                                 <span class="n">trace_kvm_mmu_get_page</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="mi">1066</span>                         <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="mi">1067</span>                                 <span class="n">tdp_mmu_free_sp</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>
<span class="mi">1068</span>                                 <span class="k">break</span><span class="p">;</span>
<span class="mi">1069</span>                         <span class="p">}</span>
<span class="mi">1070</span>                 <span class="p">}</span>
<span class="mi">1071</span>         <span class="p">}</span>
<span class="mi">1072</span> 
<span class="mi">1073</span>         <span class="nf">if</span> <span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">level</span> <span class="o">!=</span> <span class="n">level</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">1074</span>                 <span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="mi">1075</span>                 <span class="k">return</span> <span class="n">RET_PF_RETRY</span><span class="p">;</span>
<span class="mi">1076</span>         <span class="p">}</span>
<span class="mi">1077</span> 
<span class="mi">1078</span>         <span class="n">ret</span> <span class="o">=</span> <span class="n">tdp_mmu_map_handle_target_level</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">write</span><span class="p">,</span> <span class="n">map_writable</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iter</span><span class="p">,</span>
<span class="mi">1079</span>                                               <span class="n">pfn</span><span class="p">,</span> <span class="n">prefault</span><span class="p">);</span>
<span class="mi">1080</span>         <span class="nf">rcu_read_unlock</span><span class="p">();</span>
<span class="mi">1081</span> 
<span class="mi">1082</span>         <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="mi">1083</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<h3 id="initialize-non-leaf-spte-if-not-present"><span class="me-2">Initialize non-leaf SPTE (if not present)</span><a href="#initialize-non-leaf-spte-if-not-present" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<p>During the traversing spt, it might encounter some cases where the spt entries 
are not yet allocated and cannot further go down to retrieve the HPA.</p>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre><span class="mi">1045</span>                 <span class="nf">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_shadow_present_pte</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">old_spte</span><span class="p">))</span> <span class="p">{</span>               
<span class="mi">1046</span>                         <span class="cm">/*                                                 
1047                          * If SPTE has been frozen by another thread, just 
1048                          * give up and retry, avoiding unnecessary page table
1049                          * allocation and free.                            
1050                          */</span>                                                
<span class="mi">1051</span>                         <span class="k">if</span> <span class="p">(</span><span class="n">is_removed_spte</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">old_spte</span><span class="p">))</span>                
<span class="mi">1052</span>                                 <span class="k">break</span><span class="p">;</span>                                     
<span class="mi">1053</span>                                                                            
<span class="mi">1054</span>                         <span class="n">sp</span> <span class="o">=</span> <span class="n">alloc_tdp_mmu_page</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">iter</span><span class="p">.</span><span class="n">gfn</span><span class="p">,</span> <span class="n">iter</span><span class="p">.</span><span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></div></div>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">is_shadow_present_pte</span><span class="p">(</span><span class="n">u64</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>               
        <span class="k">return</span> <span class="o">!!</span><span class="p">(</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="n">SPTE_MMU_PRESENT_MASK</span><span class="p">);</span>
<span class="p">}</span>    
</pre></td></tr></tbody></table></code></div></div>

<p>To confirm whether the spte has been allocated or not, all initialized spte 
should be masked with SPTE_MMU_PRESENT_MASK bit. When the bit does not present
non-leaf spt table and its mapping should be established during the traversing.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="k">struct</span> <span class="nc">kvm_mmu_page</span> <span class="o">*</span><span class="nf">alloc_tdp_mmu_page</span><span class="p">(</span><span class="k">struct</span> <span class="nc">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">,</span>
                                               <span class="kt">int</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="nc">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>

        <span class="n">sp</span> <span class="o">=</span> <span class="n">kvm_mmu_memory_cache_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu_page_header_cache</span><span class="p">);</span>
        <span class="n">sp</span><span class="o">-&gt;</span><span class="n">spt</span> <span class="o">=</span> <span class="n">kvm_mmu_memory_cache_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu_shadow_page_cache</span><span class="p">);</span>
        <span class="n">set_page_private</span><span class="p">(</span><span class="n">virt_to_page</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">spt</span><span class="p">),</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">sp</span><span class="p">);</span>

        <span class="n">sp</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">.</span><span class="n">word</span> <span class="o">=</span> <span class="n">page_role_for_level</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">level</span><span class="p">).</span><span class="n">word</span><span class="p">;</span>
        <span class="n">sp</span><span class="o">-&gt;</span><span class="n">gfn</span> <span class="o">=</span> <span class="n">gfn</span><span class="p">;</span>
        <span class="n">sp</span><span class="o">-&gt;</span><span class="n">tdp_mmu_page</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

        <span class="n">trace_kvm_mmu_get_page</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">sp</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>It allocates and return spt table page, kvm_mmu_page. Note that the gfn param 
is the gfn of the iter.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="rouge-code"><pre><span class="mi">187</span> <span class="n">u64</span> <span class="n">make_nonleaf_spte</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="n">child_pt</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ad_disabled</span><span class="p">)</span>
<span class="mi">188</span> <span class="p">{</span>        
<span class="mi">189</span>         <span class="n">u64</span> <span class="n">spte</span> <span class="o">=</span> <span class="n">SPTE_MMU_PRESENT_MASK</span><span class="p">;</span>      
<span class="mi">190</span> 
<span class="mi">191</span>         <span class="n">spte</span> <span class="o">|=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">child_pt</span><span class="p">)</span> <span class="o">|</span> <span class="n">shadow_present_mask</span> <span class="o">|</span> <span class="n">PT_WRITABLE_MASK</span> <span class="o">|</span>
<span class="mi">192</span>                 <span class="n">shadow_user_mask</span> <span class="o">|</span> <span class="n">shadow_x_mask</span> <span class="o">|</span> <span class="n">shadow_me_mask</span><span class="p">;</span>
<span class="mi">193</span> 
<span class="mi">194</span>         <span class="k">if</span> <span class="p">(</span><span class="n">ad_disabled</span><span class="p">)</span>
<span class="mi">195</span>                 <span class="n">spte</span> <span class="o">|=</span> <span class="n">SPTE_TDP_AD_DISABLED_MASK</span><span class="p">;</span> 
<span class="mi">196</span>         <span class="k">else</span>                      
<span class="mi">197</span>                 <span class="n">spte</span> <span class="o">|=</span> <span class="n">shadow_accessed_mask</span><span class="p">;</span>
<span class="mi">198</span> 
<span class="mi">199</span>         <span class="k">return</span> <span class="n">spte</span><span class="p">;</span>
<span class="mi">200</span> <span class="p">}</span>        
</pre></td></tr></tbody></table></code></div></div>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="mi">1054</span>                         <span class="n">sp</span> <span class="o">=</span> <span class="n">alloc_tdp_mmu_page</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">iter</span><span class="p">.</span><span class="n">gfn</span><span class="p">,</span> <span class="n">iter</span><span class="p">.</span><span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="mi">1055</span>                         <span class="n">child_pt</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">spt</span><span class="p">;</span>                                
<span class="mi">1056</span>                                                                            
<span class="mi">1057</span>                         <span class="n">new_spte</span> <span class="o">=</span> <span class="n">make_nonleaf_spte</span><span class="p">(</span><span class="n">child_pt</span><span class="p">,</span>             
<span class="mi">1058</span>                                                      <span class="o">!</span><span class="n">shadow_accessed_mask</span><span class="p">);</span>
<span class="mi">1060</span>                         <span class="nf">if</span> <span class="p">(</span><span class="n">tdp_mmu_set_spte_atomic_no_dirty_log</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iter</span><span class="p">,</span> <span class="n">new_spte</span><span class="p">))</span> <span class="p">{</span>
<span class="mi">1061</span>                                 <span class="n">tdp_mmu_link_page</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span>
<span class="mi">1062</span>                                                   <span class="n">huge_page_disallowed</span> <span class="o">&amp;&amp;</span>
<span class="mi">1063</span>                                                   <span class="n">req_level</span> <span class="o">&gt;=</span> <span class="n">iter</span><span class="p">.</span><span class="n">level</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></div></div>

<p>Note that sp is the kvm_mmu_page for the child SPT, and child_pt points to the 
spt member field of the created sp. new_spte points to the physical address of 
the actual page table in the EPT with some flags enabled. Because lower 12 bits
are not used for page table entries of EPT, it can be used for carrying flags 
for that page table entry.</p>

<p>To indicate that current spte is initialized, SPTE_MMU_PRESENT_MASK bit is set 
on spte address. Moreover, note that child_pt is the spt of the newly generated
SPT page. Remember that SPT page, kvm_mmu_page, is a kernel data structure to
maintain lots of information related with SPT including the actual page table 
entries. Therefore, from the hardware’s perspective, this data structures should
not be seen, but only the spt maintained in the kvm_mmu_page should be seen so
that HW can walks the page table smoothly without considering those kernel 
defined data structure. After adding extra bits required to interpret spte, it 
returns new_spte further passed to the tdp_mmu_set_spte_atomic_no_dirty_log 
function to update SPTE for EPT.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">tdp_mmu_set_spte_atomic_no_dirty_log</span><span class="p">(</span><span class="k">struct</span> <span class="nc">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span>
                                                        <span class="k">struct</span> <span class="nc">tdp_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">,</span>
                                                        <span class="n">u64</span> <span class="n">new_spte</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">lockdep_assert_held_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>

        <span class="cm">/*
         * Do not change removed SPTEs. Only the thread that froze the SPTE
         * may modify it.
         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">is_removed_spte</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">old_spte</span><span class="p">))</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

        <span class="cm">/*
         * Note, fast_pf_fix_direct_spte() can also modify TDP MMU SPTEs and
         * does not hold the mmu_lock.
         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cmpxchg64</span><span class="p">(</span><span class="n">rcu_dereference</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">sptep</span><span class="p">),</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">old_spte</span><span class="p">,</span>
                      <span class="n">new_spte</span><span class="p">)</span> <span class="o">!=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">old_spte</span><span class="p">)</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

        <span class="n">__handle_changed_spte</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">as_id</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">gfn</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">old_spte</span><span class="p">,</span>
                              <span class="n">new_spte</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
        <span class="n">handle_changed_spte_acc_track</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">old_spte</span><span class="p">,</span> <span class="n">new_spte</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">);</span>

        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>Initially iter-&gt;sptep and iter-&gt;old_spte are set with identical address, 
cmpxchg64 will <strong>exchange the value of iter-&gt;sptep to new_spte</strong>. Now the 
current iter can point to the newly generated spte. Note that iter-&gt;sptep 
does not point to the kvm_mmu_page, but the spt field of the kvm_mmu_page. Now 
the SPT can go to lower level cause the new spte presents.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre> <span class="mi">258</span> <span class="cm">/**
 259  * tdp_mmu_link_page - Add a new page to the list of pages used by the TDP MMU
 260  *
 261  * @kvm: kvm instance
 262  * @sp: the new page
 263  * @account_nx: This page replaces a NX large page and should be marked for
 264  *              eventual reclaim.
 265  */</span>
 <span class="mi">266</span> <span class="k">static</span> <span class="kt">void</span> <span class="nf">tdp_mmu_link_page</span><span class="p">(</span><span class="k">struct</span> <span class="nc">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span>
 <span class="mi">267</span>                               <span class="kt">bool</span> <span class="n">account_nx</span><span class="p">)</span>
 <span class="mi">268</span> <span class="p">{</span>
 <span class="mi">269</span>         <span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">tdp_mmu_pages_lock</span><span class="p">);</span>
 <span class="mi">270</span>         <span class="nf">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">tdp_mmu_pages</span><span class="p">);</span>
 <span class="mi">271</span>         <span class="nf">if</span> <span class="p">(</span><span class="n">account_nx</span><span class="p">)</span>
 <span class="mi">272</span>                 <span class="n">account_huge_nx_page</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">sp</span><span class="p">);</span>
 <span class="mi">273</span>         <span class="nf">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">tdp_mmu_pages_lock</span><span class="p">);</span>
 <span class="mi">274</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>Up until now, the kvm_mmu_page is generated and its spt field is correctly 
mapped to the sptep field of the current iterator, which means that the EPT/NPT
can access next level SPTEs as a result of indexing with masking. However, the
newly generated kvm_mmu_page instance is also important because it maintains 
lots of useful information of that SPT page. Therefore, tdp_mmu_link_page links
the generated kvm_mmu_page to the list called kvm-&gt;arch.tdp_mmu_pages.</p>

<h3 id="advancing-iterator-to-traverse-spt"><span class="me-2">Advancing iterator to traverse SPT</span><a href="#advancing-iterator-to-traverse-spt" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<p>We placed the new entry for SPT that has been absent. So now, we can further 
iterate the SPT!</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="rouge-code"><pre><span class="cm">/*      
 * Step to the next SPTE in a pre-order traversal of the paging structure.
 * To get to the next SPTE, the iterator either steps down towards the goal
 * GFN, if at a present, non-last-level SPTE, or over to a SPTE mapping a
 * highter GFN.
 *      
 * The basic algorithm is as follows:
 * 1. If the current SPTE is a non-last-level SPTE, step down into the page
 *    table it points to.
 * 2. If the iterator cannot step down, it will try to step to the next SPTE
 *    in the current page of the paging structure.
 * 3. If the iterator cannot step to the next entry in the current page, it will
 *    try to step up to the parent paging structure page. In this case, that
 *    SPTE will have already been visited, and so the iterator must also step
 *    to the side again.
 */</span>
<span class="kt">void</span> <span class="nf">tdp_iter_next</span><span class="p">(</span><span class="k">struct</span> <span class="nc">tdp_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">try_step_down</span><span class="p">(</span><span class="n">iter</span><span class="p">))</span>
                <span class="k">return</span><span class="p">;</span>

        <span class="k">do</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">try_step_side</span><span class="p">(</span><span class="n">iter</span><span class="p">))</span>
                        <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">try_step_up</span><span class="p">(</span><span class="n">iter</span><span class="p">));</span>
        <span class="n">iter</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> 
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>The basic operation of tdp_iter_next is the steps down one level according to 
the index masked from the next_last_level_gfn which is faultin gpa.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="rouge-code"><pre><span class="cm">/*
 * Steps down one level in the paging structure towards the goal GFN. Returns
 * true if the iterator was able to step down a level, false otherwise.
 */</span>
<span class="k">static</span> <span class="kt">bool</span> <span class="nf">try_step_down</span><span class="p">(</span><span class="k">struct</span> <span class="nc">tdp_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">tdp_ptep_t</span> <span class="n">child_pt</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">==</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">min_level</span><span class="p">)</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

        <span class="cm">/*
         * Reread the SPTE before stepping down to avoid traversing into page
         * tables that are no longer linked from this entry.
         */</span>
        <span class="n">iter</span><span class="o">-&gt;</span><span class="n">old_spte</span> <span class="o">=</span> <span class="n">READ_ONCE</span><span class="p">(</span><span class="o">*</span><span class="n">rcu_dereference</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">sptep</span><span class="p">));</span>

        <span class="n">child_pt</span> <span class="o">=</span> <span class="n">spte_to_child_pt</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">old_spte</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">child_pt</span><span class="p">)</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

        <span class="n">iter</span><span class="o">-&gt;</span><span class="n">level</span><span class="o">--</span><span class="p">;</span>
        <span class="n">iter</span><span class="o">-&gt;</span><span class="n">pt_path</span><span class="p">[</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">child_pt</span><span class="p">;</span>
        <span class="n">iter</span><span class="o">-&gt;</span><span class="n">gfn</span> <span class="o">=</span> <span class="n">round_gfn_for_level</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">next_last_level_gfn</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">);</span>
        <span class="n">tdp_iter_refresh_sptep</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>

        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre><span class="n">tdp_ptep_t</span> <span class="nf">spte_to_child_pt</span><span class="p">(</span><span class="n">u64</span> <span class="n">spte</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">)</span>        
<span class="p">{</span>
        <span class="cm">/*
         * There's no child entry if this entry isn't present or is a
         * last-level entry.
         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_shadow_present_pte</span><span class="p">(</span><span class="n">spte</span><span class="p">)</span> <span class="o">||</span> <span class="n">is_last_spte</span><span class="p">(</span><span class="n">spte</span><span class="p">,</span> <span class="n">level</span><span class="p">))</span>
                <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">tdp_ptep_t</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="n">spte_to_pfn</span><span class="p">(</span><span class="n">spte</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<blockquote>
  <p>Given an SPTE and its level, returns a pointer containing the host virtual 
address of the child page table referenced by the SPTE. Returns null if there 
is no such entry.</p>
</blockquote>

<p>Because the spte addresses are stored as physical addresses, it should be 
translated to virtual address first. Therefore, the child_pt is the next level
spt page’s virtual address. Also, it decreases level as it steps down and 
memorize this address in the history path array, pt_path. As we did before, 
the next gfn is calculated based on level and faultin GPA. Also, function
tdp_iter_refresh_sptep initializes the sptep and old_spte based on new gfn.</p>

<h2 id="final-gpa---hpa-translation-through-leaf-spte"><span class="me-2">Final GPA -&gt; HPA translation through leaf SPTE</span><a href="#final-gpa---hpa-translation-through-leaf-spte" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>
<p>It will traverse the SPT one by one and end up reaching the last level SPTE,
PTE which is our final destination. Note that the last level would not be the 
PTE based on what page size will be used for faultin GPA. We assume that it is 
4K size PTE for simplification. Moreover, previous allocations for SPTE was for 
non-leaf entries, but PTE is the leaf entry. When it reaches the destination
level, it breaks the loop and invokes tdp_mmu_map_handle_target_level function.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">int</span> <span class="nf">tdp_mmu_map_handle_target_level</span><span class="p">(</span><span class="k">struct</span> <span class="nc">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">,</span>
                                          <span class="kt">int</span> <span class="n">map_writable</span><span class="p">,</span>
                                          <span class="k">struct</span> <span class="nc">tdp_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">,</span>
                                          <span class="n">kvm_pfn_t</span> <span class="n">pfn</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">prefault</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">u64</span> <span class="n">new_spte</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">RET_PF_FIXED</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">make_spte_ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">is_noslot_pfn</span><span class="p">(</span><span class="n">pfn</span><span class="p">)))</span>
                <span class="n">new_spte</span> <span class="o">=</span> <span class="n">make_mmio_spte</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">gfn</span><span class="p">,</span> <span class="n">ACC_ALL</span><span class="p">);</span>
        <span class="k">else</span>
                <span class="n">make_spte_ret</span> <span class="o">=</span> <span class="n">make_spte</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">ACC_ALL</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">gfn</span><span class="p">,</span>
                                         <span class="n">pfn</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">old_spte</span><span class="p">,</span> <span class="n">prefault</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span>
                                         <span class="n">map_writable</span><span class="p">,</span> <span class="o">!</span><span class="n">shadow_accessed_mask</span><span class="p">,</span>
                                         <span class="o">&amp;</span><span class="n">new_spte</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">new_spte</span> <span class="o">==</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">old_spte</span><span class="p">)</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">RET_PF_SPURIOUS</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tdp_mmu_map_set_spte_atomic</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">iter</span><span class="p">,</span> <span class="n">new_spte</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">RET_PF_RETRY</span><span class="p">;</span>

        <span class="cm">/*
         * If the page fault was caused by a write but the page is write
         * protected, emulation is needed. If the emulation was skipped,
         * the vCPU would have the same fault again.
         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">make_spte_ret</span> <span class="o">&amp;</span> <span class="n">SET_SPTE_WRITE_PROTECTED_PT</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">)</span>
                        <span class="n">ret</span> <span class="o">=</span> <span class="n">RET_PF_EMULATE</span><span class="p">;</span>
                <span class="n">kvm_make_request</span><span class="p">(</span><span class="n">KVM_REQ_TLB_FLUSH_CURRENT</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="cm">/* If a MMIO SPTE is installed, the MMIO will need to be emulated. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">is_mmio_spte</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">new_spte</span><span class="p">)))</span> <span class="p">{</span>
                <span class="n">trace_mark_mmio_spte</span><span class="p">(</span><span class="n">rcu_dereference</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">sptep</span><span class="p">),</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">gfn</span><span class="p">,</span>
                                     <span class="n">new_spte</span><span class="p">);</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">RET_PF_EMULATE</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">trace_kvm_mmu_set_spte</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">gfn</span><span class="p">,</span>
                                       <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">sptep</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="cm">/*
         * Increase pf_fixed in both RET_PF_EMULATE and RET_PF_FIXED to be
         * consistent with legacy MMU behavior.
         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">RET_PF_SPURIOUS</span><span class="p">)</span>
                <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">pf_fixed</span><span class="o">++</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>tdp_mmu_map_handle_target_level function installs a last-level SPTE, which is 
the last journey of TDP page fault handling. Note that iter parameter contains 
all information describing which SPTE should be installed. It doesn’t require 
GPA (gfn) because we already know address of SPTE entry that maps faultin GPA to
HPA. For correct translation, it also has HPA (pfn) param which will be written 
into the newly generated SPTE.</p>

<h3 id="generate-new-spte-for-the-last-level-entry"><span class="me-2">Generate new spte for the last level entry</span><a href="#generate-new-spte-for-the-last-level-entry" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<p>previously, for upper level non-leaf SPTEs, alloc_tdp_mmu_page and 
make_nonleaf_spte functions are used to allocate kvm_mmu_page and initialize 
spte, respectively. For the last level, we don’t need kvm_mmu_page because it
is not a page table but the last entry mapping GPA to HPA. Therefore, make_spte
will be similar to make_nonleaf_spte function in terms of setting spte.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
</pre></td><td class="rouge-code"><pre> <span class="mi">93</span> <span class="kt">int</span> <span class="n">make_spte</span><span class="p">(</span><span class="k">struct</span> <span class="nc">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pte_access</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span>
 <span class="mi">94</span>                      <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">kvm_pfn_t</span> <span class="n">pfn</span><span class="p">,</span> <span class="n">u64</span> <span class="n">old_spte</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">speculative</span><span class="p">,</span>
 <span class="mi">95</span>                      <span class="kt">bool</span> <span class="n">can_unsync</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">host_writable</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ad_disabled</span><span class="p">,</span>
 <span class="mi">96</span>                      <span class="n">u64</span> <span class="o">*</span><span class="n">new_spte</span><span class="p">)</span>
 <span class="mi">97</span> <span class="p">{</span>           
 <span class="mi">98</span>         <span class="n">u64</span> <span class="n">spte</span> <span class="o">=</span> <span class="n">SPTE_MMU_PRESENT_MASK</span><span class="p">;</span>
 <span class="mi">99</span>         <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="mi">100</span> 
<span class="mi">101</span>         <span class="k">if</span> <span class="p">(</span><span class="n">ad_disabled</span><span class="p">)</span>
<span class="mi">102</span>                 <span class="n">spte</span> <span class="o">|=</span> <span class="n">SPTE_TDP_AD_DISABLED_MASK</span><span class="p">;</span>
<span class="mi">103</span>         <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">kvm_vcpu_ad_need_write_protect</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>
<span class="mi">104</span>                 <span class="n">spte</span> <span class="o">|=</span> <span class="n">SPTE_TDP_AD_WRPROT_ONLY_MASK</span><span class="p">;</span>
<span class="mi">105</span> 
<span class="mi">106</span>         <span class="cm">/*  
107          * For the EPT case, shadow_present_mask is 0 if hardware
108          * supports exec-only page table entries.  In that case,
109          * ACC_USER_MASK and shadow_user_mask are used to represent
110          * read access.  See FNAME(gpte_access) in paging_tmpl.h.
111          */</span>
<span class="mi">112</span>         <span class="n">spte</span> <span class="o">|=</span> <span class="n">shadow_present_mask</span><span class="p">;</span>
<span class="mi">113</span>         <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">speculative</span><span class="p">)</span>
<span class="mi">114</span>                 <span class="n">spte</span> <span class="o">|=</span> <span class="n">spte_shadow_accessed_mask</span><span class="p">(</span><span class="n">spte</span><span class="p">);</span>
<span class="mi">115</span>                     
<span class="mi">116</span>         <span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">&gt;</span> <span class="n">PG_LEVEL_4K</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pte_access</span> <span class="o">&amp;</span> <span class="n">ACC_EXEC_MASK</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
<span class="mi">117</span>             <span class="n">is_nx_huge_page_enabled</span><span class="p">())</span> <span class="p">{</span>
<span class="mi">118</span>                 <span class="n">pte_access</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ACC_EXEC_MASK</span><span class="p">;</span>
<span class="mi">119</span>         <span class="p">}</span>
<span class="mi">120</span> 
<span class="mi">121</span>         <span class="k">if</span> <span class="p">(</span><span class="n">pte_access</span> <span class="o">&amp;</span> <span class="n">ACC_EXEC_MASK</span><span class="p">)</span>
<span class="mi">122</span>                 <span class="n">spte</span> <span class="o">|=</span> <span class="n">shadow_x_mask</span><span class="p">;</span>
<span class="mi">123</span>         <span class="k">else</span>
<span class="mi">124</span>                 <span class="n">spte</span> <span class="o">|=</span> <span class="n">shadow_nx_mask</span><span class="p">;</span>
<span class="mi">125</span>             
<span class="mi">126</span>         <span class="k">if</span> <span class="p">(</span><span class="n">pte_access</span> <span class="o">&amp;</span> <span class="n">ACC_USER_MASK</span><span class="p">)</span>
<span class="mi">127</span>                 <span class="n">spte</span> <span class="o">|=</span> <span class="n">shadow_user_mask</span><span class="p">;</span>
<span class="mi">128</span>     
<span class="mi">129</span>         <span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">&gt;</span> <span class="n">PG_LEVEL_4K</span><span class="p">)</span>
<span class="mi">130</span>                 <span class="n">spte</span> <span class="o">|=</span> <span class="n">PT_PAGE_SIZE_MASK</span><span class="p">;</span>
<span class="mi">131</span>         <span class="nf">if</span> <span class="p">(</span><span class="n">tdp_enabled</span><span class="p">)</span>
<span class="mi">132</span>                 <span class="n">spte</span> <span class="o">|=</span> <span class="n">static_call</span><span class="p">(</span><span class="n">kvm_x86_get_mt_mask</span><span class="p">)(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span>
<span class="mi">133</span>                         <span class="n">kvm_is_mmio_pfn</span><span class="p">(</span><span class="n">pfn</span><span class="p">));</span>
<span class="mi">134</span> 
<span class="mi">135</span>         <span class="k">if</span> <span class="p">(</span><span class="n">host_writable</span><span class="p">)</span>
<span class="mi">136</span>                 <span class="n">spte</span> <span class="o">|=</span> <span class="n">shadow_host_writable_mask</span><span class="p">;</span>
<span class="mi">137</span>         <span class="k">else</span>
<span class="mi">138</span>                 <span class="n">pte_access</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ACC_WRITE_MASK</span><span class="p">;</span>
<span class="mi">139</span> 
<span class="mi">140</span>         <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kvm_is_mmio_pfn</span><span class="p">(</span><span class="n">pfn</span><span class="p">))</span>
<span class="mi">141</span>                 <span class="n">spte</span> <span class="o">|=</span> <span class="n">shadow_me_mask</span><span class="p">;</span>
<span class="mi">142</span> 
<span class="mi">143</span>         <span class="n">spte</span> <span class="o">|=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
<span class="mi">144</span> 
<span class="mi">145</span>         <span class="nf">if</span> <span class="p">(</span><span class="n">pte_access</span> <span class="o">&amp;</span> <span class="n">ACC_WRITE_MASK</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">146</span>                 <span class="n">spte</span> <span class="o">|=</span> <span class="n">PT_WRITABLE_MASK</span> <span class="o">|</span> <span class="n">shadow_mmu_writable_mask</span><span class="p">;</span>
<span class="mi">147</span> 
<span class="mi">148</span>                 <span class="cm">/*
149                  * Optimization: for pte sync, if spte was writable the hash
150                  * lookup is unnecessary (and expensive). Write protection
151                  * is responsibility of kvm_mmu_get_page / kvm_mmu_sync_roots.
152                  * Same reasoning can be applied to dirty page accounting.
153                  */</span>
<span class="mi">154</span>                 <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">can_unsync</span> <span class="o">&amp;&amp;</span> <span class="n">is_writable_pte</span><span class="p">(</span><span class="n">old_spte</span><span class="p">))</span>
<span class="mi">155</span>                         <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="mi">156</span> 
<span class="mi">157</span>                 <span class="cm">/*
158                  * Unsync shadow pages that are reachable by the new, writable
159                  * SPTE.  Write-protect the SPTE if the page can't be unsync'd,
160                  * e.g. it's write-tracked (upper-level SPs) or has one or more
161                  * shadow pages and unsync'ing pages is not allowed.
162                  */</span>
<span class="mi">163</span>                 <span class="k">if</span> <span class="p">(</span><span class="n">mmu_try_to_unsync_pages</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">can_unsync</span><span class="p">))</span> <span class="p">{</span>
<span class="mi">164</span>                         <span class="n">pgprintk</span><span class="p">(</span><span class="s">"%s: found shadow page for %llx, marking ro</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
<span class="mi">165</span>                                  <span class="n">__func__</span><span class="p">,</span> <span class="n">gfn</span><span class="p">);</span>
<span class="mi">166</span>                         <span class="n">ret</span> <span class="o">|=</span> <span class="n">SET_SPTE_WRITE_PROTECTED_PT</span><span class="p">;</span>
<span class="mi">167</span>                         <span class="n">pte_access</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ACC_WRITE_MASK</span><span class="p">;</span>
<span class="mi">168</span>                         <span class="n">spte</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">PT_WRITABLE_MASK</span> <span class="o">|</span> <span class="n">shadow_mmu_writable_mask</span><span class="p">);</span>
<span class="mi">169</span>                 <span class="p">}</span>
<span class="mi">170</span>         <span class="p">}</span>
<span class="mi">171</span> 
<span class="mi">172</span>         <span class="nf">if</span> <span class="p">(</span><span class="n">pte_access</span> <span class="o">&amp;</span> <span class="n">ACC_WRITE_MASK</span><span class="p">)</span>
<span class="mi">173</span>                 <span class="n">spte</span> <span class="o">|=</span> <span class="n">spte_shadow_dirty_mask</span><span class="p">(</span><span class="n">spte</span><span class="p">);</span>
<span class="mi">174</span> 
<span class="mi">175</span>         <span class="nf">if</span> <span class="p">(</span><span class="n">speculative</span><span class="p">)</span>
<span class="mi">176</span>                 <span class="n">spte</span> <span class="o">=</span> <span class="n">mark_spte_for_access_track</span><span class="p">(</span><span class="n">spte</span><span class="p">);</span>
<span class="mi">177</span> 
<span class="mi">178</span> <span class="n">out</span><span class="o">:</span>
<span class="mi">179</span>         <span class="nf">WARN_ONCE</span><span class="p">(</span><span class="n">is_rsvd_spte</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="o">-&gt;</span><span class="n">shadow_zero_check</span><span class="p">,</span> <span class="n">spte</span><span class="p">,</span> <span class="n">level</span><span class="p">),</span>
<span class="mi">180</span>                   <span class="s">"spte = 0x%llx, level = %d, rsvd bits = 0x%llx"</span><span class="p">,</span> <span class="n">spte</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span>
<span class="mi">181</span>                   <span class="n">get_rsvd_bits</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="o">-&gt;</span><span class="n">shadow_zero_check</span><span class="p">,</span> <span class="n">spte</span><span class="p">,</span> <span class="n">level</span><span class="p">));</span>
<span class="mi">182</span> 
<span class="mi">183</span>         <span class="o">*</span><span class="n">new_spte</span> <span class="o">=</span> <span class="n">spte</span><span class="p">;</span>
<span class="mi">184</span>         <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="mi">185</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>The most important role of make_spte function is setup spte flags according to 
platform setting and what level of spte it is. After setting up the flags, it 
combine the flags with pfn, so that the translation smoothly continues. However,
note that the initialized spte is stored at new_spte variable which does not
point to the last level STPE.</p>

<h3 id="set-generated-spte-to-the-leaf-spte"><span class="me-2">Set generated SPTE to the leaf SPTE</span><a href="#set-generated-spte-to-the-leaf-spte" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">tdp_mmu_map_set_spte_atomic</span><span class="p">(</span><span class="k">struct</span> <span class="nc">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
                                               <span class="k">struct</span> <span class="nc">tdp_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">,</span>
                                               <span class="n">u64</span> <span class="n">new_spte</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="nc">kvm</span> <span class="o">*</span><span class="n">kvm</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tdp_mmu_set_spte_atomic_no_dirty_log</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">iter</span><span class="p">,</span> <span class="n">new_spte</span><span class="p">))</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

        <span class="cm">/*
         * Use kvm_vcpu_gfn_to_memslot() instead of going through
         * handle_changed_spte_dirty_log() to leverage vcpu-&gt;last_used_slot.
         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">is_writable_pte</span><span class="p">(</span><span class="n">new_spte</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">struct</span> <span class="nc">kvm_memory_slot</span> <span class="o">*</span><span class="n">slot</span> <span class="o">=</span> <span class="n">kvm_vcpu_gfn_to_memslot</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">gfn</span><span class="p">);</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">&amp;&amp;</span> <span class="n">kvm_slot_dirty_track_enabled</span><span class="p">(</span><span class="n">slot</span><span class="p">))</span> <span class="p">{</span>
                        <span class="cm">/* Enforced by kvm_mmu_hugepage_adjust. */</span>
                        <span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">&gt;</span> <span class="n">PG_LEVEL_4K</span><span class="p">);</span>
                        <span class="n">mark_page_dirty_in_slot</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">gfn</span><span class="p">);</span>
                <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>Because SPTE can be shared among multiple VCPUs, the generated SPTE should be
atomically written into SPT. It invokes tdp_mmu_set_spte_atomic_no_dirty_log,
which is already covered in setting non-leaf spte. The vcpu param is the 
instance that took the TDP page fault. The iter param is a tdp_iter instance 
currently on the SPTE that should be set. The new_spte is the value the SPTE 
should be set to. After this function successfully returns, the page fault can 
be resolved, and the translation from faultin GPA to HPA will not fail again.</p>

<h2 id="misc"><span class="me-2">MISC</span><a href="#misc" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>
<h3 id="some-error-codes-related-with-page-fault-handling"><span class="me-2">Some error codes related with page fault handling</span><a href="#some-error-codes-related-with-page-fault-handling" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="rouge-code"><pre><span class="cm">/*      
 * Return values of handle_mmio_page_fault, mmu.page_fault, and fast_page_fault().
 *      
 * RET_PF_RETRY: let CPU fault again on the address.
 * RET_PF_EMULATE: mmio page fault, emulate the instruction directly.
 * RET_PF_INVALID: the spte is invalid, let the real page fault path update it.
 * RET_PF_FIXED: The faulting entry has been fixed.
 * RET_PF_SPURIOUS: The faulting entry was already fixed, e.g. by another vCPU.
 *                                       
 * Any names added to this enum should be exported to userspace for use in
 * tracepoints via TRACE_DEFINE_ENUM() in mmutrace.h
 */</span>             
<span class="k">enum</span> <span class="p">{</span>  
        <span class="n">RET_PF_RETRY</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">RET_PF_EMULATE</span><span class="p">,</span>
        <span class="n">RET_PF_INVALID</span><span class="p">,</span>
        <span class="n">RET_PF_FIXED</span><span class="p">,</span>
        <span class="n">RET_PF_SPURIOUS</span><span class="p">,</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></div></div>
<h3 id="checking-tdp"><span class="me-2">Checking TDP</span><a href="#checking-tdp" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">is_tdp_mmu_enabled</span><span class="p">(</span><span class="k">struct</span> <span class="nc">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">tdp_mmu_enabled</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">is_tdp_mmu_page</span><span class="p">(</span><span class="k">struct</span> <span class="nc">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">tdp_mmu_page</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">is_tdp_mmu</span><span class="p">(</span><span class="k">struct</span> <span class="nc">kvm_mmu</span> <span class="o">*</span><span class="n">mmu</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="nc">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
        <span class="n">hpa_t</span> <span class="n">hpa</span> <span class="o">=</span> <span class="n">mmu</span><span class="o">-&gt;</span><span class="n">root_hpa</span><span class="p">;</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">VALID_PAGE</span><span class="p">(</span><span class="n">hpa</span><span class="p">)))</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">sp</span> <span class="o">=</span> <span class="n">to_shadow_page</span><span class="p">(</span><span class="n">hpa</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">sp</span> <span class="o">&amp;&amp;</span> <span class="n">is_tdp_mmu_page</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">root_count</span><span class="p">;</span>
<span class="p">}</span>       
</pre></td></tr></tbody></table></code></div></div>

<p>When TDP is enabled, <strong>kvm_tdp_mmu_map</strong> is invoked to handle EPT fault not 
through __direct_map function. root_hpa is a pointer to physical address of root
spt. If TDP is enabled, <strong>root_hpa</strong> has been initialized by the 
kvm_tdp_mmu_get_vcpu_root_hpa, tdp_mmu_page returns true.</p>


  </div>

  <div class="post-tail-wrapper text-muted">
    <!-- categories -->
    
      <div class="post-meta mb-3">
        <i class="far fa-folder-open fa-fw me-1"></i>
        
          <a href="/categories/confidential-computing/">Confidential Computing</a>,
          <a href="/categories/kvm/">KVM</a>
      </div>
    

    <!-- tags -->
    

    <div
      class="
        post-tail-bottom
        d-flex justify-content-between align-items-center mt-5 pb-2
      "
    >
      <div class="license-wrapper">
        
          

          This post is licensed under 
        <a href="https://creativecommons.org/licenses/by/4.0/">
          CC BY 4.0
        </a>
         by the author.
        
      </div>

      <!-- Post sharing snippet -->

<div class="share-wrapper d-flex align-items-center">
  <span class="share-label text-muted">Share</span>
  <span class="share-icons">
    
    
    

    

      

      <a
        href="https://twitter.com/intent/tweet?text=KVM%20page-fault%20handling%20-%20Ruach&url=https%3A%2F%2Fruach.github.io%2Fposts%2FPAGEFAULT-HANDLING-KVM%2F"
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="Twitter"
        target="_blank"
        rel="noopener"
        aria-label="Twitter"
      >
        <i class="fa-fw fa-brands fa-square-x-twitter"></i>
      </a>
    

      

      <a
        href="https://www.facebook.com/sharer/sharer.php?title=KVM%20page-fault%20handling%20-%20Ruach&u=https%3A%2F%2Fruach.github.io%2Fposts%2FPAGEFAULT-HANDLING-KVM%2F"
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="Facebook"
        target="_blank"
        rel="noopener"
        aria-label="Facebook"
      >
        <i class="fa-fw fab fa-facebook-square"></i>
      </a>
    

      

      <a
        href="https://t.me/share/url?url=https%3A%2F%2Fruach.github.io%2Fposts%2FPAGEFAULT-HANDLING-KVM%2F&text=KVM%20page-fault%20handling%20-%20Ruach"
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="Telegram"
        target="_blank"
        rel="noopener"
        aria-label="Telegram"
      >
        <i class="fa-fw fab fa-telegram"></i>
      </a>
    

      

      <a
        href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fruach.github.io%2Fposts%2FPAGEFAULT-HANDLING-KVM%2F"
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="Linkedin"
        target="_blank"
        rel="noopener"
        aria-label="Linkedin"
      >
        <i class="fa-fw fab fa-linkedin"></i>
      </a>
    

    <button
      id="copy-link"
      aria-label="Copy link"
      class="btn small"
      data-bs-toggle="tooltip"
      data-bs-placement="top"
      title="Copy link"
      data-title-succeed="Link copied successfully!"
    >
      <i class="fa-fw fas fa-link pe-none fs-6"></i>
    </button>
  </span>
</div>

    </div>
    <!-- .post-tail-bottom -->
  </div>
  <!-- div.post-tail-wrapper -->
</article>


            
          </main>

          <!-- panel -->
          <aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 mb-5 text-muted">
            <div class="access">
              <!-- Get the last 5 posts from lastmod list. -->















              <!-- The trending tags list -->


















            </div>

            
              
              



  <section id="toc-wrapper" class="ps-0 pe-4">
    <h2 class="panel-heading ps-3 pt-2 mb-2">Contents</h2>
    <nav id="toc"></nav>
  </section>


            
          </aside>
        </div>

        <div class="row">
          <!-- tail -->
          <div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4">
            
              
              <!-- Recommend the other 3 posts according to the tags and categories of the current post. -->

<!-- The total size of related posts -->


<!-- An random integer that bigger than 0 -->


<!-- Equals to TAG_SCORE / {max_categories_hierarchy} -->














  

  

  

  

  

  

  

  

  

  

  

  

  

  
    
  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  











  <aside id="related-posts" aria-labelledby="related-label">
    <h3 class="mb-4" id="related-label">Further Reading</h3>
    <nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4">
      
        <article class="col">
          <a href="/posts/TDX-MODULE-LIFECYCLE-2/" class="post-preview card h-100">
            <div class="card-body">
              <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->




<time
  
  data-ts="1679544000"
  data-df="ll"
  
>
  Mar 23, 2023
</time>

              <h4 class="pt-0 my-2">TDX Module Life Cycle Part 2</h4>
              <div class="text-muted">
                <p>
                  





                  In previous posts, I discussed the initialization of the TDX module using 
TDH_SYS_INIT SEAMCALL. As depicted in the image below, several additional 
configuration steps are necessary for the TDX m...
                </p>
              </div>
            </div>
          </a>
        </article>
      
        <article class="col">
          <a href="/posts/SPT-AND-MEMSLOT/" class="post-preview card h-100">
            <div class="card-body">
              <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->




<time
  
  data-ts="1681099200"
  data-df="ll"
  
>
  Apr 10, 2023
</time>

              <h4 class="pt-0 my-2">Shadow Page Table (SPT) and MEMSLOT</h4>
              <div class="text-muted">
                <p>
                  





                  Shadow Page Table (SPT)
Before the introduction of TDP, shadow paging has been utilized to translate
GPA to HPA. The KVM module utilize a unified concept to abstract the 
structure managing this tr...
                </p>
              </div>
            </div>
          </a>
        </article>
      
        <article class="col">
          <a href="/posts/PAGEFAULT-HANDLING-KVM-TDX/" class="post-preview card h-100">
            <div class="card-body">
              <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->




<time
  
  data-ts="1681531200"
  data-df="ll"
  
>
  Apr 15, 2023
</time>

              <h4 class="pt-0 my-2">KVM page-fault handling for TDX</h4>
              <div class="text-muted">
                <p>
                  





                  Basic idea to implement private page

  Because shared EPT is the same as the existing EPT, use the existing logic for
shared EPT.  On the other hand, secure EPT requires additional operations
inst...
                </p>
              </div>
            </div>
          </a>
        </article>
      
    </nav>
  </aside>
  <!-- #related-posts -->


            
              
              <!-- Navigation buttons at the bottom of the post. -->

<nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation">
  
  

  
    <a
      href="/posts/QEMU-KVM-ADDRESS-SPACE/"
      class="btn btn-outline-primary"
      aria-label="Older"
    >
      <p>QEMU Side Memory Management for VM with RAMBLOCK</p>
    </a>
  

  
    <a
      href="/posts/PAGEFAULT-HANDLING-KVM-TDX/"
      class="btn btn-outline-primary"
      aria-label="Newer"
    >
      <p>KVM page-fault handling for TDX</p>
    </a>
  
</nav>

            
              
              <!--  The comments switcher -->

  
  <!-- The Disqus lazy loading. -->

<div id="disqus_thread">
  <p class="text-center text-muted small">Comments powered by <a href="https://disqus.com/">Disqus</a>.</p>
</div>

<script type="text/javascript">
  var disqus_config = function () {
    this.page.url = 'https://ruach.github.io/posts/PAGEFAULT-HANDLING-KVM/';
    this.page.identifier = '/posts/PAGEFAULT-HANDLING-KVM/';
  };

  /* Lazy loading */
  var disqus_observer = new IntersectionObserver(
    function (entries) {
      if (entries[0].isIntersecting) {
        (function () {
          var d = document,
            s = d.createElement('script');
          s.src = 'https://ruach.disqus.com/embed.js';
          s.setAttribute('data-timestamp', +new Date());
          (d.head || d.body).appendChild(s);
        })();

        disqus_observer.disconnect();
      }
    },
    { threshold: [0] }
  );

  disqus_observer.observe(document.querySelector('#disqus_thread'));

  /* Auto switch theme */
  function reloadDisqus() {
    if (event.source === window && event.data && event.data.direction === ModeToggle.ID) {
      /* Disqus hasn't been loaded */
      if (typeof DISQUS === 'undefined') {
        return;
      }

      if (document.readyState == 'complete') {
        DISQUS.reset({ reload: true, config: disqus_config });
      }
    }
  }

  if (document.querySelector('.mode-toggle')) {
    window.addEventListener('message', reloadDisqus);
  }
</script>



            

            <!-- The Footer -->

<footer
  aria-label="Site Info"
  class="
    d-flex flex-column justify-content-center text-muted
    flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3
  "
>
  <p>
    ©
    <time>2024</time>
    <a href="https://ruach.github.io">Jaehyuk Lee</a>.
    
      <span
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author."
      >Some rights reserved.</span>
    
  </p>

  <p>Using the <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme for <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>
  </p>
</footer>

          </div>
        </div>

        <!-- The Search results -->

<div id="search-result-wrapper" class="d-flex justify-content-center unloaded">
  <div class="col-11 content">
    <div id="search-hints">
      <!-- The trending tags list -->


















    </div>
    <div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div>
  </div>
</div>

      </div>

      <aside aria-label="Scroll to Top">
        <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow">
          <i class="fas fa-angle-up"></i>
        </button>
      </aside>
    </div>

    <div id="mask"></div>

    
      <aside
  id="notification"
  class="toast"
  role="alert"
  aria-live="assertive"
  aria-atomic="true"
  data-bs-animation="true"
  data-bs-autohide="false"
>
  <div class="toast-header">
    <button
      type="button"
      class="btn-close ms-auto"
      data-bs-dismiss="toast"
      aria-label="Close"
    ></button>
  </div>
  <div class="toast-body text-center pt-0">
    <p class="px-2 mb-3">A new version of content is available.</p>
    <button type="button" class="btn btn-primary" aria-label="Update">
      Update
    </button>
  </div>
</aside>

    

    <!-- JavaScripts -->

    <!-- JS selector for site. -->

<!-- commons -->



<!-- layout specified -->


  

  
    <!-- image lazy-loading & popup & clipboard -->
    
  















  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  



  <script src="https://cdn.jsdelivr.net/combine/npm/jquery@3.7.1/dist/jquery.min.js,npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js,npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/magnific-popup@1.1.0/dist/jquery.magnific-popup.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.10/dayjs.min.js,npm/dayjs@1.11.10/locale/en.min.js,npm/dayjs@1.11.10/plugin/relativeTime.min.js,npm/dayjs@1.11.10/plugin/localizedFormat.min.js,npm/tocbot@4.21.2/dist/tocbot.min.js"></script>






<script defer src="/assets/js/dist/post.min.js"></script>






    

    <!--
  Jekyll Simple Search loader
  See: <https://github.com/christian-fei/Simple-Jekyll-Search>
-->





<script>
  /* Note: dependent library will be loaded in `js-selector.html` */
  SimpleJekyllSearch({
    searchInput: document.getElementById('search-input'),
    resultsContainer: document.getElementById('search-results'),
    json: '/assets/js/data/search.json',
    searchResultTemplate: '  <article class="px-1 px-sm-2 px-lg-4 px-xl-0">    <header>      <h2><a href="{url}">{title}</a></h2>      <div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1">        {categories}        {tags}      </div>    </header>    <p>{snippet}</p>  </article>',
    noResultsText: '<p class="mt-5"></p>',
    templateMiddleware: function(prop, value, template) {
      if (prop === 'categories') {
        if (value === '') {
          return `${value}`;
        } else {
          return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`;
        }
      }

      if (prop === 'tags') {
        if (value === '') {
          return `${value}`;
        } else {
          return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`;
        }
      }
    }
  });
</script>

  </body>
</html>

