<!doctype html>














<!-- `site.alt_lang` can specify a language different from the UI -->
<html lang="en" data-mode="light">
  <!-- The Head -->

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta
    name="viewport"
    content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover"
  >

  

  

  
    <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v4.3.3" />
<meta property="og:title" content="TDX Module Life Cycle Part 2" />
<meta property="og:locale" content="en" />
<meta name="description" content="In previous posts, I discussed the initialization of the TDX module using TDH_SYS_INIT SEAMCALL. As depicted in the image below, several additional configuration steps are necessary for the TDX module initialization sequence, which will be addressed in this post." />
<meta property="og:description" content="In previous posts, I discussed the initialization of the TDX module using TDH_SYS_INIT SEAMCALL. As depicted in the image below, several additional configuration steps are necessary for the TDX module initialization sequence, which will be addressed in this post." />
<link rel="canonical" href="https://ruach.github.io/posts/TDX-MODULE-LIFECYCLE-2/" />
<meta property="og:url" content="https://ruach.github.io/posts/TDX-MODULE-LIFECYCLE-2/" />
<meta property="og:site_name" content="Ruach" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-03-23T00:00:00-04:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="TDX Module Life Cycle Part 2" />
<meta name="twitter:site" content="@ruach_lee" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-03-23T00:00:00-04:00","datePublished":"2023-03-23T00:00:00-04:00","description":"In previous posts, I discussed the initialization of the TDX module using TDH_SYS_INIT SEAMCALL. As depicted in the image below, several additional configuration steps are necessary for the TDX module initialization sequence, which will be addressed in this post.","headline":"TDX Module Life Cycle Part 2","mainEntityOfPage":{"@type":"WebPage","@id":"https://ruach.github.io/posts/TDX-MODULE-LIFECYCLE-2/"},"url":"https://ruach.github.io/posts/TDX-MODULE-LIFECYCLE-2/"}</script>
<!-- End Jekyll SEO tag -->

  

  <title>TDX Module Life Cycle Part 2 | Ruach
  </title>

  <!--
  The Favicons for Web, Android, Microsoft, and iOS (iPhone and iPad) Apps
  Generated by: https://realfavicongenerator.net/
-->



<link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png">
<link rel="manifest" href="/assets/img/favicons/site.webmanifest">
<link rel="shortcut icon" href="/assets/img/favicons/favicon.ico">
<meta name="apple-mobile-web-app-title" content="Ruach">
<meta name="application-name" content="Ruach">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml">
<meta name="theme-color" content="#ffffff">


  
    
      <link rel="preconnect" href="https://fonts.googleapis.com" >
      <link rel="dns-prefetch" href="https://fonts.googleapis.com" >
    
      <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
      <link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin>
    
      <link rel="preconnect" href="https://fonts.googleapis.com" >
      <link rel="dns-prefetch" href="https://fonts.googleapis.com" >
    
      <link rel="preconnect" href="https://cdn.jsdelivr.net" >
      <link rel="dns-prefetch" href="https://cdn.jsdelivr.net" >
    

    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap">
  

  <!-- GA -->
  

  <!-- Bootstrap -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css">

  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.2/css/all.min.css">

  <link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css">

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.21.2/dist/tocbot.min.css">
  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css">
  

  
    <!-- Manific Popup -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css">
  

  <!-- JavaScript -->

  

  <!-- A placeholder to allow defining custom metadata -->

</head>


  <body>
    <!-- The Side Bar -->

<aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end">
  <header class="profile-wrapper">
    <a href="/" id="avatar" class="rounded-circle">
      
        
        <img src="/assets/img/jaehyuk.png" width="112" height="112" alt="avatar" onerror="this.style.display='none'">
      
    </a>

    <h1 class="site-title">
      <a href="/">Ruach</a>
    </h1>
    <p class="site-subtitle fst-italic mb-0">Jaehyuk Lee</p>
  </header>
  <!-- .profile-wrapper -->

  <nav class="flex-column flex-grow-1 w-100 ps-0">
    <ul class="nav">
      <!-- home -->
      <li class="nav-item">
        <a href="/" class="nav-link">
          <i class="fa-fw fas fa-home"></i>
          <span>HOME</span>
        </a>
      </li>
      <!-- the real tabs -->
      
        <li class="nav-item">
          <a href="/categories/" class="nav-link">
            <i class="fa-fw fas fa-stream"></i>
            

            <span>CATEGORIES</span>
          </a>
        </li>
        <!-- .nav-item -->
      
        <li class="nav-item">
          <a href="/archives/" class="nav-link">
            <i class="fa-fw fas fa-archive"></i>
            

            <span>ARCHIVES</span>
          </a>
        </li>
        <!-- .nav-item -->
      
        <li class="nav-item">
          <a href="/about/" class="nav-link">
            <i class="fa-fw fas fa-info-circle"></i>
            

            <span>ABOUT</span>
          </a>
        </li>
        <!-- .nav-item -->
      
    </ul>
  </nav>

  <div class="sidebar-bottom d-flex flex-wrap  align-items-center w-100">
    

    
      

      
        <a
          href="javascript:location.href = 'mailto:' + ['jaehyuk','gatech.edu'].join('@')"
          aria-label="email"
          

          

          

          
        >
          <i class="fas fa-envelope"></i>
        </a>
      
    
      

      
        <a
          href="https://www.linkedin.com/in/jaehyuk-lee-29b33b121/"
          aria-label="linkedin"
          

          
            target="_blank"
            
          

          

          
            rel="noopener noreferrer"
          
        >
          <i class="fab fa-linkedin"></i>
        </a>
      
    
      

      
        <a
          href="https://github.com/Ruach"
          aria-label="github"
          

          
            target="_blank"
            
          

          

          
            rel="noopener noreferrer"
          
        >
          <i class="fab fa-github"></i>
        </a>
      
    
      

      
        <a
          href="https://stackoverflow.com/users/4460514/ruach?tab=profile"
          aria-label="stack-overflow"
          

          
            target="_blank"
            
          

          

          
            rel="noopener noreferrer"
          
        >
          <i class="fab fa-stack-overflow"></i>
        </a>
      
    
  </div>
  <!-- .sidebar-bottom -->
</aside>
<!-- #sidebar -->


    <div id="main-wrapper" class="d-flex justify-content-center">
      <div class="container d-flex flex-column px-xxl-5">
        <!-- The Top Bar -->

<header id="topbar-wrapper" aria-label="Top Bar">
  <div
    id="topbar"
    class="d-flex align-items-center justify-content-between px-lg-3 h-100"
  >
    <nav id="breadcrumb" aria-label="Breadcrumb">
      

      
        
          
            <span>
              <a href="/">
                Home
              </a>
            </span>

          
        
          
        
          
            
              <span>TDX Module Life Cycle Part 2</span>
            

          
        
      
    </nav>
    <!-- endof #breadcrumb -->

    <button type="button" id="sidebar-trigger" class="btn btn-link">
      <i class="fas fa-bars fa-fw"></i>
    </button>

    <div id="topbar-title">
      Post
    </div>

    <button type="button" id="search-trigger" class="btn btn-link">
      <i class="fas fa-search fa-fw"></i>
    </button>

    <search class="align-items-center ms-3 ms-lg-0">
      <i class="fas fa-search fa-fw"></i>
      <input
        class="form-control"
        id="search-input"
        type="search"
        aria-label="search"
        autocomplete="off"
        placeholder="Search..."
      >
    </search>
    <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button>
  </div>
</header>


        <div class="row flex-grow-1">
          <main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4">
            
              <!-- Refactor the HTML structure -->



<!--
  In order to allow a wide table to scroll horizontally,
  we suround the markdown table with `<div class="table-wrapper">` and `</div>`
-->



<!--
  Fixed kramdown code highlight rendering:
  https://github.com/penibelst/jekyll-compress-html/issues/101
  https://github.com/penibelst/jekyll-compress-html/issues/71#issuecomment-188144901
-->



<!-- Change the icon of checkbox -->



<!-- Handle images -->




  
  

  <!-- CDN URL -->
  

  <!-- Add image path -->
  

  
    
      
      
    

    
    

    

    
    

    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    
    

    

    
      <!-- do not add shimmer by default -->
      
    

    <!-- lazy-load images -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        

        
        
      
    

    <!-- combine -->
    
  
    

    
    

    

    
    

    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    
    

    

    
      <!-- do not add shimmer by default -->
      
    

    <!-- lazy-load images -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        

        
        
      
    

    <!-- combine -->
    
  

  


<!-- Add header for code snippets -->



<!-- Create heading anchors -->





  
  

  
    
    

    
      
        
        
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    

    
  

  
  

  
    
    

    
      
        
        
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    

    
  

  
  

  

  
  

  




<!-- return -->




<article class="px-1">
  <header>
    <h1 data-toc-skip>TDX Module Life Cycle Part 2</h1>

    <div class="post-meta text-muted">
      <!-- published date -->
      <span>
        Posted
        <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->




<time
  
  data-ts="1679544000"
  data-df="ll"
  
    data-bs-toggle="tooltip" data-bs-placement="bottom"
  
>
  Mar 23, 2023
</time>

      </span>

      <!-- lastmod date -->
      

      

      <div class="d-flex justify-content-between">
        <!-- author(s) -->
        <span>
          

          By

          <em>
            
              <a href="https://ruach.github.io">Jaehyuk Lee</a>
            
          </em>
        </span>

        <!-- read time -->
        <!-- Calculate the post's reading time, and display the word count in tooltip -->



<!-- words per minute -->










<!-- return element -->
<span
  class="readtime"
  data-bs-toggle="tooltip"
  data-bs-placement="bottom"
  title="7051 words"
>
  <em>39 min</em> read</span>

      </div>
      <!-- .d-flex -->
    </div>
    <!-- .post-meta -->
  </header>

  <div class="content">
    <p>In previous posts, I discussed the initialization of the TDX module using 
TDH_SYS_INIT SEAMCALL. As depicted in the image below, several additional 
configuration steps are necessary for the TDX module initialization sequence, 
which will be addressed in this post.</p>

<p><a href="/assets/img/TDX//tdx-module-init.png" class="popup img-link "><img src="/assets/img/TDX//tdx-module-init.png" alt="TDX_MODULE_INIT" loading="lazy"></a></p>

<h2 id="tdx-module-global-configuration"><span class="me-2">TDX Module Global Configuration</span><a href="#tdx-module-global-configuration" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>
<p>After initializing all logical processors on the platform, global data structure
for TDX module should be configured and initialized. This includes TDMR, PAMT 
and HKID for TDX Module.</p>

<h3 id="tdmr"><span class="me-2">TDMR</span><a href="#tdmr" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<p>Trust Domain Memory Region (TDMR) is memory range that can be converted between
TD-VM pages and normal pages. The memory pages that does not belong to TDMR can
not be converted to TD-VM page, especially private pages. TDMR should meet below
specific requirements:</p>
<ol>
  <li>There is no requirement for TMDRs to cover all CMRs.</li>
  <li>Each TDMR has its own size which must be a multiple of 1GB.</li>
  <li>TDMR memory, except for reserved areas, must be convertible as checked by
MCHECK (i.e., every TDMR page must reside within a CMR).</li>
  <li>TDMRs are configured at platform scope (no separate configuration per package).</li>
  <li>TDMRs should not be overlapped with each other.</li>
</ol>

<h3 id="pamt"><span class="me-2">PAMT</span><a href="#pamt" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<p>The Physical Address Metadata Table (PAMT) is the metadata of <strong>every physical 
page in TDMR</strong>. A page metadata include page type, page size, assignment to a TD,
and other attributes.</p>

<ol>
  <li>PAMT area must reside in convertible memory (CMR)</li>
  <li>PAMT areas must not overlap with TDMR non-reserved areas; however, they may 
reside within TDMR reserved areas (as long as these are convertible).</li>
  <li>PAMT areas must not overlap with each other.</li>
</ol>

<blockquote>
  <p>For each 1GB of TDMR physical memory, there is a corresponding PAMT block. 
A PAMT block is <strong>logically</strong> arranged in a three-level tree structure of PAMT 
entries. Levels 0 through 2 (PAMT_4K, PAMT_2M and PAMT_1G) correspond to 4KB, 
2MB and 1GB physical TDMR pages, respectively. <strong>Physically</strong>, for each TDMR the
design includes three arrays of PAMT entries, one for each PAMT level. This aims
to simplify VMM memory allocation. A logical PAMT block has one entry from the 
PAMT_1G array, 512 entries from the PAMT_2M array, and 512^2 entries from the 
PAMT_4K array.</p>
</blockquote>

<p>Each TDMR is defined as controlled by a (logically) single Physical Address 
Metadata Table (PAMT). Therefore, three levels of PAMT should be configured for 
every TDMR.</p>

<h3 id="reserved-area"><span class="me-2">Reserved area</span><a href="#reserved-area" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<p>The granularity of the TDMR is 1GB. However, there can be a requirement for the
host VMM to be able to allocate memory at granularities smaller than 1GB. To 
support the two requirements above, the TDX module’s design allows arbitrary
reserved areas within TDMRs. Reserved areas are still covered by PAMT. However,
during initialization their respective PAMT entries are marked with a PT_RSVD 
page type, so pages in reserved areas are not used by the Intel TDX module for 
allocating private memory pages (but they can be used for PAMT areas). Only the
non-reserved parts of a TDMR are required to be inside CMRs, which means the 
reserved area can be located outside of CMR. Why? Sometimes one TDMR cannot be 
covered by one CMR because of lack of memory space in that CMR.</p>

<p><a href="/assets/img/TDX//cmr_vs_tdmr.png" class="popup img-link "><img src="/assets/img/TDX//cmr_vs_tdmr.png" alt="CMR_TDMR" loading="lazy"></a></p>

<h2 id="vmm-populates-tdmrs-for-tdx-module"><span class="me-2">VMM Populates TDMRs for TDX Module</span><a href="#vmm-populates-tdmrs-for-tdx-module" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">int</span> <span class="nf">init_tdx_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">......</span>
        <span class="cm">/*
         * To avoid having to modify the page allocator to distinguish
         * TDX and non-TDX memory allocation, convert all memory regions
         * in memblock to TDX memory to make sure all pages managed by
         * the page allocator are TDX memory.
         *
         * Sanity check all memory regions are fully covered by CMRs to
         * make sure they are truly convertible.
         */</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">check_memblock_tdx_convertible</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
                <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
        
        <span class="cm">/* Prepare enough space to construct TDMRs */</span>
        <span class="n">tdmr_array</span> <span class="o">=</span> <span class="n">alloc_tdmr_array</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tdmr_array_sz</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tdmr_array</span><span class="p">)</span> <span class="p">{</span> 
                <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
                <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* Construct TDMRs to cover all memory regions in memblock */</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">construct_tdmrs_memeblock</span><span class="p">(</span><span class="n">tdmr_array</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tdmr_num</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
                <span class="k">goto</span> <span class="n">out_free_tdmrs</span><span class="p">;</span>

        <span class="cm">/*
         * Reserve the first TDX KeyID as global KeyID to protect
         * TDX module metadata.
         */</span>
        <span class="n">tdx_global_keyid</span> <span class="o">=</span> <span class="n">tdx_keyid_start</span><span class="p">;</span>

        <span class="cm">/* Pass the TDMRs and the global KeyID to the TDX module */</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">config_tdx_module</span><span class="p">(</span><span class="n">tdmr_array</span><span class="p">,</span> <span class="n">tdmr_num</span><span class="p">,</span> <span class="n">tdx_global_keyid</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
                <span class="k">goto</span> <span class="n">out_free_pamts</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></div></div>

<p>For TDH_SYS_CONFIG, the information about physical addresses of tdmr_info 
entries and private keyid for global encryption/decryption of TDX module is 
passed to the TDX Module through the SEAMCALL. Let’s figure out how the host KVM
populate TDMR array for TDX Module.</p>

<h3 id="check-memblock-regions-are-convertible-into-tdmr"><span class="me-2">Check memblock regions are convertible into TDMR</span><a href="#check-memblock-regions-are-convertible-into-tdmr" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<p>Kernel at some point, before the buddy allocation is initialized, it manages 
all memories on the platform as MEMBLOCK. VMM populates the TDMR to cover all
MEMBLOCK regions that reside within the CMR.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="rouge-code"><pre><span class="cm">/*              
 * Check whether all memory regions in memblock are TDX convertible
 * memory.  Return 0 if all memory regions are convertible, or error.
 */</span>     
<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_memblock_tdx_convertible</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>               
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_pfn</span><span class="p">,</span> <span class="n">end_pfn</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

        <span class="n">memblock_for_each_tdx_mem_pfn_range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">start_pfn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end_pfn</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>

                <span class="n">start</span> <span class="o">=</span> <span class="n">start_pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">end_pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">range_covered_by_cmr</span><span class="p">(</span><span class="n">tdx_cmr_array</span><span class="p">,</span> <span class="n">tdx_cmr_num</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span>
                                        <span class="n">end</span><span class="p">))</span> <span class="p">{</span>
                        <span class="n">pr_err</span><span class="p">(</span><span class="s">"[0x%llx, 0x%llx) is not fully convertible memory</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                                        <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
                        <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
                <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*
 * Walks over all memblock memory regions that are intended to be
 * converted to TDX memory.  Essentially, it is all memblock memory
 * regions excluding the low memory below 1MB.
 *
 * This is because on some TDX platforms the low memory below 1MB is
 * not included in CMRs.  Excluding the low 1MB can still guarantee
 * that the pages managed by the page allocator are always TDX memory,
 * as the low 1MB is reserved during kernel boot and won't end up to
 * the ZONE_DMA (see reserve_real_mode()).
 */</span>
<span class="cp">#define memblock_for_each_tdx_mem_pfn_range(i, p_start, p_end, p_nid)   \
        for_each_mem_pfn_range(i, MAX_NUMNODES, p_start, p_end, p_nid)  \
                if (!pfn_range_skip_lowmem(p_start, p_end))
</span></pre></td></tr></tbody></table></code></div></div>

<p>Iterator literally iterates all memblock regions, but the low mem region. It 
checks if all memblocks can be converted into TDX memory, which means that the 
start and end addresses of all available memblock should be <strong>within the CMR</strong>.</p>

<h2 id="generate-tdmrs-and-set-up-pamt"><span class="me-2">Generate TDMRs and Set Up PAMT</span><a href="#generate-tdmrs-and-set-up-pamt" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>
<p>If all memblocks are able to be converted to the TDX memories, then it generates
TDMRs to cover all memory regions in memblock.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="rouge-code"><pre><span class="cm">/* 
 * Construct an array of TDMRs to cover all memory regions in memblock.
 * This makes sure all pages managed by the page allocator are TDX
 * memory.  The actual number of TDMRs is kept to @tdmr_num.
 */</span>     
<span class="k">static</span> <span class="kt">int</span> <span class="nf">construct_tdmrs_memeblock</span><span class="p">(</span><span class="k">struct</span> <span class="nc">tdmr_info</span> <span class="o">*</span><span class="n">tdmr_array</span><span class="p">,</span>
                                     <span class="kt">int</span> <span class="o">*</span><span class="n">tdmr_num</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="n">create_tdmrs</span><span class="p">(</span><span class="n">tdmr_array</span><span class="p">,</span> <span class="n">tdmr_num</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
                <span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
        
        <span class="n">ret</span> <span class="o">=</span> <span class="n">tdmrs_set_up_pamt_all</span><span class="p">(</span><span class="n">tdmr_array</span><span class="p">,</span> <span class="o">*</span><span class="n">tdmr_num</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
                <span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
                
        <span class="n">ret</span> <span class="o">=</span> <span class="n">tdmrs_set_up_rsvd_areas_all</span><span class="p">(</span><span class="n">tdmr_array</span><span class="p">,</span> <span class="o">*</span><span class="n">tdmr_num</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
                <span class="k">goto</span> <span class="n">err_free_pamts</span><span class="p">;</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">err_free_pamts:</span>
        <span class="n">tdmrs_free_pamt_all</span><span class="p">(</span><span class="n">tdmr_array</span><span class="p">,</span> <span class="o">*</span><span class="n">tdmr_num</span><span class="p">);</span>
<span class="nl">err:</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>Creating TDMRs consists of three steps: Create TDMR, Set-up PAMT for generated 
TDMR, Set-up reserved areas. Note that tdmr_array was already allocated by 
alloc_tdmr_array function.</p>

<h3 id="create-tdmrs"><span class="me-2">Create TDMRs</span><a href="#create-tdmrs" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">int</span> <span class="nf">create_tdmrs</span><span class="p">(</span><span class="k">struct</span> <span class="nc">tdmr_info</span> <span class="o">*</span><span class="n">tdmr_array</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">tdmr_num</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_pfn</span><span class="p">,</span> <span class="n">end_pfn</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">tdmr_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="cm">/*
         * Loop over all memory regions in memblock and create TDMRs to
         * cover them.  To keep it simple, always try to use one TDMR to
         * cover memory region.
         */</span>
        <span class="n">memblock_for_each_tdx_mem_pfn_range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">start_pfn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end_pfn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nid</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">struct</span> <span class="nc">tdmr_info</span> <span class="o">*</span><span class="n">tdmr</span><span class="p">;</span>
                <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>

                <span class="n">tdmr</span> <span class="o">=</span> <span class="n">tdmr_array_entry</span><span class="p">(</span><span class="n">tdmr_array</span><span class="p">,</span> <span class="n">tdmr_idx</span><span class="p">);</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">TDMR_ALIGN_DOWN</span><span class="p">(</span><span class="n">start_pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">TDMR_ALIGN_UP</span><span class="p">(</span><span class="n">end_pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>

                <span class="cm">/*
                 * If the current TDMR's size hasn't been initialized,
                 * it is a new TDMR to cover the new memory region.
                 * Otherwise, the current TDMR has already covered the
                 * previous memory region.  In the latter case, check
                 * whether the current memory region has been fully or
                 * partially covered by the current TDMR, since TDMR is
                 * 1G aligned.
                 */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">tdmr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
                        <span class="cm">/*
                         * Loop to the next memory region if the current
                         * region has already fully covered by the
                         * current TDMR.
                         */</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&lt;=</span> <span class="n">tdmr_end</span><span class="p">(</span><span class="n">tdmr</span><span class="p">))</span>
                                <span class="k">continue</span><span class="p">;</span>

                        <span class="cm">/*
                         * If part of the current memory region has
                         * already been covered by the current TDMR,
                         * skip the already covered part.
                         */</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">tdmr_end</span><span class="p">(</span><span class="n">tdmr</span><span class="p">))</span>
                                <span class="n">start</span> <span class="o">=</span> <span class="n">tdmr_end</span><span class="p">(</span><span class="n">tdmr</span><span class="p">);</span>

                        <span class="cm">/*
                         * Create a new TDMR to cover the current memory
                         * region, or the remaining part of it.
                         */</span>
                        <span class="n">tdmr_idx</span><span class="o">++</span><span class="p">;</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">tdmr_idx</span> <span class="o">&gt;=</span> <span class="n">tdx_sysinfo</span><span class="p">.</span><span class="n">max_tdmrs</span><span class="p">)</span>
                                <span class="k">return</span> <span class="o">-</span><span class="n">E2BIG</span><span class="p">;</span>

                        <span class="n">tdmr</span> <span class="o">=</span> <span class="n">tdmr_array_entry</span><span class="p">(</span><span class="n">tdmr_array</span><span class="p">,</span> <span class="n">tdmr_idx</span><span class="p">);</span>
                <span class="p">}</span>

                <span class="n">tdmr</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
                <span class="n">tdmr</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* @tdmr_idx is always the index of last valid TDMR. */</span>
        <span class="o">*</span><span class="n">tdmr_num</span> <span class="o">=</span> <span class="n">tdmr_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>One TDMR can contain multiple memblock regions because it is 1G aligned
address range. To check whether one memblock region can be covered by this 
TDMR region, it aligns down and up the start and end addresses respectively.
If the current memblock region can be covered by the existing TDMR region, then 
it is included in the TDMR. If not, it generates another TDMR region.</p>

<h3 id="allocate-pamt-for-tdmr"><span class="me-2">Allocate PAMT for TDMR</span><a href="#allocate-pamt-for-tdmr" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre><span class="cm">/* Allocate and set up PAMTs for all TDMRs */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tdmrs_set_up_pamt_all</span><span class="p">(</span><span class="k">struct</span> <span class="nc">tdmr_info</span> <span class="o">*</span><span class="n">tdmr_array</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tdmr_num</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tdmr_num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">tdmr_set_up_pamt</span><span class="p">(</span><span class="n">tdmr_array_entry</span><span class="p">(</span><span class="n">tdmr_array</span><span class="p">,</span> <span class="n">i</span><span class="p">));</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
                        <span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">err</span><span class="o">:</span>
        <span class="n">tdmrs_free_pamt_all</span><span class="p">(</span><span class="n">tdmr_array</span><span class="p">,</span> <span class="n">tdmr_num</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">int</span> <span class="nf">tdmr_set_up_pamt</span><span class="p">(</span><span class="k">struct</span> <span class="nc">tdmr_info</span> <span class="o">*</span><span class="n">tdmr</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pamt_base</span><span class="p">[</span><span class="n">TDX_PG_MAX</span><span class="p">];</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pamt_size</span><span class="p">[</span><span class="n">TDX_PG_MAX</span><span class="p">];</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tdmr_pamt_base</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tdmr_pamt_size</span><span class="p">;</span>
        <span class="k">enum</span> <span class="n">tdx_page_sz</span> <span class="n">pgsz</span><span class="p">;</span>
        <span class="k">struct</span> <span class="nc">page</span> <span class="o">*</span><span class="n">pamt</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">nid</span><span class="p">;</span>

        <span class="n">nid</span> <span class="o">=</span> <span class="n">tdmr_get_nid</span><span class="p">(</span><span class="n">tdmr</span><span class="p">);</span>

        <span class="cm">/*
         * Calculate the PAMT size for each TDX supported page size
         * and the total PAMT size.
         */</span>
        <span class="n">tdmr_pamt_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">pgsz</span> <span class="o">=</span> <span class="n">TDX_PG_4K</span><span class="p">;</span> <span class="n">pgsz</span> <span class="o">&lt;</span> <span class="n">TDX_PG_MAX</span><span class="p">;</span> <span class="n">pgsz</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">pamt_size</span><span class="p">[</span><span class="n">pgsz</span><span class="p">]</span> <span class="o">=</span> <span class="n">tdmr_get_pamt_sz</span><span class="p">(</span><span class="n">tdmr</span><span class="p">,</span> <span class="n">pgsz</span><span class="p">);</span>
                <span class="n">tdmr_pamt_size</span> <span class="o">+=</span> <span class="n">pamt_size</span><span class="p">[</span><span class="n">pgsz</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="cm">/*
         * Allocate one chunk of physically contiguous memory for all
         * PAMTs.  This helps minimize the PAMT's use of reserved areas
         * in overlapped TDMRs.
         */</span>
        <span class="n">pamt</span> <span class="o">=</span> <span class="n">alloc_contig_pages</span><span class="p">(</span><span class="n">tdmr_pamt_size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span>
                        <span class="n">nid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">node_online_map</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pamt</span><span class="p">)</span>
                <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

        <span class="cm">/* Calculate PAMT base and size for all supported page sizes. */</span>
        <span class="n">tdmr_pamt_base</span> <span class="o">=</span> <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">pamt</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">pgsz</span> <span class="o">=</span> <span class="n">TDX_PG_4K</span><span class="p">;</span> <span class="n">pgsz</span> <span class="o">&lt;</span> <span class="n">TDX_PG_MAX</span><span class="p">;</span> <span class="n">pgsz</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">pamt_base</span><span class="p">[</span><span class="n">pgsz</span><span class="p">]</span> <span class="o">=</span> <span class="n">tdmr_pamt_base</span><span class="p">;</span>
                <span class="n">tdmr_pamt_base</span> <span class="o">+=</span> <span class="n">pamt_size</span><span class="p">[</span><span class="n">pgsz</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="n">tdmr</span><span class="o">-&gt;</span><span class="n">pamt_4k_base</span> <span class="o">=</span> <span class="n">pamt_base</span><span class="p">[</span><span class="n">TDX_PG_4K</span><span class="p">];</span>
        <span class="n">tdmr</span><span class="o">-&gt;</span><span class="n">pamt_4k_size</span> <span class="o">=</span> <span class="n">pamt_size</span><span class="p">[</span><span class="n">TDX_PG_4K</span><span class="p">];</span>
        <span class="n">tdmr</span><span class="o">-&gt;</span><span class="n">pamt_2m_base</span> <span class="o">=</span> <span class="n">pamt_base</span><span class="p">[</span><span class="n">TDX_PG_2M</span><span class="p">];</span>
        <span class="n">tdmr</span><span class="o">-&gt;</span><span class="n">pamt_2m_size</span> <span class="o">=</span> <span class="n">pamt_size</span><span class="p">[</span><span class="n">TDX_PG_2M</span><span class="p">];</span>
        <span class="n">tdmr</span><span class="o">-&gt;</span><span class="n">pamt_1g_base</span> <span class="o">=</span> <span class="n">pamt_base</span><span class="p">[</span><span class="n">TDX_PG_1G</span><span class="p">];</span>
        <span class="n">tdmr</span><span class="o">-&gt;</span><span class="n">pamt_1g_size</span> <span class="o">=</span> <span class="n">pamt_size</span><span class="p">[</span><span class="n">TDX_PG_1G</span><span class="p">];</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>tdmr_set_up_pamt function is invoked for every TDMR and allocate PAMT pages 
based on the size of the TDMR. Because we don’t know which page size will be 
used to map physical pages in the TDMR, PAMT should be ready for all possible 
sizes. Information about each level of PAMT is managed by the tdmr_info struct.</p>

<h3 id="set-up-reserved-area-within-tdmr"><span class="me-2">Set up reserved area within TDMR</span><a href="#set-up-reserved-area-within-tdmr" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">int</span> <span class="nf">tdmrs_set_up_rsvd_areas_all</span><span class="p">(</span><span class="k">struct</span> <span class="nc">tdmr_info</span> <span class="o">*</span><span class="n">tdmr_array</span><span class="p">,</span>
                                      <span class="kt">int</span> <span class="n">tdmr_num</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tdmr_num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

                <span class="n">ret</span> <span class="o">=</span> <span class="n">tdmr_set_up_rsvd_areas</span><span class="p">(</span><span class="n">tdmr_array_entry</span><span class="p">(</span><span class="n">tdmr_array</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span>
                                <span class="n">tdmr_array</span><span class="p">,</span> <span class="n">tdmr_num</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
                        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>It iterates all TDMR and check whether the TDMR requires reserved area.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
</pre></td><td class="rouge-code"><pre><span class="cm">/* Set up reserved areas for a TDMR, including memory holes and PAMTs */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tdmr_set_up_rsvd_areas</span><span class="p">(</span><span class="k">struct</span> <span class="nc">tdmr_info</span> <span class="o">*</span><span class="n">tdmr</span><span class="p">,</span>
                                  <span class="k">struct</span> <span class="nc">tdmr_info</span> <span class="o">*</span><span class="n">tdmr_array</span><span class="p">,</span>
                                  <span class="kt">int</span> <span class="n">tdmr_num</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_pfn</span><span class="p">,</span> <span class="n">end_pfn</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">rsvd_idx</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">u64</span> <span class="n">prev_end</span><span class="p">;</span>

        <span class="cm">/* Mark holes between memory regions as reserved */</span>
        <span class="n">rsvd_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">prev_end</span> <span class="o">=</span> <span class="n">tdmr_start</span><span class="p">(</span><span class="n">tdmr</span><span class="p">);</span>
        <span class="n">memblock_for_each_tdx_mem_pfn_range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">start_pfn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end_pfn</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>

                <span class="n">start</span> <span class="o">=</span> <span class="n">start_pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">end_pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

                <span class="cm">/* Break if this region is after the TDMR */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">tdmr_end</span><span class="p">(</span><span class="n">tdmr</span><span class="p">))</span>
                        <span class="k">break</span><span class="p">;</span>

                <span class="cm">/* Exclude regions before this TDMR */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">tdmr_start</span><span class="p">(</span><span class="n">tdmr</span><span class="p">))</span>
                        <span class="k">continue</span><span class="p">;</span>

                <span class="cm">/*
                 * Skip if no hole exists before this region. "&lt;=" is
                 * used because one memory region might span two TDMRs
                 * (when the previous TDMR covers part of this region).
                 * In this case the start address of this region is
                 * smaller than the start address of the second TDMR.
                 *
                 * Update the prev_end to the end of this region where
                 * the possible memory hole starts.
                 */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;=</span> <span class="n">prev_end</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">prev_end</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
                        <span class="k">continue</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="cm">/* Add the hole before this region */</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">tdmr_add_rsvd_area</span><span class="p">(</span><span class="n">tdmr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rsvd_idx</span><span class="p">,</span> <span class="n">prev_end</span><span class="p">,</span>
                                <span class="n">start</span> <span class="o">-</span> <span class="n">prev_end</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
                        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

                <span class="n">prev_end</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* Add the hole after the last region if it exists. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">prev_end</span> <span class="o">&lt;</span> <span class="n">tdmr_end</span><span class="p">(</span><span class="n">tdmr</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">tdmr_add_rsvd_area</span><span class="p">(</span><span class="n">tdmr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rsvd_idx</span><span class="p">,</span> <span class="n">prev_end</span><span class="p">,</span>
                                <span class="n">tdmr_end</span><span class="p">(</span><span class="n">tdmr</span><span class="p">)</span> <span class="o">-</span> <span class="n">prev_end</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
                        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/*
         * If any PAMT overlaps with this TDMR, the overlapping part
         * must also be put to the reserved area too.  Walk over all
         * TDMRs to find out those overlapping PAMTs and put them to
         * reserved areas.
         */</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tdmr_num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">struct</span> <span class="nc">tdmr_info</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">tdmr_array_entry</span><span class="p">(</span><span class="n">tdmr_array</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
                <span class="n">u64</span> <span class="n">pamt_start</span><span class="p">,</span> <span class="n">pamt_end</span><span class="p">;</span>

                <span class="n">pamt_start</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">pamt_4k_base</span><span class="p">;</span>
                <span class="n">pamt_end</span> <span class="o">=</span> <span class="n">pamt_start</span> <span class="o">+</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">pamt_4k_size</span> <span class="o">+</span>
                        <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">pamt_2m_size</span> <span class="o">+</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">pamt_1g_size</span><span class="p">;</span>

                <span class="cm">/* Skip PAMTs outside of the given TDMR */</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">pamt_end</span> <span class="o">&lt;=</span> <span class="n">tdmr_start</span><span class="p">(</span><span class="n">tdmr</span><span class="p">))</span> <span class="o">||</span>
                                <span class="p">(</span><span class="n">pamt_start</span> <span class="o">&gt;=</span> <span class="n">tdmr_end</span><span class="p">(</span><span class="n">tdmr</span><span class="p">)))</span>
                        <span class="k">continue</span><span class="p">;</span>

                <span class="cm">/* Only mark the part within the TDMR as reserved */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">pamt_start</span> <span class="o">&lt;</span> <span class="n">tdmr_start</span><span class="p">(</span><span class="n">tdmr</span><span class="p">))</span>
                        <span class="n">pamt_start</span> <span class="o">=</span> <span class="n">tdmr_start</span><span class="p">(</span><span class="n">tdmr</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">pamt_end</span> <span class="o">&gt;</span> <span class="n">tdmr_end</span><span class="p">(</span><span class="n">tdmr</span><span class="p">))</span>
                        <span class="n">pamt_end</span> <span class="o">=</span> <span class="n">tdmr_end</span><span class="p">(</span><span class="n">tdmr</span><span class="p">);</span>

                <span class="n">ret</span> <span class="o">=</span> <span class="n">tdmr_add_rsvd_area</span><span class="p">(</span><span class="n">tdmr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rsvd_idx</span><span class="p">,</span> <span class="n">pamt_start</span><span class="p">,</span>
                                <span class="n">pamt_end</span> <span class="o">-</span> <span class="n">pamt_start</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
                        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* TDX requires reserved areas listed in address ascending order */</span>
        <span class="n">sort</span><span class="p">(</span><span class="n">tdmr</span><span class="o">-&gt;</span><span class="n">reserved_areas</span><span class="p">,</span> <span class="n">rsvd_idx</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="nc">tdmr_reserved_area</span><span class="p">),</span>
                        <span class="n">rsvd_area_cmp_func</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<h2 id="sets-up-tdmr-and-hkid-on-tdx-module"><span class="me-2">Sets Up TDMR and HKID on TDX Module</span><a href="#sets-up-tdmr-and-hkid-on-tdx-module" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre>    <span class="k">case</span> <span class="n">TDH_SYS_CONFIG_LEAF</span><span class="p">:</span>
    <span class="p">{</span>   
        <span class="n">hkid_api_input_t</span> <span class="n">global_private_hkid</span><span class="p">;</span>
        <span class="n">global_private_hkid</span><span class="p">.</span><span class="n">raw</span> <span class="o">=</span> <span class="n">local_data</span><span class="o">-&gt;</span><span class="n">vmm_regs</span><span class="p">.</span><span class="n">r8</span><span class="p">;</span>
        
        <span class="n">local_data</span><span class="o">-&gt;</span><span class="n">vmm_regs</span><span class="p">.</span><span class="n">rax</span> <span class="o">=</span> <span class="n">tdh_sys_config</span><span class="p">(</span><span class="n">local_data</span><span class="o">-&gt;</span><span class="n">vmm_regs</span><span class="p">.</span><span class="n">rcx</span><span class="p">,</span>
                                                 <span class="n">local_data</span><span class="o">-&gt;</span><span class="n">vmm_regs</span><span class="p">.</span><span class="n">rdx</span><span class="p">,</span>
                                                 <span class="n">global_private_hkid</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>   
</pre></td></tr></tbody></table></code></div></div>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
</pre></td><td class="rouge-code"><pre><span class="n">api_error_type</span> <span class="nf">tdh_sys_config</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">tdmr_info_array_pa</span><span class="p">,</span>
                             <span class="kt">uint64_t</span> <span class="n">num_of_tdmr_entries</span><span class="p">,</span>
                             <span class="n">hkid_api_input_t</span> <span class="n">global_private_hkid</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Temporary Variables</span>
    <span class="n">tdmr_info_entry_t</span><span class="o">*</span>   <span class="n">tdmr_info_p</span><span class="p">;</span>   <span class="c1">// Pointer to TDMR info</span>
    <span class="n">tdmr_info_entry_t</span><span class="o">*</span>   <span class="n">tdmr_info_copy</span><span class="p">;</span><span class="c1">// Pointer to TDMR info array</span>
    <span class="n">bool_t</span>               <span class="n">tdmr_info_p_init</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">pa_t</span>                 <span class="n">tdmr_info_pa</span> <span class="o">=</span> <span class="p">{.</span><span class="n">raw</span> <span class="o">=</span> <span class="n">tdmr_info_array_pa</span><span class="p">};</span>  <span class="c1">// Physical address of an array of physical addresses of the TDMR info structure</span>
    <span class="kt">uint64_t</span><span class="o">*</span>            <span class="n">tdmr_pa_array</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">// Pointer to an array of physical addresses of the TDMR info structure</span>
    <span class="kt">uint16_t</span>             <span class="n">hkid</span> <span class="o">=</span> <span class="n">global_private_hkid</span><span class="p">.</span><span class="n">hkid</span><span class="p">;</span>
    <span class="n">bool_t</span>               <span class="n">global_lock_acquired</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">tdx_module_global_t</span><span class="o">*</span> <span class="n">tdx_global_data_ptr</span> <span class="o">=</span> <span class="n">get_global_data</span><span class="p">();</span>

    <span class="n">api_error_type</span>       <span class="n">retval</span> <span class="o">=</span> <span class="n">TDX_SYS_BUSY</span><span class="p">;</span>
    <span class="p">......</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">global_private_hkid</span><span class="p">.</span><span class="n">reserved</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">is_private_hkid</span><span class="p">(</span><span class="n">hkid</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">TDX_ERROR</span><span class="p">(</span><span class="s">"HKID 0x%x is not private</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">hkid</span><span class="p">);</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="n">api_error_with_operand_id</span><span class="p">(</span><span class="n">TDX_OPERAND_INVALID</span><span class="p">,</span> <span class="n">OPERAND_ID_R8</span><span class="p">);</span>
        <span class="k">goto</span> <span class="n">EXIT</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">tdx_global_data_ptr</span><span class="o">-&gt;</span><span class="n">kot</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">hkid</span><span class="p">].</span><span class="n">state</span> <span class="o">=</span> <span class="n">KOT_STATE_HKID_RESERVED</span><span class="p">;</span>
    <span class="n">tdx_global_data_ptr</span><span class="o">-&gt;</span><span class="n">hkid</span> <span class="o">=</span> <span class="n">hkid</span><span class="p">;</span>
        
    <span class="n">tdmr_pa_array</span> <span class="o">=</span> <span class="n">map_pa</span><span class="p">(</span><span class="n">tdmr_info_pa</span><span class="p">.</span><span class="n">raw_void</span><span class="p">,</span> <span class="n">TDX_RANGE_RO</span><span class="p">);</span>
    <span class="n">tdmr_info_p_init</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> 
    
    <span class="c1">// map only 2 tdmr entries each time</span>
    <span class="n">pa_t</span> <span class="n">tdmr_entry</span><span class="p">;</span>
    <span class="n">pamt_data_t</span> <span class="n">pamt_data_array</span><span class="p">[</span><span class="n">MAX_TDMRS</span><span class="p">];</span>
    <span class="n">api_error_type</span> <span class="n">err</span><span class="p">;</span>
    
    <span class="n">tdmr_info_copy</span> <span class="o">=</span> <span class="n">tdx_global_data_ptr</span><span class="o">-&gt;</span><span class="n">tdmr_info_copy</span><span class="p">;</span>
    
    <span class="k">for</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_of_tdmr_entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>

        <span class="n">tdmr_entry</span><span class="p">.</span><span class="n">raw</span> <span class="o">=</span> <span class="n">tdmr_pa_array</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="n">shared_hpa_check_with_pwr_2_alignment</span><span class="p">(</span><span class="n">tdmr_entry</span><span class="p">,</span> <span class="n">TDMR_INFO_ENTRY_PTR_ARRAY_ALIGNMENT</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="n">TDX_SUCCESS</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">retval</span> <span class="o">=</span> <span class="n">api_error_with_operand_id</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="n">OPERAND_ID_RCX</span><span class="p">);</span>
            <span class="n">TDX_ERROR</span><span class="p">(</span><span class="s">"TDMR entry PA is not a valid shared HPA pa=0x%llx, error=0x%llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">tdmr_entry</span><span class="p">.</span><span class="n">raw</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
            <span class="k">goto</span> <span class="n">EXIT</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">tdmr_info_p</span> <span class="o">=</span> <span class="p">(</span><span class="n">tdmr_info_entry_t</span><span class="o">*</span><span class="p">)</span><span class="n">map_pa</span><span class="p">(</span><span class="n">tdmr_entry</span><span class="p">.</span><span class="n">raw_void</span><span class="p">,</span> <span class="n">TDX_RANGE_RO</span><span class="p">);</span>
        <span class="n">copy_tdmr_info_entry</span> <span class="p">(</span><span class="n">tdmr_info_p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tdmr_info_copy</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">free_la</span><span class="p">(</span><span class="n">tdmr_info_p</span><span class="p">);</span>


        <span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">check_and_set_tdmrs</span><span class="p">(</span><span class="n">tdmr_info_copy</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">pamt_data_array</span><span class="p">))</span> <span class="o">!=</span> <span class="n">TDX_SUCCESS</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">TDX_ERROR</span><span class="p">(</span><span class="s">"Check and set TDMRs failed</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
            <span class="n">retval</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
            <span class="k">goto</span> <span class="n">EXIT</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">update_pamt_array</span><span class="p">(</span><span class="n">tdmr_info_copy</span><span class="p">,</span> <span class="n">pamt_data_array</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">i</span><span class="p">);</span> <span class="c1">// save tdmr's pamt data</span>
    <span class="p">}</span>

    <span class="n">tdx_global_data_ptr</span><span class="o">-&gt;</span><span class="n">num_of_tdmr_entries</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">num_of_tdmr_entries</span><span class="p">;</span>

    <span class="c1">// ALL_CHECKS_PASSED:  The function is guaranteed to succeed</span>

    <span class="c1">// Complete CPUID handling</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_NUM_CPUID_LOOKUP</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">uint32_t</span> <span class="n">cpuid_value</span> <span class="o">=</span> <span class="n">tdx_global_data_ptr</span><span class="o">-&gt;</span><span class="n">cpuid_values</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">values</span><span class="p">.</span><span class="n">values</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>

            <span class="c1">// Clear the bits that will be later virtualized as FIXED0 or DYNAMIC</span>
            <span class="n">cpuid_value</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">cpuid_lookup</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">fixed0_or_dynamic</span><span class="p">.</span><span class="n">values</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>

            <span class="c1">// Set to 1 any bits that will be later virtualized as FIXED1</span>
            <span class="n">cpuid_value</span> <span class="o">|=</span> <span class="n">cpuid_lookup</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">fixed1</span><span class="p">.</span><span class="n">values</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>

            <span class="n">tdx_global_data_ptr</span><span class="o">-&gt;</span><span class="n">cpuid_values</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">values</span><span class="p">.</span><span class="n">values</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpuid_value</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Prepare state variables for TDHSYSKEYCONFIG</span>
    <span class="n">tdx_global_data_ptr</span><span class="o">-&gt;</span><span class="n">pkg_config_bitmap</span> <span class="o">=</span> <span class="mi">0ULL</span><span class="p">;</span>

    <span class="c1">// Mark the system initialization as done</span>
    <span class="n">tdx_global_data_ptr</span><span class="o">-&gt;</span><span class="n">global_state</span><span class="p">.</span><span class="n">sys_state</span> <span class="o">=</span> <span class="n">SYSCONFIG_DONE</span><span class="p">;</span>
    <span class="n">retval</span> <span class="o">=</span> <span class="n">TDX_SUCCESS</span><span class="p">;</span>

<span class="n">EXIT</span><span class="o">:</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">global_lock_acquired</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">release_sharex_lock_ex</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tdx_global_data_ptr</span><span class="o">-&gt;</span><span class="n">global_lock</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">tdmr_info_p_init</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">free_la</span><span class="p">(</span><span class="n">tdmr_pa_array</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>The first parameter tdmr_info_array_pa is the array containing <strong>physical</strong>
addresses of the <strong>tdmr_info</strong> maintained by the kernel. It has been passed as a
physical addresses, so it should be remapped by the TDX module before accessing 
them to get the TDMR information passed from the host KVM side. After mapping 
the physical addresses, TDX Module accesses them through <strong>tmdr_info_entry_t</strong>
struct pointer. TDMR information is copied to the tdmr_info_copy field of the 
tdx_global_data_ptr. Note that this mapping is populated through the keyhole 
by the map_pa function.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">PACKED</span> <span class="n">tdmr_info_entry_s</span>
<span class="p">{</span>       
    <span class="kt">uint64_t</span> <span class="n">tdmr_base</span><span class="p">;</span>    <span class="cm">/**&lt; Base address of the TDMR (HKID bits must be 0). 1GB aligned. */</span>
    <span class="kt">uint64_t</span> <span class="n">tdmr_size</span><span class="p">;</span>    <span class="cm">/**&lt; Size of the CMR, in bytes. 1GB aligned. */</span>
    <span class="kt">uint64_t</span> <span class="n">pamt_1g_base</span><span class="p">;</span> <span class="cm">/**&lt; Base address of the PAMT_1G range associated with the above TDMR (HKID bits must be 0). 4K aligned. */</span>
    <span class="kt">uint64_t</span> <span class="n">pamt_1g_size</span><span class="p">;</span> <span class="cm">/**&lt; Size of the PAMT_1G range associated with the above TDMR. 4K aligned. */</span>
    <span class="kt">uint64_t</span> <span class="n">pamt_2m_base</span><span class="p">;</span> <span class="cm">/**&lt; Base address of the PAMT_2M range associated with the above TDMR (HKID bits must be 0). 4K aligned. */</span>
    <span class="kt">uint64_t</span> <span class="n">pamt_2m_size</span><span class="p">;</span> <span class="cm">/**&lt; Size of the PAMT_2M range associated with the above TDMR. 4K aligned. */</span>
    <span class="kt">uint64_t</span> <span class="n">pamt_4k_base</span><span class="p">;</span> <span class="cm">/**&lt; Base address of the PAMT_4K range associated with the above TDMR (HKID bits must be 0). 4K aligned. */</span>
    <span class="kt">uint64_t</span> <span class="n">pamt_4k_size</span><span class="p">;</span> <span class="cm">/**&lt; Size of the PAMT_4K range associated with the above TDMR. 4K aligned. */</span>
        
    <span class="k">struct</span>
    <span class="p">{</span>
        <span class="kt">uint64_t</span> <span class="n">offset</span><span class="p">;</span> <span class="cm">/**&lt; Offset of reserved range 0 within the TDMR. 4K aligned. */</span>
        <span class="kt">uint64_t</span> <span class="n">size</span><span class="p">;</span>   <span class="cm">/**&lt; Size of reserved range 0 within the TDMR. A size of 0 indicates a null entry. 4K aligned. */</span>
    <span class="p">}</span> <span class="n">rsvd_areas</span><span class="p">[</span><span class="n">MAX_RESERVED_AREAS</span><span class="p">];</span>

<span class="p">}</span> <span class="n">tdmr_info_entry_t</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></div></div>

<h3 id="copy-tdmr_info-and-its-validation"><span class="me-2">Copy tdmr_info and its validation</span><a href="#copy-tdmr_info-and-its-validation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<p>Because the tdmr_info is generated by the kernel side, TDX should verify the
information before it is copied to the TDX memories. The main loop of the above
function iterates all TDMR passed from the host KVM side and check its validity.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="rouge-code"><pre>    <span class="k">for</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_of_tdmr_entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>                           
    <span class="p">{</span>                                                                           
                                                                                
        <span class="n">tdmr_entry</span><span class="p">.</span><span class="n">raw</span> <span class="o">=</span> <span class="n">tdmr_pa_array</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>                                      
        <span class="n">retval</span> <span class="o">=</span> <span class="n">shared_hpa_check_with_pwr_2_alignment</span><span class="p">(</span><span class="n">tdmr_entry</span><span class="p">,</span> <span class="n">TDMR_INFO_ENTRY_PTR_ARRAY_ALIGNMENT</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="n">TDX_SUCCESS</span><span class="p">)</span>                                              
        <span class="p">{</span>                                                                       
            <span class="n">retval</span> <span class="o">=</span> <span class="n">api_error_with_operand_id</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="n">OPERAND_ID_RCX</span><span class="p">);</span>         
            <span class="n">TDX_ERROR</span><span class="p">(</span><span class="s">"TDMR entry PA is not a valid shared HPA pa=0x%llx, error=0x%llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">tdmr_entry</span><span class="p">.</span><span class="n">raw</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
            <span class="k">goto</span> <span class="n">EXIT</span><span class="p">;</span>                                                          
        <span class="p">}</span>                                                                       
                                                                                
        <span class="n">tdmr_info_p</span> <span class="o">=</span> <span class="p">(</span><span class="n">tdmr_info_entry_t</span><span class="o">*</span><span class="p">)</span><span class="n">map_pa</span><span class="p">(</span><span class="n">tdmr_entry</span><span class="p">.</span><span class="n">raw_void</span><span class="p">,</span> <span class="n">TDX_RANGE_RO</span><span class="p">);</span>
        <span class="n">copy_tdmr_info_entry</span> <span class="p">(</span><span class="n">tdmr_info_p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tdmr_info_copy</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>                 
        <span class="n">free_la</span><span class="p">(</span><span class="n">tdmr_info_p</span><span class="p">);</span>                                                   
                                                                                
                                                                                
        <span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">check_and_set_tdmrs</span><span class="p">(</span><span class="n">tdmr_info_copy</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">pamt_data_array</span><span class="p">))</span> <span class="o">!=</span> <span class="n">TDX_SUCCESS</span><span class="p">)</span>
        <span class="p">{</span>                                                                       
            <span class="n">TDX_ERROR</span><span class="p">(</span><span class="s">"Check and set TDMRs failed</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>                          
            <span class="n">retval</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>                                                       
            <span class="k">goto</span> <span class="n">EXIT</span><span class="p">;</span>                                                          
        <span class="p">}</span>                                                                       
        <span class="n">update_pamt_array</span><span class="p">(</span><span class="n">tdmr_info_copy</span><span class="p">,</span> <span class="n">pamt_data_array</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">i</span><span class="p">);</span> <span class="c1">// save tdmr's pamt data</span>
    <span class="p">}</span>       

</pre></td></tr></tbody></table></code></div></div>

<p>Before validating the passed tdmr_info, it maps the tdmr_info entry, so that it 
can be accessible inside the TDX module. Recall that the passed addresses are 
physical addresses. After the mapping is established, it copies the data from 
host side to TDX module side. From now on, TDMR information can be accessible 
through the tdmr_info_copy array.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="n">api_error_type</span> <span class="nf">check_and_set_tdmrs</span><span class="p">(</span><span class="n">tdmr_info_entry_t</span> <span class="n">tdmr_info_copy</span><span class="p">[</span><span class="n">MAX_TDMRS</span><span class="p">],</span>
        <span class="kt">uint64_t</span> <span class="n">i</span><span class="p">,</span> <span class="n">pamt_data_t</span> <span class="n">pamt_data_array</span><span class="p">[])</span>
<span class="p">{</span>   
    <span class="c1">// Check TDMR_INFO and update the internal TDMR_TABLE with TDMR, reserved areas and PAMT setup:</span>
        
    <span class="kt">uint64_t</span> <span class="n">tdmr_base</span> <span class="o">=</span> <span class="n">tdmr_info_copy</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">tdmr_base</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">prev_tdmr_base</span><span class="p">,</span> <span class="n">prev_tdmr_size</span><span class="p">;</span>
            
    <span class="c1">// Check for integer overflow</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_valid_integer_range</span><span class="p">(</span><span class="n">tdmr_info_copy</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">tdmr_base</span><span class="p">,</span> <span class="n">tdmr_info_copy</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">tdmr_size</span><span class="p">))</span>
    <span class="p">{</span>   
        <span class="n">TDX_ERROR</span><span class="p">(</span><span class="s">"TDMR[%d]: base+size cues integer overflow</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">api_error_with_multiple_info</span><span class="p">(</span><span class="n">TDX_INVALID_TDMR</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
        
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>   
        <span class="n">prev_tdmr_base</span> <span class="o">=</span> <span class="n">tdmr_info_copy</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">tdmr_base</span><span class="p">;</span>
        <span class="n">prev_tdmr_size</span> <span class="o">=</span> <span class="n">tdmr_info_copy</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">tdmr_size</span><span class="p">;</span>
    <span class="p">}</span>
        
    <span class="c1">// TDMRs must be sorted in an ascending base address order.</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">tdmr_base</span> <span class="o">&lt;</span> <span class="n">prev_tdmr_base</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">TDX_ERROR</span><span class="p">(</span><span class="s">"TDMR_BASE[%d]=0x%llx is smaller than TDMR_BASE[%d]=0x%llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">tdmr_info_copy</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">tdmr_base</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">tdmr_info_copy</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">tdmr_base</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">api_error_with_multiple_info</span><span class="p">(</span><span class="n">TDX_NON_ORDERED_TDMR</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// TDMRs must not overlap with other TDMRs.</span>
    <span class="c1">// Check will be correct due to previous (ascension) check correctness.</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tdmr_base</span> <span class="o">&lt;</span> <span class="n">prev_tdmr_base</span> <span class="o">+</span> <span class="n">prev_tdmr_size</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">TDX_ERROR</span><span class="p">(</span><span class="s">"TDMR[%d]: (from 0x%llx to 0x%llx) overlaps TDMR[%d] at 0x%llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">prev_tdmr_base</span><span class="p">,</span> <span class="n">prev_tdmr_base</span> <span class="o">+</span> <span class="n">prev_tdmr_size</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">tdmr_base</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">api_error_with_multiple_info</span><span class="p">(</span><span class="n">TDX_NON_ORDERED_TDMR</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">api_error_type</span> <span class="n">err</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">check_tdmr_area_addresses_and_size</span><span class="p">(</span><span class="n">tdmr_info_copy</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">i</span><span class="p">))</span> <span class="o">!=</span> <span class="n">TDX_SUCCESS</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">check_tdmr_reserved_areas</span><span class="p">(</span><span class="n">tdmr_info_copy</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">i</span><span class="p">))</span> <span class="o">!=</span> <span class="n">TDX_SUCCESS</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">check_tdmr_pamt_areas</span><span class="p">(</span><span class="n">tdmr_info_copy</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">i</span><span class="p">,</span> <span class="n">pamt_data_array</span><span class="p">))</span> <span class="o">!=</span> <span class="n">TDX_SUCCESS</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">check_tdmr_available_areas</span><span class="p">(</span><span class="n">tdmr_info_copy</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">i</span><span class="p">))</span> <span class="o">!=</span> <span class="n">TDX_SUCCESS</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// All checks passed for current TDMR, fill it in our module data:</span>

    <span class="n">set_tdmr_info_in_global_data</span><span class="p">(</span><span class="n">tdmr_info_copy</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">i</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">TDX_SUCCESS</span><span class="p">;</span>

<span class="p">}</span>

</pre></td></tr></tbody></table></code></div></div>
<p>check_and_set_tdmrs validates whether the TDMR regions are sorted ascending 
order, addresses and size has been correctly configured, etc.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">void</span> <span class="nf">set_tdmr_info_in_global_data</span><span class="p">(</span><span class="n">tdmr_info_entry_t</span> <span class="n">tdmr_info_copy</span><span class="p">[</span><span class="n">MAX_TDMRS</span><span class="p">],</span> <span class="kt">uint32_t</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">tdx_module_global_t</span><span class="o">*</span> <span class="n">global_data_ptr</span> <span class="o">=</span> <span class="n">get_global_data</span><span class="p">();</span>
    
    <span class="n">global_data_ptr</span><span class="o">-&gt;</span><span class="n">tdmr_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">base</span> <span class="o">=</span> <span class="n">tdmr_info_copy</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">tdmr_base</span><span class="p">;</span>
    <span class="n">global_data_ptr</span><span class="o">-&gt;</span><span class="n">tdmr_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="n">tdmr_info_copy</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">tdmr_size</span><span class="p">;</span>
    <span class="n">global_data_ptr</span><span class="o">-&gt;</span><span class="n">tdmr_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">last_initialized</span> <span class="o">=</span> <span class="n">global_data_ptr</span><span class="o">-&gt;</span><span class="n">tdmr_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">base</span><span class="p">;</span>
    <span class="n">global_data_ptr</span><span class="o">-&gt;</span><span class="n">tdmr_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">global_data_ptr</span><span class="o">-&gt;</span><span class="n">tdmr_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pamt_1g_base</span> <span class="o">=</span> <span class="n">tdmr_info_copy</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pamt_1g_base</span><span class="p">;</span>
    <span class="n">global_data_ptr</span><span class="o">-&gt;</span><span class="n">tdmr_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pamt_2m_base</span> <span class="o">=</span> <span class="n">tdmr_info_copy</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pamt_2m_base</span><span class="p">;</span>
    <span class="n">global_data_ptr</span><span class="o">-&gt;</span><span class="n">tdmr_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pamt_4k_base</span> <span class="o">=</span> <span class="n">tdmr_info_copy</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pamt_4k_base</span><span class="p">;</span>
    <span class="n">global_data_ptr</span><span class="o">-&gt;</span><span class="n">tdmr_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">num_of_pamt_blocks</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="n">tdmr_info_copy</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">tdmr_size</span> <span class="o">/</span> <span class="n">_1GB</span><span class="p">);</span>
    
    <span class="n">global_data_ptr</span><span class="o">-&gt;</span><span class="n">tdmr_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">num_of_rsvd_areas</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">MAX_RESERVED_AREAS</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">global_data_ptr</span><span class="o">-&gt;</span><span class="n">tdmr_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rsvd_areas</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">offset</span> <span class="o">=</span> <span class="n">tdmr_info_copy</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rsvd_areas</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">offset</span><span class="p">;</span>
        <span class="n">global_data_ptr</span><span class="o">-&gt;</span><span class="n">tdmr_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rsvd_areas</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="n">tdmr_info_copy</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rsvd_areas</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">size</span><span class="p">;</span>
    
        <span class="k">if</span> <span class="p">(</span><span class="n">global_data_ptr</span><span class="o">-&gt;</span><span class="n">tdmr_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rsvd_areas</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// NULL entry is last </span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    
        <span class="n">global_data_ptr</span><span class="o">-&gt;</span><span class="n">tdmr_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">num_of_rsvd_areas</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>   
<span class="p">}</span>       
</pre></td></tr></tbody></table></code></div></div>

<p>The validated TDMR is copied to the <strong>global_data_ptr-&gt;tdmr_table</strong> so that the
TDMR information can be globally accessed during processing TDX operations. 
Recall that <strong>TDMR is not enforced through specific registers</strong>, but checked by
the TDX module (software constraint) during its runtime. Also the information of
the TDMR such as base and size of the TDMR is entirely provided by the host KVM,
but the information is copied to the TDX module during the initialization.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="n">_STATIC_INLINE_</span> <span class="kt">void</span> <span class="nf">update_pamt_array</span> <span class="p">(</span><span class="n">tdmr_info_entry_t</span><span class="o">*</span>   <span class="n">tdmr_info_copy</span><span class="p">,</span> <span class="n">pamt_data_t</span> <span class="n">pamt_data_array</span><span class="p">[],</span> <span class="kt">uint32_t</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>   
    <span class="n">pamt_data_array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pamt_1g_base</span> <span class="o">=</span> <span class="n">tdmr_info_copy</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pamt_1g_base</span><span class="p">;</span>
    <span class="n">pamt_data_array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pamt_1g_size</span> <span class="o">=</span> <span class="n">tdmr_info_copy</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pamt_1g_size</span><span class="p">;</span>
    <span class="n">pamt_data_array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pamt_2m_base</span> <span class="o">=</span> <span class="n">tdmr_info_copy</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pamt_2m_base</span><span class="p">;</span>
    <span class="n">pamt_data_array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pamt_2m_size</span> <span class="o">=</span> <span class="n">tdmr_info_copy</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pamt_2m_size</span><span class="p">;</span>
    <span class="n">pamt_data_array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pamt_4k_base</span> <span class="o">=</span> <span class="n">tdmr_info_copy</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pamt_4k_base</span><span class="p">;</span>
    <span class="n">pamt_data_array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pamt_4k_size</span> <span class="o">=</span> <span class="n">tdmr_info_copy</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pamt_4k_size</span><span class="p">;</span>
<span class="p">}</span>   
</pre></td></tr></tbody></table></code></div></div>

<p>After setting up the global variable for TDMR, set_tdmr_info_in_global_data, it
updates PAMT associated with the TDMR by update_pamt_array. Note that this 
information is used for verifying other TDMRs.</p>

<h2 id="per-package-key-initialization-for-tdx-module"><span class="me-2">Per Package Key initialization for TDX Module</span><a href="#per-package-key-initialization-for-tdx-module" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>
<h3 id="host-kvm-side"><span class="me-2">Host KVM side</span><a href="#host-kvm-side" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>        <span class="cm">/* Config the key of global KeyID on all packages */</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">config_global_keyid</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
                <span class="k">goto</span> <span class="n">out_free_pamts</span><span class="p">;</span>

</pre></td></tr></tbody></table></code></div></div>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">int</span> <span class="nf">config_global_keyid</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>       
        <span class="k">struct</span> <span class="nc">seamcall_ctx</span> <span class="n">sc</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">fn</span> <span class="o">=</span> <span class="n">TDH_SYS_KEY_CONFIG</span> <span class="p">};</span>

        <span class="cm">/*
         * Configure the key of the global KeyID on all packages by
         * calling TDH.SYS.KEY.CONFIG on all packages.
         *      
         * TDH.SYS.KEY.CONFIG may fail with entropy error (which is
         * a recoverable error).  Assume this is exceedingly rare and
         * just return error if encountered instead of retrying.
         */</span>
        <span class="k">return</span> <span class="nf">seamcall_on_each_package_serialized</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>The key initialization should be invoked per CPU package, not per core.</p>

<h3 id="tdx-module-side"><span class="me-2">TDX Module side</span><a href="#tdx-module-side" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="rouge-code"><pre><span class="n">api_error_type</span> <span class="nf">tdh_sys_key_config</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">bool_t</span> <span class="n">tmp_global_lock_acquired</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">tdx_module_global_t</span><span class="o">*</span> <span class="n">tdx_global_data_ptr</span> <span class="o">=</span> <span class="n">get_global_data</span><span class="p">();</span>
    <span class="n">tdx_module_local_t</span><span class="o">*</span> <span class="n">tdx_local_data_ptr</span> <span class="o">=</span> <span class="n">get_local_data</span><span class="p">();</span>
    <span class="n">api_error_type</span> <span class="n">retval</span> <span class="o">=</span> <span class="n">TDX_SYS_BUSY</span><span class="p">;</span>
    <span class="p">......</span>
    <span class="c1">// Execute PCONFIG to configure the TDX-SEAM global private HKID on the package, with a CPU-generated random key.</span>
    <span class="c1">// PCONFIG may fail due to and entropy error or a device busy error.</span>
    <span class="c1">// In this case, the VMM should retry TDHSYSKEYCONFIG.</span>
    <span class="n">retval</span> <span class="o">=</span> <span class="n">program_mktme_keys</span><span class="p">(</span><span class="n">tdx_global_data_ptr</span><span class="o">-&gt;</span><span class="n">hkid</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="n">TDX_SUCCESS</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">TDX_ERROR</span><span class="p">(</span><span class="s">"Failed to program MKTME keys for this package</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="c1">// Clear the package configured bit</span>
        <span class="n">_lock_btr_32b</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tdx_global_data_ptr</span><span class="o">-&gt;</span><span class="n">pkg_config_bitmap</span><span class="p">,</span> <span class="n">tdx_local_data_ptr</span><span class="o">-&gt;</span><span class="n">lp_info</span><span class="p">.</span><span class="n">pkg</span><span class="p">);</span>
        <span class="k">goto</span> <span class="n">EXIT</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Update the number of initialized packages. If this is the last one, update the system state.</span>
    <span class="n">tdx_global_data_ptr</span><span class="o">-&gt;</span><span class="n">num_of_init_pkgs</span><span class="o">++</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tdx_global_data_ptr</span><span class="o">-&gt;</span><span class="n">num_of_init_pkgs</span> <span class="o">==</span> <span class="n">tdx_global_data_ptr</span><span class="o">-&gt;</span><span class="n">num_of_pkgs</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">tdx_global_data_ptr</span><span class="o">-&gt;</span><span class="n">global_state</span><span class="p">.</span><span class="n">sys_state</span> <span class="o">=</span> <span class="n">SYS_READY</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">retval</span> <span class="o">=</span> <span class="n">TDX_SUCCESS</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></div></div>

<p>It sets the MKTME key for TDX module for current CPU package. All information 
required to set MKTME key is stored in the tdx_global_data_ptr including whether
it provides the integrity, how to generate the key, the encryption algorithm &amp;c.
Note that the hkid in the global data of the TDX module is passed from the host 
KVM when the TDH_SYS_CONFIG SEAMCALL is invoked.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="rouge-code"><pre>  <span class="mi">30</span> <span class="n">api_error_code_e</span> <span class="n">program_mktme_keys</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">hkid</span><span class="p">)</span>
  <span class="mi">31</span> <span class="p">{</span>
<span class="p">......</span>
  <span class="mi">38</span>         <span class="c1">// set the command, hkid as keyid and encryption algorithm</span>
  <span class="mi">39</span>         <span class="n">mktme_key_program</span><span class="p">.</span><span class="n">keyid_ctrl</span><span class="p">.</span><span class="n">command</span> <span class="o">=</span> <span class="n">MKTME_KEYID_SET_KEY_RANDOM</span><span class="p">;</span>
  <span class="mi">40</span>     <span class="n">mktme_key_program</span><span class="p">.</span><span class="n">keyid</span> <span class="o">=</span> <span class="n">hkid</span><span class="p">;</span>
  <span class="mi">41</span> 
  <span class="mi">42</span>     <span class="k">if</span> <span class="p">(</span><span class="n">get_sysinfo_table</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">mcheck_fields</span><span class="p">.</span><span class="n">tdx_without_integrity</span><span class="p">)</span>
  <span class="mi">43</span>     <span class="p">{</span>
  <span class="mi">44</span>         <span class="k">if</span> <span class="p">(</span><span class="n">get_global_data</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">plt_common_config</span><span class="p">.</span><span class="n">ia32_tme_activate</span><span class="p">.</span><span class="n">mk_tme_crypto_algs_aes_xts_256</span><span class="p">)</span>
  <span class="mi">45</span>         <span class="p">{</span>
  <span class="mi">46</span>             <span class="n">mktme_key_program</span><span class="p">.</span><span class="n">keyid_ctrl</span><span class="p">.</span><span class="n">enc_algo</span> <span class="o">=</span> <span class="n">AES_XTS_256</span><span class="p">;</span>
  <span class="mi">47</span>         <span class="p">}</span>
  <span class="mi">48</span>         <span class="k">else</span>
  <span class="mi">49</span>         <span class="p">{</span>
  <span class="mi">50</span>             <span class="n">mktme_key_program</span><span class="p">.</span><span class="n">keyid_ctrl</span><span class="p">.</span><span class="n">enc_algo</span> <span class="o">=</span> <span class="n">AES_XTS_128</span><span class="p">;</span>
  <span class="mi">51</span>         <span class="p">}</span>
  <span class="mi">52</span> 
  <span class="mi">53</span>     <span class="p">}</span>
  <span class="mi">54</span>     <span class="k">else</span>
  <span class="mi">55</span>     <span class="p">{</span>
  <span class="mi">56</span>         <span class="n">mktme_key_program</span><span class="p">.</span><span class="n">keyid_ctrl</span><span class="p">.</span><span class="n">enc_algo</span> <span class="o">=</span> <span class="n">AES_XTS_128_WITH_INTEGRITY</span><span class="p">;</span>
  <span class="mi">57</span>     <span class="p">}</span>
  <span class="mi">58</span> 
  <span class="mi">59</span>         <span class="c1">// Execute the PCONFIG instruction with the updated struct and return</span>
  <span class="mi">60</span>         <span class="n">pconfig_return_code</span> <span class="o">=</span> <span class="n">ia32_mktme_key_program</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mktme_key_program</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></div></div>

<p>After setting all information, <strong>PCONFIG</strong> instruction sets the key. Refer to 
ia32_mktme_key_program function detailed implementation.</p>

<h3 id="check-the-global-keyid"><span class="me-2">Check the global keyid</span><a href="#check-the-global-keyid" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<p>global_private_hkid is the keyid for MKTME used for encryption and decryption of
memories belong to the TDX Module. Because it is passed from the host KVM, it 
should be validated whether the HKID belongs to the private HKID range. If it 
belongs to the private HKID range, then it is saved as the ephemeral key for the
TDX module. However, note that the key is not yet configured by MKTME, which
will be done by another SEAMCALL TDH_SYS_KEY_CONFIG.</p>

<h2 id="tdmr-initialization"><span class="me-2">TDMR initialization</span><a href="#tdmr-initialization" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>
<p>The main job of the TDH_SYS_TDMR_INIT SEAMCALL is partially initializing PATM 
blocks associated with the TDMR. Once the PAMT for each 1GB block of TDMR has 
been initialized, it marks that 1GB block as ready for use. After TDMR has been
initialized, the physical pages in 1GB TDMR becomes available for use by any 
TDX functions to create private TD page or a control structure page in 4k 
granularity (e.g., TDH.MEM.PAGE.ADD, TDH.VP.ADDCX, etc).</p>

<h3 id="host-kvm-side-1"><span class="me-2">Host KVM side</span><a href="#host-kvm-side-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<p>For each TDMR, the VMM should execute TDH.SYS.TDMR.INIT providing TDMR start 
address as an input of the SEAMCALL. Recall that the TDMR region is initially
set by the host KVM, so it has information about all TDMR regions.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre>        <span class="cm">/* Initialize TDMRs to complete the TDX module initialization */</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">init_tdmrs</span><span class="p">(</span><span class="n">tdmr_array</span><span class="p">,</span> <span class="n">tdmr_num</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
                <span class="k">goto</span> <span class="n">out_free_pamts</span><span class="p">;</span>
        
        <span class="n">tdx_module_status</span> <span class="o">=</span> <span class="n">TDX_MODULE_INITIALIZED</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></div></div>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="rouge-code"><pre><span class="cm">/* Initialize all TDMRs */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">init_tdmrs</span><span class="p">(</span><span class="k">struct</span> <span class="nc">tdmr_info</span> <span class="o">*</span><span class="n">tdmr_array</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tdmr_num</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

        <span class="cm">/*
         * Initialize TDMRs one-by-one for simplicity, though the TDX
         * architecture does allow different TDMRs to be initialized in
         * parallel on multiple CPUs.  Parallel initialization could
         * be added later when the time spent in the serialized scheme
         * becomes a real concern.
         */</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tdmr_num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

                <span class="n">ret</span> <span class="o">=</span> <span class="n">init_tdmr</span><span class="p">(</span><span class="n">tdmr_array_entry</span><span class="p">(</span><span class="n">tdmr_array</span><span class="p">,</span> <span class="n">i</span><span class="p">));</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
                        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td><td class="rouge-code"><pre><span class="cm">/* Initialize one TDMR */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">init_tdmr</span><span class="p">(</span><span class="k">struct</span> <span class="nc">tdmr_info</span> <span class="o">*</span><span class="n">tdmr</span><span class="p">)</span>
<span class="p">{</span>       
        <span class="n">u64</span> <span class="n">next</span><span class="p">;</span>
                
        <span class="cm">/*      
         * Initializing PAMT entries might be time-consuming (in
         * proportion to the size of the requested TDMR).  To avoid long
         * latency in one SEAMCALL, TDH.SYS.TDMR.INIT only initializes
         * an (implementation-defined) subset of PAMT entries in one
         * invocation.
         *
         * Call TDH.SYS.TDMR.INIT iteratively until all PAMT entries
         * of the requested TDMR are initialized (if next-to-initialize
         * address matches the end address of the TDMR).
         */</span>
        <span class="k">do</span> <span class="p">{</span>
                <span class="k">struct</span> <span class="nc">tdx_module_output</span> <span class="n">out</span><span class="p">;</span>
                <span class="n">u64</span> <span class="n">ret</span><span class="p">;</span>
                
                <span class="n">ret</span> <span class="o">=</span> <span class="n">seamcall</span><span class="p">(</span><span class="n">TDH_SYS_TDMR_INIT</span><span class="p">,</span> <span class="n">tdmr</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">out</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> 
                        <span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
                <span class="cm">/*      
                 * RDX contains 'next-to-initialize' address if
                 * TDH.SYS.TDMR.INT succeeded.
                 */</span>
                <span class="n">next</span> <span class="o">=</span> <span class="n">out</span><span class="p">.</span><span class="n">rdx</span><span class="p">;</span>
                <span class="cm">/* Allow scheduling when needed */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">need_resched</span><span class="p">())</span>
                        <span class="n">cond_resched</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">next</span> <span class="o">&lt;</span> <span class="n">tdmr</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">tdmr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></td></tr></tbody></table></code></div></div>

<h3 id="tdx-module-side-1"><span class="me-2">TDX Module side</span><a href="#tdx-module-side-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<p>This SEAMCALL can be executed concurrently with adding and initializing other 
TDMRs. Also, each TDH.SYS.TDMR.INIT invocation adheres to the latency rules, 
which means it should not take more than a predefined number of clock cycles.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre></td><td class="rouge-code"><pre><span class="n">api_error_type</span> <span class="nf">tdh_sys_tdmr_init</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">tdmr_pa</span><span class="p">)</span>
<span class="p">{</span>

    <span class="n">tdx_module_global_t</span><span class="o">*</span> <span class="n">tdx_global_data_ptr</span><span class="p">;</span>
    <span class="n">tdx_module_local_t</span><span class="o">*</span> <span class="n">tdx_local_data</span> <span class="o">=</span> <span class="n">get_local_data</span><span class="p">();</span>
    <span class="n">api_error_type</span> <span class="n">retval</span><span class="p">;</span>
    <span class="n">bool_t</span> <span class="n">lock_acquired</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

    <span class="n">tdx_local_data</span><span class="o">-&gt;</span><span class="n">vmm_regs</span><span class="p">.</span><span class="n">rdx</span> <span class="o">=</span> <span class="mi">0ULL</span><span class="p">;</span>

    <span class="c1">// For each TDMR, the VMM executes a loop of SEAMCALL(TDHSYSINITTDMR),</span>
    <span class="c1">// providing the TDMR start address (at 1GB granularity) as an input</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_addr_aligned_pwr_of_2</span><span class="p">(</span><span class="n">tdmr_pa</span><span class="p">,</span> <span class="n">_1GB</span><span class="p">)</span> <span class="o">||</span>
        <span class="o">!</span><span class="n">is_pa_smaller_than_max_pa</span><span class="p">(</span><span class="n">tdmr_pa</span><span class="p">)</span> <span class="o">||</span>
        <span class="p">(</span><span class="n">get_hkid_from_pa</span><span class="p">((</span><span class="n">pa_t</span><span class="p">)</span><span class="n">tdmr_pa</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="n">api_error_with_operand_id</span><span class="p">(</span><span class="n">TDX_OPERAND_INVALID</span><span class="p">,</span> <span class="n">OPERAND_ID_RCX</span><span class="p">);</span>
        <span class="k">goto</span> <span class="n">EXIT</span><span class="p">;</span>

    <span class="p">}</span>

    <span class="n">tdx_global_data_ptr</span> <span class="o">=</span> <span class="n">get_global_data</span><span class="p">();</span>

    <span class="c1">//   2.  Verify that the provided TDMR start address belongs to one of the TDMRs set during TDHSYSINIT</span>
    <span class="kt">uint32_t</span> <span class="n">tdmr_index</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">tdmr_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tdmr_index</span> <span class="o">&lt;</span> <span class="n">tdx_global_data_ptr</span><span class="o">-&gt;</span><span class="n">num_of_tdmr_entries</span><span class="p">;</span> <span class="n">tdmr_index</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tdmr_pa</span> <span class="o">==</span> <span class="n">tdx_global_data_ptr</span><span class="o">-&gt;</span><span class="n">tdmr_table</span><span class="p">[</span><span class="n">tdmr_index</span><span class="p">].</span><span class="n">base</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tdmr_index</span> <span class="o">&gt;=</span> <span class="n">tdx_global_data_ptr</span><span class="o">-&gt;</span><span class="n">num_of_tdmr_entries</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="n">api_error_with_operand_id</span><span class="p">(</span><span class="n">TDX_OPERAND_INVALID</span><span class="p">,</span> <span class="n">OPERAND_ID_RCX</span><span class="p">);</span>
        <span class="k">goto</span> <span class="n">EXIT</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">tdmr_entry_t</span> <span class="o">*</span><span class="n">tdmr_entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tdx_global_data_ptr</span><span class="o">-&gt;</span><span class="n">tdmr_table</span><span class="p">[</span><span class="n">tdmr_index</span><span class="p">];</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">acquire_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tdmr_entry</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span> <span class="o">!=</span> <span class="n">LOCK_RET_SUCCESS</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="n">api_error_with_operand_id</span><span class="p">(</span><span class="n">TDX_OPERAND_BUSY</span><span class="p">,</span> <span class="n">OPERAND_ID_RCX</span><span class="p">);</span>
        <span class="k">goto</span> <span class="n">EXIT</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">lock_acquired</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></div></div>

<p>First it checks whether a start address of the passed TDMR matches one of the 
TDMRs that have been initialized before by the TDH_SYS_CONFIG SEAMCALL. Recall
that TDH_SYS_CONFIG just verifies the TDMR and copies the TDMR content to the 
TDX module memory from Host KVM side. tdmr_entry points to the TDMR that needs 
to be initialized in this SEAMCALL invocation.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre></td><td class="rouge-code"><pre>    <span class="p">......</span>
    <span class="c1">//   3.  Retrieves the TDMR’s next-to-initialize address from the internal TDMR data structure.</span>
    <span class="c1">//       If the next-to-initialize address is higher than the address to the last byte of the TDMR, there’s nothing to do.</span>
    <span class="c1">//       If successful, the function does the following:</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tdmr_entry</span><span class="o">-&gt;</span><span class="n">last_initialized</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">tdmr_entry</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">tdmr_entry</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="n">TDX_TDMR_ALREADY_INITIALIZED</span><span class="p">;</span>
        <span class="k">goto</span> <span class="n">EXIT</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">//   4.  Initialize an (implementation defined) number of PAMT entries.</span>
    <span class="c1">//        The maximum number of PAMT entries to be initialized is set to avoid latency issues.</span>
    <span class="c1">//   5.  If the PAMT for a 1GB block of TDMR has been fully initialized, mark that 1GB block as ready for use.</span>
    <span class="c1">//        This means that 4KB pages in this 1GB block may be converted to private pages, e.g., by TDCALL(TDHMEMPAGEADD).</span>
    <span class="c1">//        This can be done concurrently with initializing other TDMRs.</span>

    <span class="n">pamt_block_t</span> <span class="n">pamt_block</span><span class="p">;</span>
    <span class="n">pamt_block</span><span class="p">.</span><span class="n">pamt_1gb_p</span> <span class="o">=</span> <span class="p">(</span><span class="n">pamt_entry_t</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">tdmr_entry</span><span class="o">-&gt;</span><span class="n">pamt_1g_base</span>
            <span class="o">+</span> <span class="p">((</span><span class="n">tdmr_entry</span><span class="o">-&gt;</span><span class="n">last_initialized</span> <span class="o">-</span> <span class="n">tdmr_entry</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">)</span> <span class="o">/</span> <span class="n">_1GB</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="n">pamt_entry_t</span><span class="p">)));</span>
    <span class="n">pamt_block</span><span class="p">.</span><span class="n">pamt_2mb_p</span> <span class="o">=</span> <span class="p">(</span><span class="n">pamt_entry_t</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">tdmr_entry</span><span class="o">-&gt;</span><span class="n">pamt_2m_base</span>
            <span class="o">+</span> <span class="p">((</span><span class="n">tdmr_entry</span><span class="o">-&gt;</span><span class="n">last_initialized</span> <span class="o">-</span> <span class="n">tdmr_entry</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">)</span> <span class="o">/</span> <span class="n">_2MB</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="n">pamt_entry_t</span><span class="p">)));</span>
    <span class="n">pamt_block</span><span class="p">.</span><span class="n">pamt_4kb_p</span> <span class="o">=</span> <span class="p">(</span><span class="n">pamt_entry_t</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">tdmr_entry</span><span class="o">-&gt;</span><span class="n">pamt_4k_base</span>
            <span class="o">+</span> <span class="p">((</span><span class="n">tdmr_entry</span><span class="o">-&gt;</span><span class="n">last_initialized</span> <span class="o">-</span> <span class="n">tdmr_entry</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">)</span> <span class="o">/</span> <span class="n">_4KB</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="n">pamt_entry_t</span><span class="p">)));</span>

    <span class="n">pamt_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pamt_block</span><span class="p">,</span> <span class="n">TDMR_4K_PAMT_INIT_COUNT</span><span class="p">,</span> <span class="n">tdmr_entry</span><span class="p">);</span>

    <span class="c1">//   6.  Store the updated next-to-initialize address in the internal TDMR data structure.</span>
    <span class="n">tdmr_entry</span><span class="o">-&gt;</span><span class="n">last_initialized</span> <span class="o">+=</span> <span class="p">(</span><span class="n">TDMR_4K_PAMT_INIT_COUNT</span> <span class="o">*</span> <span class="n">_4KB</span><span class="p">);</span>
            
    <span class="c1">//   7.  The returned next-to-initialize address is always rounded down to 1GB, so VMM won’t attempt to use a 1GB block that is not fully initialized.</span>
    <span class="n">tdx_local_data</span><span class="o">-&gt;</span><span class="n">vmm_regs</span><span class="p">.</span><span class="n">rdx</span> <span class="o">=</span> <span class="n">tdmr_entry</span><span class="o">-&gt;</span><span class="n">last_initialized</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">_1GB</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    
    <span class="n">retval</span> <span class="o">=</span> <span class="n">TDX_SUCCESS</span><span class="p">;</span>
        
    <span class="n">EXIT</span><span class="o">:</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">lock_acquired</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">release_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tdx_global_data_ptr</span><span class="o">-&gt;</span><span class="n">tdmr_table</span><span class="p">[</span><span class="n">tdmr_index</span><span class="p">].</span><span class="n">lock</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
    <span class="p">}</span>   
</pre></td></tr></tbody></table></code></div></div>

<p>It might not initialize entire PAMT associated with one TDMR at once because of
latency issues. Therefore, the base addresses of each level of PAMT that needs 
to be initialized in this invocation should be calculated based on the last 
initialized addresses base and last addresses.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="mi">168</span> <span class="kt">void</span> <span class="n">pamt_init</span><span class="p">(</span><span class="n">pamt_block_t</span><span class="o">*</span> <span class="n">pamt_block</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">num_4k_entries</span><span class="p">,</span> <span class="n">tdmr_entry_t</span> <span class="o">*</span><span class="n">tdmr_entry</span><span class="p">)</span>
<span class="mi">169</span> <span class="p">{</span>   
<span class="mi">170</span>     <span class="kt">uint64_t</span> <span class="n">start_pamt_4k_p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">pamt_block</span><span class="o">-&gt;</span><span class="n">pamt_4kb_p</span><span class="p">;</span>
<span class="mi">171</span>     <span class="kt">uint64_t</span> <span class="n">end_pamt_4k_p</span> <span class="o">=</span> <span class="n">start_pamt_4k_p</span> <span class="o">+</span> <span class="p">(</span><span class="n">num_4k_entries</span> <span class="o">*</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">pamt_entry_t</span><span class="p">));</span>
<span class="mi">172</span>     
<span class="mi">173</span>     <span class="n">pamt_4kb_init</span><span class="p">(</span><span class="n">pamt_block</span><span class="p">,</span> <span class="n">num_4k_entries</span><span class="p">,</span> <span class="n">tdmr_entry</span><span class="p">);</span>
<span class="mi">174</span>     <span class="n">pamt_nodes_init</span><span class="p">(</span><span class="n">start_pamt_4k_p</span><span class="p">,</span> <span class="n">end_pamt_4k_p</span><span class="p">,</span> <span class="n">pamt_block</span><span class="o">-&gt;</span><span class="n">pamt_2mb_p</span><span class="p">,</span> <span class="n">PAMT_4K_ENTRIES_IN_2MB</span><span class="p">,</span> <span class="n">tdmr_entry</span><span class="p">);</span>
<span class="mi">175</span>     <span class="n">pamt_nodes_init</span><span class="p">(</span><span class="n">start_pamt_4k_p</span><span class="p">,</span> <span class="n">end_pamt_4k_p</span><span class="p">,</span> <span class="n">pamt_block</span><span class="o">-&gt;</span><span class="n">pamt_1gb_p</span><span class="p">,</span> <span class="n">PAMT_4K_ENTRIES_IN_1GB</span><span class="p">,</span> <span class="n">tdmr_entry</span><span class="p">);</span>
<span class="mi">176</span> <span class="p">}</span>  
</pre></td></tr></tbody></table></code></div></div>

<p>It requires different initialization for PAMT correspodning to its level. For
leaf, it invokes pamt_4kb_init, and for non-leafs, it invokes pamt_nodes_init.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre></td><td class="rouge-code"><pre><span class="n">_STATIC_INLINE_</span> <span class="kt">void</span> <span class="nf">pamt_4kb_init</span><span class="p">(</span><span class="n">pamt_block_t</span><span class="o">*</span> <span class="n">pamt_block</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">num_4k_entries</span><span class="p">,</span> <span class="n">tdmr_entry_t</span> <span class="o">*</span><span class="n">tdmr_entry</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">pamt_entry_t</span><span class="o">*</span> <span class="n">pamt_entry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">current_4k_page_idx</span> <span class="o">=</span> <span class="p">((</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">pamt_block</span><span class="o">-&gt;</span><span class="n">pamt_4kb_p</span> <span class="o">-</span> <span class="n">tdmr_entry</span><span class="o">-&gt;</span><span class="n">pamt_4k_base</span><span class="p">)</span>
                                    <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pamt_entry_t</span><span class="p">);</span>
    <span class="kt">uint64_t</span> <span class="n">page_offset</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">last_rsdv_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    
    <span class="c1">// PAMT_CHILD_ENTRIES pamt entries take more than 1 page size, this is why</span>
    <span class="c1">// we need to do a new map each time we reach new page in the entries array</span>
    <span class="c1">// Since we work with chunks of PAMT_CHILD_ENTRIES entries it time,</span>
    <span class="c1">// the start address is always aligned on 4K page</span>
    <span class="kt">uint32_t</span> <span class="n">pamt_entries_in_page</span> <span class="o">=</span> <span class="n">TDX_PAGE_SIZE_IN_BYTES</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pamt_entry_t</span><span class="p">);</span>
    <span class="kt">uint32_t</span> <span class="n">pamt_pages</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="n">num_4k_entries</span> <span class="o">/</span> <span class="n">pamt_entries_in_page</span><span class="p">);</span>
    
    <span class="n">pamt_entry_t</span><span class="o">*</span> <span class="n">pamt_entry_start</span> <span class="o">=</span> <span class="n">pamt_block</span><span class="o">-&gt;</span><span class="n">pamt_4kb_p</span><span class="p">;</span>
    <span class="n">tdx_sanity_check</span><span class="p">(((</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">pamt_entry_start</span> <span class="o">%</span> <span class="n">TDX_PAGE_SIZE_IN_BYTES</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">SCEC_PAMT_MANAGER_SOURCE</span><span class="p">,</span> <span class="mi">11</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pamt_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">pamt_entry</span> <span class="o">=</span> <span class="n">map_pa_with_global_hkid</span><span class="p">(</span>
                <span class="o">&amp;</span><span class="n">pamt_entry_start</span><span class="p">[</span><span class="n">pamt_entries_in_page</span> <span class="o">*</span> <span class="n">i</span><span class="p">],</span> <span class="n">TDX_RANGE_RW</span><span class="p">);</span>
        <span class="c1">// create a cache aligned, cache sized chunk and fill it with 'val'</span>
        <span class="n">ALIGN</span><span class="p">(</span><span class="n">MOVDIR64_CHUNK_SIZE</span><span class="p">)</span> <span class="n">pamt_entry_t</span> <span class="n">chunk</span><span class="p">[</span><span class="n">PAMT_4K_ENTRIES_IN_CACHE</span><span class="p">];</span>
        <span class="n">basic_memset</span><span class="p">((</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">chunk</span><span class="p">,</span> <span class="n">PAMT_4K_ENTRIES_IN_CACHE</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">pamt_entry_t</span><span class="p">),</span> <span class="mi">0</span> <span class="p">,</span> <span class="n">PAMT_4K_ENTRIES_IN_CACHE</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">pamt_entry_t</span><span class="p">));</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">pamt_entries_in_page</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">,</span> <span class="n">current_4k_page_idx</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">page_offset</span> <span class="o">=</span> <span class="n">current_4k_page_idx</span> <span class="o">*</span> <span class="n">TDX_PAGE_SIZE_IN_BYTES</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">is_page_reserved</span><span class="p">(</span><span class="n">page_offset</span><span class="p">,</span> <span class="n">tdmr_entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">last_rsdv_idx</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="n">chunk</span><span class="p">[</span><span class="n">j</span><span class="o">%</span><span class="n">PAMT_4K_ENTRIES_IN_CACHE</span><span class="p">].</span><span class="n">pt</span> <span class="o">=</span> <span class="n">PT_RSVD</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="n">chunk</span><span class="p">[</span><span class="n">j</span><span class="o">%</span><span class="n">PAMT_4K_ENTRIES_IN_CACHE</span><span class="p">].</span><span class="n">pt</span> <span class="o">=</span> <span class="n">PT_NDA</span><span class="p">;</span>
                <span class="n">last_rsdv_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">PAMT_4K_ENTRIES_IN_CACHE</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">fill_cachelines_no_sfence</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pamt_entry</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">3</span><span class="p">]),</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span><span class="n">chunk</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">mfence</span><span class="p">();</span>
        <span class="n">free_la</span><span class="p">(</span><span class="n">pamt_entry</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>The number of 4K PAMT pages that can be initialized at once is set by constant 
TDMR_4K_PAMT_INIT_COUNT (i.e., 1KB PAMT entries in current version) to satisfy 
latency constraint. Based on how many PAMT entries can exist in 4K page, the 
number of PAMT pages that should be initialized will be determined. It iterates
each page and first map the PAMT page. Recall that PAMTs are located at the host
KVM controlled physical memory pages. However, to protect the PAMTs from the 
possibly malicious VMM, it maps the physical addresses of the PAMTs with HKID 
of the TDX module. As a result, the VMM cannot read/write the plain text of the 
PAMTs because HKID used for encryption belongs to the private HKID space. After 
the mapping, based on whether it is reserved or not, each PAMT 4K page’s type is 
set.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="rouge-code"><pre><span class="n">_STATIC_INLINE_</span> <span class="kt">void</span> <span class="nf">pamt_nodes_init</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">start_pamt_4k_p</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">end_pamt_4k_p</span><span class="p">,</span>
        <span class="n">pamt_entry_t</span><span class="o">*</span> <span class="n">nodes_array</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">entries_in_node</span><span class="p">,</span> <span class="n">tdmr_entry_t</span> <span class="o">*</span><span class="n">tdmr_entry</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">pamt_entry_t</span><span class="o">*</span> <span class="n">pamt_entry</span><span class="p">;</span>

    <span class="kt">uint64_t</span> <span class="n">entries_start</span> <span class="o">=</span> <span class="p">(</span><span class="n">start_pamt_4k_p</span> <span class="o">-</span> <span class="n">tdmr_entry</span><span class="o">-&gt;</span><span class="n">pamt_4k_base</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">entries_in_node</span> <span class="o">*</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">pamt_entry_t</span><span class="p">));</span>
    <span class="kt">uint64_t</span> <span class="n">entries_end</span>   <span class="o">=</span> <span class="p">(</span><span class="n">end_pamt_4k_p</span> <span class="o">-</span> <span class="n">tdmr_entry</span><span class="o">-&gt;</span><span class="n">pamt_4k_base</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">entries_in_node</span> <span class="o">*</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">pamt_entry_t</span><span class="p">));</span>

    <span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">((</span><span class="n">entries_end</span> <span class="o">-</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">entries_start</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">void</span><span class="o">*</span> <span class="n">entry_p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nodes_array</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">pamt_entry</span> <span class="o">=</span> <span class="n">map_pa_with_global_hkid</span><span class="p">(</span><span class="n">entry_p</span><span class="p">,</span> <span class="n">TDX_RANGE_RW</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">is_cacheline_aligned</span><span class="p">(</span><span class="n">entry_p</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">zero_cacheline</span><span class="p">(</span><span class="n">pamt_entry</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">pamt_entry</span><span class="o">-&gt;</span><span class="n">pt</span> <span class="o">=</span> <span class="n">PT_NDA</span><span class="p">;</span>
    
        <span class="n">free_la</span><span class="p">(</span><span class="n">pamt_entry</span><span class="p">);</span>
        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>   
</pre></td></tr></tbody></table></code></div></div>

<p>Note that the start and end addresses of the pamt_4k (1st and 2nd params) is 
calculated based on how many 4k PAMTs can be initialized in this SEAMCALL. 
Also, it passes entries_in_node param which is the size of each level of PAMT in
4K PAMT pages, so that the number of PAMT entries that needs to be initialized 
in non-leaf levels can be determined. Rest of the code is similar to the code
for leaf PAMT initialization. Now all other SEAMCALLS are available!!</p>

<h2 id="map-physical-address-in-tdx-module"><span class="me-2">Map physical address in TDX module</span><a href="#map-physical-address-in-tdx-module" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>
<p>Most of the addresses passed from the host KVM to TDX module are physical addr
belong to CMR, which might not be converted to the TDX private pages yet. 
Therefore, to securely accesses those memories, it should map the physical pages
to its private pages beforehand.</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">enum</span>
<span class="p">{</span>       
    <span class="n">TDX_RANGE_RO</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">TDX_RANGE_RW</span>   <span class="o">=</span> <span class="mi">1</span>
<span class="p">}</span> <span class="n">mapping_type_t</span><span class="p">;</span>

<span class="kt">void</span><span class="o">*</span> <span class="nf">map_pa</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">pa</span><span class="p">,</span> <span class="n">mapping_type_t</span> <span class="n">mapping_type</span><span class="p">)</span>
<span class="p">{</span>   
    <span class="k">return</span> <span class="n">map_pa_with_memtype</span><span class="p">(</span><span class="n">pa</span><span class="p">,</span> <span class="n">mapping_type</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>   
</pre></td></tr></tbody></table></code></div></div>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">void</span><span class="o">*</span> <span class="nf">map_pa_with_memtype</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">pa</span><span class="p">,</span> <span class="n">mapping_type_t</span> <span class="n">mapping_type</span><span class="p">,</span> <span class="n">bool_t</span> <span class="n">is_wb_memtype</span><span class="p">)</span>
<span class="p">{</span>   
    <span class="n">keyhole_state_t</span><span class="o">*</span> <span class="n">keyhole_state</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">get_local_data</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">keyhole_state</span><span class="p">;</span>
    <span class="n">bool_t</span> <span class="n">is_writable</span> <span class="o">=</span> <span class="p">(</span><span class="n">mapping_type</span> <span class="o">==</span> <span class="n">TDX_RANGE_RW</span><span class="p">)</span> <span class="o">?</span> <span class="nb">true</span> <span class="o">:</span> <span class="nb">false</span><span class="p">;</span>
    
    <span class="c1">// Search the requested PA first, if it's mapped or cached</span>
    <span class="kt">uint16_t</span> <span class="n">keyhole_idx</span> <span class="o">=</span> <span class="n">hash_table_find_entry</span><span class="p">((</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">pa</span><span class="p">,</span> <span class="n">is_writable</span><span class="p">,</span> <span class="n">is_wb_memtype</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    
<span class="cp">#ifdef DEBUG 
</span>    <span class="c1">// Increment the total ref count and check for overflow</span>
    <span class="n">keyhole_state</span><span class="o">-&gt;</span><span class="n">total_ref_count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">tdx_debug_assert</span><span class="p">(</span><span class="n">keyhole_state</span><span class="o">-&gt;</span><span class="n">total_ref_count</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span> 
<span class="cp">#endif  
</span>    
    <span class="c1">// Requested PA is already mapped/cached</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">keyhole_idx</span> <span class="o">!=</span> <span class="n">UNDEFINED_IDX</span><span class="p">)</span>
    <span class="p">{</span>   
        <span class="n">tdx_debug_assert</span><span class="p">(</span><span class="n">keyhole_idx</span> <span class="o">&lt;</span> <span class="n">MAX_KEYHOLE_PER_LP</span><span class="p">);</span>
        <span class="c1">// If the relevant keyhole is marked for removal, remove it from the LRU cache list</span>
        <span class="c1">// and make it "mapped"</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">keyhole_state</span><span class="o">-&gt;</span><span class="n">keyhole_array</span><span class="p">[</span><span class="n">keyhole_idx</span><span class="p">].</span><span class="n">state</span> <span class="o">==</span> <span class="n">KH_ENTRY_CAN_BE_REMOVED</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">lru_cache_remove_entry</span><span class="p">(</span><span class="n">keyhole_idx</span><span class="p">);</span>
            <span class="n">keyhole_state</span><span class="o">-&gt;</span><span class="n">keyhole_array</span><span class="p">[</span><span class="n">keyhole_idx</span><span class="p">].</span><span class="n">state</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="n">KH_ENTRY_MAPPED</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">keyhole_state</span><span class="o">-&gt;</span><span class="n">keyhole_array</span><span class="p">[</span><span class="n">keyhole_idx</span><span class="p">].</span><span class="n">ref_count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="c1">// Protection against speculative attacks on sensitive physical addresses</span>
        <span class="n">lfence</span><span class="p">();</span>

        <span class="c1">// In any case, both MAPPED and CAN_BE_REMOVED - return the existing LA to the user</span>
        <span class="k">return</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="n">la_from_keyhole_idx</span><span class="p">(</span><span class="n">keyhole_idx</span><span class="p">)</span> <span class="o">|</span> <span class="n">PG_OFFSET</span><span class="p">((</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">pa</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="c1">// If it's not mapped, take the entry from LRU tail</span>
    <span class="c1">// If there are any free entries, they will be first from tail in the LRU list</span>
    <span class="n">keyhole_idx</span> <span class="o">=</span> <span class="n">keyhole_state</span><span class="o">-&gt;</span><span class="n">lru_tail</span><span class="p">;</span>

    <span class="c1">// Check if there any available keyholes left, otherwise - kill the module</span>
    <span class="n">tdx_sanity_check</span><span class="p">(</span><span class="n">keyhole_idx</span> <span class="o">!=</span> <span class="n">UNDEFINED_IDX</span><span class="p">,</span> <span class="n">SCEC_KEYHOLE_MANAGER_SOURCE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="n">keyhole_entry_t</span><span class="o">*</span> <span class="n">target_keyhole</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">keyhole_state</span><span class="o">-&gt;</span><span class="n">keyhole_array</span><span class="p">[</span><span class="n">keyhole_idx</span><span class="p">];</span>

    <span class="kt">uint64_t</span> <span class="n">la</span> <span class="o">=</span> <span class="n">la_from_keyhole_idx</span><span class="p">(</span><span class="n">keyhole_idx</span><span class="p">)</span> <span class="o">|</span> <span class="n">PG_OFFSET</span><span class="p">((</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">pa</span><span class="p">);</span>

    <span class="c1">// Remove the entry from the LRU list - valid for both FREE and CAN_BE_REMOVED</span>
    <span class="n">lru_cache_remove_entry</span><span class="p">(</span><span class="n">keyhole_idx</span><span class="p">);</span>

    <span class="c1">// If a cached entry is being reused:</span>
    <span class="n">bool_t</span> <span class="n">flush</span> <span class="o">=</span> <span class="p">(</span><span class="n">target_keyhole</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">KH_ENTRY_CAN_BE_REMOVED</span><span class="p">);</span>

    <span class="c1">// Remove it from LRU list, remove it from the search hash table, and flush TLB</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">flush</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">hash_table_remove_entry</span><span class="p">(</span><span class="n">target_keyhole</span><span class="o">-&gt;</span><span class="n">mapped_pa</span><span class="p">,</span> <span class="n">target_keyhole</span><span class="o">-&gt;</span><span class="n">is_writable</span><span class="p">,</span>
                                <span class="n">target_keyhole</span><span class="o">-&gt;</span><span class="n">is_wb_memtype</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Update the entry info, insert it to the search hash table, and fill the actual PTE</span>
    <span class="n">target_keyhole</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">KH_ENTRY_MAPPED</span><span class="p">;</span>
    <span class="n">target_keyhole</span><span class="o">-&gt;</span><span class="n">mapped_pa</span> <span class="o">=</span> <span class="n">PG_START</span><span class="p">((</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">pa</span><span class="p">);</span>
    <span class="n">target_keyhole</span><span class="o">-&gt;</span><span class="n">is_writable</span> <span class="o">=</span> <span class="n">is_writable</span><span class="p">;</span>
    <span class="n">target_keyhole</span><span class="o">-&gt;</span><span class="n">is_wb_memtype</span> <span class="o">=</span> <span class="n">is_wb_memtype</span><span class="p">;</span>
    <span class="n">target_keyhole</span><span class="o">-&gt;</span><span class="n">ref_count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="n">hash_table_insert_entry</span><span class="p">((</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">pa</span><span class="p">,</span> <span class="n">keyhole_idx</span><span class="p">);</span>
    <span class="n">fill_keyhole_pte</span><span class="p">(</span><span class="n">keyhole_idx</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">pa</span><span class="p">,</span> <span class="n">is_writable</span><span class="p">,</span> <span class="n">is_wb_memtype</span><span class="p">);</span>

    <span class="c1">// Flush the TLB for a reused entry - ***AFTER*** the PTE was updated</span>
    <span class="c1">// If INVLPG is done before the PTE is updated - the TLB entry may not be flushed properly</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">flush</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ia32_invalidate_tlb_entries</span><span class="p">(</span><span class="n">la</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Protection against speculative attacks on sensitive physical addresses</span>
    <span class="n">lfence</span><span class="p">();</span>

    <span class="k">return</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">la</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p><strong>Each logical processor</strong> has keyhole state that manages keyhole entries 
(keyhole_entry_t) holding physical to linear PTE mappings. Why we need keyhole..?</p>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">PACKED</span> <span class="n">keyhole_state_s</span>
<span class="p">{</span>
    <span class="cm">/**
     * Each index in the keyhole_array presents an offset of the mapped linear address.
     * The array also implement and LRU doubly linked-list.
     */</span>
    <span class="n">keyhole_entry_t</span> <span class="n">keyhole_array</span><span class="p">[</span><span class="n">MAX_KEYHOLE_PER_LP</span><span class="p">];</span>
    <span class="cm">/**
     * A hash table, its index represents the index in the keyhole_array
     * that it is mapped to.
     */</span>
    <span class="kt">uint16_t</span>  <span class="n">hash_table</span><span class="p">[</span><span class="n">MAX_KEYHOLE_PER_LP</span><span class="p">];</span>
    <span class="cm">/**
     * lru_head and lru_tail present the index of the keyhole_array LRU
     * doubly linked-list.
     */</span>
    <span class="kt">uint16_t</span>  <span class="n">lru_head</span><span class="p">;</span>
    <span class="kt">uint16_t</span>  <span class="n">lru_tail</span><span class="p">;</span>
    
<span class="cp">#ifdef DEBUG
</span>    <span class="cm">/** 
     * total_ref_count counts the total amount of non-statically mapped linear addresses.
     * Incremented on map_pa and decremented on free_la
     */</span>
    <span class="kt">uint64_t</span>  <span class="n">total_ref_count</span><span class="p">;</span>
<span class="cp">#endif
</span><span class="p">}</span> <span class="n">keyhole_state_t</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></div></div>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">PACKED</span> <span class="n">keyhole_entry_s</span>
<span class="p">{</span>   
    <span class="kt">uint64_t</span>  <span class="n">mapped_pa</span><span class="p">;</span>  <span class="cm">/**&lt; mapped physical address of this keyhole entry */</span>
    <span class="cm">/**
     * lru_next and lru_prev present an LRU doubly linked-list.
     */</span>
    <span class="kt">uint16_t</span>  <span class="n">lru_next</span><span class="p">;</span>
    <span class="kt">uint16_t</span>  <span class="n">lru_prev</span><span class="p">;</span>
    <span class="kt">uint16_t</span>  <span class="n">hash_list_next</span><span class="p">;</span>  <span class="cm">/**&lt; next element in hash list */</span>
    <span class="cm">/**     
     * state can be KH_ENTRY_FREE or KH_ENTRY_MAPPED or KH_ENTRY_CAN_BE_REMOVED.
     */</span>
    <span class="kt">uint8_t</span>   <span class="n">state</span><span class="p">;</span>
    <span class="n">bool_t</span>    <span class="n">is_writable</span><span class="p">;</span>  <span class="cm">/**&lt; is PTE set to be Read-only or RW */</span>
    <span class="n">bool_t</span>    <span class="n">is_wb_memtype</span><span class="p">;</span> <span class="cm">/**&lt; is PTE should be with WB or UC memtype */</span>

    <span class="kt">uint32_t</span> <span class="n">ref_count</span><span class="p">;</span> <span class="cm">/** reference count of pages mapped in keyhole manager */</span>
<span class="p">}</span> <span class="n">keyhole_entry_t</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></div></div>

<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre><span class="cm">/** 
 * @struct kot_t
 *  
 * @brief KOT = Key Ownership Table
 *  
 * KOT is used to manage HKIDs state and ownership by TDs
 */</span> 
<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">kot_s</span>
<span class="p">{</span>
    <span class="n">sharex_lock_t</span> <span class="n">lock</span><span class="p">;</span> <span class="cm">/**&lt; shared exclusve lock to access the kot */</span>
    <span class="cm">/**
     * A table of MAX_HKIDS entries, indexed by HKID
     */</span>
    <span class="n">kot_entry_t</span> <span class="n">entries</span><span class="p">[</span><span class="n">MAX_HKIDS</span><span class="p">];</span>
<span class="p">}</span> <span class="n">kot_t</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></div></div>

<h3 id="other-interfaces"><span class="me-2">Other interfaces</span><a href="#other-interfaces" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-cpp highlighter-rouge"><div class="code-header">
        <span data-label-text="Cpp"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre><span class="n">_STATIC_INLINE_</span> <span class="kt">void</span><span class="o">*</span> <span class="nf">map_pa_with_global_hkid</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">pa</span><span class="p">,</span> <span class="n">mapping_type_t</span> <span class="n">mapping_type</span><span class="p">)</span>
<span class="p">{</span>       
    <span class="kt">uint16_t</span> <span class="n">tdx_global_hkid</span> <span class="o">=</span> <span class="n">get_global_data</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">hkid</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">map_pa_with_hkid</span><span class="p">(</span><span class="n">pa</span><span class="p">,</span> <span class="n">tdx_global_hkid</span><span class="p">,</span> <span class="n">mapping_type</span><span class="p">);</span>
<span class="p">}</span>       

<span class="n">_STATIC_INLINE_</span> <span class="kt">void</span><span class="o">*</span> <span class="nf">map_pa_with_hkid</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">pa</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">hkid</span><span class="p">,</span> <span class="n">mapping_type_t</span> <span class="n">mapping_type</span><span class="p">)</span> 
<span class="p">{</span>   
    <span class="n">pa_t</span> <span class="n">temp_pa</span> <span class="o">=</span> <span class="p">{.</span><span class="n">raw_void</span> <span class="o">=</span> <span class="n">pa</span><span class="p">};</span>
    <span class="n">pa_t</span> <span class="n">pa_with_hkid</span> <span class="o">=</span> <span class="n">set_hkid_to_pa</span><span class="p">(</span><span class="n">temp_pa</span><span class="p">,</span> <span class="n">hkid</span><span class="p">);</span>
    <span class="k">return</span> <span class="nf">map_pa</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="n">pa_with_hkid</span><span class="p">.</span><span class="n">raw</span><span class="p">,</span> <span class="n">mapping_type</span><span class="p">);</span>
<span class="p">}</span>   
        
</pre></td></tr></tbody></table></code></div></div>

<!--

[[/assets/img/TDX//tdcs-mm-alloc.png]]

[[/assets/img/TDX//tdmr-resource-reclam.png]]
-->


  </div>

  <div class="post-tail-wrapper text-muted">
    <!-- categories -->
    
      <div class="post-meta mb-3">
        <i class="far fa-folder-open fa-fw me-1"></i>
        
          <a href="/categories/confidential-computing/">Confidential Computing</a>,
          <a href="/categories/intel-tdx/">Intel TDX</a>,
          <a href="/categories/kvm/">KVM</a>,
          <a href="/categories/qemu/">QEMU</a>
      </div>
    

    <!-- tags -->
    

    <div
      class="
        post-tail-bottom
        d-flex justify-content-between align-items-center mt-5 pb-2
      "
    >
      <div class="license-wrapper">
        
          

          This post is licensed under 
        <a href="https://creativecommons.org/licenses/by/4.0/">
          CC BY 4.0
        </a>
         by the author.
        
      </div>

      <!-- Post sharing snippet -->

<div class="share-wrapper d-flex align-items-center">
  <span class="share-label text-muted">Share</span>
  <span class="share-icons">
    
    
    

    

      

      <a
        href="https://twitter.com/intent/tweet?text=TDX%20Module%20Life%20Cycle%20Part%202%20-%20Ruach&url=https%3A%2F%2Fruach.github.io%2Fposts%2FTDX-MODULE-LIFECYCLE-2%2F"
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="Twitter"
        target="_blank"
        rel="noopener"
        aria-label="Twitter"
      >
        <i class="fa-fw fa-brands fa-square-x-twitter"></i>
      </a>
    

      

      <a
        href="https://www.facebook.com/sharer/sharer.php?title=TDX%20Module%20Life%20Cycle%20Part%202%20-%20Ruach&u=https%3A%2F%2Fruach.github.io%2Fposts%2FTDX-MODULE-LIFECYCLE-2%2F"
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="Facebook"
        target="_blank"
        rel="noopener"
        aria-label="Facebook"
      >
        <i class="fa-fw fab fa-facebook-square"></i>
      </a>
    

      

      <a
        href="https://t.me/share/url?url=https%3A%2F%2Fruach.github.io%2Fposts%2FTDX-MODULE-LIFECYCLE-2%2F&text=TDX%20Module%20Life%20Cycle%20Part%202%20-%20Ruach"
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="Telegram"
        target="_blank"
        rel="noopener"
        aria-label="Telegram"
      >
        <i class="fa-fw fab fa-telegram"></i>
      </a>
    

      

      <a
        href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fruach.github.io%2Fposts%2FTDX-MODULE-LIFECYCLE-2%2F"
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="Linkedin"
        target="_blank"
        rel="noopener"
        aria-label="Linkedin"
      >
        <i class="fa-fw fab fa-linkedin"></i>
      </a>
    

    <button
      id="copy-link"
      aria-label="Copy link"
      class="btn small"
      data-bs-toggle="tooltip"
      data-bs-placement="top"
      title="Copy link"
      data-title-succeed="Link copied successfully!"
    >
      <i class="fa-fw fas fa-link pe-none fs-6"></i>
    </button>
  </span>
</div>

    </div>
    <!-- .post-tail-bottom -->
  </div>
  <!-- div.post-tail-wrapper -->
</article>


            
          </main>

          <!-- panel -->
          <aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 mb-5 text-muted">
            <div class="access">
              <!-- Get the last 5 posts from lastmod list. -->















              <!-- The trending tags list -->


















            </div>

            
              
              



  <section id="toc-wrapper" class="ps-0 pe-4">
    <h2 class="panel-heading ps-3 pt-2 mb-2">Contents</h2>
    <nav id="toc"></nav>
  </section>


            
          </aside>
        </div>

        <div class="row">
          <!-- tail -->
          <div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4">
            
              
              <!-- Recommend the other 3 posts according to the tags and categories of the current post. -->

<!-- The total size of related posts -->


<!-- An random integer that bigger than 0 -->


<!-- Equals to TAG_SCORE / {max_categories_hierarchy} -->














  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  
    
  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  











  <aside id="related-posts" aria-labelledby="related-label">
    <h3 class="mb-4" id="related-label">Further Reading</h3>
    <nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4">
      
        <article class="col">
          <a href="/posts/SPT-AND-MEMSLOT/" class="post-preview card h-100">
            <div class="card-body">
              <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->




<time
  
  data-ts="1681099200"
  data-df="ll"
  
>
  Apr 10, 2023
</time>

              <h4 class="pt-0 my-2">Shadow Page Table (SPT) and MEMSLOT</h4>
              <div class="text-muted">
                <p>
                  





                  Shadow Page Table (SPT)
Before the introduction of TDP, shadow paging has been utilized to translate
GPA to HPA. The KVM module utilize a unified concept to abstract the 
structure managing this tr...
                </p>
              </div>
            </div>
          </a>
        </article>
      
        <article class="col">
          <a href="/posts/QEMU-KVM-ADDRESS-SPACE/" class="post-preview card h-100">
            <div class="card-body">
              <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->




<time
  
  data-ts="1681185600"
  data-df="ll"
  
>
  Apr 11, 2023
</time>

              <h4 class="pt-0 my-2">QEMU Side Memory Management for VM with RAMBLOCK</h4>
              <div class="text-muted">
                <p>
                  





                  QEMU side memory management

  The MemoryRegion is the link between guest physical address space and the 
RAMBlocks containing the memory. Each MemoryRegion has the ram_addr_t offset 
of the RAMBlo...
                </p>
              </div>
            </div>
          </a>
        </article>
      
        <article class="col">
          <a href="/posts/PAGEFAULT-HANDLING-KVM-TDX/" class="post-preview card h-100">
            <div class="card-body">
              <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->




<time
  
  data-ts="1681531200"
  data-df="ll"
  
>
  Apr 15, 2023
</time>

              <h4 class="pt-0 my-2">KVM page-fault handling for TDX</h4>
              <div class="text-muted">
                <p>
                  





                  Basic idea to implement private page

  Because shared EPT is the same as the existing EPT, use the existing logic for
shared EPT.  On the other hand, secure EPT requires additional operations
inst...
                </p>
              </div>
            </div>
          </a>
        </article>
      
    </nav>
  </aside>
  <!-- #related-posts -->


            
              
              <!-- Navigation buttons at the bottom of the post. -->

<nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation">
  
  

  
    <a
      href="/posts/TDX-MODULE-LIFECYCLE-1/"
      class="btn btn-outline-primary"
      aria-label="Older"
    >
      <p>TDX Module Life Cycle Part 1</p>
    </a>
  

  
    <a
      href="/posts/TD-VM-LIFECYCLE-1/"
      class="btn btn-outline-primary"
      aria-label="Newer"
    >
      <p>TD VM Life Cycle Part 1</p>
    </a>
  
</nav>

            
              
              <!--  The comments switcher -->

  
  <!-- The Disqus lazy loading. -->

<div id="disqus_thread">
  <p class="text-center text-muted small">Comments powered by <a href="https://disqus.com/">Disqus</a>.</p>
</div>

<script type="text/javascript">
  var disqus_config = function () {
    this.page.url = 'https://ruach.github.io/posts/TDX-MODULE-LIFECYCLE-2/';
    this.page.identifier = '/posts/TDX-MODULE-LIFECYCLE-2/';
  };

  /* Lazy loading */
  var disqus_observer = new IntersectionObserver(
    function (entries) {
      if (entries[0].isIntersecting) {
        (function () {
          var d = document,
            s = d.createElement('script');
          s.src = 'https://ruach.disqus.com/embed.js';
          s.setAttribute('data-timestamp', +new Date());
          (d.head || d.body).appendChild(s);
        })();

        disqus_observer.disconnect();
      }
    },
    { threshold: [0] }
  );

  disqus_observer.observe(document.querySelector('#disqus_thread'));

  /* Auto switch theme */
  function reloadDisqus() {
    if (event.source === window && event.data && event.data.direction === ModeToggle.ID) {
      /* Disqus hasn't been loaded */
      if (typeof DISQUS === 'undefined') {
        return;
      }

      if (document.readyState == 'complete') {
        DISQUS.reset({ reload: true, config: disqus_config });
      }
    }
  }

  if (document.querySelector('.mode-toggle')) {
    window.addEventListener('message', reloadDisqus);
  }
</script>



            

            <!-- The Footer -->

<footer
  aria-label="Site Info"
  class="
    d-flex flex-column justify-content-center text-muted
    flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3
  "
>
  <p>
    ©
    <time>2024</time>
    <a href="https://ruach.github.io">Jaehyuk Lee</a>.
    
      <span
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author."
      >Some rights reserved.</span>
    
  </p>

  <p>Using the <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme for <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>
  </p>
</footer>

          </div>
        </div>

        <!-- The Search results -->

<div id="search-result-wrapper" class="d-flex justify-content-center unloaded">
  <div class="col-11 content">
    <div id="search-hints">
      <!-- The trending tags list -->


















    </div>
    <div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div>
  </div>
</div>

      </div>

      <aside aria-label="Scroll to Top">
        <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow">
          <i class="fas fa-angle-up"></i>
        </button>
      </aside>
    </div>

    <div id="mask"></div>

    
      <aside
  id="notification"
  class="toast"
  role="alert"
  aria-live="assertive"
  aria-atomic="true"
  data-bs-animation="true"
  data-bs-autohide="false"
>
  <div class="toast-header">
    <button
      type="button"
      class="btn-close ms-auto"
      data-bs-dismiss="toast"
      aria-label="Close"
    ></button>
  </div>
  <div class="toast-body text-center pt-0">
    <p class="px-2 mb-3">A new version of content is available.</p>
    <button type="button" class="btn btn-primary" aria-label="Update">
      Update
    </button>
  </div>
</aside>

    

    <!-- JavaScripts -->

    <!-- JS selector for site. -->

<!-- commons -->



<!-- layout specified -->


  

  
    <!-- image lazy-loading & popup & clipboard -->
    
  















  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  



  <script src="https://cdn.jsdelivr.net/combine/npm/jquery@3.7.1/dist/jquery.min.js,npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js,npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/magnific-popup@1.1.0/dist/jquery.magnific-popup.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.10/dayjs.min.js,npm/dayjs@1.11.10/locale/en.min.js,npm/dayjs@1.11.10/plugin/relativeTime.min.js,npm/dayjs@1.11.10/plugin/localizedFormat.min.js,npm/tocbot@4.21.2/dist/tocbot.min.js"></script>






<script defer src="/assets/js/dist/post.min.js"></script>






    

    <!--
  Jekyll Simple Search loader
  See: <https://github.com/christian-fei/Simple-Jekyll-Search>
-->





<script>
  /* Note: dependent library will be loaded in `js-selector.html` */
  SimpleJekyllSearch({
    searchInput: document.getElementById('search-input'),
    resultsContainer: document.getElementById('search-results'),
    json: '/assets/js/data/search.json',
    searchResultTemplate: '  <article class="px-1 px-sm-2 px-lg-4 px-xl-0">    <header>      <h2><a href="{url}">{title}</a></h2>      <div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1">        {categories}        {tags}      </div>    </header>    <p>{snippet}</p>  </article>',
    noResultsText: '<p class="mt-5"></p>',
    templateMiddleware: function(prop, value, template) {
      if (prop === 'categories') {
        if (value === '') {
          return `${value}`;
        } else {
          return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`;
        }
      }

      if (prop === 'tags') {
        if (value === '') {
          return `${value}`;
        } else {
          return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`;
        }
      }
    }
  });
</script>

  </body>
</html>

