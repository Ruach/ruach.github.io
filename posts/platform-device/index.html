<!doctype html>














<!-- `site.alt_lang` can specify a language different from the UI -->
<html lang="en" data-mode="light">
  <!-- The Head -->

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta
    name="viewport"
    content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover"
  >

  

  

  
    <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v4.3.3" />
<meta property="og:title" content="Platform Device" />
<meta property="og:locale" content="en" />
<meta name="description" content="Kernel initialization before DeviceTree Although we are not going to cover the details of the initialization procedure, this post will take a look at what happens before the device tree is initialized." />
<meta property="og:description" content="Kernel initialization before DeviceTree Although we are not going to cover the details of the initialization procedure, this post will take a look at what happens before the device tree is initialized." />
<link rel="canonical" href="https://ruach.github.io/posts/platform-device/" />
<meta property="og:url" content="https://ruach.github.io/posts/platform-device/" />
<meta property="og:site_name" content="Ruach" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-05-01T00:00:00-04:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Platform Device" />
<meta name="twitter:site" content="@ruach_lee" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2021-05-01T00:00:00-04:00","datePublished":"2021-05-01T00:00:00-04:00","description":"Kernel initialization before DeviceTree Although we are not going to cover the details of the initialization procedure, this post will take a look at what happens before the device tree is initialized.","headline":"Platform Device","mainEntityOfPage":{"@type":"WebPage","@id":"https://ruach.github.io/posts/platform-device/"},"url":"https://ruach.github.io/posts/platform-device/"}</script>
<!-- End Jekyll SEO tag -->

  

  <title>Platform Device | Ruach
  </title>

  <!--
  The Favicons for Web, Android, Microsoft, and iOS (iPhone and iPad) Apps
  Generated by: https://realfavicongenerator.net/
-->



<link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png">
<link rel="manifest" href="/assets/img/favicons/site.webmanifest">
<link rel="shortcut icon" href="/assets/img/favicons/favicon.ico">
<meta name="apple-mobile-web-app-title" content="Ruach">
<meta name="application-name" content="Ruach">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml">
<meta name="theme-color" content="#ffffff">


  
    
      <link rel="preconnect" href="https://fonts.googleapis.com" >
      <link rel="dns-prefetch" href="https://fonts.googleapis.com" >
    
      <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
      <link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin>
    
      <link rel="preconnect" href="https://fonts.googleapis.com" >
      <link rel="dns-prefetch" href="https://fonts.googleapis.com" >
    
      <link rel="preconnect" href="https://cdn.jsdelivr.net" >
      <link rel="dns-prefetch" href="https://cdn.jsdelivr.net" >
    

    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap">
  

  <!-- GA -->
  

  <!-- Bootstrap -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css">

  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.2/css/all.min.css">

  <link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css">

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.21.2/dist/tocbot.min.css">
  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css">
  

  
    <!-- Manific Popup -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css">
  

  <!-- JavaScript -->

  

  <!-- A placeholder to allow defining custom metadata -->

</head>


  <body>
    <!-- The Side Bar -->

<aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end">
  <header class="profile-wrapper">
    <a href="/" id="avatar" class="rounded-circle">
      
        
        <img src="/assets/img/jaehyuk.png" width="112" height="112" alt="avatar" onerror="this.style.display='none'">
      
    </a>

    <h1 class="site-title">
      <a href="/">Ruach</a>
    </h1>
    <p class="site-subtitle fst-italic mb-0">Jaehyuk Lee</p>
  </header>
  <!-- .profile-wrapper -->

  <nav class="flex-column flex-grow-1 w-100 ps-0">
    <ul class="nav">
      <!-- home -->
      <li class="nav-item">
        <a href="/" class="nav-link">
          <i class="fa-fw fas fa-home"></i>
          <span>HOME</span>
        </a>
      </li>
      <!-- the real tabs -->
      
        <li class="nav-item">
          <a href="/categories/" class="nav-link">
            <i class="fa-fw fas fa-stream"></i>
            

            <span>CATEGORIES</span>
          </a>
        </li>
        <!-- .nav-item -->
      
        <li class="nav-item">
          <a href="/archives/" class="nav-link">
            <i class="fa-fw fas fa-archive"></i>
            

            <span>ARCHIVES</span>
          </a>
        </li>
        <!-- .nav-item -->
      
        <li class="nav-item">
          <a href="/about/" class="nav-link">
            <i class="fa-fw fas fa-info-circle"></i>
            

            <span>ABOUT</span>
          </a>
        </li>
        <!-- .nav-item -->
      
    </ul>
  </nav>

  <div class="sidebar-bottom d-flex flex-wrap  align-items-center w-100">
    

    
      

      
        <a
          href="javascript:location.href = 'mailto:' + ['jaehyuk','gatech.edu'].join('@')"
          aria-label="email"
          

          

          

          
        >
          <i class="fas fa-envelope"></i>
        </a>
      
    
      

      
        <a
          href="https://www.linkedin.com/in/jaehyuk-lee-29b33b121/"
          aria-label="linkedin"
          

          
            target="_blank"
            
          

          

          
            rel="noopener noreferrer"
          
        >
          <i class="fab fa-linkedin"></i>
        </a>
      
    
      

      
        <a
          href="https://github.com/Ruach"
          aria-label="github"
          

          
            target="_blank"
            
          

          

          
            rel="noopener noreferrer"
          
        >
          <i class="fab fa-github"></i>
        </a>
      
    
      

      
        <a
          href="https://stackoverflow.com/users/4460514/ruach?tab=profile"
          aria-label="stack-overflow"
          

          
            target="_blank"
            
          

          

          
            rel="noopener noreferrer"
          
        >
          <i class="fab fa-stack-overflow"></i>
        </a>
      
    
  </div>
  <!-- .sidebar-bottom -->
</aside>
<!-- #sidebar -->


    <div id="main-wrapper" class="d-flex justify-content-center">
      <div class="container d-flex flex-column px-xxl-5">
        <!-- The Top Bar -->

<header id="topbar-wrapper" aria-label="Top Bar">
  <div
    id="topbar"
    class="d-flex align-items-center justify-content-between px-lg-3 h-100"
  >
    <nav id="breadcrumb" aria-label="Breadcrumb">
      

      
        
          
            <span>
              <a href="/">
                Home
              </a>
            </span>

          
        
          
        
          
            
              <span>Platform Device</span>
            

          
        
      
    </nav>
    <!-- endof #breadcrumb -->

    <button type="button" id="sidebar-trigger" class="btn btn-link">
      <i class="fas fa-bars fa-fw"></i>
    </button>

    <div id="topbar-title">
      Post
    </div>

    <button type="button" id="search-trigger" class="btn btn-link">
      <i class="fas fa-search fa-fw"></i>
    </button>

    <search class="align-items-center ms-3 ms-lg-0">
      <i class="fas fa-search fa-fw"></i>
      <input
        class="form-control"
        id="search-input"
        type="search"
        aria-label="search"
        autocomplete="off"
        placeholder="Search..."
      >
    </search>
    <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button>
  </div>
</header>


        <div class="row flex-grow-1">
          <main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4">
            
              <!-- Refactor the HTML structure -->



<!--
  In order to allow a wide table to scroll horizontally,
  we suround the markdown table with `<div class="table-wrapper">` and `</div>`
-->



<!--
  Fixed kramdown code highlight rendering:
  https://github.com/penibelst/jekyll-compress-html/issues/101
  https://github.com/penibelst/jekyll-compress-html/issues/71#issuecomment-188144901
-->



<!-- Change the icon of checkbox -->



<!-- Handle images -->





<!-- Add header for code snippets -->



<!-- Create heading anchors -->





  
  

  
    
    

    
      
        
        
      

      
      

      
      
      

      
    

    
  

  
  

  
    
    

    
      
        
        
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    

    
  

  
  

  

  
  

  




<!-- return -->




<article class="px-1">
  <header>
    <h1 data-toc-skip>Platform Device</h1>

    <div class="post-meta text-muted">
      <!-- published date -->
      <span>
        Posted
        <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->




<time
  
  data-ts="1619841600"
  data-df="ll"
  
    data-bs-toggle="tooltip" data-bs-placement="bottom"
  
>
  May  1, 2021
</time>

      </span>

      <!-- lastmod date -->
      

      

      <div class="d-flex justify-content-between">
        <!-- author(s) -->
        <span>
          

          By

          <em>
            
              <a href="https://ruach.github.io">Jaehyuk Lee</a>
            
          </em>
        </span>

        <!-- read time -->
        <!-- Calculate the post's reading time, and display the word count in tooltip -->



<!-- words per minute -->










<!-- return element -->
<span
  class="readtime"
  data-bs-toggle="tooltip"
  data-bs-placement="bottom"
  title="14678 words"
>
  <em>81 min</em> read</span>

      </div>
      <!-- .d-flex -->
    </div>
    <!-- .post-meta -->
  </header>

  <div class="content">
    <h3 id="kernel-initialization-before-devicetree"><span class="me-2">Kernel initialization before DeviceTree</span><a href="#kernel-initialization-before-devicetree" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<p>Although we are not going to cover the details of the initialization procedure,
this post will take a look at 
what happens before the device tree is initialized.</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
</pre></td><td class="rouge-code"><pre>        <span class="n">__HEAD</span>
        <span class="cm">/*
         * DO NOT MODIFY. Image header expected by Linux boot-loaders.
         */</span>
        <span class="n">efi_signature_nop</span>                       <span class="c1">// special NOP to identity as PE/COFF executable</span>
        <span class="n">b</span>       <span class="n">primary_entry</span>                   <span class="c1">// branch to kernel start, magic</span>
        <span class="p">.</span><span class="n">quad</span>   <span class="mi">0</span>                               <span class="c1">// Image load offset from start of RAM, little-endian</span>
        <span class="n">le64sym</span> <span class="n">_kernel_size_le</span>                 <span class="c1">// Effective size of kernel image, little-endian</span>
        <span class="n">le64sym</span> <span class="n">_kernel_flags_le</span>                <span class="c1">// Informative flags, little-endian</span>
        <span class="p">.</span><span class="n">quad</span>   <span class="mi">0</span>                               <span class="c1">// reserved</span>
        <span class="p">.</span><span class="n">quad</span>   <span class="mi">0</span>                               <span class="c1">// reserved</span>
        <span class="p">.</span><span class="n">quad</span>   <span class="mi">0</span>                               <span class="c1">// reserved</span>
        <span class="p">.</span><span class="n">ascii</span>  <span class="n">ARM64_IMAGE_MAGIC</span>               <span class="c1">// Magic number</span>
        <span class="p">.</span><span class="kt">long</span>   <span class="p">.</span><span class="n">Lpe_header_offset</span>              <span class="c1">// Offset to the PE header.</span>

        <span class="n">__EFI_PE_HEADER</span>

        <span class="n">__INIT</span>

        <span class="cm">/*
         * The following callee saved general purpose registers are used on the
         * primary lowlevel boot path:
         *
         *  Register   Scope                      Purpose
         *  x21        primary_entry() .. start_kernel()        FDT pointer passed at boot in x0
         *  x23        primary_entry() .. start_kernel()        physical misalignment/KASLR offset
         *  x28        __create_page_tables()                   callee preserved temp register
         *  x19/x20    __primary_switch()                       callee preserved temp registers
         *  x24        __primary_switch() .. relocate_kernel()  current RELR displacement
         */</span>

<span class="n">SYM_CODE_START</span><span class="p">(</span><span class="n">primary_entry</span><span class="p">)</span>
        <span class="n">bl</span>      <span class="n">preserve_boot_args</span>
        <span class="n">bl</span>      <span class="n">init_kernel_el</span>                  <span class="c1">// w0=cpu_boot_mode</span>
        <span class="n">adrp</span>    <span class="n">x23</span><span class="p">,</span> <span class="n">__PHYS_OFFSET</span>
        <span class="n">and</span>     <span class="n">x23</span><span class="p">,</span> <span class="n">x23</span><span class="p">,</span> <span class="n">MIN_KIMG_ALIGN</span> <span class="o">-</span> <span class="mi">1</span>    <span class="c1">// KASLR offset, defaults to 0</span>
        <span class="n">bl</span>      <span class="n">set_cpu_boot_mode_flag</span>
        <span class="n">bl</span>      <span class="n">__create_page_tables</span>
        <span class="cm">/*
         * The following calls CPU setup code, see arch/arm64/mm/proc.S for
         * details.
         * On return, the CPU will be ready for the MMU to be turned on and
         * the TCR will have been set.
         */</span>
        <span class="n">bl</span>      <span class="n">__cpu_setup</span>                     <span class="c1">// initialise processor</span>
        <span class="n">b</span>       <span class="n">__primary_switch</span>
<span class="n">SYM_CODE_END</span><span class="p">(</span><span class="n">primary_entry</span><span class="p">)</span>

<span class="n">SYM_FUNC_START_LOCAL</span><span class="p">(</span><span class="n">__primary_switch</span><span class="p">)</span>
<span class="cp">#ifdef CONFIG_RANDOMIZE_BASE
</span>        <span class="n">mov</span>     <span class="n">x19</span><span class="p">,</span> <span class="n">x0</span>                         <span class="c1">// preserve new SCTLR_EL1 value</span>
        <span class="n">mrs</span>     <span class="n">x20</span><span class="p">,</span> <span class="n">sctlr_el1</span>                  <span class="c1">// preserve old SCTLR_EL1 value</span>
<span class="cp">#endif
</span>
        <span class="n">adrp</span>    <span class="n">x1</span><span class="p">,</span> <span class="n">init_pg_dir</span>
        <span class="n">bl</span>      <span class="n">__enable_mmu</span>
<span class="cp">#ifdef CONFIG_RELOCATABLE
#ifdef CONFIG_RELR
</span>        <span class="n">mov</span>     <span class="n">x24</span><span class="p">,</span> <span class="err">#</span><span class="mi">0</span>                         <span class="c1">// no RELR displacement yet</span>
<span class="cp">#endif
</span>        <span class="n">bl</span>      <span class="n">__relocate_kernel</span>
<span class="cp">#ifdef CONFIG_RANDOMIZE_BASE
</span>        <span class="n">ldr</span>     <span class="n">x8</span><span class="p">,</span> <span class="o">=</span><span class="n">__primary_switched</span>
        <span class="n">adrp</span>    <span class="n">x0</span><span class="p">,</span> <span class="n">__PHYS_OFFSET</span>
        <span class="n">blr</span>     <span class="n">x8</span>

        <span class="cm">/*
         * If we return here, we have a KASLR displacement in x23 which we need
         * to take into account by discarding the current kernel mapping and
         * creating a new one.
         */</span>
        <span class="n">pre_disable_mmu_workaround</span>
        <span class="n">msr</span>     <span class="n">sctlr_el1</span><span class="p">,</span> <span class="n">x20</span>                  <span class="c1">// disable the MMU</span>
        <span class="n">isb</span>
        <span class="n">bl</span>      <span class="n">__create_page_tables</span>            <span class="c1">// recreate kernel mapping</span>

        <span class="n">tlbi</span>    <span class="n">vmalle1</span>                         <span class="c1">// Remove any stale TLB entries</span>
        <span class="n">dsb</span>     <span class="n">nsh</span>

        <span class="n">msr</span>     <span class="n">sctlr_el1</span><span class="p">,</span> <span class="n">x19</span>                  <span class="c1">// re-enable the MMU</span>
        <span class="n">isb</span>
        <span class="n">ic</span>      <span class="n">iallu</span>                           <span class="c1">// flush instructions fetched</span>
        <span class="n">dsb</span>     <span class="n">nsh</span>                             <span class="c1">// via old mapping</span>
        <span class="n">isb</span>

        <span class="n">bl</span>      <span class="n">__relocate_kernel</span>
<span class="cp">#endif
#endif
</span>        <span class="n">ldr</span>     <span class="n">x8</span><span class="p">,</span> <span class="o">=</span><span class="n">__primary_switched</span>
        <span class="n">adrp</span>    <span class="n">x0</span><span class="p">,</span> <span class="n">__PHYS_OFFSET</span>
        <span class="n">br</span>      <span class="n">x8</span>
<span class="n">SYM_FUNC_END</span><span class="p">(</span><span class="n">__primary_switch</span><span class="p">)</span>

<span class="cm">/*
 * The following fragment of code is executed with the MMU enabled.
 *
 *   x0 = __PHYS_OFFSET
 */</span>
<span class="n">SYM_FUNC_START_LOCAL</span><span class="p">(</span><span class="n">__primary_switched</span><span class="p">)</span>
        <span class="n">adrp</span>    <span class="n">x4</span><span class="p">,</span> <span class="n">init_thread_union</span>
        <span class="n">add</span>     <span class="n">sp</span><span class="p">,</span> <span class="n">x4</span><span class="p">,</span> <span class="err">#</span><span class="n">THREAD_SIZE</span>
        <span class="n">adr_l</span>   <span class="n">x5</span><span class="p">,</span> <span class="n">init_task</span>
        <span class="n">msr</span>     <span class="n">sp_el0</span><span class="p">,</span> <span class="n">x5</span>                      <span class="c1">// Save thread_info</span>

<span class="cp">#ifdef CONFIG_ARM64_PTR_AUTH
</span>        <span class="n">__ptrauth_keys_init_cpu</span> <span class="n">x5</span><span class="p">,</span> <span class="n">x6</span><span class="p">,</span> <span class="n">x7</span><span class="p">,</span> <span class="n">x8</span>
<span class="cp">#endif
</span>
        <span class="n">adr_l</span>   <span class="n">x8</span><span class="p">,</span> <span class="n">vectors</span>                     <span class="c1">// load VBAR_EL1 with virtual</span>
        <span class="n">msr</span>     <span class="n">vbar_el1</span><span class="p">,</span> <span class="n">x8</span>                    <span class="c1">// vector table address</span>
        <span class="n">isb</span>

        <span class="n">stp</span>     <span class="n">xzr</span><span class="p">,</span> <span class="n">x30</span><span class="p">,</span> <span class="p">[</span><span class="n">sp</span><span class="p">,</span> <span class="err">#</span><span class="o">-</span><span class="mi">16</span><span class="p">]</span><span class="o">!</span>
        <span class="n">mov</span>     <span class="n">x29</span><span class="p">,</span> <span class="n">sp</span>

<span class="cp">#ifdef CONFIG_SHADOW_CALL_STACK
</span>        <span class="n">adr_l</span>   <span class="n">scs_sp</span><span class="p">,</span> <span class="n">init_shadow_call_stack</span>  <span class="c1">// Set shadow call stack</span>
<span class="cp">#endif
</span>
        <span class="n">str_l</span>   <span class="n">x21</span><span class="p">,</span> <span class="n">__fdt_pointer</span><span class="p">,</span> <span class="n">x5</span>          <span class="c1">// Save FDT pointer</span>

        <span class="n">ldr_l</span>   <span class="n">x4</span><span class="p">,</span> <span class="n">kimage_vaddr</span>                <span class="c1">// Save the offset between</span>
        <span class="n">sub</span>     <span class="n">x4</span><span class="p">,</span> <span class="n">x4</span><span class="p">,</span> <span class="n">x0</span>                      <span class="c1">// the kernel virtual and</span>
        <span class="n">str_l</span>   <span class="n">x4</span><span class="p">,</span> <span class="n">kimage_voffset</span><span class="p">,</span> <span class="n">x5</span>          <span class="c1">// physical mappings</span>

        <span class="c1">// Clear BSS</span>
        <span class="n">adr_l</span>   <span class="n">x0</span><span class="p">,</span> <span class="n">__bss_start</span>
        <span class="n">mov</span>     <span class="n">x1</span><span class="p">,</span> <span class="n">xzr</span>
        <span class="n">adr_l</span>   <span class="n">x2</span><span class="p">,</span> <span class="n">__bss_stop</span>
        <span class="n">sub</span>     <span class="n">x2</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x0</span>
        <span class="n">bl</span>      <span class="n">__pi_memset</span>
        <span class="n">dsb</span>     <span class="n">ishst</span>                           <span class="c1">// Make zero page visible to PTW</span>

<span class="cp">#if defined(CONFIG_KASAN_GENERIC) || defined(CONFIG_KASAN_SW_TAGS)
</span>        <span class="n">bl</span>      <span class="n">kasan_early_init</span>
<span class="cp">#endif
#ifdef CONFIG_RANDOMIZE_BASE
</span>        <span class="n">tst</span>     <span class="n">x23</span><span class="p">,</span> <span class="o">~</span><span class="p">(</span><span class="n">MIN_KIMG_ALIGN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>      <span class="c1">// already running randomized?</span>
        <span class="n">b</span><span class="p">.</span><span class="n">ne</span>    <span class="mi">0</span><span class="n">f</span>
        <span class="n">mov</span>     <span class="n">x0</span><span class="p">,</span> <span class="n">x21</span>                         <span class="c1">// pass FDT address in x0</span>
        <span class="n">bl</span>      <span class="n">kaslr_early_init</span>                <span class="c1">// parse FDT for KASLR options</span>
        <span class="n">cbz</span>     <span class="n">x0</span><span class="p">,</span> <span class="mi">0</span><span class="n">f</span>                          <span class="c1">// KASLR disabled? just proceed</span>
        <span class="n">orr</span>     <span class="n">x23</span><span class="p">,</span> <span class="n">x23</span><span class="p">,</span> <span class="n">x0</span>                    <span class="c1">// record KASLR offset</span>
        <span class="n">ldp</span>     <span class="n">x29</span><span class="p">,</span> <span class="n">x30</span><span class="p">,</span> <span class="p">[</span><span class="n">sp</span><span class="p">],</span> <span class="err">#</span><span class="mi">16</span>             <span class="c1">// we must enable KASLR, return</span>
        <span class="n">ret</span>                                     <span class="c1">// to __primary_switch()</span>
<span class="mi">0</span><span class="o">:</span>
<span class="cp">#endif
</span>        <span class="n">add</span>     <span class="n">sp</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="err">#</span><span class="mi">16</span>
        <span class="n">mov</span>     <span class="n">x29</span><span class="p">,</span> <span class="err">#</span><span class="mi">0</span>
        <span class="n">mov</span>     <span class="n">x30</span><span class="p">,</span> <span class="err">#</span><span class="mi">0</span>
        <span class="n">b</span>       <span class="n">start_kernel</span>
<span class="n">SYM_FUNC_END</span><span class="p">(</span><span class="n">__primary_switched</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></div></div>
<p>After the processor has been initialized and
sets up the execution environment,
it jumps to the first C programmed function, start_kernel.</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
</pre></td><td class="rouge-code"><pre><span class="n">asmlinkage</span> <span class="n">__visible</span> <span class="kt">void</span> <span class="n">__init</span> <span class="n">__no_sanitize_address</span> <span class="nf">start_kernel</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">command_line</span><span class="p">;</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">after_dashes</span><span class="p">;</span>

        <span class="n">set_task_stack_end_magic</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_task</span><span class="p">);</span>
        <span class="n">smp_setup_processor_id</span><span class="p">();</span>
        <span class="n">debug_objects_early_init</span><span class="p">();</span>

        <span class="n">cgroup_init_early</span><span class="p">();</span>

        <span class="n">local_irq_disable</span><span class="p">();</span>
        <span class="n">early_boot_irqs_disabled</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

        <span class="cm">/*
         * Interrupts are still disabled. Do necessary setups, then
         * enable them.
         */</span>
        <span class="n">boot_cpu_init</span><span class="p">();</span>
        <span class="n">page_address_init</span><span class="p">();</span>
        <span class="n">pr_notice</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">linux_banner</span><span class="p">);</span>
        <span class="n">early_security_init</span><span class="p">();</span>
        <span class="n">setup_arch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">command_line</span><span class="p">);</span>
        <span class="n">setup_boot_config</span><span class="p">(</span><span class="n">command_line</span><span class="p">);</span>
        <span class="n">setup_command_line</span><span class="p">(</span><span class="n">command_line</span><span class="p">);</span>
        <span class="n">setup_nr_cpu_ids</span><span class="p">();</span>
        <span class="n">setup_per_cpu_areas</span><span class="p">();</span>
        <span class="n">smp_prepare_boot_cpu</span><span class="p">();</span> <span class="cm">/* arch-specific boot-cpu hooks */</span>
        <span class="n">boot_cpu_hotplug_init</span><span class="p">();</span>

        <span class="n">build_all_zonelists</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
        <span class="n">page_alloc_init</span><span class="p">();</span>

        <span class="n">pr_notice</span><span class="p">(</span><span class="s">"Kernel command line: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">saved_command_line</span><span class="p">);</span>
        <span class="cm">/* parameters may set static keys */</span>
        <span class="n">jump_label_init</span><span class="p">();</span>
        <span class="n">parse_early_param</span><span class="p">();</span>
        <span class="n">after_dashes</span> <span class="o">=</span> <span class="n">parse_args</span><span class="p">(</span><span class="s">"Booting kernel"</span><span class="p">,</span>
                                  <span class="n">static_command_line</span><span class="p">,</span> <span class="n">__start___param</span><span class="p">,</span>
                                  <span class="n">__stop___param</span> <span class="o">-</span> <span class="n">__start___param</span><span class="p">,</span>
                                  <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">unknown_bootoption</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">after_dashes</span><span class="p">))</span>
                <span class="n">parse_args</span><span class="p">(</span><span class="s">"Setting init args"</span><span class="p">,</span> <span class="n">after_dashes</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                           <span class="nb">NULL</span><span class="p">,</span> <span class="n">set_init_arg</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">extra_init_args</span><span class="p">)</span>
                <span class="n">parse_args</span><span class="p">(</span><span class="s">"Setting extra init args"</span><span class="p">,</span> <span class="n">extra_init_args</span><span class="p">,</span>
                           <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">set_init_arg</span><span class="p">);</span>

        <span class="cm">/*
         * These use large bootmem allocations and must precede
         * kmem_cache_init()
         */</span>
        <span class="n">setup_log_buf</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="n">vfs_caches_init_early</span><span class="p">();</span>
        <span class="n">sort_main_extable</span><span class="p">();</span>
        <span class="n">trap_init</span><span class="p">();</span>
        <span class="n">mm_init</span><span class="p">();</span>

        <span class="n">ftrace_init</span><span class="p">();</span>

        <span class="cm">/* trace_printk can be enabled here */</span>
        <span class="n">early_trace_init</span><span class="p">();</span>

        <span class="cm">/*
         * Set up the scheduler prior starting any interrupts (such as the
         * timer interrupt). Full topology setup happens at smp_init()
         * time - but meanwhile we still have a functioning scheduler.
         */</span>
        <span class="n">sched_init</span><span class="p">();</span>
        <span class="cm">/*
         * Disable preemption - early bootup scheduling is extremely
         * fragile until we cpu_idle() for the first time.
         */</span>
        <span class="n">preempt_disable</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">WARN</span><span class="p">(</span><span class="o">!</span><span class="n">irqs_disabled</span><span class="p">(),</span>
                 <span class="s">"Interrupts were enabled *very* early, fixing it</span><span class="se">\n</span><span class="s">"</span><span class="p">))</span>
                <span class="n">local_irq_disable</span><span class="p">();</span>
        <span class="n">radix_tree_init</span><span class="p">();</span>

        <span class="cm">/*
         * Set up housekeeping before setting up workqueues to allow the unbound
         * workqueue to take non-housekeeping into account.
         */</span>
        <span class="n">housekeeping_init</span><span class="p">();</span>

        <span class="cm">/*
         * Allow workqueue creation and work item queueing/cancelling
         * early.  Work item execution depends on kthreads and starts after
         * workqueue_init().
         */</span>
        <span class="n">workqueue_init_early</span><span class="p">();</span>

        <span class="n">rcu_init</span><span class="p">();</span>

        <span class="cm">/* Trace events are available after this */</span>
        <span class="n">trace_init</span><span class="p">();</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">initcall_debug</span><span class="p">)</span>
                <span class="n">initcall_debug_enable</span><span class="p">();</span>

        <span class="n">context_tracking_init</span><span class="p">();</span>
        <span class="cm">/* init some links before init_ISA_irqs() */</span>
        <span class="n">early_irq_init</span><span class="p">();</span>
        <span class="n">init_IRQ</span><span class="p">();</span>
        <span class="n">tick_init</span><span class="p">();</span>
        <span class="n">rcu_init_nohz</span><span class="p">();</span>
        <span class="n">init_timers</span><span class="p">();</span>
        <span class="n">hrtimers_init</span><span class="p">();</span>
        <span class="n">softirq_init</span><span class="p">();</span>
        <span class="n">timekeeping_init</span><span class="p">();</span>

        <span class="cm">/*
         * For best initial stack canary entropy, prepare it after:
         * - setup_arch() for any UEFI RNG entropy and boot cmdline access
         * - timekeeping_init() for ktime entropy used in rand_initialize()
         * - rand_initialize() to get any arch-specific entropy like RDRAND
         * - add_latent_entropy() to get any latent entropy
         * - adding command line entropy
         */</span>
        <span class="n">rand_initialize</span><span class="p">();</span>
        <span class="n">add_latent_entropy</span><span class="p">();</span>
        <span class="n">add_device_randomness</span><span class="p">(</span><span class="n">command_line</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">command_line</span><span class="p">));</span>
        <span class="n">boot_init_stack_canary</span><span class="p">();</span>

        <span class="n">time_init</span><span class="p">();</span>
        <span class="n">perf_event_init</span><span class="p">();</span>
        <span class="n">profile_init</span><span class="p">();</span>
        <span class="n">call_function_init</span><span class="p">();</span>
        <span class="n">WARN</span><span class="p">(</span><span class="o">!</span><span class="n">irqs_disabled</span><span class="p">(),</span> <span class="s">"Interrupts were enabled early</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

        <span class="n">early_boot_irqs_disabled</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">local_irq_enable</span><span class="p">();</span>

        <span class="n">kmem_cache_init_late</span><span class="p">();</span>

        <span class="cm">/*
         * HACK ALERT! This is early. We're enabling the console before
         * we've done PCI setups etc, and console_init() must be aware of
         * this. But we do want output early, in case something goes wrong.
         */</span>
        <span class="n">console_init</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">panic_later</span><span class="p">)</span>
                <span class="n">panic</span><span class="p">(</span><span class="s">"Too many boot %s vars at `%s'"</span><span class="p">,</span> <span class="n">panic_later</span><span class="p">,</span>
                      <span class="n">panic_param</span><span class="p">);</span>

        <span class="n">lockdep_init</span><span class="p">();</span>

        <span class="cm">/*
         * Need to run this when irqs are enabled, because it wants
         * to self-test [hard/soft]-irqs on/off lock inversion bugs
         * too:
         */</span>
        <span class="n">locking_selftest</span><span class="p">();</span>

        <span class="cm">/*
         * This needs to be called before any devices perform DMA
         * operations that might use the SWIOTLB bounce buffers. It will
         * mark the bounce buffers as decrypted so that their usage will
         * not cause "plain-text" data to be decrypted when accessed.
         */</span>
        <span class="n">mem_encrypt_init</span><span class="p">();</span>

<span class="cp">#ifdef CONFIG_BLK_DEV_INITRD
</span>        <span class="k">if</span> <span class="p">(</span><span class="n">initrd_start</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">initrd_below_start_ok</span> <span class="o">&amp;&amp;</span>
            <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">virt_to_page</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">initrd_start</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">min_low_pfn</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">pr_crit</span><span class="p">(</span><span class="s">"initrd overwritten (0x%08lx &lt; 0x%08lx) - disabling it.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                    <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">virt_to_page</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">initrd_start</span><span class="p">)),</span>
                    <span class="n">min_low_pfn</span><span class="p">);</span>
                <span class="n">initrd_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
<span class="cp">#endif
</span>        <span class="n">setup_per_cpu_pageset</span><span class="p">();</span>
        <span class="n">numa_policy_init</span><span class="p">();</span>
        <span class="n">acpi_early_init</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">late_time_init</span><span class="p">)</span>
                <span class="n">late_time_init</span><span class="p">();</span>
        <span class="n">sched_clock_init</span><span class="p">();</span>
        <span class="n">calibrate_delay</span><span class="p">();</span>
        <span class="n">pid_idr_init</span><span class="p">();</span>
        <span class="n">anon_vma_init</span><span class="p">();</span>
<span class="cp">#ifdef CONFIG_X86
</span>        <span class="k">if</span> <span class="p">(</span><span class="n">efi_enabled</span><span class="p">(</span><span class="n">EFI_RUNTIME_SERVICES</span><span class="p">))</span>
                <span class="n">efi_enter_virtual_mode</span><span class="p">();</span>
<span class="cp">#endif
</span>        <span class="n">thread_stack_cache_init</span><span class="p">();</span>
        <span class="n">cred_init</span><span class="p">();</span>
        <span class="n">fork_init</span><span class="p">();</span>
        <span class="n">proc_caches_init</span><span class="p">();</span>
        <span class="n">uts_ns_init</span><span class="p">();</span>
        <span class="n">key_init</span><span class="p">();</span>
        <span class="n">security_init</span><span class="p">();</span>
        <span class="n">dbg_late_init</span><span class="p">();</span>
        <span class="n">vfs_caches_init</span><span class="p">();</span>
        <span class="n">pagecache_init</span><span class="p">();</span>
        <span class="n">signals_init</span><span class="p">();</span>
        <span class="n">seq_file_init</span><span class="p">();</span>
        <span class="n">proc_root_init</span><span class="p">();</span>
        <span class="n">nsfs_init</span><span class="p">();</span>
        <span class="n">cpuset_init</span><span class="p">();</span>
        <span class="n">cgroup_init</span><span class="p">();</span>
        <span class="n">taskstats_init_early</span><span class="p">();</span>
        <span class="n">delayacct_init</span><span class="p">();</span>

        <span class="n">poking_init</span><span class="p">();</span>
        <span class="n">check_bugs</span><span class="p">();</span>

        <span class="n">acpi_subsystem_init</span><span class="p">();</span>
        <span class="n">arch_post_acpi_subsys_init</span><span class="p">();</span>
        <span class="n">sfi_init_late</span><span class="p">();</span>
        <span class="n">kcsan_init</span><span class="p">();</span>

        <span class="cm">/* Do the rest non-__init'ed, we're now alive */</span>
        <span class="n">arch_call_rest_init</span><span class="p">();</span>

        <span class="n">prevent_tail_call_optimization</span><span class="p">();</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>Although there are so many initialization function for kernel,
what we have interest in now is the last init function,
arch_call_rest_init which invokes rest_init function.</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
</pre></td><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">__init</span> <span class="n">__weak</span> <span class="nf">arch_call_rest_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">rest_init</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*
 * We need to finalize in a non-__init function or else race conditions
 * between the root thread and the init thread may cause start_kernel to
 * be reaped by free_initmem before the root thread has proceeded to
 * cpu_idle.
 *
 * gcc-3.4 accidentally inlines this function, so use noinline.
 */</span>

<span class="k">static</span> <span class="n">__initdata</span> <span class="nf">DECLARE_COMPLETION</span><span class="p">(</span><span class="n">kthreadd_done</span><span class="p">);</span>

<span class="n">noinline</span> <span class="kt">void</span> <span class="n">__ref</span> <span class="nf">rest_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>

        <span class="n">rcu_scheduler_starting</span><span class="p">();</span>
        <span class="cm">/*
         * We need to spawn init first so that it obtains pid 1, however
         * the init task will end up wanting to create kthreads, which, if
         * we schedule it before we create kthreadd, will OOPS.
         */</span>
        <span class="n">pid</span> <span class="o">=</span> <span class="n">kernel_thread</span><span class="p">(</span><span class="n">kernel_init</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">CLONE_FS</span><span class="p">);</span>
        <span class="cm">/*
         * Pin init on the boot CPU. Task migration is not properly working
         * until sched_init_smp() has been run. It will set the allowed
         * CPUs for init to the non isolated CPUs.
         */</span>
        <span class="n">rcu_read_lock</span><span class="p">();</span>
        <span class="n">tsk</span> <span class="o">=</span> <span class="n">find_task_by_pid_ns</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">init_pid_ns</span><span class="p">);</span>
        <span class="n">set_cpus_allowed_ptr</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">cpumask_of</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">()));</span>
        <span class="n">rcu_read_unlock</span><span class="p">();</span>

        <span class="n">numa_default_policy</span><span class="p">();</span>
        <span class="n">pid</span> <span class="o">=</span> <span class="n">kernel_thread</span><span class="p">(</span><span class="n">kthreadd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">CLONE_FS</span> <span class="o">|</span> <span class="n">CLONE_FILES</span><span class="p">);</span>
        <span class="n">rcu_read_lock</span><span class="p">();</span>
        <span class="n">kthreadd_task</span> <span class="o">=</span> <span class="n">find_task_by_pid_ns</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">init_pid_ns</span><span class="p">);</span>
        <span class="n">rcu_read_unlock</span><span class="p">();</span>

        <span class="cm">/*
         * Enable might_sleep() and smp_processor_id() checks.
         * They cannot be enabled earlier because with CONFIG_PREEMPTION=y
         * kernel_thread() would trigger might_sleep() splats. With
         * CONFIG_PREEMPT_VOLUNTARY=y the init task might have scheduled
         * already, but it's stuck on the kthreadd_done completion.
         */</span>
        <span class="n">system_state</span> <span class="o">=</span> <span class="n">SYSTEM_SCHEDULING</span><span class="p">;</span>

        <span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kthreadd_done</span><span class="p">);</span>

        <span class="cm">/*
         * The boot idle thread must execute schedule()
         * at least once to get things moving:
         */</span>
        <span class="n">schedule_preempt_disabled</span><span class="p">();</span>
        <span class="cm">/* Call into cpu_idle with preempt disabled */</span>
        <span class="n">cpu_startup_entry</span><span class="p">(</span><span class="n">CPUHP_ONLINE</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>The most important thing of the rest_init function is
spawning kernel_init thread as the first kernel thread. 
The spawned kernel thread is dedicated to run
the first process as the kernel privilege,
which is usally named */init.</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">int</span> <span class="n">__ref</span> <span class="nf">kernel_init</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

        <span class="n">kernel_init_freeable</span><span class="p">();</span>
        <span class="cm">/* need to finish all async __init code before freeing the memory */</span>
        <span class="n">async_synchronize_full</span><span class="p">();</span>
        <span class="n">kprobe_free_init_mem</span><span class="p">();</span>
        <span class="n">ftrace_free_init_mem</span><span class="p">();</span>
        <span class="n">free_initmem</span><span class="p">();</span>
        <span class="n">mark_readonly</span><span class="p">();</span>

        <span class="cm">/*
         * Kernel mappings are now finalized - update the userspace page-table
         * to finalize PTI.
         */</span>
        <span class="n">pti_finalize</span><span class="p">();</span>

        <span class="n">system_state</span> <span class="o">=</span> <span class="n">SYSTEM_RUNNING</span><span class="p">;</span>
        <span class="n">numa_default_policy</span><span class="p">();</span>

        <span class="n">rcu_end_inkernel_boot</span><span class="p">();</span>

        <span class="n">do_sysctl_args</span><span class="p">();</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">ramdisk_execute_command</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">run_init_process</span><span class="p">(</span><span class="n">ramdisk_execute_command</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
                        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">pr_err</span><span class="p">(</span><span class="s">"Failed to execute %s (error %d)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                       <span class="n">ramdisk_execute_command</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="cm">/*
         * We try each of these until one succeeds.
         *
         * The Bourne shell can be used instead of init if we are
         * trying to recover a really broken machine.
         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">execute_command</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">run_init_process</span><span class="p">(</span><span class="n">execute_command</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
                        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">panic</span><span class="p">(</span><span class="s">"Requested init %s failed (error %d)."</span><span class="p">,</span>
                      <span class="n">execute_command</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">CONFIG_DEFAULT_INIT</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">run_init_process</span><span class="p">(</span><span class="n">CONFIG_DEFAULT_INIT</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
                        <span class="n">pr_err</span><span class="p">(</span><span class="s">"Default init %s failed (error %d)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                               <span class="n">CONFIG_DEFAULT_INIT</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
                <span class="k">else</span>
                        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">try_to_run_init_process</span><span class="p">(</span><span class="s">"/sbin/init"</span><span class="p">)</span> <span class="o">||</span>
            <span class="o">!</span><span class="n">try_to_run_init_process</span><span class="p">(</span><span class="s">"/etc/init"</span><span class="p">)</span> <span class="o">||</span>
            <span class="o">!</span><span class="n">try_to_run_init_process</span><span class="p">(</span><span class="s">"/bin/init"</span><span class="p">)</span> <span class="o">||</span>
            <span class="o">!</span><span class="n">try_to_run_init_process</span><span class="p">(</span><span class="s">"/bin/sh"</span><span class="p">))</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

        <span class="n">panic</span><span class="p">(</span><span class="s">"No working init found.  Try passing init= option to kernel. "</span>
              <span class="s">"See Linux Documentation/admin-guide/init.rst for guidance."</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>Although the most important goal of kernel_init thread is 
executing the init process,
but we will see only the parts 
that allow us to handle registration 
of the devices specified in the device tree. 
Before the init_thread actuall invokes the init process,
it calls kernel_init_freeable function
which actually handles the device registration.</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="n">noinline</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">kernel_init_freeable</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="cm">/*
         * Wait until kthreadd is all set-up.
         */</span>
        <span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kthreadd_done</span><span class="p">);</span>

        <span class="cm">/* Now the scheduler is fully set up and can do blocking allocations */</span>
        <span class="n">gfp_allowed_mask</span> <span class="o">=</span> <span class="n">__GFP_BITS_MASK</span><span class="p">;</span>

        <span class="cm">/*
         * init can allocate pages on any node
         */</span>
        <span class="n">set_mems_allowed</span><span class="p">(</span><span class="n">node_states</span><span class="p">[</span><span class="n">N_MEMORY</span><span class="p">]);</span>

        <span class="n">cad_pid</span> <span class="o">=</span> <span class="n">task_pid</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>

        <span class="n">smp_prepare_cpus</span><span class="p">(</span><span class="n">setup_max_cpus</span><span class="p">);</span>

        <span class="n">workqueue_init</span><span class="p">();</span>

        <span class="n">init_mm_internals</span><span class="p">();</span>

        <span class="n">rcu_init_tasks_generic</span><span class="p">();</span>
        <span class="n">do_pre_smp_initcalls</span><span class="p">();</span>
        <span class="n">lockup_detector_init</span><span class="p">();</span>

        <span class="n">smp_init</span><span class="p">();</span>
        <span class="n">sched_init_smp</span><span class="p">();</span>

        <span class="n">padata_init</span><span class="p">();</span>
        <span class="n">page_alloc_init_late</span><span class="p">();</span>
        <span class="cm">/* Initialize page ext after all struct pages are initialized. */</span>
        <span class="n">page_ext_init</span><span class="p">();</span>

        <span class="n">do_basic_setup</span><span class="p">();</span>

        <span class="n">kunit_run_all_tests</span><span class="p">();</span>

        <span class="n">console_on_rootfs</span><span class="p">();</span>

        <span class="cm">/*
         * check if there is an early userspace init.  If yes, let it do all
         * the work
         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">init_eaccess</span><span class="p">(</span><span class="n">ramdisk_execute_command</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">ramdisk_execute_command</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
                <span class="n">prepare_namespace</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="cm">/*
         * Ok, we have completed the initial bootup, and
         * we're essentially up and running. Get rid of the
         * initmem segments and start the user-mode stuff..
         *
         * rootfs is available now, try loading the public keys
         * and default modules
         */</span>


        <span class="n">integrity_load_keys</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*
 * Ok, the machine is now initialized. None of the devices
 * have been touched yet, but the CPU subsystem is up and
 * running, and memory and process management works.
 *
 * Now we can finally start doing some real work..
 */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">do_basic_setup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">cpuset_init_smp</span><span class="p">();</span>
        <span class="n">driver_init</span><span class="p">();</span>
        <span class="n">init_irq_proc</span><span class="p">();</span>
        <span class="n">do_ctors</span><span class="p">();</span>
        <span class="n">usermodehelper_enable</span><span class="p">();</span>
        <span class="n">do_initcalls</span><span class="p">();</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>Among the multiple initializations done by the do_basic_setup,
driver_init and do_initcalls are strongly related to 
platform_device and device tree parsing.
Here device tree parsing means that register the devices
specified in the device tree to the 
kernel driver system.</p>

<h3 id="initialization-of-driver-subsystem"><span class="me-2">Initialization of driver subsystem</span><a href="#initialization-of-driver-subsystem" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<p>Before we assign the devices and bind the driver associated with,
we have to initialize the driver subsystem of the kernel.</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
</pre></td><td class="rouge-code"><pre><span class="cm">/**
 * driver_init - initialize driver model.
 *
 * Call the driver model init functions to initialize their
 * subsystems. Called early from init/main.c.
 */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">driver_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="cm">/* These are the core pieces */</span>
        <span class="n">devtmpfs_init</span><span class="p">();</span>
        <span class="n">devices_init</span><span class="p">();</span>
        <span class="n">buses_init</span><span class="p">();</span>
        <span class="n">classes_init</span><span class="p">();</span>
        <span class="n">firmware_init</span><span class="p">();</span>
        <span class="n">hypervisor_init</span><span class="p">();</span>

        <span class="cm">/* These are also core pieces, but must come after the
         * core core pieces.
         */</span>
        <span class="n">of_core_init</span><span class="p">();</span>
        <span class="n">platform_bus_init</span><span class="p">();</span>
        <span class="n">cpu_dev_init</span><span class="p">();</span>
        <span class="n">memory_dev_init</span><span class="p">();</span>
        <span class="n">container_dev_init</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">devices_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">devices_kset</span> <span class="o">=</span> <span class="n">kset_create_and_add</span><span class="p">(</span><span class="s">"devices"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">device_uevent_ops</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">devices_kset</span><span class="p">)</span>
                <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
        <span class="n">dev_kobj</span> <span class="o">=</span> <span class="n">kobject_create_and_add</span><span class="p">(</span><span class="s">"dev"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev_kobj</span><span class="p">)</span>
                <span class="k">goto</span> <span class="n">dev_kobj_err</span><span class="p">;</span>
        <span class="n">sysfs_dev_block_kobj</span> <span class="o">=</span> <span class="n">kobject_create_and_add</span><span class="p">(</span><span class="s">"block"</span><span class="p">,</span> <span class="n">dev_kobj</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sysfs_dev_block_kobj</span><span class="p">)</span>
                <span class="k">goto</span> <span class="n">block_kobj_err</span><span class="p">;</span>
        <span class="n">sysfs_dev_char_kobj</span> <span class="o">=</span> <span class="n">kobject_create_and_add</span><span class="p">(</span><span class="s">"char"</span><span class="p">,</span> <span class="n">dev_kobj</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sysfs_dev_char_kobj</span><span class="p">)</span>
                <span class="k">goto</span> <span class="n">char_kobj_err</span><span class="p">;</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">char_kobj_err:</span>
        <span class="n">kobject_put</span><span class="p">(</span><span class="n">sysfs_dev_block_kobj</span><span class="p">);</span>
 <span class="nl">block_kobj_err:</span>
        <span class="n">kobject_put</span><span class="p">(</span><span class="n">dev_kobj</span><span class="p">);</span>
 <span class="nl">dev_kobj_err:</span>
        <span class="n">kset_unregister</span><span class="p">(</span><span class="n">devices_kset</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">buses_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">bus_kset</span> <span class="o">=</span> <span class="n">kset_create_and_add</span><span class="p">(</span><span class="s">"bus"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus_uevent_ops</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bus_kset</span><span class="p">)</span>
                <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

        <span class="n">system_kset</span> <span class="o">=</span> <span class="n">kset_create_and_add</span><span class="p">(</span><span class="s">"system"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devices_kset</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">system_kset</span><span class="p">)</span>
                <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">firmware_kobj</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">firmware_kobj</span><span class="p">);</span>
 
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">firmware_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>       
        <span class="n">firmware_kobj</span> <span class="o">=</span> <span class="n">kobject_create_and_add</span><span class="p">(</span><span class="s">"firmware"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">firmware_kobj</span><span class="p">)</span>
                <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>  
</pre></td></tr></tbody></table></code></div></div>

<p>Most of the init functions are about 
initializing driver related structures to manage 
device, driver, bus, etc 
which represent resources 
that can be registered on the driver sub-system. 
Those resources are managed with the kset and kobjects.
For example, 
devices_init function allocates
kset for managing all device resource
registered to the system. 
It has root kobject, dev, and block and char devices are
manages ad its children resource. 
Other init functions are mostly same,
allocating kset and kobjects associated with specific resources used in driver sub-system.</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">__init</span> <span class="nf">of_core_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">;</span>


        <span class="cm">/* Create the kset, and register existing nodes */</span>
        <span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">of_mutex</span><span class="p">);</span>
        <span class="n">of_kset</span> <span class="o">=</span> <span class="n">kset_create_and_add</span><span class="p">(</span><span class="s">"devicetree"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">firmware_kobj</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">of_kset</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">of_mutex</span><span class="p">);</span>
                <span class="n">pr_err</span><span class="p">(</span><span class="s">"failed to register existing nodes</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
                <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">for_each_of_allnodes</span><span class="p">(</span><span class="n">np</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">__of_attach_node_sysfs</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">phandle</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">phandle_cache</span><span class="p">[</span><span class="n">of_phandle_cache_hash</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">phandle</span><span class="p">)])</span>
                        <span class="n">phandle_cache</span><span class="p">[</span><span class="n">of_phandle_cache_hash</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">phandle</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">of_mutex</span><span class="p">);</span>

        <span class="cm">/* Symlink in /proc as required by userspace ABI */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">of_root</span><span class="p">)</span>
                <span class="n">proc_symlink</span><span class="p">(</span><span class="s">"device-tree"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">"/sys/firmware/devicetree/base"</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>Similar to other init functions, 
of_core_init function also generates kset for devicetree.
In addition to this,
it traverse entire device_node of the device tree 
and generate hash of the phandle of each device node.</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="rouge-code"><pre>
<span class="k">struct</span> <span class="n">bus_type</span> <span class="n">platform_bus_type</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">name</span>           <span class="o">=</span> <span class="s">"platform"</span><span class="p">,</span>
        <span class="p">.</span><span class="n">dev_groups</span>     <span class="o">=</span> <span class="n">platform_dev_groups</span><span class="p">,</span>
        <span class="p">.</span><span class="n">match</span>          <span class="o">=</span> <span class="n">platform_match</span><span class="p">,</span>
        <span class="p">.</span><span class="n">uevent</span>         <span class="o">=</span> <span class="n">platform_uevent</span><span class="p">,</span>
        <span class="p">.</span><span class="n">probe</span>          <span class="o">=</span> <span class="n">platform_probe</span><span class="p">,</span>
        <span class="p">.</span><span class="n">remove</span>         <span class="o">=</span> <span class="n">platform_remove</span><span class="p">,</span>
        <span class="p">.</span><span class="n">shutdown</span>       <span class="o">=</span> <span class="n">platform_shutdown</span><span class="p">,</span>
        <span class="p">.</span><span class="n">dma_configure</span>  <span class="o">=</span> <span class="n">platform_dma_configure</span><span class="p">,</span>
        <span class="p">.</span><span class="n">pm</span>             <span class="o">=</span> <span class="o">&amp;</span><span class="n">platform_dev_pm_ops</span><span class="p">,</span>
<span class="p">};</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">platform_bus_type</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">platform_bus_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

        <span class="n">early_platform_cleanup</span><span class="p">();</span>

        <span class="n">error</span> <span class="o">=</span> <span class="n">device_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">platform_bus</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">platform_bus</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">error</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">error</span> <span class="o">=</span>  <span class="n">bus_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">platform_bus_type</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
                <span class="n">device_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">platform_bus</span><span class="p">);</span>
        <span class="n">of_platform_register_reconfig_notifier</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>Now finally we have some more complex routines 
that XXX</p>

<h3 id="registering-bus-device"><span class="me-2">Registering bus device</span><a href="#registering-bus-device" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<p><strong>drivers/base/core.c</strong></p>
<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
</pre></td><td class="rouge-code"><pre><span class="cm">/**     
 * device_register - register a device with the system.
 * @dev: pointer to the device structure
 *
 * This happens in two clean steps - initialize the device
 * and add it to the system. The two steps can be called
 * separately, but this is the easiest and most common.
 * I.e. you should only call the two helpers separately if
 * have a clearly defined need to use and refcount the device
 * before it is added to the hierarchy.
 *
 * For more information, see the kerneldoc for device_initialize()
 * and device_add().    
 *      
 * NOTE: _Never_ directly free @dev after calling this function, even
 * if it returned an error! Always use put_device() to give up the
 * reference initialized in this function instead.
 */</span>     
<span class="kt">int</span> <span class="nf">device_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>       
        <span class="n">device_initialize</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">device_add</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">device_register</span><span class="p">);</span>
<span class="cm">/**
 * device_initialize - init device structure.
 * @dev: device.
 *
 * This prepares the device for use by other layers by initializing
 * its fields.
 * It is the first half of device_register(), if called by
 * that function, though it can also be called separately, so one
 * may use @dev's fields. In particular, get_device()/put_device()
 * may be used for reference counting of @dev after calling this
 * function.
 * 
 * All fields in @dev must be initialized by the caller to 0, except
 * for those explicitly set to some other value.  The simplest
 * approach is to use kzalloc() to allocate the structure containing
 * @dev.
 *
 * NOTE: Use put_device() to give up your reference instead of freeing
 * @dev directly once you have called this function.
 */</span>     
<span class="kt">void</span> <span class="nf">device_initialize</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">.</span><span class="n">kset</span> <span class="o">=</span> <span class="n">devices_kset</span><span class="p">;</span>
        <span class="n">kobject_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">device_ktype</span><span class="p">);</span>
        <span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_pools</span><span class="p">);</span>
        <span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_PROVE_LOCKING
</span>        <span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lockdep_mutex</span><span class="p">);</span>
<span class="cp">#endif                  
</span>        <span class="n">lockdep_set_novalidate_class</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
        <span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devres_lock</span><span class="p">);</span>
        <span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devres_head</span><span class="p">);</span>
        <span class="n">device_pm_init</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
        <span class="n">set_dev_node</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_GENERIC_MSI_IRQ
</span>        <span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">msi_list</span><span class="p">);</span>
<span class="cp">#endif
</span>        <span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">links</span><span class="p">.</span><span class="n">consumers</span><span class="p">);</span>
        <span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">links</span><span class="p">.</span><span class="n">suppliers</span><span class="p">);</span>
        <span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">links</span><span class="p">.</span><span class="n">defer_sync</span><span class="p">);</span>
        <span class="n">dev</span><span class="o">-&gt;</span><span class="n">links</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">DL_DEV_NO_DRIVER</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">device_initialize</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></div></div>

<p>The first part of the device_register function is 
device_initialize,
which initialize the device structure passed to the 
device_register.</p>

<p>The most important part of the device_initialize is 
assign devices_kset to
kset of the kobject of the initialized device. 
We will see later, but 
to add the kobject of the device,
kobj-&gt;kset must be assigned before calling kobject_add function.</p>

<p>Also, to manage the device structure using kobject,
its ktypes should be set by the kojbect_init function.
The second parameter device_ktype is a kobj_type object
that contains some callback functions.
The most important one is release callback function
that is going to be invoked
when the reference count of the device structure 
(maintained by the kobject) becomes zero.</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="k">struct</span> <span class="n">kobj_type</span> <span class="n">device_ktype</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">release</span>        <span class="o">=</span> <span class="n">device_release</span><span class="p">,</span>
        <span class="p">.</span><span class="n">sysfs_ops</span>      <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev_sysfs_ops</span><span class="p">,</span>
        <span class="p">.</span><span class="n">namespace</span>      <span class="o">=</span> <span class="n">device_namespace</span><span class="p">,</span>
        <span class="p">.</span><span class="n">get_ownership</span>  <span class="o">=</span> <span class="n">device_get_ownership</span><span class="p">,</span>
<span class="p">};</span>
<span class="cm">/**
 * device_release - free device structure.
 * @kobj: device's kobject.
 *
 * This is called once the reference count for the object
 * reaches 0. We forward the call to the device's release
 * method, which should handle actually freeing the structure.
 */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">device_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">kobj_to_dev</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>
        <span class="k">struct</span> <span class="n">device_private</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">;</span>

        <span class="cm">/*
         * Some platform devices are driven without driver attached
         * and managed resources may have been acquired.  Make sure
         * all resources are released.
         *
         * Drivers still can add resources into device after device
         * is deleted but alive, so release devres here to avoid
         * possible memory leak.
         */</span>
        <span class="n">devres_release_all</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

        <span class="n">kfree</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_range_map</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">)</span>
                <span class="n">dev</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">)</span>
                <span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">dev_release</span><span class="p">)</span>
                <span class="n">dev</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">dev_release</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
        <span class="k">else</span>
                <span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">KERN_ERR</span> <span class="s">"Device '%s' does not have a release() function, it is broken and must be fixed. See Documentation/core-api/kobject.rst.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                        <span class="n">dev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
        <span class="n">kfree</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>When the device_relase function is invoked,
it firstly free the all resources allocated for the device, 
devres_release_all(dev).
After that, by invoking the release function 
registered in the device structure,
it can release the device structure which is not used anymore.</p>

<p>Now, let’s take a look at rest of the device_initialize.
The passed device argument of the function is 
platform_bus variable in this case.</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">device</span> <span class="n">platform_bus</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">init_name</span>      <span class="o">=</span> <span class="s">"platform"</span><span class="p">,</span>
<span class="p">};</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">platform_bus</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></div></div>
<p>Although this device structure has only single initialized member field,
device structure contains bunch of other fields 
used to abstract physical/virtual device 
in the driver sub-system.</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
</pre></td><td class="rouge-code"><pre><span class="cm">/**
 * struct device - The basic device structure
 * @parent:     The device's "parent" device, the device to which it is attached.
 *              In most cases, a parent device is some sort of bus or host
 *              controller. If parent is NULL, the device, is a top-level device,
 *              which is not usually what you want.
 * @p:          Holds the private data of the driver core portions of the device.
 *              See the comment of the struct device_private for detail.
 * @kobj:       A top-level, abstract class from which other classes are derived.
 * @init_name:  Initial name of the device.
 * @type:       The type of device.
 *              This identifies the device type and carries type-specific
 *              information.
 * @mutex:      Mutex to synchronize calls to its driver.
 * @lockdep_mutex: An optional debug lock that a subsystem can use as a
 *              peer lock to gain localized lockdep coverage of the device_lock.
 * @bus:        Type of bus device is on.
 * @driver:     Which driver has allocated this
 * @platform_data: Platform data specific to the device.
 *              Example: For devices on custom boards, as typical of embedded
 *              and SOC based hardware, Linux often uses platform_data to point
 *              to board-specific structures describing devices and how they
 *              are wired.  That can include what ports are available, chip
 *              variants, which GPIO pins act in what additional roles, and so
 *              on.  This shrinks the "Board Support Packages" (BSPs) and
 *              minimizes board-specific #ifdefs in drivers.
 * @driver_data: Private pointer for driver specific info.
 * @links:      Links to suppliers and consumers of this device.
 * @power:      For device power management.
 *              See Documentation/driver-api/pm/devices.rst for details.
 * @pm_domain:  Provide callbacks that are executed during system suspend,
 *              hibernation, system resume and during runtime PM transitions
 *              along with subsystem-level and driver-level callbacks.
 * @em_pd:      device's energy model performance domain
 * @pins:       For device pin management.
 *              See Documentation/driver-api/pinctl.rst for details.
 * @msi_list:   Hosts MSI descriptors
 * @msi_domain: The generic MSI domain this device is using.
 * @numa_node:  NUMA node this device is close to.
 * @dma_ops:    DMA mapping operations for this device.
 * @dma_mask:   Dma mask (if dma'ble device).
 * @coherent_dma_mask: Like dma_mask, but for alloc_coherent mapping as not all
 *              hardware supports 64-bit addresses for consistent allocations
 *              such descriptors.
 * @bus_dma_limit: Limit of an upstream bridge or bus which imposes a smaller
 *              DMA limit than the device itself supports.
 * @dma_range_map: map for DMA memory ranges relative to that of RAM
 * @dma_parms:  A low level driver may set these to teach IOMMU code about
 *              segment limitations.
 * @dma_pools:  Dma pools (if dma'ble device).
 * @dma_mem:    Internal for coherent mem override.
 * @cma_area:   Contiguous memory area for dma allocations
 * @archdata:   For arch-specific additions.
 * @of_node:    Associated device tree node.
 * @fwnode:     Associated device node supplied by platform firmware.
 * @devt:       For creating the sysfs "dev".
 * @id:         device instance
 * @devres_lock: Spinlock to protect the resource of the device.
 * @devres_head: The resources list of the device.
 * @knode_class: The node used to add the device to the class list.
 * @class:      The class of the device.
 * @groups:     Optional attribute groups.
 * @release:    Callback to free the device after all references have
 *              gone away. This should be set by the allocator of the
 *              device (i.e. the bus driver that discovered the device).
 * @iommu_group: IOMMU group the device belongs to.
 * @iommu:      Per device generic IOMMU runtime data
 *
 * @offline_disabled: If set, the device is permanently online.
 * @offline:    Set after successful invocation of bus type's .offline().
 * @of_node_reused: Set if the device-tree node is shared with an ancestor
 *              device.
 * @state_synced: The hardware state of this device has been synced to match
 *                the software state of this device by calling the driver/bus
 *                sync_state() callback.
 * @dma_coherent: this particular device is dma coherent, even if the
 *              architecture supports non-coherent devices.
 * @dma_ops_bypass: If set to %true then the dma_ops are bypassed for the
 *              streaming DMA operations (-&gt;map_* / -&gt;unmap_* / -&gt;sync_*),
 *              and optionall (if the coherent mask is large enough) also
 *              for dma allocations.  This flag is managed by the dma ops
 *              instance from -&gt;dma_supported.
 *
 * At the lowest level, every device in a Linux system is represented by an
 * instance of struct device. The device structure contains the information
 * that the device model core needs to model the system. Most subsystems,
 * however, track additional information about the devices they host. As a
 * result, it is rare for devices to be represented by bare device structures;
 * instead, that structure, like kobject structures, is usually embedded within
 * a higher-level representation of the device.
 */</span>
<span class="k">struct</span> <span class="n">device</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">kobject</span> <span class="n">kobj</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">device</span>           <span class="o">*</span><span class="n">parent</span><span class="p">;</span>

        <span class="k">struct</span> <span class="n">device_private</span>   <span class="o">*</span><span class="n">p</span><span class="p">;</span>

        <span class="k">const</span> <span class="kt">char</span>              <span class="o">*</span><span class="n">init_name</span><span class="p">;</span> <span class="cm">/* initial name of the device */</span>
        <span class="k">const</span> <span class="k">struct</span> <span class="n">device_type</span> <span class="o">*</span><span class="n">type</span><span class="p">;</span>

        <span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">;</span>           <span class="cm">/* type of bus device is on */</span>
        <span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">;</span>   <span class="cm">/* which driver has allocated this
                                           device */</span>
        <span class="kt">void</span>            <span class="o">*</span><span class="n">platform_data</span><span class="p">;</span> <span class="cm">/* Platform specific data, device
                                           core doesn't touch it */</span>
        <span class="kt">void</span>            <span class="o">*</span><span class="n">driver_data</span><span class="p">;</span>   <span class="cm">/* Driver data, set and get with
                                           dev_set_drvdata/dev_get_drvdata */</span>
<span class="cp">#ifdef CONFIG_PROVE_LOCKING
</span>        <span class="k">struct</span> <span class="n">mutex</span>            <span class="n">lockdep_mutex</span><span class="p">;</span>
<span class="cp">#endif
</span>        <span class="k">struct</span> <span class="n">mutex</span>            <span class="n">mutex</span><span class="p">;</span>  <span class="cm">/* mutex to synchronize calls to
                                         * its driver.
                                         */</span>

        <span class="k">struct</span> <span class="n">dev_links_info</span>   <span class="n">links</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">dev_pm_info</span>      <span class="n">power</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">dev_pm_domain</span>    <span class="o">*</span><span class="n">pm_domain</span>

<span class="cp">#ifdef CONFIG_ENERGY_MODEL
</span>        <span class="k">struct</span> <span class="n">em_perf_domain</span>   <span class="o">*</span><span class="n">em_pd</span><span class="p">;</span>
<span class="cp">#endif
</span>
<span class="cp">#ifdef CONFIG_GENERIC_MSI_IRQ_DOMAIN
</span>        <span class="k">struct</span> <span class="n">irq_domain</span>       <span class="o">*</span><span class="n">msi_domain</span><span class="p">;</span>
<span class="cp">#endif
#ifdef CONFIG_PINCTRL
</span>        <span class="k">struct</span> <span class="n">dev_pin_info</span>     <span class="o">*</span><span class="n">pins</span><span class="p">;</span>
<span class="cp">#endif
#ifdef CONFIG_GENERIC_MSI_IRQ
</span>        <span class="k">struct</span> <span class="n">list_head</span>        <span class="n">msi_list</span><span class="p">;</span>
<span class="cp">#endif
#ifdef CONFIG_DMA_OPS
</span>        <span class="k">const</span> <span class="k">struct</span> <span class="n">dma_map_ops</span> <span class="o">*</span><span class="n">dma_ops</span><span class="p">;</span>
<span class="cp">#endif
</span>        <span class="n">u64</span>             <span class="o">*</span><span class="n">dma_mask</span><span class="p">;</span>      <span class="cm">/* dma mask (if dma'able device) */</span>
        <span class="n">u64</span>             <span class="n">coherent_dma_mask</span><span class="p">;</span><span class="cm">/* Like dma_mask, but for
                                             alloc_coherent mappings as
                                             not all hardware supports
                                             64 bit addresses for consistent
                                             allocations such descriptors. */</span>
        <span class="n">u64</span>             <span class="n">bus_dma_limit</span><span class="p">;</span>  <span class="cm">/* upstream dma constraint */</span>
        <span class="k">const</span> <span class="k">struct</span> <span class="n">bus_dma_region</span> <span class="o">*</span><span class="n">dma_range_map</span><span class="p">;</span>

        <span class="k">struct</span> <span class="n">device_dma_parameters</span> <span class="o">*</span><span class="n">dma_parms</span><span class="p">;</span>

        <span class="k">struct</span> <span class="n">list_head</span>        <span class="n">dma_pools</span><span class="p">;</span>      <span class="cm">/* dma pools (if dma'ble) */</span>

<span class="cp">#ifdef CONFIG_DMA_DECLARE_COHERENT
</span>        <span class="k">struct</span> <span class="n">dma_coherent_mem</span> <span class="o">*</span><span class="n">dma_mem</span><span class="p">;</span> <span class="cm">/* internal for coherent mem
                                             override */</span>
<span class="cp">#endif
#ifdef CONFIG_DMA_CMA
</span>        <span class="k">struct</span> <span class="n">cma</span> <span class="o">*</span><span class="n">cma_area</span><span class="p">;</span>           <span class="cm">/* contiguous memory area for dma
                                           allocations */</span>
<span class="cp">#endif
</span>        <span class="cm">/* arch specific additions */</span>
        <span class="k">struct</span> <span class="n">dev_archdata</span>     <span class="n">archdata</span><span class="p">;</span>

        <span class="k">struct</span> <span class="n">device_node</span>      <span class="o">*</span><span class="n">of_node</span><span class="p">;</span> <span class="cm">/* associated device tree node */</span>
        <span class="k">struct</span> <span class="n">fwnode_handle</span>    <span class="o">*</span><span class="n">fwnode</span><span class="p">;</span> <span class="cm">/* firmware device node */</span>

<span class="cp">#ifdef CONFIG_NUMA
</span>        <span class="kt">int</span>             <span class="n">numa_node</span><span class="p">;</span>      <span class="cm">/* NUMA node this device is close to */</span>
<span class="cp">#endif
</span>        <span class="n">dev_t</span>                   <span class="n">devt</span><span class="p">;</span>   <span class="cm">/* dev_t, creates the sysfs "dev" */</span>
        <span class="n">u32</span>                     <span class="n">id</span><span class="p">;</span>     <span class="cm">/* device instance */</span>

        <span class="n">spinlock_t</span>              <span class="n">devres_lock</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">list_head</span>        <span class="n">devres_head</span><span class="p">;</span>

        <span class="k">struct</span> <span class="n">class</span>            <span class="o">*</span><span class="n">class</span><span class="p">;</span>
        <span class="k">const</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="o">**</span><span class="n">groups</span><span class="p">;</span>  <span class="cm">/* optional groups */</span>

        <span class="kt">void</span>    <span class="p">(</span><span class="o">*</span><span class="n">release</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
        <span class="k">struct</span> <span class="n">iommu_group</span>      <span class="o">*</span><span class="n">iommu_group</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">dev_iommu</span>        <span class="o">*</span><span class="n">iommu</span><span class="p">;</span>

        <span class="n">bool</span>                    <span class="n">offline_disabled</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
        <span class="n">bool</span>                    <span class="n">offline</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
        <span class="n">bool</span>                    <span class="n">of_node_reused</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
        <span class="n">bool</span>                    <span class="n">state_synced</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="cp">#if defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_DEVICE) || \
    defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU) || \
    defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU_ALL)
</span>        <span class="n">bool</span>                    <span class="n">dma_coherent</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif
#ifdef CONFIG_DMA_OPS_BYPASS
</span>        <span class="n">bool</span>                    <span class="n">dma_ops_bypass</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif
</span><span class="p">};</span>
</pre></td></tr></tbody></table></code></div></div>
<p>The
device_intialize function initializes device links 
that manage consumer and suppliers of this device,
devres list which manages all resources used by the device,
dma, mutex, etc. 
Lastly, it sets current device status as 
DL_DEV_NO_DRIVER 
which means the device has no driver attached to it.</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre><span class="cm">/**     
 * enum dl_dev_state - Device driver presence tracking information.
 * @DL_DEV_NO_DRIVER: There is no driver attached to the device.
 * @DL_DEV_PROBING: A driver is probing.
 * @DL_DEV_DRIVER_BOUND: The driver has been bound to the device.
 * @DL_DEV_UNBINDING: The driver is unbinding from the device.
 */</span>     
<span class="k">enum</span> <span class="n">dl_dev_state</span> <span class="p">{</span>
        <span class="n">DL_DEV_NO_DRIVER</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">DL_DEV_PROBING</span><span class="p">,</span>
        <span class="n">DL_DEV_DRIVER_BOUND</span><span class="p">,</span>
        <span class="n">DL_DEV_UNBINDING</span><span class="p">,</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></div></div>

<h3 id="add-platform_bus-device-to-the-driver-subsystem"><span class="me-2">Add platform_bus device to the driver subsystem</span><a href="#add-platform_bus-device-to-the-driver-subsystem" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<p>After initializing kobject and some fields of the 
platform_bus device,
device_add function will register the device
to the driver sub-system.</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
</pre></td><td class="rouge-code"><pre><span class="cm">/**
 * device_add - add device to device hierarchy.
 * @dev: device.
 *
 * This is part 2 of device_register(), though may be called
 * separately _iff_ device_initialize() has been called separately.
 *
 * This adds @dev to the kobject hierarchy via kobject_add(), adds it
 * to the global and sibling lists for the device, then
 * adds it to the other relevant subsystems of the driver model.
 *
 * Do not call this routine or device_register() more than once for
 * any device structure.  The driver model core is not designed to work
 * with devices that get unregistered and then spring back to life.
 * (Among other things, it's very hard to guarantee that all references
 * to the previous incarnation of @dev have been dropped.)  Allocate
 * and register a fresh new struct device instead.
 *
 * NOTE: _Never_ directly free @dev after calling this function, even
 * if it returned an error! Always use put_device() to give up your
 * reference instead.
 *
 * Rule of thumb is: if device_add() succeeds, you should call
 * device_del() when you want to get rid of it. If device_add() has
 * *not* succeeded, use *only* put_device() to drop the reference
 * count.
 */</span>
<span class="kt">int</span> <span class="nf">device_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">class_interface</span> <span class="o">*</span><span class="n">class_intf</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">glue_dir</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

        <span class="n">dev</span> <span class="o">=</span> <span class="n">get_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
                <span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">error</span> <span class="o">=</span> <span class="n">device_private_init</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
                        <span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/*
         * for statically allocated devices, which should all be converted
         * some day, we need to initialize the name. We prevent reading back
         * the name, and force the use of dev_name()
         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">init_name</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">dev_set_name</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">"%s"</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">init_name</span><span class="p">);</span>
                <span class="n">dev</span><span class="o">-&gt;</span><span class="n">init_name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* subsystems can specify simple device enumeration */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">dev_name</span><span class="p">)</span>
                <span class="n">dev_set_name</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">"%s%u"</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">dev_name</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
                <span class="k">goto</span> <span class="n">name_error</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">pr_debug</span><span class="p">(</span><span class="s">"device: '%s': %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="n">__func__</span><span class="p">);</span>

        <span class="n">parent</span> <span class="o">=</span> <span class="n">get_device</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
        <span class="n">kobj</span> <span class="o">=</span> <span class="n">get_device_parent</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">kobj</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>
                <span class="k">goto</span> <span class="n">parent_error</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">kobj</span><span class="p">)</span>
                <span class="n">dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">kobj</span><span class="p">;</span>

        <span class="cm">/* use parent numa_node */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">parent</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">dev_to_node</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">==</span> <span class="n">NUMA_NO_NODE</span><span class="p">))</span>
                <span class="n">set_dev_node</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev_to_node</span><span class="p">(</span><span class="n">parent</span><span class="p">));</span>

        <span class="cm">/* first, register with generic layer. */</span>
        <span class="cm">/* we require the name to be set before, and pass NULL */</span>
        <span class="n">error</span> <span class="o">=</span> <span class="n">kobject_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">.</span><span class="n">parent</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">glue_dir</span> <span class="o">=</span> <span class="n">get_glue_dir</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
                <span class="k">goto</span> <span class="n">Error</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* notify platform of device entry */</span>
        <span class="n">error</span> <span class="o">=</span> <span class="n">device_platform_notify</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">KOBJ_ADD</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
                <span class="k">goto</span> <span class="n">platform_error</span><span class="p">;</span>

        <span class="n">error</span> <span class="o">=</span> <span class="n">device_create_file</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_uevent</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
                <span class="k">goto</span> <span class="n">attrError</span><span class="p">;</span>

        <span class="n">error</span> <span class="o">=</span> <span class="n">device_add_class_symlinks</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
                <span class="k">goto</span> <span class="n">SymlinkError</span><span class="p">;</span>
        <span class="n">error</span> <span class="o">=</span> <span class="n">device_add_attrs</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
                <span class="k">goto</span> <span class="n">AttrsError</span><span class="p">;</span>
        <span class="n">error</span> <span class="o">=</span> <span class="n">bus_add_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
                <span class="k">goto</span> <span class="n">BusError</span><span class="p">;</span>
        <span class="n">error</span> <span class="o">=</span> <span class="n">dpm_sysfs_add</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
                <span class="k">goto</span> <span class="n">DPMError</span><span class="p">;</span>
        <span class="n">device_pm_add</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">MAJOR</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devt</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">error</span> <span class="o">=</span> <span class="n">device_create_file</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_dev</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
                        <span class="k">goto</span> <span class="n">DevAttrError</span><span class="p">;</span>

                <span class="n">error</span> <span class="o">=</span> <span class="n">device_create_sys_dev_entry</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
                        <span class="k">goto</span> <span class="n">SysEntryError</span><span class="p">;</span>

                <span class="n">devtmpfs_create_node</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="cm">/* Notify clients of device addition.  This call must come
         * after dpm_sysfs_add() and before kobject_uevent().
         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">)</span>
                <span class="n">blocking_notifier_call_chain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">bus_notifier</span><span class="p">,</span>
                                             <span class="n">BUS_NOTIFY_ADD_DEVICE</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

        <span class="n">kobject_uevent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">KOBJ_ADD</span><span class="p">);</span>

        <span class="cm">/*
         * Check if any of the other devices (consumers) have been waiting for
         * this device (supplier) to be added so that they can create a device
         * link to it.
         *
         * This needs to happen after device_pm_add() because device_link_add()
         * requires the supplier be registered before it's called.
         *
         * But this also needs to happen before bus_probe_device() to make sure
         * waiting consumers can link to it before the driver is bound to the
         * device and the driver sync_state callback is called for this device.
         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">fwnode</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">fwnode</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">dev</span><span class="o">-&gt;</span><span class="n">fwnode</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
                <span class="n">fw_devlink_link_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">bus_probe_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">)</span>
                <span class="n">klist_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">knode_parent</span><span class="p">,</span>
                               <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">klist_children</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">class</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
                <span class="cm">/* tie the class to the device */</span>
                <span class="n">klist_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">knode_class</span><span class="p">,</span>
                               <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">klist_devices</span><span class="p">);</span>

                <span class="cm">/* notify any interfaces that the device is here */</span>
                <span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">class_intf</span><span class="p">,</span>
                                    <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">interfaces</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">class_intf</span><span class="o">-&gt;</span><span class="n">add_dev</span><span class="p">)</span>
                                <span class="n">class_intf</span><span class="o">-&gt;</span><span class="n">add_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">class_intf</span><span class="p">);</span>
                <span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
        <span class="p">}</span>
<span class="nl">done:</span>
        <span class="n">put_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">error</span><span class="p">;</span>
 <span class="nl">SysEntryError:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">MAJOR</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devt</span><span class="p">))</span>
                <span class="n">device_remove_file</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_dev</span><span class="p">);</span>
 <span class="nl">DevAttrError:</span>
        <span class="n">device_pm_remove</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
        <span class="n">dpm_sysfs_remove</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
 <span class="nl">DPMError:</span>
        <span class="n">bus_remove_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
 <span class="nl">BusError:</span>
        <span class="n">device_remove_attrs</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
 <span class="nl">AttrsError:</span>
        <span class="n">device_remove_class_symlinks</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
 <span class="nl">SymlinkError:</span>
        <span class="n">device_remove_file</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_uevent</span><span class="p">);</span>
 <span class="nl">attrError:</span>
        <span class="n">device_platform_notify</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">KOBJ_REMOVE</span><span class="p">);</span>
<span class="nl">platform_error:</span>
        <span class="n">kobject_uevent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">KOBJ_REMOVE</span><span class="p">);</span>
        <span class="n">glue_dir</span> <span class="o">=</span> <span class="n">get_glue_dir</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
        <span class="n">kobject_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">);</span>
 <span class="nl">Error:</span>
        <span class="n">cleanup_glue_dir</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">glue_dir</span><span class="p">);</span>
<span class="nl">parent_error:</span>
        <span class="n">put_device</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
<span class="nl">name_error:</span>
        <span class="n">kfree</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">);</span>
        <span class="n">dev</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">device_add</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></div></div>

<p>We can easily find that weird behavior of the device_add,
which invokes get_device(dev) function to retrieve the 
reference to the device even though we have an access to it.</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="nf">get_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">return</span> <span class="n">dev</span> <span class="o">?</span> <span class="n">kobj_to_dev</span><span class="p">(</span><span class="n">kobject_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">))</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">get_device</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="nf">kobject_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">kobj</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kobj</span><span class="o">-&gt;</span><span class="n">state_initialized</span><span class="p">)</span>
                        <span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">KERN_WARNING</span>
                                <span class="s">"kobject: '%s' (%p): is not initialized, yet kobject_get() is being called.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                             <span class="n">kobject_name</span><span class="p">(</span><span class="n">kobj</span><span class="p">),</span> <span class="n">kobj</span><span class="p">);</span>
                <span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kobj</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">kobj</span><span class="p">;</span> 
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kobject_get</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="nf">kobj_to_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span><span class="p">,</span> <span class="n">kobj</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>This is because we now have an initialized 
kobject embedded in the device.
When the get_device function is invoked,
it just returns the device reference,
but it increases the reference counter 
of the embedded kobject of the device.
The kobject_get function increases the reference counter,
and return the kobject reference of the device.
The kobj_to_dev function just utilize the container_of macro
to retrieve the device structure
associated with current kobject.</p>

<p>Because platform_bus device is statically allocated
and has no parent device,
its parent field is NULL and we can just ignore 
all functions related with retrieving 
its parent device object. 
After that, 
it invokes kobject_add function
which register the platform_bus device to 
its kset, devices_kset.</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre></td><td class="rouge-code"><pre><span class="cm">/**
 * kobject_add() - The main kobject add function.
 * @kobj: the kobject to add
 * @parent: pointer to the parent of the kobject.
 * @fmt: format to name the kobject with.
 *
 * The kobject name is set and added to the kobject hierarchy in this
 * function.
 *
 * If @parent is set, then the parent of the @kobj will be set to it.
 * If @parent is NULL, then the parent of the @kobj will be set to the
 * kobject associated with the kset assigned to this kobject.  If no kset
 * is assigned to the kobject, then the kobject will be located in the
 * root of the sysfs tree.
 *
 * Note, no "add" uevent will be created with this call, the caller should set
 * up all of the necessary sysfs files for the object and then call
 * kobject_uevent() with the UEVENT_ADD parameter to ensure that
 * userspace is properly notified of this kobject's creation.
 *      
 * Return: If this function returns an error, kobject_put() must be
 *         called to properly clean up the memory associated with the
 *         object.  Under no instance should the kobject that is passed
 *         to this function be directly freed with a call to kfree(),
 *         that can leak memory.
 *
 *         If this function returns success, kobject_put() must also be called
 *         in order to properly clean up the memory associated with the object.
 *              
 *         In short, once this function is called, kobject_put() MUST be called
 *         when the use of the object is finished in order to properly free
 *         everything.
 */</span>     

<span class="kt">int</span> <span class="nf">kobject_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> 
                <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>        
        <span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
                
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kobj</span><span class="p">)</span>
                <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kobj</span><span class="o">-&gt;</span><span class="n">state_initialized</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">pr_err</span><span class="p">(</span><span class="s">"kobject '%s' (%p): tried to add an uninitialized object, something is seriously wrong.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                       <span class="n">kobject_name</span><span class="p">(</span><span class="n">kobj</span><span class="p">),</span> <span class="n">kobj</span><span class="p">);</span>
                <span class="n">dump_stack</span><span class="p">();</span>
                <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
        <span class="p">}</span>       
        <span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="n">kobject_add_varg</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
        <span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
        
        <span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>       
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kobject_add</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></div></div>
<p>Here, note that its parent and fmt argument is set as NULL
because platform_bus device has no parent device,
and kobj points to the platform_bus device itself. 
First conditional statement confirms whether the 
device structure has been initialized 
by checking state_initialized field of kobject of platform_bus device.
This field has been initialized at the first part of device_register function,
device_initialize.</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">int</span> <span class="nf">kobject_add_internal</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kobj</span><span class="p">)</span>
                <span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kobj</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">||</span> <span class="o">!</span><span class="n">kobj</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span>
                     <span class="s">"kobject: (%p): attempted to be registered with empty name!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                     <span class="n">kobj</span><span class="p">);</span>
                <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">parent</span> <span class="o">=</span> <span class="n">kobject_get</span><span class="p">(</span><span class="n">kobj</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>

        <span class="cm">/* join kset if set, use it as parent if we do not already have one */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">kobj</span><span class="o">-&gt;</span><span class="n">kset</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parent</span><span class="p">)</span>
                        <span class="n">parent</span> <span class="o">=</span> <span class="n">kobject_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kobj</span><span class="o">-&gt;</span><span class="n">kset</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">);</span>
                <span class="n">kobj_kset_join</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>
                <span class="n">kobj</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">pr_debug</span><span class="p">(</span><span class="s">"kobject: '%s' (%p): %s: parent: '%s', set: '%s'</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                 <span class="n">kobject_name</span><span class="p">(</span><span class="n">kobj</span><span class="p">),</span> <span class="n">kobj</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
                 <span class="n">parent</span> <span class="o">?</span> <span class="n">kobject_name</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span> <span class="o">:</span> <span class="s">"&lt;NULL&gt;"</span><span class="p">,</span>
                 <span class="n">kobj</span><span class="o">-&gt;</span><span class="n">kset</span> <span class="o">?</span> <span class="n">kobject_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kobj</span><span class="o">-&gt;</span><span class="n">kset</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">)</span> <span class="o">:</span> <span class="s">"&lt;NULL&gt;"</span><span class="p">);</span>

        <span class="n">error</span> <span class="o">=</span> <span class="n">create_dir</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">kobj_kset_leave</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>
                <span class="n">kobject_put</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
                <span class="n">kobj</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

                <span class="cm">/* be noisy on error issues */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">)</span>
                        <span class="n">pr_err</span><span class="p">(</span><span class="s">"%s failed for %s with -EEXIST, don't try to register things with the same name in the same directory.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                               <span class="n">__func__</span><span class="p">,</span> <span class="n">kobject_name</span><span class="p">(</span><span class="n">kobj</span><span class="p">));</span>
                <span class="k">else</span>
                        <span class="n">pr_err</span><span class="p">(</span><span class="s">"%s failed for %s (error: %d parent: %s)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                               <span class="n">__func__</span><span class="p">,</span> <span class="n">kobject_name</span><span class="p">(</span><span class="n">kobj</span><span class="p">),</span> <span class="n">error</span><span class="p">,</span>
                               <span class="n">parent</span> <span class="o">?</span> <span class="n">kobject_name</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span> <span class="o">:</span> <span class="s">"'none'"</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span>
                <span class="n">kobj</span><span class="o">-&gt;</span><span class="n">state_in_sysfs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>It register the kobject of the platform_bus to its kset
using kobj_kset_join function.
Also because this device doesn’t have parent,
its kobject deosn’t have parent neither. 
Therefore, 
it allocates the kset’s kobject 
as its parent kobject.</p>

<p>Although the current device has no attached bus
because it is the bus device itself,
if it were a end-device, it needs to be attached to the proper bus
by bus_add_device function.</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="rouge-code"><pre><span class="cm">/**
 * bus_add_device - add device to bus
 * @dev: device being added
 *              
 * - Add device's bus attributes.
 * - Create links to device's bus.
 * - Add the device to its bus's list of devices.
 */</span>     
<span class="kt">int</span> <span class="nf">bus_add_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>               
        <span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span> <span class="o">=</span> <span class="n">bus_get</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                
        <span class="k">if</span> <span class="p">(</span><span class="n">bus</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">pr_debug</span><span class="p">(</span><span class="s">"bus: '%s': add device %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
                <span class="n">error</span> <span class="o">=</span> <span class="n">device_add_groups</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">dev_groups</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
                        <span class="k">goto</span> <span class="n">out_put</span><span class="p">;</span>
                <span class="n">error</span> <span class="o">=</span> <span class="n">sysfs_create_link</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">devices_kset</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span>
                                                <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
                        <span class="k">goto</span> <span class="n">out_groups</span><span class="p">;</span>
                <span class="n">error</span> <span class="o">=</span> <span class="n">sysfs_create_link</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span>
                                <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">.</span><span class="n">kobj</span><span class="p">,</span> <span class="s">"subsystem"</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
                        <span class="k">goto</span> <span class="n">out_subsys</span><span class="p">;</span>
                <span class="n">klist_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">knode_bus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">klist_devices</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
         
<span class="nl">out_subsys:</span>
        <span class="n">sysfs_remove_link</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">devices_kset</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
<span class="nl">out_groups:</span>                                  
        <span class="n">device_remove_groups</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">dev_groups</span><span class="p">);</span>
<span class="nl">out_put:</span>
        <span class="n">bus_put</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>  
</pre></td></tr></tbody></table></code></div></div>

<p>The most important part of this function is 
registering the device’s knode for bus, knode_bus
to the bus’ klist_device klist.
This registration is done by klist_add_tail function. 
After device attachment is done,
the device driver that can handle the registered device 
should be bound to the device.</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="rouge-code"><pre><span class="cm">/**             
 * bus_probe_device - probe drivers for a new device
 * @dev: device to probe
 *
 * - Automatically probe for a driver if the bus allows it.
 */</span>     
<span class="kt">void</span> <span class="nf">bus_probe_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>                              
        <span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">subsys_interface</span> <span class="o">*</span><span class="n">sif</span><span class="p">;</span>
                
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bus</span><span class="p">)</span>
                <span class="k">return</span><span class="p">;</span>
                               
        <span class="k">if</span> <span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">drivers_autoprobe</span><span class="p">)</span>
                <span class="n">device_initial_probe</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
                
        <span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span> 
        <span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">sif</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">interfaces</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">sif</span><span class="o">-&gt;</span><span class="n">add_dev</span><span class="p">)</span>
                        <span class="n">sif</span><span class="o">-&gt;</span><span class="n">add_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">sif</span><span class="p">);</span>
        <span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>If the current device is attached to the bus and 
autoprobe of the bus has been enabled,
it invokes device_initial_probe 
that will actually searches the device driver and binding.
The details will be coverd in this post.</p>

<h3 id="bus-registration"><span class="me-2">Bus registration</span><a href="#bus-registration" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p>What we have done for platform_bus so far is 
registering platform_bus as device 
to the driver sub-system.
In other words, because even the bus is treated and managed by the 
driver sub-system in the Linux kernel,
we have to firstly create the device for the bus
and register it to the system.
However, 
because the bus device is used to manage other devices attached to it
it should have its private sub-system for managing 
the attached devices.</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">__init</span> <span class="nf">platform_bus_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

        <span class="n">early_platform_cleanup</span><span class="p">();</span>

        <span class="n">error</span> <span class="o">=</span> <span class="n">device_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">platform_bus</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">platform_bus</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">error</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">error</span> <span class="o">=</span>  <span class="n">bus_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">platform_bus_type</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
                <span class="n">device_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">platform_bus</span><span class="p">);</span>
        <span class="n">of_platform_register_reconfig_notifier</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

</pre></td></tr></tbody></table></code></div></div>
<p>When we revisit the platform_bus_init function,
we can find that bus_register function is called 
with platform_bus_type which is an object
of bus_type.
Let’s take what is the purpose of bus_type
and implementation of platform_bus_type.</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
</pre></td><td class="rouge-code"><pre><span class="cm">/**
 * struct bus_type - The bus type of the device
 *
 * @name:       The name of the bus.
 * @dev_name:   Used for subsystems to enumerate devices like ("foo%u", dev-&gt;id).
 * @dev_root:   Default device to use as the parent.
 * @bus_groups: Default attributes of the bus.
 * @dev_groups: Default attributes of the devices on the bus.
 * @drv_groups: Default attributes of the device drivers on the bus.
 * @match:      Called, perhaps multiple times, whenever a new device or driver
 *              is added for this bus. It should return a positive value if the
 *              given device can be handled by the given driver and zero
 *              otherwise. It may also return error code if determining that
 *              the driver supports the device is not possible. In case of
 *              -EPROBE_DEFER it will queue the device for deferred probing.
 * @uevent:     Called when a device is added, removed, or a few other things
 *              that generate uevents to add the environment variables.
 * @probe:      Called when a new device or driver add to this bus, and callback
 *              the specific driver's probe to initial the matched device.
 * @sync_state: Called to sync device state to software state after all the
 *              state tracking consumers linked to this device (present at
 *              the time of late_initcall) have successfully bound to a
 *              driver. If the device has no consumers, this function will
 *              be called at late_initcall_sync level. If the device has
 *              consumers that are never bound to a driver, this function
 *              will never get called until they do.
 * @remove:     Called when a device removed from this bus.
 * @shutdown:   Called at shut-down time to quiesce the device.
 *
 * @online:     Called to put the device back online (after offlining it).
 * @offline:    Called to put the device offline for hot-removal. May fail.
 *
 * @suspend:    Called when a device on this bus wants to go to sleep mode.
 * @resume:     Called to bring a device on this bus out of sleep mode.
 * @num_vf:     Called to find out how many virtual functions a device on this
 *              bus supports.
 * @dma_configure:      Called to setup DMA configuration on a device on
 *                      this bus.
 * @pm:         Power management operations of this bus, callback the specific
 *              device driver's pm-ops.
 * @iommu_ops:  IOMMU specific operations for this bus, used to attach IOMMU
 *              driver implementations to a bus and allow the driver to do
 *              bus-specific setup
 * @p:          The private data of the driver core, only the driver core can
 *              touch this.
 * @lock_key:   Lock class key for use by the lock validator
 * @need_parent_lock:   When probing or removing a device on this bus, the
 *                      device core should lock the device's parent.
 *
 * A bus is a channel between the processor and one or more devices. For the
 * purposes of the device model, all devices are connected via a bus, even if
 * it is an internal, virtual, "platform" bus. Buses can plug into each other.
 * A USB controller is usually a PCI device, for example. The device model
 * represents the actual connections between buses and the devices they control.
 * A bus is represented by the bus_type structure. It contains the name, the
 * default attributes, the bus' methods, PM operations, and the driver core's
 * private data.
 */</span>
<span class="k">struct</span> <span class="n">bus_type</span> <span class="p">{</span>
        <span class="k">const</span> <span class="kt">char</span>              <span class="o">*</span><span class="n">name</span><span class="p">;</span>
        <span class="k">const</span> <span class="kt">char</span>              <span class="o">*</span><span class="n">dev_name</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">device</span>           <span class="o">*</span><span class="n">dev_root</span><span class="p">;</span>
        <span class="k">const</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="o">**</span><span class="n">bus_groups</span><span class="p">;</span>
        <span class="k">const</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="o">**</span><span class="n">dev_groups</span><span class="p">;</span>
        <span class="k">const</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="o">**</span><span class="n">drv_groups</span><span class="p">;</span>

        <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">match</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">);</span>
        <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">uevent</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_uevent_env</span> <span class="o">*</span><span class="n">env</span><span class="p">);</span>
        <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">probe</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
        <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">sync_state</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
        <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">remove</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
        <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">shutdown</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

        <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">online</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
        <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">offline</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

        <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">suspend</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">);</span>
        <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">resume</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

        <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">num_vf</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

        <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">dma_configure</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

        <span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="o">*</span><span class="n">pm</span><span class="p">;</span>

        <span class="k">const</span> <span class="k">struct</span> <span class="n">iommu_ops</span> <span class="o">*</span><span class="n">iommu_ops</span><span class="p">;</span>

        <span class="k">struct</span> <span class="n">subsys_private</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">lock_class_key</span> <span class="n">lock_key</span><span class="p">;</span>

        <span class="n">bool</span> <span class="n">need_parent_lock</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">bus_type</span> <span class="n">platform_bus_type</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">name</span>           <span class="o">=</span> <span class="s">"platform"</span><span class="p">,</span>
        <span class="p">.</span><span class="n">dev_groups</span>     <span class="o">=</span> <span class="n">platform_dev_groups</span><span class="p">,</span>
        <span class="p">.</span><span class="n">match</span>          <span class="o">=</span> <span class="n">platform_match</span><span class="p">,</span>
        <span class="p">.</span><span class="n">uevent</span>         <span class="o">=</span> <span class="n">platform_uevent</span><span class="p">,</span>
        <span class="p">.</span><span class="n">probe</span>          <span class="o">=</span> <span class="n">platform_probe</span><span class="p">,</span>
        <span class="p">.</span><span class="n">remove</span>         <span class="o">=</span> <span class="n">platform_remove</span><span class="p">,</span>
        <span class="p">.</span><span class="n">shutdown</span>       <span class="o">=</span> <span class="n">platform_shutdown</span><span class="p">,</span>
        <span class="p">.</span><span class="n">dma_configure</span>  <span class="o">=</span> <span class="n">platform_dma_configure</span><span class="p">,</span>
        <span class="p">.</span><span class="n">pm</span>             <span class="o">=</span> <span class="o">&amp;</span><span class="n">platform_dev_pm_ops</span><span class="p">,</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></div></div>
<p>The bus_type structure contains
some information about the bus itself and 
bunch of call-back functions 
required to manage bus and its sub-devices
attached to the bus.
Also, it maintains subsys_private pointer
that actually used to manage the bus
and its associated devices and drivers.</p>

<p>Let’s take a look at
how the bus_register function actually register 
a new bus sub-system.</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
</pre></td><td class="rouge-code"><pre><span class="cm">/**
 * bus_register - register a driver-core subsystem
 * @bus: bus to register
 *
 * Once we have that, we register the bus with the kobject
 * infrastructure, then register the children subsystems it has:
 * the devices and drivers that belong to the subsystem.
 */</span>
<span class="kt">int</span> <span class="nf">bus_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">subsys_private</span> <span class="o">*</span><span class="n">priv</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">lock_class_key</span> <span class="o">*</span><span class="n">key</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">lock_key</span><span class="p">;</span>

        <span class="n">priv</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">subsys_private</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="p">)</span>
                <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

        <span class="n">priv</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">=</span> <span class="n">bus</span><span class="p">;</span>
        <span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>

        <span class="n">BLOCKING_INIT_NOTIFIER_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">bus_notifier</span><span class="p">);</span>

        <span class="n">retval</span> <span class="o">=</span> <span class="n">kobject_set_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">.</span><span class="n">kobj</span><span class="p">,</span> <span class="s">"%s"</span><span class="p">,</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
                <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

        <span class="n">priv</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">.</span><span class="n">kobj</span><span class="p">.</span><span class="n">kset</span> <span class="o">=</span> <span class="n">bus_kset</span><span class="p">;</span>
        <span class="n">priv</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">.</span><span class="n">kobj</span><span class="p">.</span><span class="n">ktype</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bus_ktype</span><span class="p">;</span>
        <span class="n">priv</span><span class="o">-&gt;</span><span class="n">drivers_autoprobe</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="n">retval</span> <span class="o">=</span> <span class="n">kset_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
                <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

        <span class="n">retval</span> <span class="o">=</span> <span class="n">bus_create_file</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus_attr_uevent</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
                <span class="k">goto</span> <span class="n">bus_uevent_fail</span><span class="p">;</span>

        <span class="n">priv</span><span class="o">-&gt;</span><span class="n">devices_kset</span> <span class="o">=</span> <span class="n">kset_create_and_add</span><span class="p">(</span><span class="s">"devices"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
                                                 <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">.</span><span class="n">kobj</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">devices_kset</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
                <span class="k">goto</span> <span class="n">bus_devices_fail</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">priv</span><span class="o">-&gt;</span><span class="n">drivers_kset</span> <span class="o">=</span> <span class="n">kset_create_and_add</span><span class="p">(</span><span class="s">"drivers"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
                                                 <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">.</span><span class="n">kobj</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">drivers_kset</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
                <span class="k">goto</span> <span class="n">bus_drivers_fail</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">interfaces</span><span class="p">);</span>
        <span class="n">__mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">,</span> <span class="s">"subsys mutex"</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
        <span class="n">klist_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">klist_devices</span><span class="p">,</span> <span class="n">klist_devices_get</span><span class="p">,</span> <span class="n">klist_devices_put</span><span class="p">);</span>
        <span class="n">klist_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">klist_drivers</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

        <span class="n">retval</span> <span class="o">=</span> <span class="n">add_probe_files</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
                <span class="k">goto</span> <span class="n">bus_probe_files_fail</span><span class="p">;</span>

        <span class="n">retval</span> <span class="o">=</span> <span class="n">bus_add_groups</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">bus_groups</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
                <span class="k">goto</span> <span class="n">bus_groups_fail</span><span class="p">;</span>

        <span class="n">pr_debug</span><span class="p">(</span><span class="s">"bus: '%s': registered</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">bus_groups_fail:</span>
        <span class="n">remove_probe_files</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>
<span class="nl">bus_probe_files_fail:</span>
        <span class="n">kset_unregister</span><span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">drivers_kset</span><span class="p">);</span>
<span class="nl">bus_drivers_fail:</span>
        <span class="n">kset_unregister</span><span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">devices_kset</span><span class="p">);</span>
<span class="nl">bus_devices_fail:</span>
        <span class="n">bus_remove_file</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus_attr_uevent</span><span class="p">);</span>
<span class="nl">bus_uevent_fail:</span>
        <span class="n">kset_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">);</span>
<span class="nl">out:</span>
        <span class="n">kfree</span><span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">);</span>
        <span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">bus_register</span><span class="p">);</span>

<span class="cm">/**
 * struct subsys_private - structure to hold the private to the driver core portions of the bus_type/class structure.
 *
 * @subsys - the struct kset that defines this subsystem
 * @devices_kset - the subsystem's 'devices' directory
 * @interfaces - list of subsystem interfaces associated
 * @mutex - protect the devices, and interfaces lists.
 *
 * @drivers_kset - the list of drivers associated
 * @klist_devices - the klist to iterate over the @devices_kset
 * @klist_drivers - the klist to iterate over the @drivers_kset
 * @bus_notifier - the bus notifier list for anything that cares about things
 *                 on this bus.
 * @bus - pointer back to the struct bus_type that this structure is associated
 *        with.
 *
 * @glue_dirs - "glue" directory to put in-between the parent device to
 *              avoid namespace conflicts
 * @class - pointer back to the struct class that this structure is associated
 *          with.
 *
 * This structure is the one that is the actual kobject allowing struct
 * bus_type/class to be statically allocated safely.  Nothing outside of the
 * driver core should ever touch these fields.
 */</span>
<span class="k">struct</span> <span class="n">subsys_private</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">kset</span> <span class="n">subsys</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">kset</span> <span class="o">*</span><span class="n">devices_kset</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">list_head</span> <span class="n">interfaces</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">mutex</span> <span class="n">mutex</span><span class="p">;</span>

        <span class="k">struct</span> <span class="n">kset</span> <span class="o">*</span><span class="n">drivers_kset</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">klist</span> <span class="n">klist_devices</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">klist</span> <span class="n">klist_drivers</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">blocking_notifier_head</span> <span class="n">bus_notifier</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">drivers_autoprobe</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">;</span>

        <span class="k">struct</span> <span class="n">kset</span> <span class="n">glue_dirs</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">class</span> <span class="o">*</span><span class="n">class</span><span class="p">;</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></div></div>

<p>The most important role of the bus_register function is 
generating a subsystem for the bus device,
which is used to manage the devices and their drivers 
sitting on the bus. 
Therefore,
to understand how the registered bus manages
devices attached to the bus and its associated drivers,
we have to understand the data structure subsys_private
which contains most important data fields
regarding device and driver management.</p>

<p>The first thing done by the bus_register function is
allocating the subsys_private object and initialization.
The function chains the bus_type structure and subsys_private structure
by assigning the pointers to each other
as their memeber fields respectively.
Therefore, when you have either bus_type or subsys_private object,
you can reference the other also.
It assigns the generated subsys_private object to
bus object memeber field, p.</p>

<p>Because subsystems are also managed by as kset and kobjects system,
the kobject should be properly registered to a kset.
You might remeber that 
buses_init function genereates kset named bus_kset.
Note that generated subsystem’s kobject’s kset field 
points to the bus_kset,
which means the generated subsystem will be managed by bus_kset.
kset_register function actually handles registration process.</p>

<p>Next important thing is 
intializing klist for managing devices and its associated drivers
that could sit on the current bus,
klist_devices and klist_drivers.
Note that this klist_devices kset is 
dedicated for the current bus subsystem.</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">__init</span> <span class="nf">devices_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">devices_kset</span> <span class="o">=</span> <span class="n">kset_create_and_add</span><span class="p">(</span><span class="s">"devices"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">device_uevent_ops</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="p">...</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>Although previous devices_init function 
also genereated the kset named “devices”
and assign this to devices_kset,
priv-&gt;devices_kset which is dedicated to a one bus sub-system is 
totally different.
The devices_kset of the bus subsystem only manages 
devices attached to the bus,
but the devices_kset is orchestrates
devices in the whole Linux driver system.</p>

<h3 id="add-notifier-block-to-device-file-notifier-chain"><span class="me-2">Add notifier block to device file notifier chain</span><a href="#add-notifier-block-to-device-file-notifier-chain" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<p>Because device file heavily make use of platform device,
it needs to register notifer of platform device,
platform_of_notifer,
to the devie file’s notifier chain.
Before we take a look at 
which platform related function 
of the notifier block will be added 
to the device file’s notifier chain,
let’s take a look at the API functions 
that help us to register platform notifier block.</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre></td><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">of_platform_register_reconfig_notifier</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">WARN_ON</span><span class="p">(</span><span class="n">of_reconfig_notifier_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">platform_of_notifier</span><span class="p">));</span>
<span class="p">}</span>   

<span class="k">static</span> <span class="nf">BLOCKING_NOTIFIER_HEAD</span><span class="p">(</span><span class="n">of_reconfig_chain</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">of_reconfig_notifier_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">return</span> <span class="n">blocking_notifier_chain_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">of_reconfig_chain</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
<span class="p">}</span>       

<span class="cm">/* 
 *      Blocking notifier chain routines.  All access to the chain is
 *      synchronized by an rwsem.
 */</span>     

<span class="cm">/**
 *      blocking_notifier_chain_register - Add notifier to a blocking notifier chain
 *      @nh: Pointer to head of the blocking notifier chain
 *      @n: New entry in notifier chain
 *
 *      Adds a notifier to a blocking notifier chain.
 *      Must be called in process context.
 *
 *      Currently always returns zero.
 */</span>
<span class="kt">int</span> <span class="nf">blocking_notifier_chain_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">blocking_notifier_head</span> <span class="o">*</span><span class="n">nh</span><span class="p">,</span>
                <span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>               
        <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

        <span class="cm">/*
         * This code gets used during boot-up, when task switching is
         * not yet working and interrupts must remain disabled.  At
         * such times we must not call down_write().
         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">system_state</span> <span class="o">==</span> <span class="n">SYSTEM_BOOTING</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">notifier_chain_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nh</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>

        <span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nh</span><span class="o">-&gt;</span><span class="n">rwsem</span><span class="p">);</span> 
        <span class="n">ret</span> <span class="o">=</span> <span class="n">notifier_chain_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nh</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
        <span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nh</span><span class="o">-&gt;</span><span class="n">rwsem</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">blocking_notifier_chain_register</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></div></div>

<p>of_reconfig_chain is a list 
that manages all registered notifier blocks of the device file.
The blocking_notifier_chain_register helps us
register the notifier block to the list.</p>

<p>Let’s take what function is included in the platform notifier block.</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">platform_of_notifier</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">of_platform_notify</span><span class="p">,</span>
<span class="p">};</span>  

<span class="k">static</span> <span class="kt">int</span> <span class="nf">of_platform_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">,</span>
                                <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">of_reconfig_data</span> <span class="o">*</span><span class="n">rd</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span> 
        <span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev_parent</span><span class="p">,</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
        <span class="n">bool</span> <span class="n">children_left</span><span class="p">;</span>
 
        <span class="k">switch</span> <span class="p">(</span><span class="n">of_reconfig_get_state_change</span><span class="p">(</span><span class="n">action</span><span class="p">,</span> <span class="n">rd</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">OF_RECONFIG_CHANGE_ADD</span><span class="p">:</span>
                <span class="cm">/* verify that the parent is a bus */</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">of_node_check_flag</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">,</span> <span class="n">OF_POPULATED_BUS</span><span class="p">))</span>
                        <span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>       <span class="cm">/* not for us */</span>

                <span class="cm">/* already populated? (driver using of_populate manually) */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">of_node_check_flag</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">dn</span><span class="p">,</span> <span class="n">OF_POPULATED</span><span class="p">))</span>
                        <span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>

                <span class="cm">/* pdev_parent may be NULL when no bus platform device */</span>
                <span class="n">pdev_parent</span> <span class="o">=</span> <span class="n">of_find_device_by_node</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
                <span class="n">pdev</span> <span class="o">=</span> <span class="n">of_platform_device_create</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">dn</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
                                <span class="n">pdev_parent</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">pdev_parent</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">);</span>
                <span class="n">of_dev_put</span><span class="p">(</span><span class="n">pdev_parent</span><span class="p">);</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">pdev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">pr_err</span><span class="p">(</span><span class="s">"%s: failed to create for '%pOF'</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                                        <span class="n">__func__</span><span class="p">,</span> <span class="n">rd</span><span class="o">-&gt;</span><span class="n">dn</span><span class="p">);</span>
                        <span class="cm">/* of_platform_device_create tosses the error code */</span>
                        <span class="k">return</span> <span class="n">notifier_from_errno</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="k">break</span><span class="p">;</span>
        
        <span class="k">case</span> <span class="n">OF_RECONFIG_CHANGE_REMOVE</span><span class="p">:</span>
        
                <span class="cm">/* already depopulated? */</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">of_node_check_flag</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">dn</span><span class="p">,</span> <span class="n">OF_POPULATED</span><span class="p">))</span>
                        <span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>

                <span class="cm">/* find our device by node */</span>
                <span class="n">pdev</span> <span class="o">=</span> <span class="n">of_find_device_by_node</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">dn</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">pdev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
                        <span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>       <span class="cm">/* no? not meant for us */</span>

                <span class="cm">/* unregister takes one ref away */</span>
                <span class="n">of_platform_device_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">children_left</span><span class="p">);</span>
        
                <span class="cm">/* and put the reference of the find */</span>
                <span class="n">of_dev_put</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>               
                
        <span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
<span class="p">}</span>       



</pre></td></tr></tbody></table></code></div></div>

<h2 id="detect-and-add-platform-devices"><span class="me-2">Detect and add platform devices</span><a href="#detect-and-add-platform-devices" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>
<p>So far we explored how the platform bus has been initialized 
as sub-system of the entire driver system of the Linux kernel.
Then how can we detect the devices that needs to be registered as platform device
instead of other usb or pci devices which can be automatically detected
by the bus supporting hot-plugging?
Although there are several other parts of the kernel
register the devices as platform device,
the biggest chance to discover and register 
most of the platform devices exists in the device tree. 
Therefore, let’s take a look at the initialization function
of the device tree.</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">of_platform_default_populate_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>       
        <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>

        <span class="n">device_links_supplier_sync_state_pause</span><span class="p">();</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">of_have_populated_dt</span><span class="p">())</span>
                <span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
 
        <span class="cm">/*
         * Handle certain compatibles explicitly, since we don't want to create
         * platform_devices for every node in /reserved-memory with a
         * "compatible",
         */</span>                      
        <span class="n">for_each_matching_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">reserved_mem_matches</span><span class="p">)</span>
                <span class="n">of_platform_device_create</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
 
        <span class="n">node</span> <span class="o">=</span> <span class="n">of_find_node_by_path</span><span class="p">(</span><span class="s">"/firmware"</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span> 
                <span class="n">of_platform_populate</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
                <span class="n">of_node_put</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
        <span class="p">}</span>
        
        <span class="cm">/* Populate everything else. */</span> 
        <span class="n">of_platform_default_populate</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">arch_initcall_sync</span><span class="p">(</span><span class="n">of_platform_default_populate_init</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></div></div>
<p>We can find that of_platform_default_populate_init function is set 
as initcall function that will be executed 
during do_initcall function.
The detailed information of the do_initcall
and its related macros are going to explained in other posts.</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">of_platform_default_populate</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
                                 <span class="k">const</span> <span class="k">struct</span> <span class="n">of_dev_auxdata</span> <span class="o">*</span><span class="n">lookup</span><span class="p">,</span>
                                 <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">return</span> <span class="n">of_platform_populate</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">of_default_bus_match_table</span><span class="p">,</span> <span class="n">lookup</span><span class="p">,</span>
                                    <span class="n">parent</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">of_platform_default_populate</span><span class="p">)</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">of_device_id</span> <span class="n">of_default_bus_match_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{</span> <span class="p">.</span><span class="n">compatible</span> <span class="o">=</span> <span class="s">"simple-bus"</span><span class="p">,</span> <span class="p">},</span>
        <span class="p">{</span> <span class="p">.</span><span class="n">compatible</span> <span class="o">=</span> <span class="s">"simple-mfd"</span><span class="p">,</span> <span class="p">},</span>
        <span class="p">{</span> <span class="p">.</span><span class="n">compatible</span> <span class="o">=</span> <span class="s">"isa"</span><span class="p">,</span> <span class="p">},</span>
<span class="cp">#ifdef CONFIG_ARM_AMBA
</span>        <span class="p">{</span> <span class="p">.</span><span class="n">compatible</span> <span class="o">=</span> <span class="s">"arm,amba-bus"</span><span class="p">,</span> <span class="p">},</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_ARM_AMBA */</span><span class="cp">
</span>        <span class="p">{}</span> <span class="cm">/* Empty terminated list */</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></div></div>
<p>of_platform_default_populate function is a wrapper function of the 
of_platform_populate function which is set to be invoked 
with of_default_bus_match_table as its second parameter.
The string contained in the match table will be used to find a node 
where its compatible string is same as one of the specified compatible string.
Also because this is the first function to traverse the device tree,
it have NULL value for first and third argument, root and parent.</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
</pre></td><td class="rouge-code"><pre><span class="cm">/**
 * of_platform_populate() - Populate platform_devices from device tree data
 * @root: parent of the first level to probe or NULL for the root of the tree
 * @matches: match table, NULL to use the default
 * @lookup: auxdata table for matching id and platform_data with device nodes
 * @parent: parent to hook devices from, NULL for toplevel
 *
 * Similar to of_platform_bus_probe(), this function walks the device tree
 * and creates devices from nodes.  It differs in that it follows the modern
 * convention of requiring all device nodes to have a 'compatible' property,
 * and it is suitable for creating devices which are children of the root
 * node (of_platform_bus_probe will only create children of the root which
 * are selected by the @matches argument).
 *
 * New board support should be using this function instead of
 * of_platform_bus_probe().
 *
 * Returns 0 on success, &lt; 0 on failure.
 */</span>
<span class="kt">int</span> <span class="nf">of_platform_populate</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
                        <span class="k">const</span> <span class="k">struct</span> <span class="n">of_device_id</span> <span class="o">*</span><span class="n">matches</span><span class="p">,</span>
                        <span class="k">const</span> <span class="k">struct</span> <span class="n">of_dev_auxdata</span> <span class="o">*</span><span class="n">lookup</span><span class="p">,</span>
                        <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>       
        <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">child</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        
        <span class="n">root</span> <span class="o">=</span> <span class="n">root</span> <span class="o">?</span> <span class="n">of_node_get</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="o">:</span> <span class="n">of_find_node_by_path</span><span class="p">(</span><span class="s">"/"</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span>
                <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

        <span class="n">pr_debug</span><span class="p">(</span><span class="s">"%s()</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
        <span class="n">pr_debug</span><span class="p">(</span><span class="s">" starting at: %pOF</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>

        <span class="n">device_links_supplier_sync_state_pause</span><span class="p">();</span>
        <span class="n">for_each_child_of_node</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">rc</span> <span class="o">=</span> <span class="n">of_platform_bus_create</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">matches</span><span class="p">,</span> <span class="n">lookup</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">of_node_put</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
                        <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">device_links_supplier_sync_state_resume</span><span class="p">();</span>

        <span class="n">of_node_set_flag</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">OF_POPULATED_BUS</span><span class="p">);</span>

        <span class="n">of_node_put</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">of_platform_populate</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></div></div>
<p>Becuase the root device_node has been passed as NULL,
it should first find the root node by traversing the device tree.
The of_find_node_by_path will find the root node.
After the root node has been find, 
it traverse every node in the tree 
with for_each_child_of_node macro. 
Note that it invokes of_platform_bus_create function
for every children of the root 
which means entire nodes in the device tree.
Although it passes 5 parameters,
only child and matches parameters are meaningful because 
others are set as NULL.</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
</pre></td><td class="rouge-code"><pre><span class="cm">/**
 * of_platform_bus_create() - Create a device for a node and its children.
 * @bus: device node of the bus to instantiate
 * @matches: match table for bus nodes
 * @lookup: auxdata table for matching id and platform_data with device nodes
 * @parent: parent for new device, or NULL for top level.
 * @strict: require compatible property
 *
 * Creates a platform_device for the provided device_node, and optionally
 * recursively create devices for all the child nodes.
 */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">of_platform_bus_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span>
                                  <span class="k">const</span> <span class="k">struct</span> <span class="n">of_device_id</span> <span class="o">*</span><span class="n">matches</span><span class="p">,</span>
                                  <span class="k">const</span> <span class="k">struct</span> <span class="n">of_dev_auxdata</span> <span class="o">*</span><span class="n">lookup</span><span class="p">,</span>
                                  <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="n">bool</span> <span class="n">strict</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">const</span> <span class="k">struct</span> <span class="n">of_dev_auxdata</span> <span class="o">*</span><span class="n">auxdata</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">child</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
        <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">bus_id</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="kt">void</span> <span class="o">*</span><span class="n">platform_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="cm">/* Make sure it has a compatible property */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">strict</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">of_get_property</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="s">"compatible"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)))</span> <span class="p">{</span>
                <span class="n">pr_debug</span><span class="p">(</span><span class="s">"%s() - skipping %pOF, no compatible prop</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                         <span class="n">__func__</span><span class="p">,</span> <span class="n">bus</span><span class="p">);</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* Skip nodes for which we don't want to create devices */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">of_match_node</span><span class="p">(</span><span class="n">of_skipped_node_table</span><span class="p">,</span> <span class="n">bus</span><span class="p">)))</span> <span class="p">{</span>
                <span class="n">pr_debug</span><span class="p">(</span><span class="s">"%s() - skipping %pOF node</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">bus</span><span class="p">);</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">of_node_check_flag</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">OF_POPULATED_BUS</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">pr_debug</span><span class="p">(</span><span class="s">"%s() - skipping %pOF, already populated</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                        <span class="n">__func__</span><span class="p">,</span> <span class="n">bus</span><span class="p">);</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">auxdata</span> <span class="o">=</span> <span class="n">of_dev_lookup</span><span class="p">(</span><span class="n">lookup</span><span class="p">,</span> <span class="n">bus</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">auxdata</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">bus_id</span> <span class="o">=</span> <span class="n">auxdata</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
                <span class="n">platform_data</span> <span class="o">=</span> <span class="n">auxdata</span><span class="o">-&gt;</span><span class="n">platform_data</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">of_device_is_compatible</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="s">"arm,primecell"</span><span class="p">))</span> <span class="p">{</span>
                <span class="cm">/*
                 * Don't return an error here to keep compatibility with older
                 * device tree files.
                 */</span>
                <span class="n">of_amba_device_create</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">bus_id</span><span class="p">,</span> <span class="n">platform_data</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">dev</span> <span class="o">=</span> <span class="n">of_platform_device_create_pdata</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">bus_id</span><span class="p">,</span> <span class="n">platform_data</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span> <span class="o">||</span> <span class="o">!</span><span class="n">of_match_node</span><span class="p">(</span><span class="n">matches</span><span class="p">,</span> <span class="n">bus</span><span class="p">))</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

        <span class="n">for_each_child_of_node</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">pr_debug</span><span class="p">(</span><span class="s">"   create child: %pOF</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">child</span><span class="p">);</span>
                <span class="n">rc</span> <span class="o">=</span> <span class="n">of_platform_bus_create</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">matches</span><span class="p">,</span> <span class="n">lookup</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">strict</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">of_node_put</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
                        <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">of_node_set_flag</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">OF_POPULATED_BUS</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>Some readers might wonder why the name of the function is
not “of_platform_device_create”, but <em>bus</em>. 
Also, remember that the matches parameter passed to this function is 
of_default_bus_match_table,
and this is usually matches with a node 
that has compatible string names “simple-bus” in most cases.</p>

<h3 id="allocating-and-intializing-platform-device-from-device-node"><span class="me-2">Allocating and intializing platform device from device node</span><a href="#allocating-and-intializing-platform-device-from-device-node" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre></td><td class="rouge-code"><pre><span class="cm">/**
 * of_platform_device_create_pdata - Alloc, initialize and register an of_device
 * @np: pointer to node to create device for
 * @bus_id: name to assign device
 * @platform_data: pointer to populate platform_data pointer with
 * @parent: Linux device model parent device.
 *
 * Returns pointer to created platform device, or NULL if a device was not
 * registered.  Unavailable devices will not get registered.
 */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="nf">of_platform_device_create_pdata</span><span class="p">(</span>
                                        <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span>
                                        <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">bus_id</span><span class="p">,</span>
                                        <span class="kt">void</span> <span class="o">*</span><span class="n">platform_data</span><span class="p">,</span>
                                        <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">of_device_is_available</span><span class="p">(</span><span class="n">np</span><span class="p">)</span> <span class="o">||</span>
            <span class="n">of_node_test_and_set_flag</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">OF_POPULATED</span><span class="p">))</span>
                <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

        <span class="n">dev</span> <span class="o">=</span> <span class="n">of_device_alloc</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">bus_id</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
                <span class="k">goto</span> <span class="n">err_clear_flag</span><span class="p">;</span>

        <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">coherent_dma_mask</span> <span class="o">=</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">dma_mask</span><span class="p">)</span>
                <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">dma_mask</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">coherent_dma_mask</span><span class="p">;</span>
        <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">bus</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">platform_bus_type</span><span class="p">;</span>
        <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">platform_data</span> <span class="o">=</span> <span class="n">platform_data</span><span class="p">;</span>
        <span class="n">of_msi_configure</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">of_device_add</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">platform_device_put</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
                <span class="k">goto</span> <span class="n">err_clear_flag</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">dev</span><span class="p">;</span>

<span class="nl">err_clear_flag:</span>
        <span class="n">of_node_clear_flag</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">OF_POPULATED</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>The above function allocates the platform_device (of_device_alloc)
and assign the platform_bus bus_type to the 
generated device.
After that, 
the generated device is registered to the 
bus sub-system with the device_add function
that we covered before. 
The device_add function is invoked 
inside the of_device_add function.
Let’s take a look at step by step
from the device creation to its register.</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
</pre></td><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">platform_device</span> <span class="p">{</span>
        <span class="k">const</span> <span class="kt">char</span>      <span class="o">*</span><span class="n">name</span><span class="p">;</span>
        <span class="kt">int</span>             <span class="n">id</span><span class="p">;</span>
        <span class="n">bool</span>            <span class="n">id_auto</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">device</span>   <span class="n">dev</span><span class="p">;</span>
        <span class="n">u64</span>             <span class="n">platform_dma_mask</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">device_dma_parameters</span> <span class="n">dma_parms</span><span class="p">;</span>
        <span class="n">u32</span>             <span class="n">num_resources</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">resource</span><span class="p">;</span>

        <span class="k">const</span> <span class="k">struct</span> <span class="n">platform_device_id</span> <span class="o">*</span><span class="n">id_entry</span><span class="p">;</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">driver_override</span><span class="p">;</span> <span class="cm">/* Driver name to force a match */</span>

        <span class="cm">/* MFD cell pointer */</span>
        <span class="k">struct</span> <span class="n">mfd_cell</span> <span class="o">*</span><span class="n">mfd_cell</span><span class="p">;</span>

        <span class="cm">/* arch specific additions */</span>
        <span class="k">struct</span> <span class="n">pdev_archdata</span>    <span class="n">archdata</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/**
 * of_device_alloc - Allocate and initialize an of_device
 * @np: device node to assign to device
 * @bus_id: Name to assign to the device.  May be null to use default name.
 * @parent: Parent device.
 */</span>
<span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="nf">of_device_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span>
                                  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">bus_id</span><span class="p">,</span>
                                  <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">num_reg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">num_irq</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="n">temp_res</span><span class="p">;</span>

        <span class="n">dev</span> <span class="o">=</span> <span class="n">platform_device_alloc</span><span class="p">(</span><span class="s">""</span><span class="p">,</span> <span class="n">PLATFORM_DEVID_NONE</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
                <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

        <span class="cm">/* count the io and irq resources */</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">of_address_to_resource</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">num_reg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp_res</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">num_reg</span><span class="o">++</span><span class="p">;</span>
        <span class="n">num_irq</span> <span class="o">=</span> <span class="n">of_irq_count</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>

        <span class="cm">/* Populate the resource table */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">num_irq</span> <span class="o">||</span> <span class="n">num_reg</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">num_irq</span> <span class="o">+</span> <span class="n">num_reg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">res</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">platform_device_put</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
                        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="n">dev</span><span class="o">-&gt;</span><span class="n">num_resources</span> <span class="o">=</span> <span class="n">num_reg</span> <span class="o">+</span> <span class="n">num_irq</span><span class="p">;</span>
                <span class="n">dev</span><span class="o">-&gt;</span><span class="n">resource</span> <span class="o">=</span> <span class="n">res</span><span class="p">;</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_reg</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">res</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">rc</span> <span class="o">=</span> <span class="n">of_address_to_resource</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
                        <span class="n">WARN_ON</span><span class="p">(</span><span class="n">rc</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">of_irq_to_resource_table</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">num_irq</span><span class="p">)</span> <span class="o">!=</span> <span class="n">num_irq</span><span class="p">)</span>
                        <span class="n">pr_debug</span><span class="p">(</span><span class="s">"not all legacy IRQ resources mapped for %pOFn</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                                 <span class="n">np</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span> <span class="o">=</span> <span class="n">of_node_get</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
        <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">fwnode</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">fwnode</span><span class="p">;</span>
        <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span> <span class="o">?</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">platform_bus</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">bus_id</span><span class="p">)</span>
                <span class="n">dev_set_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">"%s"</span><span class="p">,</span> <span class="n">bus_id</span><span class="p">);</span>
        <span class="k">else</span>
                <span class="n">of_device_make_bus_id</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">dev</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">of_device_alloc</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></div></div>
<p>Compared to other devices registration,
all required information to populate and manage the device 
is described in the device tree itself. 
Those information should be stored in the generated device structure
to allow the device driver which will be bound to the current device 
to manage the device properly.</p>

<p>One device tree node can contain two 
important resource related to the device: register and interrupt.
However, until the device tree has been parsed,
we cannot know how many resource the device does have.
Therefore, to allocate an array dynamically based on the number of resource,
it needs number indication how many register and interrupt 
resources are available for the device. 
Based on that information, it allocates a resource array and copies
all resource from the device tree to the resource array.
After the resource has been successfully parsed and stored in the resource array of the platform device, 
it sets the device node of the current device
to its of_node member field 
which will be required to access 
the device tree node in the device driver later.
Also, it sets parent node as platform_bus 
when it is NULL.</p>

<p>After the platform_device object for the current device node 
has been properly allocated and set,
it returns the device.
The returned device is passed to 
of_device_add function,
which register the generated device to the bus subsystem.</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre>        <span class="n">dev</span> <span class="o">=</span> <span class="n">of_device_alloc</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">bus_id</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
                <span class="k">goto</span> <span class="n">err_clear_flag</span><span class="p">;</span>
        
        <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">coherent_dma_mask</span> <span class="o">=</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">dma_mask</span><span class="p">)</span>
                <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">dma_mask</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">coherent_dma_mask</span><span class="p">;</span>
        <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">bus</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">platform_bus_type</span><span class="p">;</span>
        <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">platform_data</span> <span class="o">=</span> <span class="n">platform_data</span><span class="p">;</span>
        <span class="n">of_msi_configure</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></div></div>
<p>Note that below code of the of_platform_device_create_pdata
sets the bus of the generated platform device 
as <em>platform_bus_type</em> which has been registered as bus
for platform devices at 
platform_bus_init function.</p>

<h3 id="adding-generated-platform_device"><span class="me-2">Adding generated platform_device</span><a href="#adding-generated-platform_device" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<p>Then let’s take a look at how the generated platform device can be added
to the driver sub-system.</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">of_device_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">ofdev</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">BUG_ON</span><span class="p">(</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>

        <span class="cm">/* name and id have to be set so that the platform bus doesn't get
         * confused on matching */</span>          
        <span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
        <span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">PLATFORM_DEVID_NONE</span><span class="p">;</span>

        <span class="cm">/*
         * If this device has not binding numa node in devicetree, that is
         * of_node_to_nid returns NUMA_NO_NODE. device_add will assume that this
         * device is on the same node as the parent.
         */</span>                                      
        <span class="n">set_dev_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">of_node_to_nid</span><span class="p">(</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span><span class="p">));</span>
                                                 
        <span class="k">return</span> <span class="n">device_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>  
</pre></td></tr></tbody></table></code></div></div>
<p>The of_device_add function is kind of a wrapper function
that sets some fields of the platform device for one device node 
and just invokes the device_add function
with its device structure embedded in the platform_device structure.</p>

<p>Now it’s time to revisit device_add function once again.
Compared to when the device_add function is invoked 
to add the platform bus as device to the driver system,
current device_add function is invoked to add 
the platform device to the platform bus.
Becuase most details are already covered,
we will highlights some part of it related to registering the device to the bus.</p>

<p>In the middle of device_add function,
it invokes bus_add_device function with the passed device structure.</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">bus_add_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>       
        <span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span> <span class="o">=</span> <span class="n">bus_get</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">bus</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">pr_debug</span><span class="p">(</span><span class="s">"bus: '%s': add device %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
                <span class="n">error</span> <span class="o">=</span> <span class="n">device_add_groups</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">dev_groups</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
                        <span class="k">goto</span> <span class="n">out_put</span><span class="p">;</span>
                <span class="n">error</span> <span class="o">=</span> <span class="n">sysfs_create_link</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">devices_kset</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span>
                                                <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
                        <span class="k">goto</span> <span class="n">out_groups</span><span class="p">;</span>
                <span class="n">error</span> <span class="o">=</span> <span class="n">sysfs_create_link</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span>
                                <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">.</span><span class="n">kobj</span><span class="p">,</span> <span class="s">"subsystem"</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
                        <span class="k">goto</span> <span class="n">out_subsys</span><span class="p">;</span>
                <span class="n">klist_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">knode_bus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">klist_devices</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        
<span class="nl">out_subsys:</span>
        <span class="n">sysfs_remove_link</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">devices_kset</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
<span class="nl">out_groups:</span>     
        <span class="n">device_remove_groups</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">dev_groups</span><span class="p">);</span>
<span class="nl">out_put:</span>                
        <span class="n">bus_put</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">error</span><span class="p">;</span> 
<span class="p">}</span>   
</pre></td></tr></tbody></table></code></div></div>
<p>Compared to previous device_add, which doesn’t have a bus field 
because it was a platform device itself,
current platfrom device’s device has bus 
which is a platform_bus_type.
After invoking several functions to register the device to the sysfs,
klist_add_tail(&amp;dev-&gt;p-&gt;knode_bus, &amp;bus-&gt;p-&gt;klist_devices)
macro adds the current device to the 
klist_devices klist which are managed by the target bus.
Note that the private field of the bus is used to register the device to the bus subsystem.</p>

<p>Remember that
we allocated a private platform bus subsystem 
using the platform_bus_type
when the bus_register function has been invoked at the platform_bus_init.
Because platform_bus_type is a global structure and 
has been initialized to have private sub-system,
whenever any device who wants to be attached to that bus
should make the bus member field of the device 
to reference platform_bus_type.</p>

<h3 id="binding-the-device-to-the-driver"><span class="me-2">Binding the device to the driver</span><a href="#binding-the-device-to-the-driver" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="rouge-code"><pre><span class="cm">/**      
 * bus_probe_device - probe drivers for a new device
 * @dev: device to probe 
 *       
 * - Automatically probe for a driver if the bus allows it.
 */</span>      
<span class="kt">void</span> <span class="nf">bus_probe_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>               
        <span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">subsys_interface</span> <span class="o">*</span><span class="n">sif</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bus</span><span class="p">)</span>
                <span class="k">return</span><span class="p">;</span>
                
        <span class="k">if</span> <span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">drivers_autoprobe</span><span class="p">)</span>
                <span class="n">device_initial_probe</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
        
        <span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
        <span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">sif</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">interfaces</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">sif</span><span class="o">-&gt;</span><span class="n">add_dev</span><span class="p">)</span>
                        <span class="n">sif</span><span class="o">-&gt;</span><span class="n">add_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">sif</span><span class="p">);</span>
        <span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>               
</pre></td></tr></tbody></table></code></div></div>

<p>After the device has been registered to the platform_bus bus type, 
the device can be bound to the corresponding driver if possible.
We didn’t cover this function before 
because previous platform_bus device doesn’t have bus field 
and it just returned instead of trying to bind the driver to the device.
However, current platform device has the bus,
it can ask the bus to find the driver associated with current device.</p>

<p><strong>drivers/base/dd.c</strong></p>
<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
</pre></td><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">device_initial_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">__device_attach</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__device_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">bool</span> <span class="n">allow_async</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="n">device_lock</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">dead</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">device_is_bound</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
                        <span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                        <span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">device_bind_driver</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                        <span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="k">else</span> <span class="p">{</span>
                        <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
                        <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">struct</span> <span class="n">device_attach_data</span> <span class="n">data</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="p">.</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">,</span>
                        <span class="p">.</span><span class="n">check_async</span> <span class="o">=</span> <span class="n">allow_async</span><span class="p">,</span>
                        <span class="p">.</span><span class="n">want_async</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span>
                <span class="p">};</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
                        <span class="n">pm_runtime_get_sync</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>

                <span class="n">ret</span> <span class="o">=</span> <span class="n">bus_for_each_drv</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span>
                                        <span class="n">__device_attach_driver</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">allow_async</span> <span class="o">&amp;&amp;</span> <span class="n">data</span><span class="p">.</span><span class="n">have_async</span><span class="p">)</span> <span class="p">{</span>
                        <span class="cm">/*
                         * If we could not find appropriate driver
                         * synchronously and we are allowed to do
                         * async probes and there are drivers that
                         * want to probe asynchronously, we'll
                         * try them.
                         */</span>
                        <span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">"scheduling asynchronous probe</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
                        <span class="n">get_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
                        <span class="n">async_schedule_dev</span><span class="p">(</span><span class="n">__device_attach_async_helper</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="n">pm_request_idle</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
                <span class="p">}</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
                        <span class="n">pm_runtime_put</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
        <span class="p">}</span>
<span class="nl">out_unlock:</span>
        <span class="n">device_unlock</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>Because our device is not dead,
the else statement should be executed,
and bus_for_each_drv function will run 
__device_attach_driver function against 
all drivers managed by the bus.</p>

<p>Before the iteration starts,
it sets the data which contains
the device that we are trying to register
so that the __device_attach_driver function
can have access on the device.
And the function traverse the klist_drivers of the bus 
and select one driver registered to the bus one by one
and pass it to the __device_attach_driver function.
As a result,
the function can have access not only on the device but also
the possible candidate driver that might manage our device.</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">int</span> <span class="nf">__device_attach_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">_data</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">device_attach_data</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">_data</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
        <span class="n">bool</span> <span class="n">async_allowed</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="n">driver_match_device</span><span class="p">(</span><span class="n">drv</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="cm">/* no match */</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EPROBE_DEFER</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">"Device match requests probe deferral</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
                <span class="n">driver_deferred_probe_add</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">"Bus failed to match device: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
        <span class="p">}</span> <span class="cm">/* ret &gt; 0 means positive match */</span>

        <span class="n">async_allowed</span> <span class="o">=</span> <span class="n">driver_allows_async_probing</span><span class="p">(</span><span class="n">drv</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">async_allowed</span><span class="p">)</span>
                <span class="n">data</span><span class="o">-&gt;</span><span class="n">have_async</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">check_async</span> <span class="o">&amp;&amp;</span> <span class="n">async_allowed</span> <span class="o">!=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">want_async</span><span class="p">)</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">driver_probe_device</span><span class="p">(</span><span class="n">drv</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">driver_match_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">,</span>
                                      <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">return</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">match</span> <span class="o">?</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">drv</span><span class="p">)</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>Note that the currently selected driver,
passed as the first argument of the __device_attach_driver function
is just one of the drivers registered to the bus.
Therefore, first job of this function is 
trying to figure out 
if the currently selected driver has capability to manage 
our device.
%
To achieve this, it invokes the driver_match_device function
with the selected driver and device object.
This function is a simple macro 
that invokes the <em>match</em> function
of the bus attached to the device.</p>

<h3 id="platform-device-match-function"><span class="me-2">Platform device match function</span><a href="#platform-device-match-function" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">bus_type</span> <span class="n">platform_bus_type</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">name</span>           <span class="o">=</span> <span class="s">"platform"</span><span class="p">,</span>
        <span class="p">.</span><span class="n">dev_groups</span>     <span class="o">=</span> <span class="n">platform_dev_groups</span><span class="p">,</span>
        <span class="p">.</span><span class="n">match</span>          <span class="o">=</span> <span class="n">platform_match</span><span class="p">,</span>
        <span class="p">.</span><span class="n">uevent</span>         <span class="o">=</span> <span class="n">platform_uevent</span><span class="p">,</span>
        <span class="p">.</span><span class="n">probe</span>          <span class="o">=</span> <span class="n">platform_probe</span><span class="p">,</span>
        <span class="p">.</span><span class="n">remove</span>         <span class="o">=</span> <span class="n">platform_remove</span><span class="p">,</span>
        <span class="p">.</span><span class="n">shutdown</span>       <span class="o">=</span> <span class="n">platform_shutdown</span><span class="p">,</span>
        <span class="p">.</span><span class="n">dma_configure</span>  <span class="o">=</span> <span class="n">platform_dma_configure</span><span class="p">,</span>
        <span class="p">.</span><span class="n">pm</span>             <span class="o">=</span> <span class="o">&amp;</span><span class="n">platform_dev_pm_ops</span><span class="p">,</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></div></div>
<p>In this case, we assign the platform_bus_type as 
our platform device’s bus,
its match function, platform_match, 
should be invoked.</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="rouge-code"><pre><span class="cm">/**
 * platform_match - bind platform device to platform driver.
 * @dev: device.
 * @drv: driver.
 *
 * Platform device IDs are assumed to be encoded like this:
 * "&lt;name&gt;&lt;instance&gt;", where &lt;name&gt; is a short description of the type of
 * device, like "pci" or "floppy", and &lt;instance&gt; is the enumerated
 * instance of the device, like '0' or '42'.  Driver IDs are simply
 * "&lt;name&gt;".  So, extract the &lt;name&gt; from the platform_device structure,
 * and compare it against the name of the driver. Return whether they match
 * or not.
 */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">platform_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_platform_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
        <span class="k">struct</span> <span class="n">platform_driver</span> <span class="o">*</span><span class="n">pdrv</span> <span class="o">=</span> <span class="n">to_platform_driver</span><span class="p">(</span><span class="n">drv</span><span class="p">);</span>

        <span class="cm">/* When driver_override is set, only bind to the matching driver */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">driver_override</span><span class="p">)</span>
                <span class="k">return</span> <span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">driver_override</span><span class="p">,</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

        <span class="cm">/* Attempt an OF style match first */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">of_driver_match_device</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">drv</span><span class="p">))</span>
                <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

        <span class="cm">/* Then try ACPI style match */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">acpi_driver_match_device</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">drv</span><span class="p">))</span>
                <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

        <span class="cm">/* Then try to match against the id table */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pdrv</span><span class="o">-&gt;</span><span class="n">id_table</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">platform_match_id</span><span class="p">(</span><span class="n">pdrv</span><span class="o">-&gt;</span><span class="n">id_table</span><span class="p">,</span> <span class="n">pdev</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>

        <span class="cm">/* fall-back to driver name match */</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>When the platform_match function is invoked,
it firstly translates the generic drvier and device to 
platform driver and platform device.
Even though each bus utilize different type of device and driver 
following the detailed implementation of the bus,
because the probe function is invoked through a generic interface of 
linux driver system, 
the match function of the bus should have generic type for 
device and driver, and tralsate them to the bus specific ones.</p>

<p>After that, it invokes different match functions
because platform device can be registered 
through multiple different methods.
We have a platform device detected and generated by the 
device file, so of_driver_match function should 
match the device and driver 
using the compatible strings specified in the device driver 
supporting device tree. 
When the driver does not support the device tree,
then other matching functions 
should be in charge of device-to-driver matching.</p>

<h3 id="binding-the-matching-driver-and-device"><span class="me-2">Binding the matching driver and device</span><a href="#binding-the-matching-driver-and-device" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<p>If the matching function finds a driver claiming that it can support 
currently being registered device,
__device_attach_driver function invokes the 
driver_probe_device function
which finally binds the device and its corresponding driver.</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre></td><td class="rouge-code"><pre><span class="cm">/**
 * driver_probe_device - attempt to bind device &amp; driver together
 * @drv: driver to bind a device to
 * @dev: device to try to bind to the driver
 *
 * This function returns -ENODEV if the device is not registered,
 * 1 if the device is bound successfully and 0 otherwise.
 *
 * This function must be called with @dev lock held.  When called for a
 * USB interface, @dev-&gt;parent lock must be held as well.
 *
 * If the device has a parent, runtime-resume the parent before driver probing.
 */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">driver_probe_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">device_is_registered</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
                <span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

        <span class="n">pr_debug</span><span class="p">(</span><span class="s">"bus: '%s': %s: matched device %s with driver %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                 <span class="n">drv</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

        <span class="n">pm_runtime_get_suppliers</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
                <span class="n">pm_runtime_get_sync</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>

        <span class="n">pm_runtime_barrier</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">initcall_debug</span><span class="p">)</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">really_probe_debug</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">drv</span><span class="p">);</span>
        <span class="k">else</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">really_probe</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">drv</span><span class="p">);</span>
        <span class="n">pm_request_idle</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
                <span class="n">pm_runtime_put</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>

        <span class="n">pm_runtime_put_suppliers</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>To bind the driver to the device,
the matching driver should be invoked.
The probe function of the matching driver provides an 
entry function for this binding process. 
As shown in the code,
when it is not in debug mode,
the really_probe function will be invoked,
and will call the probe function of the matching driver.</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">int</span> <span class="nf">really_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROBE_DEFER</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">local_trigger_count</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">deferred_trigger_count</span><span class="p">);</span>
        <span class="n">bool</span> <span class="n">test_remove</span> <span class="o">=</span> <span class="n">IS_ENABLED</span><span class="p">(</span><span class="n">CONFIG_DEBUG_TEST_DRIVER_REMOVE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
                           <span class="o">!</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">suppress_bind_attrs</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">defer_all_probes</span><span class="p">)</span> <span class="p">{</span>
                <span class="cm">/*
                 * Value of defer_all_probes can be set only by
                 * device_block_probing() which, in turn, will call
                 * wait_for_device_probe() right after that to avoid any races.
                 */</span>
                <span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">"Driver %s force probe deferral</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
                <span class="n">driver_deferred_probe_add</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="n">device_links_check_suppliers</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EPROBE_DEFER</span><span class="p">)</span>
                <span class="n">driver_deferred_probe_add_trigger</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">local_trigger_count</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

        <span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">probe_count</span><span class="p">);</span>
        <span class="n">pr_debug</span><span class="p">(</span><span class="s">"bus: '%s': %s: probing driver %s with device %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                 <span class="n">drv</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devres_head</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">dev_crit</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">"Resources present before probing</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
                <span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
        <span class="p">}</span>

<span class="nl">re_probe:</span>
        <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">=</span> <span class="n">drv</span><span class="p">;</span>

        <span class="cm">/* If using pinctrl, bind pins now before probing */</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">pinctrl_bind_pins</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
                <span class="k">goto</span> <span class="n">pinctrl_bind_failed</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">dma_configure</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">dma_configure</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
                        <span class="k">goto</span> <span class="n">probe_failed</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">driver_sysfs_add</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">pr_err</span><span class="p">(</span><span class="s">"%s: driver_sysfs_add(%s) failed</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                       <span class="n">__func__</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
                <span class="k">goto</span> <span class="n">probe_failed</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pm_domain</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">pm_domain</span><span class="o">-&gt;</span><span class="n">activate</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">pm_domain</span><span class="o">-&gt;</span><span class="n">activate</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
                        <span class="k">goto</span> <span class="n">probe_failed</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">probe</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">probe</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
                        <span class="k">goto</span> <span class="n">probe_failed</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">probe</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">probe</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
                        <span class="k">goto</span> <span class="n">probe_failed</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">device_add_groups</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">dev_groups</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">"device_add_groups() failed</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
                <span class="k">goto</span> <span class="n">dev_groups_failed</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">dev_has_sync_state</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
            <span class="n">device_create_file</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_state_synced</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">"state_synced sysfs add failed</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
                <span class="k">goto</span> <span class="n">dev_sysfs_state_synced_failed</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">test_remove</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">test_remove</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

                <span class="n">device_remove_file</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_state_synced</span><span class="p">);</span>
                <span class="n">device_remove_groups</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">dev_groups</span><span class="p">);</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">remove</span><span class="p">)</span>
                        <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">remove</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
                <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">remove</span><span class="p">)</span>
                        <span class="n">drv</span><span class="o">-&gt;</span><span class="n">remove</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

                <span class="n">devres_release_all</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
                <span class="n">driver_sysfs_remove</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
                <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
                <span class="n">dev_set_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pm_domain</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">pm_domain</span><span class="o">-&gt;</span><span class="n">dismiss</span><span class="p">)</span>
                        <span class="n">dev</span><span class="o">-&gt;</span><span class="n">pm_domain</span><span class="o">-&gt;</span><span class="n">dismiss</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
                <span class="n">pm_runtime_reinit</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

                <span class="k">goto</span> <span class="n">re_probe</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">pinctrl_init_done</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pm_domain</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">pm_domain</span><span class="o">-&gt;</span><span class="n">sync</span><span class="p">)</span>
                <span class="n">dev</span><span class="o">-&gt;</span><span class="n">pm_domain</span><span class="o">-&gt;</span><span class="n">sync</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

        <span class="n">driver_bound</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">pr_debug</span><span class="p">(</span><span class="s">"bus: '%s': %s: bound device %s to driver %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                 <span class="n">drv</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
        <span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

<span class="nl">dev_sysfs_state_synced_failed:</span>
        <span class="n">device_remove_groups</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">dev_groups</span><span class="p">);</span>
<span class="nl">dev_groups_failed:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">remove</span><span class="p">)</span>
                <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">remove</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">remove</span><span class="p">)</span>
                <span class="n">drv</span><span class="o">-&gt;</span><span class="n">remove</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="nl">probe_failed:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">)</span>
                <span class="n">blocking_notifier_call_chain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">bus_notifier</span><span class="p">,</span>
                                             <span class="n">BUS_NOTIFY_DRIVER_NOT_BOUND</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
<span class="nl">pinctrl_bind_failed:</span>
        <span class="n">device_links_no_driver</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
        <span class="n">devres_release_all</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
        <span class="n">arch_teardown_dma_ops</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
        <span class="n">driver_sysfs_remove</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
        <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">dev_set_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pm_domain</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">pm_domain</span><span class="o">-&gt;</span><span class="n">dismiss</span><span class="p">)</span>
                <span class="n">dev</span><span class="o">-&gt;</span><span class="n">pm_domain</span><span class="o">-&gt;</span><span class="n">dismiss</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
        <span class="n">pm_runtime_reinit</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
        <span class="n">dev_pm_set_driver_flags</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

        <span class="k">switch</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">-</span><span class="n">EPROBE_DEFER</span><span class="p">:</span>
                <span class="cm">/* Driver requested deferred probing */</span>
                <span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">"Driver %s requests probe deferral</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
                <span class="n">driver_deferred_probe_add_trigger</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">local_trigger_count</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">:</span>
        <span class="k">case</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">:</span>
                <span class="n">pr_debug</span><span class="p">(</span><span class="s">"%s: probe of %s rejects match %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                         <span class="n">drv</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="n">ret</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
        <span class="nl">default:</span>
                <span class="cm">/* driver matched but the probe failed */</span>
                <span class="n">pr_warn</span><span class="p">(</span><span class="s">"%s: probe of %s failed with error %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                        <span class="n">drv</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="n">ret</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="cm">/*
         * Ignore errors returned by -&gt;probe so that the next driver can try
         * its luck.
         */</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">done:</span>
        <span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">probe_count</span><span class="p">);</span>
        <span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">probe_waitqueue</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>Although there are many complex details in the really_probe function,
our interest is only when the probe of the matching driver is invoked.
When you look at the middle of the function,
you can find that below code block invokes the probe function of the 
bus or the driver based on condition.</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre>        <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">probe</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">probe</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
                        <span class="k">goto</span> <span class="n">probe_failed</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">probe</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">probe</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
                        <span class="k">goto</span> <span class="n">probe_failed</span><span class="p">;</span>
        <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>Because our bus, platform_bus_type
has its own probe function, platform_probe,
the probe function of the bus should be called
instead of invoking the driver’s probe function directly.
Let’s see the detailed implementation of the probe function of our bus,
platform_probe.</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">int</span> <span class="nf">platform_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">_dev</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">platform_driver</span> <span class="o">*</span><span class="n">drv</span> <span class="o">=</span> <span class="n">to_platform_driver</span><span class="p">(</span><span class="n">_dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">);</span>
        <span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">to_platform_device</span><span class="p">(</span><span class="n">_dev</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

        <span class="cm">/*
         * A driver registered using platform_driver_probe() cannot be bound
         * again later because the probe function usually lives in __init code
         * and so is gone. For these drivers .probe is set to
         * platform_probe_fail in __platform_driver_probe(). Don't even prepare
         * clocks and PM domains for these to match the traditional behaviour.
         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">probe</span> <span class="o">==</span> <span class="n">platform_probe_fail</span><span class="p">))</span>
                <span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="n">of_clk_set_defaults</span><span class="p">(</span><span class="n">_dev</span><span class="o">-&gt;</span><span class="n">of_node</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="n">dev_pm_domain_attach</span><span class="p">(</span><span class="n">_dev</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
                <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">probe</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">probe</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
                        <span class="n">dev_pm_domain_detach</span><span class="p">(</span><span class="n">_dev</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
        <span class="p">}</span>

<span class="nl">out:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">prevent_deferred_probe</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EPROBE_DEFER</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">dev_warn</span><span class="p">(</span><span class="n">_dev</span><span class="p">,</span> <span class="s">"probe deferral not supported</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>Although we only have access to the device, 
because we already register the matching driver to device’s driver field before
we can retrieve the matching driver’s object
(check the re_probe jump flag of the really_probe function).
Because platform_probe function is a generic wrapper probe for all platform devices,
it invokes several functions to manage the device as platform device
such as attaching power domain or setting the clk for the device.
After those generic settings are done,
the real probe function of the matching driver is invoked. 
Although, the platform_probe function only passes
the platform device object to the probe function,
different buses can support different prototype of probe function.
In that case the bus’ probe function will feed those operands 
before the driver’s probe function is invoked.</p>

<p>For the probe function of the matching driver,
you should take a look at the implementation of the probe function
in the corresponding device driver.
We are not going to take a look at probe function of 
one particular device in this posting.
After the probing function of the matching driver is invoked,
rest part of the device_register function.</p>


  </div>

  <div class="post-tail-wrapper text-muted">
    <!-- categories -->
    
      <div class="post-meta mb-3">
        <i class="far fa-folder-open fa-fw me-1"></i>
        
          <a href="/categories/linux/">linux,</a>,
          <a href="/categories/embedded-linux/">embedded-linux</a>
      </div>
    

    <!-- tags -->
    

    <div
      class="
        post-tail-bottom
        d-flex justify-content-between align-items-center mt-5 pb-2
      "
    >
      <div class="license-wrapper">
        
          

          This post is licensed under 
        <a href="https://creativecommons.org/licenses/by/4.0/">
          CC BY 4.0
        </a>
         by the author.
        
      </div>

      <!-- Post sharing snippet -->

<div class="share-wrapper d-flex align-items-center">
  <span class="share-label text-muted">Share</span>
  <span class="share-icons">
    
    
    

    

      

      <a
        href="https://twitter.com/intent/tweet?text=Platform%20Device%20-%20Ruach&url=https%3A%2F%2Fruach.github.io%2Fposts%2Fplatform-device%2F"
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="Twitter"
        target="_blank"
        rel="noopener"
        aria-label="Twitter"
      >
        <i class="fa-fw fa-brands fa-square-x-twitter"></i>
      </a>
    

      

      <a
        href="https://www.facebook.com/sharer/sharer.php?title=Platform%20Device%20-%20Ruach&u=https%3A%2F%2Fruach.github.io%2Fposts%2Fplatform-device%2F"
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="Facebook"
        target="_blank"
        rel="noopener"
        aria-label="Facebook"
      >
        <i class="fa-fw fab fa-facebook-square"></i>
      </a>
    

      

      <a
        href="https://t.me/share/url?url=https%3A%2F%2Fruach.github.io%2Fposts%2Fplatform-device%2F&text=Platform%20Device%20-%20Ruach"
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="Telegram"
        target="_blank"
        rel="noopener"
        aria-label="Telegram"
      >
        <i class="fa-fw fab fa-telegram"></i>
      </a>
    

      

      <a
        href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fruach.github.io%2Fposts%2Fplatform-device%2F"
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="Linkedin"
        target="_blank"
        rel="noopener"
        aria-label="Linkedin"
      >
        <i class="fa-fw fab fa-linkedin"></i>
      </a>
    

    <button
      id="copy-link"
      aria-label="Copy link"
      class="btn small"
      data-bs-toggle="tooltip"
      data-bs-placement="top"
      title="Copy link"
      data-title-succeed="Link copied successfully!"
    >
      <i class="fa-fw fas fa-link pe-none fs-6"></i>
    </button>
  </span>
</div>

    </div>
    <!-- .post-tail-bottom -->
  </div>
  <!-- div.post-tail-wrapper -->
</article>


            
          </main>

          <!-- panel -->
          <aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 mb-5 text-muted">
            <div class="access">
              <!-- Get the last 5 posts from lastmod list. -->















              <!-- The trending tags list -->


















            </div>

            
              
              



  <section id="toc-wrapper" class="ps-0 pe-4">
    <h2 class="panel-heading ps-3 pt-2 mb-2">Contents</h2>
    <nav id="toc"></nav>
  </section>


            
          </aside>
        </div>

        <div class="row">
          <!-- tail -->
          <div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4">
            
              
              <!-- Recommend the other 3 posts according to the tags and categories of the current post. -->

<!-- The total size of related posts -->


<!-- An random integer that bigger than 0 -->


<!-- Equals to TAG_SCORE / {max_categories_hierarchy} -->














  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  
    
  

  

  

  

  

  











  <aside id="related-posts" aria-labelledby="related-label">
    <h3 class="mb-4" id="related-label">Further Reading</h3>
    <nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4">
      
        <article class="col">
          <a href="/posts/initcalls/" class="post-preview card h-100">
            <div class="card-body">
              <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->




<time
  
  data-ts="1619582400"
  data-df="ll"
  
>
  Apr 28, 2021
</time>

              <h4 class="pt-0 my-2">Initcalls</h4>
              <div class="text-muted">
                <p>
                  





                  do_initcalls
static void __init do_basic_setup(void)
{
        cpuset_init_smp();
        driver_init();
        init_irq_proc();
        do_ctors();
        usermodehelper_enable();
        do_ini...
                </p>
              </div>
            </div>
          </a>
        </article>
      
        <article class="col">
          <a href="/posts/register-platform-device-driver/" class="post-preview card h-100">
            <div class="card-body">
              <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->




<time
  
  data-ts="1619928000"
  data-df="ll"
  
>
  May  2, 2021
</time>

              <h4 class="pt-0 my-2">Register Platform Device Driver</h4>
              <div class="text-muted">
                <p>
                  





                  We will cover how the platform device drivers 
can be registered and managed by the platform device bus subsystem.

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
struct pl...
                </p>
              </div>
            </div>
          </a>
        </article>
      
        <article class="col">
          <a href="/posts/register-device-through-bus/" class="post-preview card h-100">
            <div class="card-body">
              <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->




<time
  
  data-ts="1620100800"
  data-df="ll"
  
>
  May  4, 2021
</time>

              <h4 class="pt-0 my-2">Register Device Through Bus</h4>
              <div class="text-muted">
                <p>
                  





                  Initializing usb subsystem
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
/*
 * In...
                </p>
              </div>
            </div>
          </a>
        </article>
      
    </nav>
  </aside>
  <!-- #related-posts -->


            
              
              <!-- Navigation buttons at the bottom of the post. -->

<nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation">
  
  

  
    <a
      href="/posts/initcalls/"
      class="btn btn-outline-primary"
      aria-label="Older"
    >
      <p>Initcalls</p>
    </a>
  

  
    <a
      href="/posts/register-platform-device-driver/"
      class="btn btn-outline-primary"
      aria-label="Newer"
    >
      <p>Register Platform Device Driver</p>
    </a>
  
</nav>

            
              
              <!--  The comments switcher -->

  
  <!-- The Disqus lazy loading. -->

<div id="disqus_thread">
  <p class="text-center text-muted small">Comments powered by <a href="https://disqus.com/">Disqus</a>.</p>
</div>

<script type="text/javascript">
  var disqus_config = function () {
    this.page.url = 'https://ruach.github.io/posts/platform-device/';
    this.page.identifier = '/posts/platform-device/';
  };

  /* Lazy loading */
  var disqus_observer = new IntersectionObserver(
    function (entries) {
      if (entries[0].isIntersecting) {
        (function () {
          var d = document,
            s = d.createElement('script');
          s.src = 'https://ruach.disqus.com/embed.js';
          s.setAttribute('data-timestamp', +new Date());
          (d.head || d.body).appendChild(s);
        })();

        disqus_observer.disconnect();
      }
    },
    { threshold: [0] }
  );

  disqus_observer.observe(document.querySelector('#disqus_thread'));

  /* Auto switch theme */
  function reloadDisqus() {
    if (event.source === window && event.data && event.data.direction === ModeToggle.ID) {
      /* Disqus hasn't been loaded */
      if (typeof DISQUS === 'undefined') {
        return;
      }

      if (document.readyState == 'complete') {
        DISQUS.reset({ reload: true, config: disqus_config });
      }
    }
  }

  if (document.querySelector('.mode-toggle')) {
    window.addEventListener('message', reloadDisqus);
  }
</script>



            

            <!-- The Footer -->

<footer
  aria-label="Site Info"
  class="
    d-flex flex-column justify-content-center text-muted
    flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3
  "
>
  <p>
    ©
    <time>2024</time>
    <a href="https://ruach.github.io">Jaehyuk Lee</a>.
    
      <span
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author."
      >Some rights reserved.</span>
    
  </p>

  <p>Using the <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme for <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>
  </p>
</footer>

          </div>
        </div>

        <!-- The Search results -->

<div id="search-result-wrapper" class="d-flex justify-content-center unloaded">
  <div class="col-11 content">
    <div id="search-hints">
      <!-- The trending tags list -->


















    </div>
    <div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div>
  </div>
</div>

      </div>

      <aside aria-label="Scroll to Top">
        <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow">
          <i class="fas fa-angle-up"></i>
        </button>
      </aside>
    </div>

    <div id="mask"></div>

    
      <aside
  id="notification"
  class="toast"
  role="alert"
  aria-live="assertive"
  aria-atomic="true"
  data-bs-animation="true"
  data-bs-autohide="false"
>
  <div class="toast-header">
    <button
      type="button"
      class="btn-close ms-auto"
      data-bs-dismiss="toast"
      aria-label="Close"
    ></button>
  </div>
  <div class="toast-body text-center pt-0">
    <p class="px-2 mb-3">A new version of content is available.</p>
    <button type="button" class="btn btn-primary" aria-label="Update">
      Update
    </button>
  </div>
</aside>

    

    <!-- JavaScripts -->

    <!-- JS selector for site. -->

<!-- commons -->



<!-- layout specified -->


  

  
    <!-- image lazy-loading & popup & clipboard -->
    
  















  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  



  <script src="https://cdn.jsdelivr.net/combine/npm/jquery@3.7.1/dist/jquery.min.js,npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js,npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/magnific-popup@1.1.0/dist/jquery.magnific-popup.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.10/dayjs.min.js,npm/dayjs@1.11.10/locale/en.min.js,npm/dayjs@1.11.10/plugin/relativeTime.min.js,npm/dayjs@1.11.10/plugin/localizedFormat.min.js,npm/tocbot@4.21.2/dist/tocbot.min.js"></script>






<script defer src="/assets/js/dist/post.min.js"></script>






    

    <!--
  Jekyll Simple Search loader
  See: <https://github.com/christian-fei/Simple-Jekyll-Search>
-->





<script>
  /* Note: dependent library will be loaded in `js-selector.html` */
  SimpleJekyllSearch({
    searchInput: document.getElementById('search-input'),
    resultsContainer: document.getElementById('search-results'),
    json: '/assets/js/data/search.json',
    searchResultTemplate: '  <article class="px-1 px-sm-2 px-lg-4 px-xl-0">    <header>      <h2><a href="{url}">{title}</a></h2>      <div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1">        {categories}        {tags}      </div>    </header>    <p>{snippet}</p>  </article>',
    noResultsText: '<p class="mt-5"></p>',
    templateMiddleware: function(prop, value, template) {
      if (prop === 'categories') {
        if (value === '') {
          return `${value}`;
        } else {
          return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`;
        }
      }

      if (prop === 'tags') {
        if (value === '') {
          return `${value}`;
        } else {
          return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`;
        }
      }
    }
  });
</script>

  </body>
</html>

