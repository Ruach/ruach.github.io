<!doctype html>














<!-- `site.alt_lang` can specify a language different from the UI -->
<html lang="en" data-mode="light">
  <!-- The Head -->

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta
    name="viewport"
    content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover"
  >

  

  

  
    <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v4.3.2" />
<meta property="og:title" content="Usb Device Add" />
<meta property="og:locale" content="en" />
<meta name="description" content="USB drivers are designed for interfaces" />
<meta property="og:description" content="USB drivers are designed for interfaces" />
<link rel="canonical" href="https://ruach.github.io/posts/usb-device-add/" />
<meta property="og:url" content="https://ruach.github.io/posts/usb-device-add/" />
<meta property="og:site_name" content="Ruach" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-05-07T00:00:00-04:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Usb Device Add" />
<meta name="twitter:site" content="@ruach_lee" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2021-05-07T00:00:00-04:00","datePublished":"2021-05-07T00:00:00-04:00","description":"USB drivers are designed for interfaces","headline":"Usb Device Add","mainEntityOfPage":{"@type":"WebPage","@id":"https://ruach.github.io/posts/usb-device-add/"},"url":"https://ruach.github.io/posts/usb-device-add/"}</script>
<!-- End Jekyll SEO tag -->

  

  <title>Usb Device Add | Ruach
  </title>

  <!--
  The Favicons for Web, Android, Microsoft, and iOS (iPhone and iPad) Apps
  Generated by: https://realfavicongenerator.net/
-->



<link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png">
<link rel="manifest" href="/assets/img/favicons/site.webmanifest">
<link rel="shortcut icon" href="/assets/img/favicons/favicon.ico">
<meta name="apple-mobile-web-app-title" content="Ruach">
<meta name="application-name" content="Ruach">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml">
<meta name="theme-color" content="#ffffff">


  
    
      <link rel="preconnect" href="https://fonts.googleapis.com" >
      <link rel="dns-prefetch" href="https://fonts.googleapis.com" >
    
      <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
      <link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin>
    
      <link rel="preconnect" href="https://fonts.googleapis.com" >
      <link rel="dns-prefetch" href="https://fonts.googleapis.com" >
    
      <link rel="preconnect" href="https://cdn.jsdelivr.net" >
      <link rel="dns-prefetch" href="https://cdn.jsdelivr.net" >
    

    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap">
  

  <!-- GA -->
  

  <!-- Bootstrap -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css">

  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.2/css/all.min.css">

  <link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css">

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.21.2/dist/tocbot.min.css">
  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css">
  

  
    <!-- Manific Popup -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css">
  

  <!-- JavaScript -->

  

  <!-- A placeholder to allow defining custom metadata -->

</head>


  <body>
    <!-- The Side Bar -->

<aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end">
  <header class="profile-wrapper">
    <a href="/" id="avatar" class="rounded-circle">
      
        
        <img src="/assets/img/jaehyuk.png" width="112" height="112" alt="avatar" onerror="this.style.display='none'">
      
    </a>

    <h1 class="site-title">
      <a href="/">Ruach</a>
    </h1>
    <p class="site-subtitle fst-italic mb-0">Jaehyuk Lee</p>
  </header>
  <!-- .profile-wrapper -->

  <nav class="flex-column flex-grow-1 w-100 ps-0">
    <ul class="nav">
      <!-- home -->
      <li class="nav-item">
        <a href="/" class="nav-link">
          <i class="fa-fw fas fa-home"></i>
          <span>HOME</span>
        </a>
      </li>
      <!-- the real tabs -->
      
        <li class="nav-item">
          <a href="/categories/" class="nav-link">
            <i class="fa-fw fas fa-stream"></i>
            

            <span>CATEGORIES</span>
          </a>
        </li>
        <!-- .nav-item -->
      
        <li class="nav-item">
          <a href="/archives/" class="nav-link">
            <i class="fa-fw fas fa-archive"></i>
            

            <span>ARCHIVES</span>
          </a>
        </li>
        <!-- .nav-item -->
      
        <li class="nav-item">
          <a href="/Professional-Career/" class="nav-link">
            <i class="fa-fw fas fa-id-card"></i>
            

            <span>PROFESSIONAL CAREER</span>
          </a>
        </li>
        <!-- .nav-item -->
      
        <li class="nav-item">
          <a href="/about/" class="nav-link">
            <i class="fa-fw fas fa-info-circle"></i>
            

            <span>ABOUT</span>
          </a>
        </li>
        <!-- .nav-item -->
      
    </ul>
  </nav>

  <div class="sidebar-bottom d-flex flex-wrap  align-items-center w-100">
    

    
      

      
        <a
          href="javascript:location.href = 'mailto:' + ['jaehyuk','gatech.edu'].join('@')"
          aria-label="email"
          

          

          

          
        >
          <i class="fas fa-envelope"></i>
        </a>
      
    
      

      
        <a
          href="https://www.linkedin.com/in/jaehyuk-lee-29b33b121/"
          aria-label="linkedin"
          

          
            target="_blank"
            
          

          

          
            rel="noopener noreferrer"
          
        >
          <i class="fab fa-linkedin"></i>
        </a>
      
    
      

      
        <a
          href="https://github.com/Ruach"
          aria-label="github"
          

          
            target="_blank"
            
          

          

          
            rel="noopener noreferrer"
          
        >
          <i class="fab fa-github"></i>
        </a>
      
    
      

      
        <a
          href="https://stackoverflow.com/users/4460514/ruach?tab=profile"
          aria-label="stack-overflow"
          

          
            target="_blank"
            
          

          

          
            rel="noopener noreferrer"
          
        >
          <i class="fab fa-stack-overflow"></i>
        </a>
      
    
  </div>
  <!-- .sidebar-bottom -->
</aside>
<!-- #sidebar -->


    <div id="main-wrapper" class="d-flex justify-content-center">
      <div class="container d-flex flex-column px-xxl-5">
        <!-- The Top Bar -->

<header id="topbar-wrapper" aria-label="Top Bar">
  <div
    id="topbar"
    class="d-flex align-items-center justify-content-between px-lg-3 h-100"
  >
    <nav id="breadcrumb" aria-label="Breadcrumb">
      

      
        
          
            <span>
              <a href="/">
                Home
              </a>
            </span>

          
        
          
        
          
            
              <span>Usb Device Add</span>
            

          
        
      
    </nav>
    <!-- endof #breadcrumb -->

    <button type="button" id="sidebar-trigger" class="btn btn-link">
      <i class="fas fa-bars fa-fw"></i>
    </button>

    <div id="topbar-title">
      Post
    </div>

    <button type="button" id="search-trigger" class="btn btn-link">
      <i class="fas fa-search fa-fw"></i>
    </button>

    <search class="align-items-center ms-3 ms-lg-0">
      <i class="fas fa-search fa-fw"></i>
      <input
        class="form-control"
        id="search-input"
        type="search"
        aria-label="search"
        autocomplete="off"
        placeholder="Search..."
      >
    </search>
    <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button>
  </div>
</header>


        <div class="row flex-grow-1">
          <main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4">
            
              <!-- Refactor the HTML structure -->



<!--
  In order to allow a wide table to scroll horizontally,
  we suround the markdown table with `<div class="table-wrapper">` and `</div>`
-->



<!--
  Fixed kramdown code highlight rendering:
  https://github.com/penibelst/jekyll-compress-html/issues/101
  https://github.com/penibelst/jekyll-compress-html/issues/71#issuecomment-188144901
-->



<!-- Change the icon of checkbox -->



<!-- Handle images -->





<!-- Add header for code snippets -->



<!-- Create heading anchors -->





  
  

  
    
    

    
      
        
        
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    

    
  

  
  

  
    
    

    
      
        
        
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    

    
  

  
  

  

  
  

  




<!-- return -->




<article class="px-1">
  <header>
    <h1 data-toc-skip>Usb Device Add</h1>

    <div class="post-meta text-muted">
      <!-- published date -->
      <span>
        Posted
        <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->




<time
  
  data-ts="1620360000"
  data-df="ll"
  
    data-bs-toggle="tooltip" data-bs-placement="bottom"
  
>
  May  7, 2021
</time>

      </span>

      <!-- lastmod date -->
      

      

      <div class="d-flex justify-content-between">
        <!-- author(s) -->
        <span>
          

          By

          <em>
            
              <a href="https://ruach.github.io">Jaehyuk Lee</a>
            
          </em>
        </span>

        <!-- read time -->
        <!-- Calculate the post's reading time, and display the word count in tooltip -->



<!-- words per minute -->










<!-- return element -->
<span
  class="readtime"
  data-bs-toggle="tooltip"
  data-bs-placement="bottom"
  title="3610 words"
>
  <em>20 min</em> read</span>

      </div>
      <!-- .d-flex -->
    </div>
    <!-- .post-meta -->
  </header>

  <div class="content">
    <h1 id="usb-drivers-are-designed-for-interfaces">USB drivers are designed for interfaces</h1>

<p>For USB device,
the drivers are not designed for the USB device itself,
but for its interfaces provided by the USB devices. 
Therefore, when a new USB device is plugged in to the usb-bus,
the first thing needs to done by the usb core system is 
enumerating configuration, interfaces, and endponints 
supported by the plugged device.</p>

<p>However, 
in the Linux usb-subsystem, 
whether it is a physical usb device or its interfaces,
they are all handles as a usb device
and processed by a single unified APIs to register the devices.</p>

<p>In this posting,
we will see how the Interface driver is designed
and registered to the usb-bus,
and how those usb drivers can be probed and bound later 
when the new usb device is plugged in.</p>

<h2 id="registering-usb-interface-driver"><span class="me-2">Registering USB interface driver</span><a href="#registering-usb-interface-driver" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre><span class="cm">/**
 * module_usb_driver() - Helper macro for registering a USB driver
 * @__usb_driver: usb_driver struct
 * 
 * Helper macro for USB drivers which do not do anything special in module
 * init/exit. This eliminates a lot of boilerplate. Each module may only
 * use this macro once, and calling it replaces module_init() and module_exit()
 */</span>
<span class="cp">#define module_usb_driver(__usb_driver) \
        module_driver(__usb_driver, usb_register, \
                       usb_deregister)
</span></pre></td></tr></tbody></table></code></div></div>
<p>To register interface usb driver,
you can utilize the module_usb_driver macro that 
automatically implements the initialization function of the interface driver.
This initialiation function only contains the usb_register macro
that invokes usb_register_driver function.
This usb_register_driver function actually registers the interface driver.
The detailed explanation about this function was described in previous posting.</p>

<h2 id="how-the-usb-sub-system-matches-the-device-to-its-associated-driver"><span class="me-2">How the USB sub-system matches the device to its associated driver?</span><a href="#how-the-usb-sub-system-matches-the-device-to-its-associated-driver" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>
<p>Whether the device is a real usb device or its interface,
both should be registered on the usb-bus.
Therefore, when the device and interfaces are added to the usb-bus,
its probe function, usb_device_match function will be invoked 
after the device is registered.</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_device_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">)</span>
<span class="p">{</span>
        <span class="cm">/* devices and interfaces are handled separately */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">is_usb_device</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">;</span>
                <span class="k">struct</span> <span class="n">usb_device_driver</span> <span class="o">*</span><span class="n">udrv</span><span class="p">;</span>

                <span class="cm">/* interface drivers never match devices */</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_usb_device_driver</span><span class="p">(</span><span class="n">drv</span><span class="p">))</span>
                        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

                <span class="n">udev</span> <span class="o">=</span> <span class="n">to_usb_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
                <span class="n">udrv</span> <span class="o">=</span> <span class="n">to_usb_device_driver</span><span class="p">(</span><span class="n">drv</span><span class="p">);</span>

                <span class="cm">/* If the device driver under consideration does not have a
                 * id_table or a match function, then let the driver's probe
                 * function decide.
                 */</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udrv</span><span class="o">-&gt;</span><span class="n">id_table</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">udrv</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">)</span>
                        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

                <span class="k">return</span> <span class="n">usb_driver_applicable</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">udrv</span><span class="p">);</span>

        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_usb_interface</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">;</span>
                <span class="k">struct</span> <span class="n">usb_driver</span> <span class="o">*</span><span class="n">usb_drv</span><span class="p">;</span>
                <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">;</span>

                <span class="cm">/* device drivers never match interfaces */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">is_usb_device_driver</span><span class="p">(</span><span class="n">drv</span><span class="p">))</span>
                        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

                <span class="n">intf</span> <span class="o">=</span> <span class="n">to_usb_interface</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
                <span class="n">usb_drv</span> <span class="o">=</span> <span class="n">to_usb_driver</span><span class="p">(</span><span class="n">drv</span><span class="p">);</span>

                <span class="n">id</span> <span class="o">=</span> <span class="n">usb_match_id</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="n">usb_drv</span><span class="o">-&gt;</span><span class="n">id_table</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span>
                        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

                <span class="n">id</span> <span class="o">=</span> <span class="n">usb_match_dynamic_id</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="n">usb_drv</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span>
                        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>The match function has different behavior depending on 
whether it is usb device or usb interface.
Note that the device object passed to the probe function
is not a usb or interface specific device structure, but
a generic device structure representing any device.</p>

<h3 id="device-type-for-usb-system"><span class="me-2">Device type for USB system</span><a href="#device-type-for-usb-system" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_usb_device</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">return</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">usb_device_type</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_usb_interface</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">return</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">usb_if_device_type</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>Because the device structure is not only used for representing the USB device and its interface device,
but also for any other devices in the linux driver sub-system,
it it not a good way to add another member field for distinguishing 
USB interface and driver.
Instead of adding another field,
usb sub-system utilize the type field of the device structure.</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="rouge-code"><pre><span class="cm">/*
 * The type of device, "struct device" is embedded in. A class
 * or bus can contain devices of different types
 * like "partitions" and "disks", "mouse" and "event".
 * This identifies the device type and carries type-specific
 * information, equivalent to the kobj_type of a kobject.
 * If "name" is specified, the uevent will contain it in
 * the DEVTYPE variable.
 */</span>
<span class="k">struct</span> <span class="n">device_type</span> <span class="p">{</span>
        <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
        <span class="k">const</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="o">**</span><span class="n">groups</span><span class="p">;</span>
        <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">uevent</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_uevent_env</span> <span class="o">*</span><span class="n">env</span><span class="p">);</span>
        <span class="kt">char</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">devnode</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">umode_t</span> <span class="o">*</span><span class="n">mode</span><span class="p">,</span>
                         <span class="n">kuid_t</span> <span class="o">*</span><span class="n">uid</span><span class="p">,</span> <span class="n">kgid_t</span> <span class="o">*</span><span class="n">gid</span><span class="p">);</span>
        <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">release</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

        <span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="o">*</span><span class="n">pm</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">device_type</span> <span class="n">usb_device_type</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">name</span> <span class="o">=</span>         <span class="s">"usb_device"</span><span class="p">,</span>
        <span class="p">.</span><span class="n">release</span> <span class="o">=</span>      <span class="n">usb_release_dev</span><span class="p">,</span>
        <span class="p">.</span><span class="n">uevent</span> <span class="o">=</span>       <span class="n">usb_dev_uevent</span><span class="p">,</span>
        <span class="p">.</span><span class="n">devnode</span> <span class="o">=</span>      <span class="n">usb_devnode</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_PM
</span>        <span class="p">.</span><span class="n">pm</span> <span class="o">=</span>           <span class="o">&amp;</span><span class="n">usb_device_pm_ops</span><span class="p">,</span>
<span class="cp">#endif  
</span><span class="p">};</span>                  
              
<span class="k">struct</span> <span class="n">device_type</span> <span class="n">usb_if_device_type</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">name</span> <span class="o">=</span>         <span class="s">"usb_interface"</span><span class="p">,</span>
        <span class="p">.</span><span class="n">release</span> <span class="o">=</span>      <span class="n">usb_release_interface</span><span class="p">,</span>
        <span class="p">.</span><span class="n">uevent</span> <span class="o">=</span>       <span class="n">usb_if_uevent</span><span class="p">,</span>
<span class="p">};</span> 
</pre></td></tr></tbody></table></code></div></div>

<p>As shown in the above code,
each USB subsystem utilize the two different types of device 
usb_device_type and usb_if_device_type.
Actually there are two more types that are not discovered in this posting,
type for USB endpoints and USB port. 
We will not cover them because they are not related to 
binding the driver to the hot-plugged USB device and its interface.</p>

<h3 id="driver-type-for-usb-drivers"><span class="me-2">Driver type for USB drivers</span><a href="#driver-type-for-usb-drivers" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_usb_device_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">)</span>
<span class="p">{</span>                       
        <span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">drv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usbdrv_wrap</span><span class="p">,</span> <span class="n">driver</span><span class="p">)</span><span class="o">-&gt;</span>
                        <span class="n">for_devices</span><span class="p">;</span>
<span class="p">}</span>   
</pre></td></tr></tbody></table></code></div></div>
<p>You might remember the usb_register_device_driver(&amp;usb_generic_driver, THIS_MODULE) function invocation
in the usb_init function in the previous blog posting.
At the first glance, it is hard to understand 
how is that function is different form the 
usb_register_driver function used for registering the interface drivers.
Most of the time you will utilize the usb_register_driver
through the usb_register macro
because registering interface driver for your USB interfaces 
is your first priority job
to use your USB device on the Linux system.</p>

<p>When you compare the two function line by line,
you can easily find that for_devices field is only set
when the driver is registered through the 
usb_register_device_driver. 
And also you can find that different probe function is assigned 
to the driver attached to the usb-bus.</p>

<p>Now the secret can be revealed.
The is_usb_device_driver checks whether the for_device has been set,
which means the current driver passed to this macro is designed for managing 
entire <em>USB devices</em> on the USB subsystem. 
From the name of the driver and its probe function
you can also infer its purpose,
usb_generic_driver and usb_generic_driver_match.</p>

<p>The importance of this macro is 
you can always select the device driver for the USB device 
when the USB device wants to be registered to the USB bus.
We will soon see how this macro is used 
for the USB matching function.</p>

<h3 id="usb-interface-device-utilizes-id_table"><span class="me-2">USB interface device utilizes id_table</span><a href="#usb-interface-device-utilizes-id_table" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="rouge-code"><pre>        <span class="err">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">is_usb_interface</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">;</span>
                <span class="k">struct</span> <span class="n">usb_driver</span> <span class="o">*</span><span class="n">usb_drv</span><span class="p">;</span>
                <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">;</span>

                <span class="cm">/* device drivers never match interfaces */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">is_usb_device_driver</span><span class="p">(</span><span class="n">drv</span><span class="p">))</span>
                        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

                <span class="n">intf</span> <span class="o">=</span> <span class="n">to_usb_interface</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
                <span class="n">usb_drv</span> <span class="o">=</span> <span class="n">to_usb_driver</span><span class="p">(</span><span class="n">drv</span><span class="p">);</span>

                <span class="n">id</span> <span class="o">=</span> <span class="n">usb_match_id</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="n">usb_drv</span><span class="o">-&gt;</span><span class="n">id_table</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span>
                        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

                <span class="n">id</span> <span class="o">=</span> <span class="n">usb_match_dynamic_id</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="n">usb_drv</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span>
                        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>



</pre></td></tr></tbody></table></code></div></div>
<p>Although the USB device should be matched and probed first
before the interface device can be populated,
we will take a look at how the match function works
when the interface device has been passed.
This is because USB interface always utilize the id_table mechanism for matching the 
interface to its supporting driver,
but the USB device may or may not contain a id_table and defer
the matching to the later probing.</p>

<p>Anyway, 
first of all, to figure out whether the current device is 
USB interface device,
it invokes is_usb_device macro.
when the device is turned out to be interface device,
then it checks current device driver passed to the match function
is an interface driver not the USB device driver 
with the help of isb_usb_device_driver macro.
When those conditionals are passed,
then the interface object can be retrieved from the device structure.
The contain_of macro can do magic here;
because the device structure is embedded in the interface object.
When the target interface is retrieved,
it invokes usb_match_id function.</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
</pre></td><td class="rouge-code"><pre><span class="cm">/**
 * usb_match_id - find first usb_device_id matching device or interface
 * @interface: the interface of interest
 * @id: array of usb_device_id structures, terminated by zero entry
 *
 * usb_match_id searches an array of usb_device_id's and returns
 * the first one matching the device or interface, or null.
 * This is used when binding (or rebinding) a driver to an interface.
 * Most USB device drivers will use this indirectly, through the usb core,
 * but some layered driver frameworks use it directly.
const struct usb_device_id *usb_match_id(struct usb_interface *interface,
                                         const struct usb_device_id *id)
{
        /* proc_connectinfo in devio.c may call us with id == NULL. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
                <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

        <span class="cm">/* It is important to check that id-&gt;driver_info is nonzero,
           since an entry that is all zeroes except for a nonzero
           id-&gt;driver_info is the way to create an entry that
           indicates that the driver want to examine every
           device and interface. */</span>
        <span class="k">for</span> <span class="p">(;</span> <span class="n">id</span><span class="o">-&gt;</span><span class="n">idVendor</span> <span class="o">||</span> <span class="n">id</span><span class="o">-&gt;</span><span class="n">idProduct</span> <span class="o">||</span> <span class="n">id</span><span class="o">-&gt;</span><span class="n">bDeviceClass</span> <span class="o">||</span>
               <span class="n">id</span><span class="o">-&gt;</span><span class="n">bInterfaceClass</span> <span class="o">||</span> <span class="n">id</span><span class="o">-&gt;</span><span class="n">driver_info</span><span class="p">;</span> <span class="n">id</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">usb_match_one_id</span><span class="p">(</span><span class="n">interface</span><span class="p">,</span> <span class="n">id</span><span class="p">))</span>
                        <span class="k">return</span> <span class="n">id</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="err">}</span>

<span class="cm">/* returns 0 if no match, 1 if match */</span>
<span class="kt">int</span> <span class="nf">usb_match_one_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">interface</span><span class="p">,</span>
                     <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">usb_host_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

        <span class="cm">/* proc_connectinfo in devio.c may call us with id == NULL. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

        <span class="n">intf</span> <span class="o">=</span> <span class="n">interface</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="p">;</span>
        <span class="n">dev</span> <span class="o">=</span> <span class="n">interface_to_usbdev</span><span class="p">(</span><span class="n">interface</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usb_match_device</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">id</span><span class="p">))</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">usb_match_one_id_intf</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">intf</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* returns 0 if no match, 1 if match */</span>
<span class="kt">int</span> <span class="nf">usb_match_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">match_flags</span> <span class="o">&amp;</span> <span class="n">USB_DEVICE_ID_MATCH_VENDOR</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
            <span class="n">id</span><span class="o">-&gt;</span><span class="n">idVendor</span> <span class="o">!=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">idVendor</span><span class="p">))</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">((</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">match_flags</span> <span class="o">&amp;</span> <span class="n">USB_DEVICE_ID_MATCH_PRODUCT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
            <span class="n">id</span><span class="o">-&gt;</span><span class="n">idProduct</span> <span class="o">!=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">idProduct</span><span class="p">))</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

        <span class="cm">/* No need to test id-&gt;bcdDevice_lo != 0, since 0 is never
           greater than any unsigned number. */</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">match_flags</span> <span class="o">&amp;</span> <span class="n">USB_DEVICE_ID_MATCH_DEV_LO</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
            <span class="p">(</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">bcdDevice_lo</span> <span class="o">&gt;</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">bcdDevice</span><span class="p">)))</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">((</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">match_flags</span> <span class="o">&amp;</span> <span class="n">USB_DEVICE_ID_MATCH_DEV_HI</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
            <span class="p">(</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">bcdDevice_hi</span> <span class="o">&lt;</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">bcdDevice</span><span class="p">)))</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">((</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">match_flags</span> <span class="o">&amp;</span> <span class="n">USB_DEVICE_ID_MATCH_DEV_CLASS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
            <span class="p">(</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">bDeviceClass</span> <span class="o">!=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">bDeviceClass</span><span class="p">))</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">((</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">match_flags</span> <span class="o">&amp;</span> <span class="n">USB_DEVICE_ID_MATCH_DEV_SUBCLASS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
            <span class="p">(</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">bDeviceSubClass</span> <span class="o">!=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">bDeviceSubClass</span><span class="p">))</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">((</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">match_flags</span> <span class="o">&amp;</span> <span class="n">USB_DEVICE_ID_MATCH_DEV_PROTOCOL</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
            <span class="p">(</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">bDeviceProtocol</span> <span class="o">!=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">bDeviceProtocol</span><span class="p">))</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* returns 0 if no match, 1 if match */</span>
<span class="kt">int</span> <span class="nf">usb_match_one_id_intf</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
                          <span class="k">struct</span> <span class="n">usb_host_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">,</span>
                          <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
        <span class="cm">/* The interface class, subclass, protocol and number should never be
         * checked for a match if the device class is Vendor Specific,
         * unless the match record specifies the Vendor ID. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">bDeviceClass</span> <span class="o">==</span> <span class="n">USB_CLASS_VENDOR_SPEC</span> <span class="o">&amp;&amp;</span>
                        <span class="o">!</span><span class="p">(</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">match_flags</span> <span class="o">&amp;</span> <span class="n">USB_DEVICE_ID_MATCH_VENDOR</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
                        <span class="p">(</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">match_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">USB_DEVICE_ID_MATCH_INT_CLASS</span> <span class="o">|</span>
                                <span class="n">USB_DEVICE_ID_MATCH_INT_SUBCLASS</span> <span class="o">|</span>
                                <span class="n">USB_DEVICE_ID_MATCH_INT_PROTOCOL</span> <span class="o">|</span>
                                <span class="n">USB_DEVICE_ID_MATCH_INT_NUMBER</span><span class="p">)))</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        
        <span class="k">if</span> <span class="p">((</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">match_flags</span> <span class="o">&amp;</span> <span class="n">USB_DEVICE_ID_MATCH_INT_CLASS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
            <span class="p">(</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">bInterfaceClass</span> <span class="o">!=</span> <span class="n">intf</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceClass</span><span class="p">))</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
                
        <span class="k">if</span> <span class="p">((</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">match_flags</span> <span class="o">&amp;</span> <span class="n">USB_DEVICE_ID_MATCH_INT_SUBCLASS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
            <span class="p">(</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">bInterfaceSubClass</span> <span class="o">!=</span> <span class="n">intf</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceSubClass</span><span class="p">))</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        
        <span class="k">if</span> <span class="p">((</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">match_flags</span> <span class="o">&amp;</span> <span class="n">USB_DEVICE_ID_MATCH_INT_PROTOCOL</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
            <span class="p">(</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">bInterfaceProtocol</span> <span class="o">!=</span> <span class="n">intf</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceProtocol</span><span class="p">))</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">((</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">match_flags</span> <span class="o">&amp;</span> <span class="n">USB_DEVICE_ID_MATCH_INT_NUMBER</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
            <span class="p">(</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">bInterfaceNumber</span> <span class="o">!=</span> <span class="n">intf</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceNumber</span><span class="p">))</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

</pre></td></tr></tbody></table></code></div></div>
<p>The first for loop in the usb_match_one_id function 
invokes usb_match_one_id with every USB device &amp; interface information
stored in the device_id table 
until the match happens.</p>

<p>Each entry in the id_table not only contains information of the USB device itself 
associated with current interface, but also the information of each interface.
invokes usb_match_one_id function with each interface information.</p>

<p>Therefore, it need to check 
whether current interface has been populated by a USB device 
supported by the matching driver. 
The usb_match_device function
check USB device information stored in the usb_device structure 
associated with current interface driver.
Because the interface driver has a reference of the USB device 
that populated current interface,
it can retrieve the reference to the parent USB device.
And because the USB device contains its USB device specific information
such as vendorID, productID,
based on the match_flags of the id,
it checks whether the match occurs.</p>

<p>If the matching for the device information is done, 
then it invokes usb_match_one_id_intf function to further match
the interface specific information.</p>

<p>When all those conditional statmenets are passed in two functions,
it means that the current USB information stored in the Nth location of the id_table,
it returns 1 to the usb_match_id function.</p>

<h3 id="usb-device-needs-to-be-handled-by-the-usb-device-driver"><span class="me-2">USB device needs to be handled by the USB device driver</span><a href="#usb-device-needs-to-be-handled-by-the-usb-device-driver" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="rouge-code"><pre>        <span class="k">if</span> <span class="p">(</span><span class="n">is_usb_device</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">;</span>
                <span class="k">struct</span> <span class="n">usb_device_driver</span> <span class="o">*</span><span class="n">udrv</span><span class="p">;</span>

                <span class="cm">/* interface drivers never match devices */</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_usb_device_driver</span><span class="p">(</span><span class="n">drv</span><span class="p">))</span>
                        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

                <span class="n">udev</span> <span class="o">=</span> <span class="n">to_usb_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
                <span class="n">udrv</span> <span class="o">=</span> <span class="n">to_usb_device_driver</span><span class="p">(</span><span class="n">drv</span><span class="p">);</span>

                <span class="cm">/* If the device driver under consideration does not have a
                 * id_table or a match function, then let the driver's probe
                 * function decide.
                 */</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udrv</span><span class="o">-&gt;</span><span class="n">id_table</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">udrv</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">)</span>
                        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

                <span class="k">return</span> <span class="n">usb_driver_applicable</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">udrv</span><span class="p">);</span>

</pre></td></tr></tbody></table></code></div></div>
<p>When the current device used for matching is USB device not an interface,
known by the is_usb_device macro,
it first checks the current driver is the USB device driver.
Because usb_init function registers only one USB device driver,
usb_generic_driver,
until that driver is found, it will keep returning 0.</p>

<p>When the USB device driver is found,
it first checks whether the driver has 
id_table and match callback function both
(remind that current matching function is
a callback match function of the usb_bus_type).
When both of them doesn’t exist,
it just returns value 1.
And because usb_generic_driver doesn’t have match function and id_table field
it will return 1 and defer all the further job to its probe function,
usb_generic_driver_probe.</p>

<h2 id="after-matching-invoke-probe-of-the-matching-driver"><span class="me-2">After matching, invoke probe of the matching driver</span><a href="#after-matching-invoke-probe-of-the-matching-driver" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>
<p>Note that based on the USB device type,
USB device or USB interface,
different probe function will be invoked.</p>

<h3 id="usb-device-is-handled-by-the-usb-device-driver"><span class="me-2">USB device is handled by the USB device driver</span><a href="#usb-device-is-handled-by-the-usb-device-driver" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<p>For a USB device,
it always matches with a USB device driver, usb_generic_driver.
Therefore, 
when the probe function is invoked as a result of successful matching,
it always invokes the usb_generic_driver_probe function.</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">usb_generic_driver_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span>

        <span class="cm">/* Choose and set the configuration.  This registers the interfaces
         * with the driver core and lets interface drivers bind to them.
         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">authorized</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">"Device is not authorized for usage</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">else</span> <span class="p">{</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">usb_choose_configuration</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">err</span> <span class="o">=</span> <span class="n">usb_set_configuration</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="n">err</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">)</span> <span class="p">{</span>
                                <span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">"can't set config #%d, error %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                                        <span class="n">c</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
                                <span class="cm">/* This need not be fatal.  The user can try to
                                 * set other configurations. */</span>
                        <span class="p">}</span>
                <span class="p">}</span>
        <span class="p">}</span>
        <span class="cm">/* USB device state == configured ... usable */</span>
        <span class="n">usb_notify_add_device</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>There are two important functions inside the probe function:
usb_choose_configuration and usb_set_configuration.
The first function chooses the best suitable configuration
from the availables ones supported by the USB device.
The details will not be convered in this posting.
When the configuration is chosen, 
it returns the index of configuration.
With the index, it invokes usb_set_configuration.
Currently, we only have USB device provided configuration information
stored in the descriptor.
Therefore, we should set the selected configuration
to allow Linux USB subsystem can manage it 
for further operations.</p>

<h3 id="usb_set_configuration-populating-the-interface-devices"><span class="me-2">usb_set_configuration, populating the interface devices</span><a href="#usb_set_configuration-populating-the-interface-devices" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>
<p>Because the usb_set_configuration is too complex to take a look at its entire operation in this posting,
we will study only fractions of it related to the interface device allocation
and binding to the driver.</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
</pre></td><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">usb_set_configuration</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">configuration</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">usb_host_config</span> <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">**</span><span class="n">new_interfaces</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span> <span class="o">=</span> <span class="n">bus_to_hcd</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">nintf</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">authorized</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">configuration</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">configuration</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">else</span> <span class="p">{</span>  
                <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">bNumConfigurations</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">desc</span><span class="p">.</span><span class="n">bConfigurationValue</span> <span class="o">==</span>
                                        <span class="n">configuration</span><span class="p">)</span> <span class="p">{</span>
                                <span class="n">cp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                                <span class="k">break</span><span class="p">;</span>
                        <span class="p">}</span>
                <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">cp</span> <span class="o">&amp;&amp;</span> <span class="n">configuration</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
                <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

        <span class="cm">/* The USB spec says configuration 0 means unconfigured.
         * But if a device includes a configuration numbered 0,
         * we will accept it as a correctly configured state.
         * Use -1 if you really want to unconfigure the device.
         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cp</span> <span class="o">&amp;&amp;</span> <span class="n">configuration</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">"config 0 descriptor??</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

        <span class="cm">/* Allocate memory for new interfaces before doing anything else,
         * so that if we run out then nothing will have changed. */</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">nintf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">nintf</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bNumInterfaces</span><span class="p">;</span>
                <span class="n">new_interfaces</span> <span class="o">=</span> <span class="n">kmalloc_array</span><span class="p">(</span><span class="n">nintf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">new_interfaces</span><span class="p">),</span>
                                               <span class="n">GFP_NOIO</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_interfaces</span><span class="p">)</span>
                        <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
                
                <span class="k">for</span> <span class="p">(;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">nintf</span><span class="p">;</span> <span class="o">++</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">new_interfaces</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span>
                                        <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span><span class="p">),</span>
                                        <span class="n">GFP_NOIO</span><span class="p">);</span>
                        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_interfaces</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="p">{</span>
                                <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="nl">free_interfaces:</span>                
                                <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
                                        <span class="n">kfree</span><span class="p">(</span><span class="n">new_interfaces</span><span class="p">[</span><span class="n">n</span><span class="p">]);</span>
                                <span class="n">kfree</span><span class="p">(</span><span class="n">new_interfaces</span><span class="p">);</span>
                                <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
                        <span class="p">}</span>
                <span class="p">}</span>
                
                <span class="n">i</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus_mA</span> <span class="o">-</span> <span class="n">usb_get_max_power</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
                        <span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">"new config #%d exceeds power "</span>
                                        <span class="s">"limit by %dmA</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                                        <span class="n">configuration</span><span class="p">,</span> <span class="o">-</span><span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>Because the configuration number has been chosen by the usb_choose_configuration function,
we can understand which configuration of the USB device should be enabled.
Because usb_device can maintain all configurations 
provided by the USB device,
it first choose the selected configuration based on the configuration index parameter.
And then it allocates the interfaces 
supported by the selected configuration.
Each configuration can support different number of interfaces,
so based on the bNumInterfaces filed of the descriptor of the selected configuration,
it allocates memory for the interfaces.</p>

<p>After the memory space for interfaces are allocated,
it needs to be initialized.</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
</pre></td><td class="rouge-code"><pre>        <span class="cm">/*
         * Initialize the new interface structures and the
         * hc/hcd/usbcore interface/endpoint state.
         */</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nintf</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">struct</span> <span class="n">usb_interface_cache</span> <span class="o">*</span><span class="n">intfc</span><span class="p">;</span>
                <span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">;</span>
                <span class="k">struct</span> <span class="n">usb_host_interface</span> <span class="o">*</span><span class="n">alt</span><span class="p">;</span>
                <span class="n">u8</span> <span class="n">ifnum</span><span class="p">;</span>

                <span class="n">cp</span><span class="o">-&gt;</span><span class="n">interface</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">intf</span> <span class="o">=</span> <span class="n">new_interfaces</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="n">intfc</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">intf_cache</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="n">intf</span><span class="o">-&gt;</span><span class="n">altsetting</span> <span class="o">=</span> <span class="n">intfc</span><span class="o">-&gt;</span><span class="n">altsetting</span><span class="p">;</span>
                <span class="n">intf</span><span class="o">-&gt;</span><span class="n">num_altsetting</span> <span class="o">=</span> <span class="n">intfc</span><span class="o">-&gt;</span><span class="n">num_altsetting</span><span class="p">;</span>
                <span class="n">intf</span><span class="o">-&gt;</span><span class="n">authorized</span> <span class="o">=</span> <span class="o">!!</span><span class="n">HCD_INTF_AUTHORIZED</span><span class="p">(</span><span class="n">hcd</span><span class="p">);</span>
                <span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intfc</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">);</span>

                <span class="n">alt</span> <span class="o">=</span> <span class="n">usb_altnum_to_altsetting</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

                <span class="cm">/* No altsetting 0?  We'll assume the first altsetting.
                 * We could use a GetInterface call, but if a device is
                 * so non-compliant that it doesn't have altsetting 0
                 * then I wouldn't trust its reply anyway.
                 */</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alt</span><span class="p">)</span>
                        <span class="n">alt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">altsetting</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

                <span class="n">ifnum</span> <span class="o">=</span> <span class="n">alt</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceNumber</span><span class="p">;</span>
                <span class="n">intf</span><span class="o">-&gt;</span><span class="n">intf_assoc</span> <span class="o">=</span> <span class="n">find_iad</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">ifnum</span><span class="p">);</span>
                <span class="n">intf</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span> <span class="o">=</span> <span class="n">alt</span><span class="p">;</span>
                <span class="n">usb_enable_interface</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">intf</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
                <span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">usb_of_has_combined_node</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
                        <span class="n">device_set_of_node_from_dev</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span> <span class="o">=</span> <span class="n">usb_of_get_interface_node</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
                                        <span class="n">configuration</span><span class="p">,</span> <span class="n">ifnum</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="n">ACPI_COMPANION_SET</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">ACPI_COMPANION</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">));</span>
                <span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
                <span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">bus</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">usb_bus_type</span><span class="p">;</span>
                <span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">usb_if_device_type</span><span class="p">;</span>
                <span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">groups</span> <span class="o">=</span> <span class="n">usb_interface_groups</span><span class="p">;</span>
                <span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">reset_ws</span><span class="p">,</span> <span class="n">__usb_queue_reset_device</span><span class="p">);</span>
                <span class="n">intf</span><span class="o">-&gt;</span><span class="n">minor</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
                <span class="n">device_initialize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
                <span class="n">pm_runtime_no_callbacks</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
                <span class="n">dev_set_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">"%d-%s:%d.%d"</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">busnum</span><span class="p">,</span>
                                <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devpath</span><span class="p">,</span> <span class="n">configuration</span><span class="p">,</span> <span class="n">ifnum</span><span class="p">);</span>
                <span class="n">usb_get_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">kfree</span><span class="p">(</span><span class="n">new_interfaces</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></div></div>
<p>Here, the nintf means the number of interfaces 
should be supported for the selected configuration.
Each interface is set to beattached to the usb_bus_type bus,
and has usb_if_device_type as its type
(seen in the match function before).</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="rouge-code"><pre>        <span class="cm">/* Now that all the interfaces are set up, register them
         * to trigger binding of drivers to interfaces.  probe()
         * routines may install different altsettings and may
         * claim() any interfaces not yet bound.  Many class drivers
         * need that: CDC, audio, video, etc.
         */</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nintf</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">interface</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span> <span class="o">&amp;&amp;</span>
                    <span class="o">!</span><span class="n">of_device_is_available</span><span class="p">(</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span><span class="p">))</span> <span class="p">{</span>
                        <span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">"skipping disabled interface %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                                 <span class="n">intf</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceNumber</span><span class="p">);</span>
                        <span class="k">continue</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
                        <span class="s">"adding %s (config #%d, interface %d)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                        <span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">),</span> <span class="n">configuration</span><span class="p">,</span>
                        <span class="n">intf</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceNumber</span><span class="p">);</span>
                <span class="n">device_enable_async_suspend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">device_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">"device_add(%s) --&gt; %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                                <span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">),</span> <span class="n">ret</span><span class="p">);</span>
                        <span class="k">continue</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">create_intf_ep_devs</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
        <span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<p>After the interface has been initialized,
it should be registered to the usb bus to be utilized.
Note that driver field of the interface device is passed to the device_add function.
Because this device is set to be attached to the usb_bus_type bus,
the same match function we’ve analyzed before will be invoked once again,
usb_device_match.
This time, the device passed to the usb_device_match is the interface,
it will traverse entire registered interface drivers and 
tries to find the driver supporting current interface device.
Note that the id_table will be used for matching.
After the interface device matches with a specific interface driver,
it will end up calling the probe function of the driver.
Note that the probe function called at this time is not a
probe function of the USB device driver,
which led us to populate the interface devices.
This time the probe function registered in the matched device driver will be invoked instead!
Yeah~! now your USB device interface is bound to a driver and 
can be managed by the Linux from now on.</p>


  </div>

  <div class="post-tail-wrapper text-muted">
    <!-- categories -->
    
      <div class="post-meta mb-3">
        <i class="far fa-folder-open fa-fw me-1"></i>
        
          <a href="/categories/linux/">linux,</a>,
          <a href="/categories/embedded-linux/">embedded-linux</a>
      </div>
    

    <!-- tags -->
    

    <div
      class="
        post-tail-bottom
        d-flex justify-content-between align-items-center mt-5 pb-2
      "
    >
      <div class="license-wrapper">
        
          

          This post is licensed under 
        <a href="https://creativecommons.org/licenses/by/4.0/">
          CC BY 4.0
        </a>
         by the author.
        
      </div>

      <!-- Post sharing snippet -->

<div class="share-wrapper d-flex align-items-center">
  <span class="share-label text-muted">Share</span>
  <span class="share-icons">
    
    
    

    

      

      <a
        href="https://twitter.com/intent/tweet?text=Usb%20Device%20Add%20-%20Ruach&url=https%3A%2F%2Fruach.github.io%2Fposts%2Fusb-device-add%2F"
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="Twitter"
        target="_blank"
        rel="noopener"
        aria-label="Twitter"
      >
        <i class="fa-fw fa-brands fa-square-x-twitter"></i>
      </a>
    

      

      <a
        href="https://www.facebook.com/sharer/sharer.php?title=Usb%20Device%20Add%20-%20Ruach&u=https%3A%2F%2Fruach.github.io%2Fposts%2Fusb-device-add%2F"
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="Facebook"
        target="_blank"
        rel="noopener"
        aria-label="Facebook"
      >
        <i class="fa-fw fab fa-facebook-square"></i>
      </a>
    

      

      <a
        href="https://t.me/share/url?url=https%3A%2F%2Fruach.github.io%2Fposts%2Fusb-device-add%2F&text=Usb%20Device%20Add%20-%20Ruach"
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="Telegram"
        target="_blank"
        rel="noopener"
        aria-label="Telegram"
      >
        <i class="fa-fw fab fa-telegram"></i>
      </a>
    

      

      <a
        href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fruach.github.io%2Fposts%2Fusb-device-add%2F"
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="Linkedin"
        target="_blank"
        rel="noopener"
        aria-label="Linkedin"
      >
        <i class="fa-fw fab fa-linkedin"></i>
      </a>
    

    <button
      id="copy-link"
      aria-label="Copy link"
      class="btn small"
      data-bs-toggle="tooltip"
      data-bs-placement="top"
      title="Copy link"
      data-title-succeed="Link copied successfully!"
    >
      <i class="fa-fw fas fa-link pe-none fs-6"></i>
    </button>
  </span>
</div>

    </div>
    <!-- .post-tail-bottom -->
  </div>
  <!-- div.post-tail-wrapper -->
</article>


            
          </main>

          <!-- panel -->
          <aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 mb-5 text-muted">
            <div class="access">
              <!-- Get the last 5 posts from lastmod list. -->















              <!-- The trending tags list -->


















            </div>

            
              
              



  <section id="toc-wrapper" class="ps-0 pe-4">
    <h2 class="panel-heading ps-3 pt-2 mb-2">Contents</h2>
    <nav id="toc"></nav>
  </section>


            
          </aside>
        </div>

        <div class="row">
          <!-- tail -->
          <div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4">
            
              
              <!-- Recommend the other 3 posts according to the tags and categories of the current post. -->

<!-- The total size of related posts -->


<!-- An random integer that bigger than 0 -->


<!-- Equals to TAG_SCORE / {max_categories_hierarchy} -->














  

  
    
  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  











  <aside id="related-posts" aria-labelledby="related-label">
    <h3 class="mb-4" id="related-label">Further Reading</h3>
    <nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4">
      
        <article class="col">
          <a href="/posts/initcalls/" class="post-preview card h-100">
            <div class="card-body">
              <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->




<time
  
  data-ts="1619582400"
  data-df="ll"
  
>
  Apr 28, 2021
</time>

              <h4 class="pt-0 my-2">Initcalls</h4>
              <div class="text-muted">
                <p>
                  





                  #do_initcalls
static void __init do_basic_setup(void)
{
        cpuset_init_smp();
        driver_init();
        init_irq_proc();
        do_ctors();
        usermodehelper_enable();
        do_in...
                </p>
              </div>
            </div>
          </a>
        </article>
      
        <article class="col">
          <a href="/posts/platform-device/" class="post-preview card h-100">
            <div class="card-body">
              <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->




<time
  
  data-ts="1619841600"
  data-df="ll"
  
>
  May  1, 2021
</time>

              <h4 class="pt-0 my-2">Platform Device</h4>
              <div class="text-muted">
                <p>
                  





                  Kernel initialization before DeviceTree
Although we are not going to cover the details of the initialization procedure,
this post will take a look at 
what happens before the device tree is initial...
                </p>
              </div>
            </div>
          </a>
        </article>
      
        <article class="col">
          <a href="/posts/register-platform-device-driver/" class="post-preview card h-100">
            <div class="card-body">
              <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->




<time
  
  data-ts="1619928000"
  data-df="ll"
  
>
  May  2, 2021
</time>

              <h4 class="pt-0 my-2">Register Platform Device Driver</h4>
              <div class="text-muted">
                <p>
                  





                  We will cover how the platform device drivers 
can be registered and managed by the platform device bus subsystem.

struct platform_driver {
        int (*probe)(struct platform_device *);
        ...
                </p>
              </div>
            </div>
          </a>
        </article>
      
    </nav>
  </aside>
  <!-- #related-posts -->


            
              
              <!-- Navigation buttons at the bottom of the post. -->

<nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation">
  
  

  
    <a
      href="/posts/clks/"
      class="btn btn-outline-primary"
      aria-label="Older"
    >
      <p>Clks</p>
    </a>
  

  
    <a
      href="/posts/O3-CPU-GEM5/"
      class="btn btn-outline-primary"
      aria-label="Newer"
    >
      <p>O3 Cpu Gem5</p>
    </a>
  
</nav>

            
              
              <!--  The comments switcher -->

  
  <!-- The Disqus lazy loading. -->

<div id="disqus_thread">
  <p class="text-center text-muted small">Comments powered by <a href="https://disqus.com/">Disqus</a>.</p>
</div>

<script type="text/javascript">
  var disqus_config = function () {
    this.page.url = 'https://ruach.github.io/posts/usb-device-add/';
    this.page.identifier = '/posts/usb-device-add/';
  };

  /* Lazy loading */
  var disqus_observer = new IntersectionObserver(
    function (entries) {
      if (entries[0].isIntersecting) {
        (function () {
          var d = document,
            s = d.createElement('script');
          s.src = 'https://ruach.disqus.com/embed.js';
          s.setAttribute('data-timestamp', +new Date());
          (d.head || d.body).appendChild(s);
        })();

        disqus_observer.disconnect();
      }
    },
    { threshold: [0] }
  );

  disqus_observer.observe(document.querySelector('#disqus_thread'));

  /* Auto switch theme */
  function reloadDisqus() {
    if (event.source === window && event.data && event.data.direction === ModeToggle.ID) {
      /* Disqus hasn't been loaded */
      if (typeof DISQUS === 'undefined') {
        return;
      }

      if (document.readyState == 'complete') {
        DISQUS.reset({ reload: true, config: disqus_config });
      }
    }
  }

  if (document.querySelector('.mode-toggle')) {
    window.addEventListener('message', reloadDisqus);
  }
</script>



            

            <!-- The Footer -->

<footer
  aria-label="Site Info"
  class="
    d-flex flex-column justify-content-center text-muted
    flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3
  "
>
  <p>
    ©
    <time>2024</time>
    <a href="https://ruach.github.io">Jaehyuk Lee</a>.
    
      <span
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author."
      >Some rights reserved.</span>
    
  </p>

  <p>Using the <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme for <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>
  </p>
</footer>

          </div>
        </div>

        <!-- The Search results -->

<div id="search-result-wrapper" class="d-flex justify-content-center unloaded">
  <div class="col-11 content">
    <div id="search-hints">
      <!-- The trending tags list -->


















    </div>
    <div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div>
  </div>
</div>

      </div>

      <aside aria-label="Scroll to Top">
        <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow">
          <i class="fas fa-angle-up"></i>
        </button>
      </aside>
    </div>

    <div id="mask"></div>

    
      <aside
  id="notification"
  class="toast"
  role="alert"
  aria-live="assertive"
  aria-atomic="true"
  data-bs-animation="true"
  data-bs-autohide="false"
>
  <div class="toast-header">
    <button
      type="button"
      class="btn-close ms-auto"
      data-bs-dismiss="toast"
      aria-label="Close"
    ></button>
  </div>
  <div class="toast-body text-center pt-0">
    <p class="px-2 mb-3">A new version of content is available.</p>
    <button type="button" class="btn btn-primary" aria-label="Update">
      Update
    </button>
  </div>
</aside>

    

    <!-- JavaScripts -->

    <!-- JS selector for site. -->

<!-- commons -->



<!-- layout specified -->


  

  
    <!-- image lazy-loading & popup & clipboard -->
    
  















  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  



  <script src="https://cdn.jsdelivr.net/combine/npm/jquery@3.7.1/dist/jquery.min.js,npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js,npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/magnific-popup@1.1.0/dist/jquery.magnific-popup.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.10/dayjs.min.js,npm/dayjs@1.11.10/locale/en.min.js,npm/dayjs@1.11.10/plugin/relativeTime.min.js,npm/dayjs@1.11.10/plugin/localizedFormat.min.js,npm/tocbot@4.21.2/dist/tocbot.min.js"></script>






<script defer src="/assets/js/dist/post.min.js"></script>






    

    <!--
  Jekyll Simple Search loader
  See: <https://github.com/christian-fei/Simple-Jekyll-Search>
-->





<script>
  /* Note: dependent library will be loaded in `js-selector.html` */
  SimpleJekyllSearch({
    searchInput: document.getElementById('search-input'),
    resultsContainer: document.getElementById('search-results'),
    json: '/assets/js/data/search.json',
    searchResultTemplate: '  <article class="px-1 px-sm-2 px-lg-4 px-xl-0">    <header>      <h2><a href="{url}">{title}</a></h2>      <div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1">        {categories}        {tags}      </div>    </header>    <p>{snippet}</p>  </article>',
    noResultsText: '<p class="mt-5"></p>',
    templateMiddleware: function(prop, value, template) {
      if (prop === 'categories') {
        if (value === '') {
          return `${value}`;
        } else {
          return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`;
        }
      }

      if (prop === 'tags') {
        if (value === '') {
          return `${value}`;
        } else {
          return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`;
        }
      }
    }
  });
</script>

  </body>
</html>

